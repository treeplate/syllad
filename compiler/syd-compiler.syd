import 'core.syd';
import 'syd-utils.syd';
import 'syd-types.syd';
import 'syd-vots.syd';
import 'syd-assembler.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+58h : rbp+48h : (local variable from previous stack frame)
    *                       (maybe arg 2 here)
     *  rsp+50h : rbp+40h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+48h : rbp+38h : type of arg 1
     *  rsp+40h : rbp+30h : pointer to return value (and type), to be filled in
     *  rsp+38h : rbp+28h : shadow r9
     *  rsp+30h : rbp+20h : shadow r8
     *  rsp+28h : rbp+18h : shadow rdx
     *  rsp+20h : rbp+10h : shadow rcx
     *  rsp+18h : rbp +8h : return address
                            (maybe other saved registers here)
     *  rsp+10h : rbp     : saved non-volatile register rbp                      
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */

     // on the heap, a 16 byte entry has the value first, then the type 8 bytes "later" (positive address)
     //    so if the value is at p, type at p+0x08
     // on the stack, a 16 byte entry has the value first, then the type 8 bytes "later" (negative address)
     //    so if the value is at p, type at p-0x08


// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================
fwdclass Slot extends VotSource;
fwdclassprop NullFunction Slot.constructor;
fwdclass CompilationEnvironment extends TypeRegistry;
fwdclassprop NullFunction CompilationEnvironment.constructor;
fwdclass CompiledScope extends Object;
fwdclassprop NullFunction CompiledScope.constructor;
fwdclass CompiledNestedScope extends CompiledScope;
fwdclassprop NullFunction CompiledNestedScope.constructor;
fwdclass CompiledStackFrameScope extends CompiledScope;
fwdclassprop NullFunction CompiledStackFrameScope.constructor;
fwdclass CompiledSubroutine extends CompiledStackFrameScope;
fwdclassprop NullFunction CompiledSubroutine.constructor;
fwdclass CompiledLibrary extends CompiledStackFrameScope;
fwdclassprop NullFunction CompiledLibrary.constructor;
fwdclass CompiledIntrinsicsLibrary extends CompiledLibrary;
fwdclassprop NullFunction CompiledIntrinsicsLibrary.constructor;
fwdclass Instruction extends Object;
fwdclassprop NullFunction Instruction.constructor;
fwdclass StringConstantInstruction extends Instruction;
fwdclassprop NullFunction StringConstantInstruction.constructor;
fwdclass CompiledSubroutineWithSpecificParameters extends CompiledSubroutine;
fwdclassprop NullFunction CompiledSubroutineWithSpecificParameters.constructor;
fwdclass BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters;
fwdclassprop NullFunction BuiltInSubroutine.constructor;
fwdclass BuiltInPrintSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction BuiltInPrintSubroutine.constructor;
fwdclass BuiltInExitSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction BuiltInExitSubroutine.constructor;
fwdclass KernelGetProcessHeapSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction KernelGetProcessHeapSubroutine.constructor;
fwdclass KernelHeapAllocSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction KernelHeapAllocSubroutine.constructor;
fwdclass KernelHeapFreeSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction KernelHeapFreeSubroutine.constructor;
fwdclass KernelGetLastErrorSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction KernelGetLastErrorSubroutine.constructor;
fwdclass BuiltInLenSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction BuiltInLenSubroutine.constructor;
fwdclass BuiltInDebuggerSubroutine extends BuiltInSubroutine;
fwdclassprop NullFunction BuiltInDebuggerSubroutine.constructor;
fwdclass CompilerIntrinsic extends BuiltInSubroutine;
fwdclassprop NullFunction CompilerIntrinsic.constructor;
fwdclass BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic;
fwdclassprop NullFunction BuiltInReadFromAddressIntrinsic.constructor;
fwdclass BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic;
fwdclassprop NullFunction BuiltInWriteToAddressIntrinsic.constructor;
fwdclass CompiledVarArgsSubroutine extends CompiledSubroutine;
fwdclassprop NullFunction CompiledVarArgsSubroutine.constructor;

fwdclassprop Boolean Slot.isImmutable;
fwdclassprop ValueVotNullable Slot.location;
fwdclassprop NullFunction Slot.assignLocation;
fwdclassprop NullFunction Slot.write;

fwdclassprop CompiledScopeNullable CompiledScope.parent;
fwdclassprop String CompiledScope.name;
fwdclassprop CompilationEnvironmentFunction CompiledScope.environment;
fwdclassprop CompiledStackFrameScopeFunction CompiledScope.stackFrame;
fwdclassprop CompiledLibraryFunction CompiledScope.globalScope;
fwdclassprop SlotNullableFunction CompiledScope.lookupIdentifier;
fwdclassprop NullFunction CompiledScope.prepareInstructions;
fwdclassprop NullFunction CompiledScope.generateAssembler;
fwdclassprop NullFunction CompiledScope.emitInstruction;
fwdclassprop SlotFunction CompiledScope.registerDynamicValue;
fwdclassprop SlotFunction CompiledScope.registerStaticValue;
fwdclassprop SlotFunction CompiledScope.registerConstant;
fwdclassprop SlotFunction CompiledScope.registerSubroutine;
fwdclassprop StringListFunction CompiledStackFrameScope.nonvolatileRegistersUsed;
fwdclassprop NullFunction CompiledStackFrameScope.registerSlot;
fwdclassprop NullFunction CompiledStackFrameScope.declareType;
fwdclassprop NullFunction CompiledStackFrameScope.prepareSlots;
fwdclassprop NullFunction CompiledStackFrameScope.generateAssemblerBlock;
fwdclassprop String CompiledSubroutine.label;
fwdclassprop String CompiledSubroutine.epilogLabel;
fwdclassprop AbstractSubroutineTypeWithSpecificParameters CompiledSubroutine.type;
fwdclassprop SlotNullableFunction CompiledSubroutine.inline;
fwdclassprop CompilationEnvironment CompiledLibrary.compilationEnvironment;
fwdclassprop TypeNullableFunction CompiledLibrary.lookupType;

fwdclassprop CompiledIntrinsicsLibraryNullable CompilationEnvironment.intrinsicsLibrary;
fwdclassprop Integer CompilationEnvironment.typeTableWidth;
fwdclassprop Integer CompilationEnvironment.typeTableOffset;
fwdclassprop String CompilationEnvironment.typeTableLabel;
fwdclassprop StringFunction CompilationEnvironment.generateLabel;
fwdclassprop ValueHandleFunction CompilationEnvironment.integer;


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

class CompiledIntrinsicsLibrary extends CompiledLibrary {
  String labelPrefix() {
    return 'intrinsics';
  }

  VotSource integers;
  VotSource registers;

  AnythingType coreAnythingType;
  WhateverType coreWhateverType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;
  SentinelType coreSentinelType;

  ValueVot coreSentinel;
  Slot coreNull;
  Slot coreTrue;
  Slot coreFalse;

  Slot corePrint; // actually __print; the real print is in the rtl
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;
  Slot returnValueTypeCheckFailureMessage;
  Slot operandTypeCheckFailureMessage;
  Slot asOperatorFailureMessage;
  Slot boundsFailureMessage;

  Slot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    String label = compilationEnvironment.generateLabel(labelBase);
    emitInstruction(StringConstantInstruction(
      this,
      label,
      value,
      SourceLocation(line, col, file),
    ));
    coreStringType.markConstructed();
    return registerStaticValue(ImmediateAddressVot(coreStringType, label), labelBase);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(compilationEnvironmentArg, nameArg);
    // internal types
    coreClassType = RootClassType(compilationEnvironmentArg);
    coreClosureType = ClosureType(compilationEnvironmentArg);
    coreSystemType = SystemType(compilationEnvironmentArg);
    coreSentinelType = SentinelType(compilationEnvironmentArg);
    // built-in types
    coreAnythingType = AnythingType(compilationEnvironmentArg);
    declareType(coreAnythingType);
    coreWhateverType = WhateverType(compilationEnvironmentArg);
    declareType(coreWhateverType);
    coreSentinel = SentinelVot(coreSentinelType);
    coreSentinelType.markConstructed();
    coreNullType = NullType(compilationEnvironmentArg);
    declareType(coreNullType);
    coreNull = registerConstant('null', LiteralIntegerVot(coreNullType, 0x00));
    coreBooleanType = BooleanType(compilationEnvironmentArg);
    declareType(coreBooleanType);
    coreFalse = registerConstant('false', LiteralIntegerVot(coreBooleanType, 0x00));
    coreTrue = registerConstant('true', LiteralIntegerVot(coreBooleanType, 0x01));
    coreIntegerType = IntegerType(compilationEnvironmentArg);
    declareType(coreIntegerType);
    integers = VotSource(coreIntegerType, 'integers');
    coreStringType = StringType(compilationEnvironmentArg);
    declareType(coreStringType);
    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));
    // built-in functions not used from compiler
    registerSubroutine(BuiltInLenSubroutine(this));
    registerSubroutine(BuiltInDebuggerSubroutine(this));
    registerSubroutine(KernelGetProcessHeapSubroutine(this));
    registerSubroutine(KernelHeapAllocSubroutine(this));
    registerSubroutine(KernelHeapFreeSubroutine(this));
    registerSubroutine(KernelGetLastErrorSubroutine(this));
    // intrinsics (functions that only work when inlined)
    registerSubroutine(BuiltInReadFromAddressIntrinsic(this));
    registerSubroutine(BuiltInWriteToAddressIntrinsic(this));
    // messages
    parameterCountCheckFailureMessage = registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    returnValueTypeCheckFailureMessage = registerStringConstant(
      'returnValueTypeCheckFailureMessage',
      'error: type mismatch for function return value, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    operandTypeCheckFailureMessage = registerStringConstant(
      'operandTypeCheckFailureMessage',
      'error: type mismatch for operand, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    asOperatorFailureMessage = registerStringConstant(
      'asOperatorFailureMessage',
      'error: type mismatch for as operator, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    boundsFailureMessage = registerStringConstant(
      'boundsFailureMessage',
      'error: subscript index out of range (%d is not in range %d..%d)\n',
      __LINE__, __COL__, __FILE__,
    );
  }
}

// Library State
enum ls { Unknown Declared Defined }

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  CompiledIntrinsicsLibraryNullable intrinsicsLibrary = null; 
  CompiledLibraryNullable runtimeLibrary = null; 

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
  }

  Null defineLibrary(String filename, CompiledLibrary library) { 
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
    append(libraryNames, filename);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is CompiledLibrary, 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  CompiledLibrary getLibrary(String filename) { 
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  Null setRuntimeLibrary(CompiledLibrary runtimeLibraryArg) { 
    runtimeLibrary = runtimeLibraryArg;
  }

  CompiledSubroutineList subroutines = []:CompiledSubroutine; 

  Null addSubroutine(CompiledSubroutine subroutine) { 
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    intrinsicsLibrary!.prepareInstructions();
    runtimeLibrary!.prepareInstructions();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).prepareInstructions();
    }
    for (subroutine in subroutines) {
      subroutine.prepareInstructions();
    }
  }

  Null prepareSlots() {
    intrinsicsLibrary!.prepareSlots();
    runtimeLibrary!.prepareSlots();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).prepareSlots();
    }
    for (subroutine in subroutines) {
      subroutine.prepareSlots();
    }
  }

  Null generateAssemblerBlocks(Assembler assembler) {
    intrinsicsLibrary!.generateAssemblerBlock(assembler);
    runtimeLibrary!.generateAssemblerBlock(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).generateAssemblerBlock(assembler);
    }
    for (subroutine in subroutines) {
      subroutine.generateAssemblerBlock(assembler);
    }
  }

  ValueHandle integer(Integer value) {
    intrinsicsLibrary!.integers.staticType.markConstructed();
    return ValueHandle(intrinsicsLibrary!.integers, LiteralIntegerVot(intrinsicsLibrary!.integers.staticType as NumericType, value));
  }

  String typeTableLabel;
  Integer typeTableOffset;
  Integer typeTableWidth;

  Null generateTypeTable(Assembler assembler, String label) {
    StringList comment = []:String;
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, '   ; Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        append(comment, concat(' ', supertype));
      }
    }
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(comment, '   ; ');
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        append(bytes, byte);
        byte = 0;
        bits = 0;
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    while (len(bytes) % 8 != 0) {
      append(bytes, 0); // padding to keep things 8-byte aligned
    }
    assembler.addConst(
      label,
      [ concat('db ', join(map(bytes, hex8) as StringList, ', ')) ],
      [ concat('Type table\n', join(comment, '')) ]:StringNullable,
    );
    typeTableOffset = offset;
    typeTableWidth = width;
  }

  Null compile(Assembler assembler) {
    typeTableLabel = generateLabel('typeTable');
    prepareInstructions();
    assignTypeCodes();
    generateTypeTable(assembler, typeTableLabel);
    prepareSlots();
    generateAssemblerBlocks(assembler);
  }

  Null constructor(Assembler assembler) {
    super.constructor();
    intrinsicsLibrary = CompiledIntrinsicsLibrary(this, 'intrinsics');
   }
}


// ============================================================================
// INSTRUCTIONS
// ============================================================================

class Instruction extends Object {
  CompiledScope scope;

  Null prepareInstructions() {}

  Null generateAssembler(Assembler assembler, Integer blockId) {}

  Null saveVolatileRegisters(Assembler assembler, Integer blockId) {
    Integer savedRegisterCount = len(scope.stackFrame().nonvolatileRegistersUsed());
    assembler.addMov(blockId, rcxShadow(savedRegisterCount), rcx, 'save rcx in shadow space');
    assembler.addMov(blockId, rdxShadow(savedRegisterCount), rdx, 'save rdx in shadow space');
    assembler.addMov(blockId, r8Shadow(savedRegisterCount), r8, 'save r8 in shadow space');
    assembler.addMov(blockId, r9Shadow(savedRegisterCount), r9, 'save r9 in shadow space');
  }

  Null restoreVolatileRegisters(Assembler assembler, Integer blockId) {
    Integer savedRegisterCount = len(scope.stackFrame().nonvolatileRegistersUsed());
    assembler.addMov(blockId, rcx, rcxShadow(savedRegisterCount), 'restore rcx from shadow space');
    assembler.addMov(blockId, rdx, rdxShadow(savedRegisterCount), 'restore rdx from shadow space');
    assembler.addMov(blockId, r8, r8Shadow(savedRegisterCount), 'restore r8 from shadow space');
    assembler.addMov(blockId, r9, r9Shadow(savedRegisterCount), 'restore r9 from shadow space');
  }

  Null constructor(CompiledScope scopeArg) {
    super.constructor();
    scope = scopeArg;
  }
}

class SourceLocationInstruction extends Instruction {
  SourceCode statement;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addPendingComment(blockId, concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), assembler.lineLength)));
  }

  Null constructor(CompiledScope scopeArg, SourceCode statementArg) {
    super.constructor(scopeArg);
    statement = statementArg;
  }
}

class CommentInstruction extends Instruction {
  String message;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, message);
  }

  Null constructor(CompiledScope scopeArg, String messageArg) {
    super.constructor(scopeArg);
    message = messageArg;
  }
}

class LabelInstruction extends Instruction {
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat(label, ':'), comment);
  }

  Null constructor(CompiledScope scopeArg, String labelArg, String commentArg) {
    super.constructor(scopeArg);
    label = labelArg;
    comment = commentArg;
  }
}

class DoBlockInstruction extends Instruction {
  CompiledNestedScope block;

  Null prepareInstructions() {
    super.prepareInstructions();
    block.prepareInstructions();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    block.generateAssembler(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, CompiledNestedScope blockArg) { 
    super.constructor(scopeArg);
    block = blockArg;
  }
}

class JumpInstruction extends Instruction {
  String target;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat('jmp ', target), comment);
  }

  Null constructor(CompiledScope scopeArg, String targetArg, String commentArg) {
    super.constructor(scopeArg);
    target = targetArg;
    comment = commentArg;
  }
}

class JumpIfEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), a.source.debugName, b.source.debugName);
    assembler.addCode(blockId, concat('je ', label), comment);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle aArg, ValueHandle bArg, String labelArg, String commentArg) {
    super.constructor(scopeArg);
    a = aArg;
    b = bArg;
    label = labelArg;
    comment = commentArg;
  }
}

class JumpUnlessEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), a.source.debugName, b.source.debugName);
    assembler.addCode(blockId, concat('jne ', label), comment);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle aArg, ValueHandle bArg, String labelArg, String commentArg) {
    super.constructor(scopeArg);
    a = aArg;
    b = bArg;
    label = labelArg;
    comment = commentArg;
  }
}

class StoreEqualityInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  ValueHandle target;
  Boolean negate;

  Null prepareInstructions() {
    super.prepareInstructions();
    target.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // TODO: hard-code result for literal comparisons
    // TODO: make this work for strings
    assembler.addZero(blockId, r10, 'prepare r10 for result of value comparison');
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), a.source.debugName, b.source.debugName);
    assembler.addCode(blockId, 'sete byte ptr r10b', 'store result in r10');
    assembler.addZero(blockId, rax, 'prepare rax for result of type comparison');
    assembler.addCmp(blockId, a.type.type!.asOperand(), b.type.type!.asOperand(), concat('type of ', a.source.debugName), concat('type of ', b.source.debugName));
    assembler.addCode(blockId, 'sete byte ptr al', 'store result in rax');
    assembler.addCode(blockId, 'and r10, rax', 'true if type and value are both equal; result goes into r10');
    if (negate) {
      assembler.addCode(blockId, 'xor r10, 1', 'negate result');
    }
    assembler.addMov(blockId, target.value!.asOperand(), r10, concat('store result in ', target.source.debugName));
    assembler.addMov(blockId, target.type.type!.asOperand(), scope.environment().intrinsicsLibrary!.coreBooleanType.asOperand(), concat(target.source.debugName, ' is a Boolean'));
  }

  Null constructor(CompiledScope scopeArg, ValueHandle aArg, ValueHandle bArg, ValueHandle targetArg, Boolean negateArg) { 
    super.constructor(scopeArg);
    a = aArg;
    b = bArg;
    target = targetArg;
    negate = negateArg;
  }
}

class TypeCheckInstruction extends Instruction {
  Type staticType;
  TypeHandle dynamicType;
  String what;

  Null prepareInstructions() {
    super.prepareInstructions();
    staticType.markUsedInTypeCheck();
  }

  // sets CF if the type check is successful (dynamicType is staticType)
  //
  // uses r10 and rax
  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, rax, dynamicType.type!.asOperand(), concat('load the dynamic type of ', what, ' into rax'));
    CompilationEnvironment environment = scope.environment();
    Integer width = environment.typeTableWidth / 8;
    if (environment.typeTableWidth % 8 > 0) {
      width += 1;
    }
    if (width > 1) {
      assembler.addCode(blockId, concat('mul ', width), 'adjust to the relative start of that type\'s entry in the type table');
    }
    Integer code = staticType.code - environment.typeTableOffset;
    if (code > 8) {
      assembler.addCode(blockId, concat('add rax, ', code / 8), concat('adjust to the byte containing the bit to check against'));
    }
    assembler.addCode(blockId, concat('lea r10, ', environment.typeTableLabel), 'move type table offset into r10');
    assembler.addCode(blockId, 'add rax, r10', 'adjust rax to point to the type table');
    assembler.addCode(blockId, concat('bt qword ptr [rax], ', concat(code % 8)), concat('check that ', what, ' is ', staticType));
  }

  Null constructor(CompiledScope scopeArg, Type staticTypeArg, TypeHandle dynamicTypeArg, String whatArg) { 
    super.constructor(scopeArg);
    staticType = staticTypeArg;
    dynamicType = dynamicTypeArg;
    what = whatArg;
  }
}

class DoIfTypeMismatchInstruction extends TypeCheckInstruction {
  String continueLabel;
  CompiledScope block;

  Null prepareInstructions() {
    super.prepareInstructions();
    block.prepareInstructions();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (!dynamicType.type!.canStaticallyProveCompatibilityWith(staticType)) {
      super.generateAssembler(assembler, blockId); // actual type check is here
      assembler.addCode(blockId, concat('jc ', continueLabel), 'skip next block if the type matches');
      block.generateAssembler(assembler, blockId);
      assembler.addCode(blockId, concat(continueLabel, ':'), null);
    }
    // TODO: xxxx we could also check if we can statically disprove compatibility
  }

  Null constructor(CompiledScope scopeArg, Type staticTypeArg, TypeHandle dynamicTypeArg, String continueLabelArg, CompiledScope blockArg, String whatArg) { 
    super.constructor(scopeArg, staticTypeArg, dynamicTypeArg, whatArg);
    continueLabel = scope.environment().generateLabel(concat(continueLabelArg, '$TypeMatch'));
    block = blockArg;
  }
}

class DoIfVarArgsTypeMismatchInstruction extends TypeCheckInstruction {
  String loopTopLabel;
  String continueLabel;
  String loopBottomLabel;
  CompiledScope block;

  Null prepareInstructions() {
    super.prepareInstructions();
    block.prepareInstructions();
  }

  Null generateInnerAssembler(Assembler assembler, Integer blockId) {
    assembler.addCmp(blockId, rsi, rdi, 'pointer to current argument', 'end of loop');
    assembler.addCode(blockId, concat('je ', loopBottomLabel), 'we have type-checked all the arguments');
    super.generateAssembler(assembler, blockId); // actual type check is here
    assembler.addCode(blockId, concat('jc ', continueLabel), 'skip next block if the type matches');
    block.generateAssembler(assembler, blockId);
    assembler.addCode(blockId, concat(continueLabel, ':'), null);
    assembler.addCode(blockId, 'add rsi, 010h', 'next argument');
    assembler.addCode(blockId, concat('jmp ', loopTopLabel), 'return to top of loop');
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // TODO: xxxx we could also check if we can statically disprove compatibility
    Integer offset = 0x08 /* type of first argument (if any) */
                   + 0x08 /* return value pointer */
                   + 0x20 /* shadow space */
                   + 0x08 /* return address */
                   + 0x08 * len(scope.stackFrame().nonvolatileRegistersUsed()); /* saved registers */
    assembler.addCode(blockId, concat('lea rsi, [rbp+', hex8(offset), ']'), 'initial index pointing to value of first argument');
    assembler.addCode(blockId, 'mov rdi, rcx', 'end of loop is the number of arguments...');
    assembler.addCode(blockId, 'shl rdi, 4', '...times the width of each argument (010h)...');
    assembler.addCode(blockId, 'add rdi, rsi', '...offset from the initial index');
    assembler.addCode(blockId, concat(loopTopLabel, ':'), null);
    assembler.indent(blockId, generateInnerAssembler);
    assembler.addCode(blockId, concat(loopBottomLabel, ':'), null);
  }

  Null constructor(CompiledScope scopeArg, Type staticTypeArg, String labelBase, CompiledScope blockArg, String whatArg) { 
    assert(scopeArg.stackFrame() is CompiledVarArgsSubroutine, 'this instruction uses rsi and rdi');
    TypeHandle typeHandle = ValueHandle(VotSource(staticTypeArg, 'varargs parameters'), DereferencedRegisterVot(staticTypeArg, 'rsi')).type;
    super.constructor(scopeArg, staticTypeArg, typeHandle, whatArg);
    CompilationEnvironment environment = scope.environment();
    loopTopLabel = environment.generateLabel(concat(labelBase, '$Loop'));
    continueLabel = environment.generateLabel(concat(labelBase, '$TypeMatch'));
    loopBottomLabel = environment.generateLabel(concat(labelBase, '$TypesAllMatch'));
    block = blockArg;
  }
}

class SubscriptInstruction extends Instruction {
  ValueHandle list;
  ValueHandle index;
  ValueHandle target;
  String boundsErrorLabel;
  String continueLabel;
  CompiledScope boundsErrorBlock;
  
  Null prepareInstructions() {
    super.prepareInstructions();
    boundsErrorBlock.prepareInstructions();
    target.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    ValueVot listVot = list.value!;
    if (listVot is VarArgsParameterVot) {
      assembler.addLea(blockId, r10, (listVot as VarArgsParameterVot).baseAddress(), 'base address of varargs');
      assembler.addMov(blockId, rax, index.value!.asOperand(), 'index into list');
      assembler.addCmp(blockId, rax, rcx, 'index into varargs', 'number of arguments');
      assembler.addCode(blockId, concat('jge ', boundsErrorLabel), 'index out of range (too high)');
      assembler.addCmp(blockId, rax, scope.environment().integer(0).value!.asOperand(), 'index into varargs', 'zero');
      assembler.addCode(blockId, concat('jns ', continueLabel), 'index not out of range (not negative)');
      assembler.addCode(blockId, concat(boundsErrorLabel, ':'), null);
      boundsErrorBlock.generateAssembler(assembler, blockId);
      assembler.addCode(blockId, concat(continueLabel, ':'), null);
      assembler.addOpcode(blockId, 'shl', [rax, Operand('4', otImm32)]:Operand, 'multiply by 8 * 2 to get to value');
      assembler.addMov(blockId, target.value!.asOperand(), Operand("r10+rax", otIndirect), 'store value');
      assembler.addOpcode(blockId, 'sub', [rax, Operand('8', otImm32)]:Operand, 'subtract 8 to get to the type');
      assembler.addMov(blockId, target.type.type!.asOperand(), Operand("r10+rax", otIndirect), 'store type');
    } else {
      throw('list subscript not implemented for this list type');
    }
  }

  Null constructor(CompiledScope scopeArg, ValueHandle listArg, ValueHandle indexArg, ValueHandle targetArg, CompiledScope boundsErrorBlockArg, String labelBase) { 
    super.constructor(scopeArg);
    list = listArg;
    index = indexArg;
    target = targetArg;
    boundsErrorBlock = boundsErrorBlockArg;
    CompilationEnvironment environment = scope.environment();
    boundsErrorLabel = environment.generateLabel(concat(labelBase, '$boundsError'));
    continueLabel = environment.generateLabel(concat(labelBase, '$inBounds'));
  }
}

class StoreTypeCheckInstruction extends TypeCheckInstruction {
  ValueHandle target;

  Null prepareInstructions() {
    super.prepareInstructions();
    target.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    super.generateAssembler(assembler, blockId);
    CompilationEnvironment environment = scope.environment();
    assembler.addMov(blockId, target.value!.asOperand(), environment.integer(0).value!.asOperand(), concat('clear ', target.source.debugName));
    assembler.addCode(blockId, concat('setc byte ptr ', target.value!.asOperand().value), concat('store result in ', target.source.debugName));
    assembler.addMov(blockId, target.type.type!.asOperand(), environment.intrinsicsLibrary!.coreBooleanType.asOperand(), concat(target.source.debugName, ' is a Boolean'));
  }

  Null constructor(CompiledScope scopeArg, Type staticTypeArg, TypeHandle dynamicTypeArg, ValueHandle targetArg, String whatArg) { 
    super.constructor(scopeArg, staticTypeArg, dynamicTypeArg, whatArg);
    target = targetArg;
  }
}

class MonoOperandInstruction extends Instruction {
  String opcode;
  ValueHandle rhs;
  ValueHandle result;
  Type resultType;
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    result.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, result.value!.asOperand(), rhs.value!.asOperand(), concat('move operand into location for result of ', opcode));
    assembler.addCode(blockId, concat('not qword ptr', result.value!.asOperand().value), comment);
    assembler.addMov(blockId, result.type.type!.asOperand(), resultType.asOperand(), 'store type');
  }

  Null constructor(CompiledScope scopeArg, String opcodeArg, ValueHandle rhsArg, ValueHandle resultArg, Type resultTypeArg, String commentArg) {
    super.constructor(scopeArg);
    opcode = opcodeArg;
    rhs = rhsArg;
    result = resultArg;
    resultType = resultTypeArg;
    comment = commentArg;
  }
}

class LogicalNotInstruction extends Instruction {
  ValueHandle rhs;
  ValueHandle result;
  Type resultType;
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    result.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addZero(blockId, r10, 'zero r10');
    assembler.addTest(blockId, rhs.value!.asOperand(), rhs.value!.asOperand(), rhs.source.debugName, rhs.source.debugName);
    assembler.addCode(blockId, 'sete byte ptr r10b', comment);
    assembler.addMov(blockId, result.value!.asOperand(), r10, 'store result');
    assembler.addMov(blockId, result.type.type!.asOperand(), resultType.asOperand(), 'store type');
  }

  Null constructor(CompiledScope scopeArg, ValueHandle rhsArg, ValueHandle resultArg, Type resultTypeArg, String commentArg) {
    super.constructor(scopeArg);
    rhs = rhsArg;
    result = resultArg;
    resultType = resultTypeArg;
    comment = commentArg;
  }
}

class ShiftInstruction extends Instruction {
  String opcode;
  ValueHandle lhs;
  ValueHandle rhs;
  ValueHandle result;
  Type resultType;
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    result.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, r10, lhs.value!.asOperand(), concat(opcode, ' mutates first operand, so indirect via register'));
    if (!rhs.value!.asOperand().isImmediate()) {
      Integer savedRegisterCount = len(scope.stackFrame().nonvolatileRegistersUsed());
      // TODO: move the responsibility for saving rcx into shadow space (and generally tracking register use) to the stack frame
      assembler.addMov(blockId, rcxShadow(savedRegisterCount), rcx, 'save rcx');
      assembler.addMov(blockId, rcx, rhs.value!.asOperand(), concat(opcode, ' uses rcx'));
      assembler.addMov(blockId, r10, lhs.value!.asOperand(), concat(opcode, ' mutates first operand, so indirect via register'));
      assembler.addOpcode(blockId, opcode, [r10, Operand("cl", otRegister) /* cl is rcx */]:Operand, comment);
      assembler.addMov(blockId, rcx, rcxShadow(savedRegisterCount), 'restore rcx');
    } else {
      assembler.addOpcode(blockId, opcode, [r10, rhs.value!.asOperand()]:Operand, comment);
    }
    assembler.addMov(blockId, result.value!.asOperand(), r10, 'store result');
    assembler.addMov(blockId, result.type.type!.asOperand(), resultType.asOperand(), 'store type');
  }

  Null constructor(CompiledScope scopeArg, String opcodeArg, ValueHandle lhsArg, ValueHandle rhsArg, ValueHandle resultArg, Type resultTypeArg, String commentArg) {
    super.constructor(scopeArg);
    opcode = opcodeArg;
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    resultType = resultTypeArg;
    comment = commentArg;
  }
}

class BiOperandInstruction extends Instruction {
  String opcode;
  ValueHandle lhs;
  ValueHandle rhs;
  ValueHandle result;
  Type resultType;
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    result.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, r10, lhs.value!.asOperand(), concat(opcode, ' mutates first operand, so indirect via register'));
    assembler.addOpcode(blockId, opcode, [r10, rhs.value!.asOperand()]:Operand, comment);
    assembler.addMov(blockId, result.value!.asOperand(), r10, 'store result');
    assembler.addMov(blockId, result.type.type!.asOperand(), resultType.asOperand(), 'store type');
  }

  Null constructor(CompiledScope scopeArg, String opcodeArg, ValueHandle lhsArg, ValueHandle rhsArg, ValueHandle resultArg, Type resultTypeArg, String commentArg) {
    super.constructor(scopeArg);
    opcode = opcodeArg;
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    resultType = resultTypeArg;
    comment = commentArg;
  }
}

class DivisonInstruction extends Instruction {
  ValueHandle lhs;
  ValueHandle rhs;
  ValueHandle result;
  Operand resultSource;
  Type resultType;
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    result.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assert(resultSource == rdx || resultSource == rax, 'invalid result source for idiv');
    // TODO: optimize power-of-two divisions to shifts
    // TODO: move the responsibility for saving rdx into shadow space (and generally tracking register use) to the stack frame
    Integer savedRegisterCount = len(scope.stackFrame().nonvolatileRegistersUsed());
    assembler.addMov(blockId, rdxShadow(savedRegisterCount), rdx, 'save rdx');
    assembler.addMov(blockId, rax, lhs.value!.asOperand(), 'prepare dividend');
    assembler.addZero(blockId, rdx, 'zero-extend dividend');
    Operand operand = rhs.value!.asOperand();
    if (operand.isImmediate()) {
      assembler.addMov(blockId, r10, operand, 'indirect via r10');
      assembler.addCode(blockId, 'idiv r10', comment);
    } else {
      assembler.addCode(blockId, concat('idiv ', operand.value), comment);
    }
    assembler.addMov(blockId, result.value!.asOperand(), resultSource, 'store result');
    assembler.addMov(blockId, result.type.type!.asOperand(), resultType.asOperand(), 'store type');
    assembler.addMov(blockId, rdx, rdxShadow(savedRegisterCount), 'restore rdx');
  }

  Null constructor(CompiledScope scopeArg, ValueHandle lhsArg, ValueHandle rhsArg, ValueHandle resultArg, Operand resultSourceArg, Type resultTypeArg, String commentArg) {
    super.constructor(scopeArg);
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    resultSource = resultSourceArg;
    resultType = resultTypeArg;
    comment = commentArg;
  }
}

enum cc { GreaterThan GreaterThanOrEqual LessThan LessThanOrEqual }

class StoreCmpInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  ValueHandle target;
  cc flag;
  CompilationEnvironment environment; 

  Null prepareInstructions() {
    super.prepareInstructions();
    target.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // TODO: hard-code result for literal comparisons
    String opcodeSuffix;
    if (flag == ccGreaterThan) {
      opcodeSuffix = 'g';
    } else if (flag == ccGreaterThanOrEqual) {
      opcodeSuffix = 'ge';
    } else if (flag == ccLessThan) {
      opcodeSuffix = 'l';
    } else if (flag == ccLessThanOrEqual) {
      opcodeSuffix = 'le';
    } else {
      assert(false, concat('unknown flag ', flag));
    }
    CompilationEnvironment environment = scope.environment();
    assembler.addMov(blockId, target.value!.asOperand(), environment.integer(0).value!.asOperand(), concat('clear ', target.source.debugName));
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), a.source.debugName, b.source.debugName);
    assembler.addCode(blockId, concat('set', opcodeSuffix, ' byte ptr ', target.value!.asOperand().value), concat('store result in ', target.source.debugName));
    assembler.addMov(blockId, target.type.type!.asOperand(), environment.intrinsicsLibrary!.coreBooleanType.asOperand(), concat(target.source.debugName, ' is a Boolean'));
  }

  Null constructor(CompiledScope scopeArg, ValueHandle aArg, ValueHandle bArg, ValueHandle targetArg, cc flagArg) { 
    super.constructor(scopeArg);
    a = aArg;
    b = bArg;
    target = targetArg;
    flag = flagArg;
  }
}

class StringConstantInstruction extends Instruction {
  String label;
  String value;
  SourceLocation source;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
    StringList data = ['dq -01h', concat('dq ', len(scalarValues(value)))]:String;
    StringNullableList comments = ['String constant (reference count)', 'Length']:StringNullable;
    if (value != '') {
      append(data, concat('db ', stringLiteral(value)));
      append(comments, concat(source));
      Integer padding = 8 - len(scalarValues(value)) % 8;
      if (padding > 0) {
        StringList buffer = []:String;
        append(buffer, 'db ');
        while (padding > 0) {
          append(buffer, '00h');
          if (padding > 1) {
            append(buffer, ', ');
          }
          padding -= 1;
        }
        append(data, joinList(buffer));
        append(comments, 'padding to align to 8-byte boundary');
      }
    }
    assembler.addConst(label, data, comments);
  }  

  Null constructor(CompiledScope scopeArg, String labelArg, String valueArg, SourceLocation sourceArg) {
    super.constructor(scopeArg);
    label = labelArg;
    value = valueArg;
    source = sourceArg;
  }
}

class SlotInstruction extends Instruction {
  Slot slot;

  Null constructor(CompiledScope scopeArg, Slot slotArg) {
    super.constructor(scopeArg);
    slot = slotArg;
  }

  String toString() {
    return concat('<', className, '(', slot, ')@', internalObjectId, '>');
  }
}

class PopulateValueHandleInstruction extends SlotInstruction {
  ValueHandle handle;
  Boolean inlined;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (!inlined) {
      assert(handle.value == null, concat('tried to generate assembler for a PopulateValueHandleInstruction (', this, ') after its handle (', handle, ') was already populated'));
      assert(slot.location != null, concat('tried to generate assembler for a PopulateValueHandleInstruction (', this, ') before the slot\'s location was populated'));
      handle.assign(slot.location!);
    }
  }

  Null constructor(CompiledScope scopeArg, Slot slotArg, ValueHandle handleArg) {
    super.constructor(scopeArg, slotArg);
    handle = handleArg;
    if (slot.location != null && slot.isImmutable) {
      // we aggressively do this if possible, so that constants et al can be inlined
      handle.assign(slot.location!);
      inlined = true;
    } else {
      inlined = false;
    }
  }
}

class WriteStaticSlotInstruction extends SlotInstruction {
  ValueVot value;
  Boolean inlined;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (!inlined) {
      if (slot.location != null) {
        assert(!slot.isImmutable, 'cannot change a static slot\'s value');
        // XXX call incref, decref
        assembler.addMov(blockId, slot.location!.asOperand(), value.asOperand(), concat('value of ', slot.debugName));
        if (slot.staticType.hasDynamicType()) {
          assert(value.staticType.hasDynamicType(), concat('unexpectedly tried to map value of normal type ', slot.staticType, ' to non-dynamic-supporting type ', value.staticType));
          assembler.addMov(blockId, slot.location!.dynamicType().asOperand(), value.dynamicType().asOperand(), concat('type of ', slot.debugName));
        }
      } else {
        assert(false, 'dynamic slot assignment for static slots not supported');
        // before enabling this code, think hard about how it affects string reference counting
        slot.assignLocation(value);
      }
    }
  }

  Null constructor(CompiledScope scopeArg, Slot slotArg, ValueVot valueArg) {
    super.constructor(scopeArg, slotArg);
    value = valueArg;
    if (slot.isImmutable) {
      slot.assignLocation(value);
      // XXX need to exempt slot from incref and decref
      inlined = true;
    } else {
      inlined = false;
    }
  }
}

class WriteDynamicSlotInstruction extends SlotInstruction {
  ValueHandle value;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (slot.location != null) {
      // XXX call incref, decref
      assembler.addMov(blockId, slot.location!.asOperand(), value.value!.asOperand(), concat('value of ', slot.debugName));
      if ((slot.staticType as Type).hasDynamicType()) {
        assembler.addMov(blockId, slot.location!.dynamicType().asOperand(), value.type.type!.asOperand(), concat('type of ', slot.debugName));
      }
    } else {
      assert(false, concat('dynamic slot assignment for dynamic slots not supported (slot: ', slot.debugName, ')'));
      // before enabling this code, think hard about how it affects string reference counting
      slot.assignLocation(value.value!);
    }
  }

  Null constructor(CompiledScope scopeArg, Slot slotArg, ValueHandle valueArg) {
    super.constructor(scopeArg, slotArg);
    value = valueArg;
  }
}

class WriteReinterpretAsInstruction extends SlotInstruction {
  ValueHandle value;
  Type type;

  Null prepareInstructions() {
    super.prepareInstructions();
    slot.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (slot.location == null) {
      // probably means it's not read
      // no point storing the value anywhere
      return;
    }
    assembler.addMov(blockId, slot.location!.asOperand(), value.value!.asOperand(), concat('value of ', slot.debugName));
    assembler.addMov(blockId, slot.location!.dynamicType().asOperand(), type.asOperand(), concat('new type of ', slot.debugName));
  }

  Null constructor(CompiledScope scopeArg, Slot slotArg, ValueHandle valueArg, Type typeArg) {
    super.constructor(scopeArg, slotArg);
    value = valueArg;
    type = typeArg;
  }
}

class SubroutineVot extends ImmediateAddressVot {
  CompiledSubroutine subroutine;

  Null constructor(CompiledSubroutine subroutineArg) {
    super.constructor(subroutineArg.type, subroutineArg.label);
    subroutine = subroutineArg;
  }
}

class SubroutineCallInstruction extends Instruction {
  ValueHandle target; // points to a CompiledSubroutine
  ValueHandleList arguments;
  ValueHandle thisPointer;
  ValueHandle closurePointer;
  ValueHandle returnValue;

  // We expect the caller to have done the static type checks.

  Null prepareInstructions() {
    super.prepareInstructions();
    returnValue.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    saveVolatileRegisters(assembler, blockId);
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      assembler.addPush(blockId, arguments[argumentIndex].value!.asOperand(), concat('value of argument #', argumentIndex + 1));
      assembler.addPush(blockId, arguments[argumentIndex].value!.dynamicType().asOperand(), concat('type of argument #', argumentIndex + 1));
      argumentIndex -= 1;
    }
    // XXX why do we do addlea/addpush via r10 instead of just addpush?
    assembler.addLea(blockId, r10, returnValue.value!.asOperand(), 'pointer to return value (and type, 8 bytes earlier)');
    assembler.addPush(blockId, r10, '(that pointer is the last value pushed to the stack)');
    // TODO: assembler.addCode(blockId, 'sub rsp, 8h', 'align to 16 byte boundary'); XXX need to also implement this on callee side
    assembler.addMov(blockId, r9, thisPointer.value!.asOperand(), 'pointer to this');
    assembler.addMov(blockId, r8, thisPointer.value!.dynamicType().asOperand(), 'type of this');
    assembler.addMov(blockId, rdx, closurePointer.value!.asOperand(), 'pointer to closure');
    assembler.addCode(blockId, concat('mov rcx, ', len(arguments)), 'number of arguments');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, concat('call ', target.value!.asOperand().value), 'jump to subroutine');
    assembler.addCode(blockId, concat('add rsp, ', hex8(32 + 8 * 2 * len(arguments) + 8)), 'release shadow space and arguments');
    restoreVolatileRegisters(assembler, blockId);
  }  

  Null constructor(CompiledScope scopeArg, ValueHandle targetArg, ValueHandleList argumentsArg, ValueHandle thisPointerArg, ValueHandle closurePointerArg, ValueHandle returnValueArg) {
    super.constructor(scopeArg);
    target = targetArg;
    arguments = argumentsArg;
    thisPointer = thisPointerArg;
    closurePointer = closurePointerArg;
    returnValue = returnValueArg;
  }
}

// ============================================================================
// SLOTS
// ============================================================================

class Slot extends VotSource {
  Boolean isAnonymous;
  Boolean isImmutable; // if true, this slot is immutable (can only be written once)

  CompiledScope homeScope; 
  Set referencingStackFrames = Set(); // of CompiledStackFrameScope
  Boolean forcedAllocation = false;
  Boolean isRead = false;
  Boolean hasSpecificLocation = true;

  Null forceAllocation() {
    forcedAllocation = true;
  }

  Null recordWrite(Boolean hasSpecificLocation) {
    hasSpecificLocation = hasSpecificLocation && hasSpecificLocation;
  }

  ValueHandle read(CompiledScope currentScope) {
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(currentScope.stackFrame());
    isRead = true;
    currentScope.emitInstruction(PopulateValueHandleInstruction(currentScope, this, result));
    return result;
  }

  Null writeStatic(CompiledScope currentScope, ValueVot newValue) { 
    referencingStackFrames.add(currentScope.stackFrame());
    currentScope.emitInstruction(WriteStaticSlotInstruction(currentScope, this, newValue));
    recordWrite(true);
  }

  Null write(CompiledScope currentScope, ValueHandle newValue) { 
    referencingStackFrames.add(currentScope.stackFrame());
    currentScope.emitInstruction(WriteDynamicSlotInstruction(currentScope, this, newValue));
    recordWrite(false);
  }

  ValueHandle prepareWrite(CompiledScope currentScope) { 
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(currentScope.stackFrame());
    currentScope.emitInstruction(PopulateValueHandleInstruction(currentScope, this, result));
    recordWrite(false);
    return result;
  }

  Null writeReinterpret(CompiledScope currentScope, ValueHandle value, Type type) { 
    referencingStackFrames.add(currentScope.stackFrame());
    currentScope.emitInstruction(WriteReinterpretAsInstruction(currentScope, this, value, type));
    recordWrite(false);
  }

  Boolean needsAllocation() {
    return isRead && (!isImmutable || forcedAllocation || !hasSpecificLocation);
  }

  Boolean isGlobal() {
    return homeScope is CompiledLibrary;
  }

  Boolean canBeGloballyAllocated() {
    return isGlobal();
  }

  Boolean canBeStackAllocated() {
    AnythingList stackFrames = referencingStackFrames.values();
    return (len(stackFrames) == 1)
        && (stackFrames[0] == homeScope.stackFrame())
        && (isAnonymous || !isGlobal());
  }

  Boolean canBeHeapAllocated() {
    return !isGlobal();
  }

  ValueVotNullable location = null;

  Null assignLocation(ValueVot locationArg) {
    assert(location == null || !isImmutable, concat('tried to assign a second location to static slot ', this));
    location = locationArg;
  }

  String toString() {
    String constant = '';
    if (hasSpecificLocation) {
      constant = '; compile-time constant';
    }
    String forced = '';
    if (forcedAllocation) {
      forced = '; forced allocation';
    }
    return concat('<', debugName, ': ', staticType, ' at ', location, constant, forced, '>');
  }

  Null constructor(Type staticTypeArg, CompiledScope homeScopeArg, String debugNameArg, Boolean isAnonymousArg, Boolean isImmutableArg) { 
    super.constructor(staticTypeArg, debugNameArg);
    homeScope = homeScopeArg;
    isAnonymous = isAnonymousArg;
    isImmutable = isImmutableArg;
  }
}


// ============================================================================
// SCOPES
// ============================================================================

class CompiledScope extends Object {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name; // TODO: rethink exactly what this means

  CompiledLibrary globalScope() { 
    assert(parent != null, 'compiled scope chain failure');
    return parent!.globalScope();
  }

  CompiledStackFrameScope stackFrame() { 
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = parent!.stackFrame() as CompiledScope;
    return result;
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return parent!.environment();
  }

  String labelPrefix() {
    abstract();
  }

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable value = identifiers.get(name) as SlotNullable;
    if (value == null && parent != null) {
      value = parent!.lookupIdentifier(name);
    }
    return value;
  }

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }

  Null registerSlot(Slot slot) {
    stackFrame().registerSlot(slot);
    // subclasses override this to add more behaviour
  }

  Slot registerDynamicValue(Type type, String debugName) {
    Slot slot = Slot(type, this, debugName, true, true); // anonymous, immutable
    registerSlot(slot);
    return slot;
  }

  Slot registerStaticValue(ValueVot value, String debugName) {
    Slot slot = Slot(value.staticType, this, debugName, true, true); // anonymous, immutable
    registerSlot(slot);
    slot.writeStatic(this, value);
    return slot;
  }

  Slot registerVariable(String name, Type type, ValueHandle initialValue) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    Slot slot = Slot(type, this, name, false, false); // named, mutable
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, initialValue);
    return slot;
  }

  Slot registerConstant(String name, ValueVot value) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    Slot slot = Slot(value.staticType, this, name, false, true); // named, immutable
    globalScope().registerSlot(slot);
    identifiers.set(name, slot);
    slot.writeStatic(this, value);
    value.staticType.markConstructed();
    return slot;
  }

  Slot registerSubroutine(CompiledSubroutine subroutine) { 
    assert(!isIdentifierDeclaredInLocalScope(subroutine.name), concat('tried to redeclare an identifier (', subroutine.name, ') within a scope'));
    Slot slot = Slot(subroutine.type, this, subroutine.name, false, true); // named, immutable
    registerSlot(slot);
    identifiers.set(subroutine.name, slot);
    slot.writeStatic(this, SubroutineVot(subroutine));
    environment().addSubroutine(subroutine);
    subroutine.type.markConstructed();
    return slot;
  }

  Slot emitSubroutineCall(ValueHandle target, ValueHandleList arguments) {
    // xxxx statically check arguments are the right type if the types are known
    if (target.value is SubroutineVot) {
      SlotNullable result = (target.value! as SubroutineVot).subroutine.inline(this, arguments);
      if (result != null) {
        return result;
      }
    }
    Slot thisPointer = registerDynamicValue(environment().intrinsicsLibrary!.coreClassType, 'this pointer for function call (placeholder)');
    Slot closurePointer = registerDynamicValue(environment().intrinsicsLibrary!.coreClosureType, 'closure pointer for function call (placeholder)');
    thisPointer.writeStatic(this, environment().intrinsicsLibrary!.coreSentinel);
    closurePointer.writeStatic(this, environment().intrinsicsLibrary!.coreSentinel);
    Type returnType;
    VotSource targetSlot = target.source;
    if (targetSlot.staticType.isSubroutineType()) {
      AbstractSubroutineType subroutineType = targetSlot.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    } else {
      returnType = environment().intrinsicsLibrary!.coreAnythingType;
    }
    ValueHandle thisPointerRead = thisPointer.read(this);
    ValueHandle closurePointerRead = closurePointer.read(this);
    Slot returnValue = registerDynamicValue(returnType, 'return value');
    ValueHandle returnValuePointer = returnValue.read(this);
    SubroutineCallInstruction call = SubroutineCallInstruction(
      this,
      target,
      arguments,
      thisPointerRead,
      closurePointerRead,
      returnValuePointer,
    );
    append(instructions, call);
    return returnValue;
  }

  CompiledNestedScope createErrorHandlerBlock(Slot errorMessage, String what) {
    CompiledScope block = CompiledNestedScope(this, concat(camelCase(what), '$Error'));
    block.emitInstruction(CommentInstruction(this, concat('Error handling block for ', what)));
    String label = environment().generateLabel(concat(block.labelPrefix(), '$', camelCase(what), '$Ok'));
    ValueHandle printHandle = environment().intrinsicsLibrary!.corePrint.read(block);
    block.emitInstruction(CommentInstruction(this, concat(' - print(', errorMessage.debugName, ')')));
    block.emitSubroutineCall(printHandle, [ errorMessage.read(block) ]);
    ValueHandle exitHandle = environment().intrinsicsLibrary!.coreExit.read(block);
    ValueHandle failureExitCode = environment().integer(0x01);
    block.emitInstruction(CommentInstruction(this, concat(' - exit(1)')));
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    return block;
  }

  Null emitTypeCheck(ValueHandle value, Type type, Slot errorMessage, String what) {
    CompiledScope block = createErrorHandlerBlock(errorMessage, what);
    append(instructions, DoIfTypeMismatchInstruction(this, type, value.type, concat(labelPrefix(), '$', camelCase(what)), block, what));
  }

  Null emitBlock(CompiledNestedScope block) {
    append(instructions, DoBlockInstruction(this, block));
  }

  // runs block if a != b
  Null emitConditionalBlock(CompiledNestedScope block, ValueHandle a, ValueHandle b, String what, String comment) {
    String label = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$continuation'));
    append(instructions, JumpIfEqualInstruction(this, a, b, label, comment));
    append(instructions, DoBlockInstruction(this, block));
    append(instructions, LabelInstruction(this, label, concat('end of ', what)));
  }

  // jumps to label if a == b
  Null emitConditionalJump(String label, ValueHandle a, ValueHandle b, String comment) {
    append(instructions, JumpIfEqualInstruction(this, a, b, label, comment));
  }

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepareInstructions();
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    for (instruction in instructions) {
      instruction.generateAssembler(assembler, blockId);
    }
  }  

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', name, ':', className, '@', internalObjectId, '>');
  }
}

class CompiledNestedScope extends CompiledScope {
  String labelPrefix() {
    return concat(parent!.labelPrefix(), '$', name);
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.indent(blockId, super.generateAssembler);
  }

  Null constructor(CompiledScope parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledStackFrameScope extends CompiledScope {
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  SlotList slots = []:Slot;

  Null registerSlot(Slot slot) {
    append(slots, slot);
  }

  Integer stackSize = 0x00;

  SlotList bssSlots = []:Slot;

  Null prepareSlots() {
    for (slot in slots) {
      //stderr(concat(slot, ' read:', slot.isRead, ' needsAllocation:', slot.needsAllocation(), ' stack?:', slot.canBeStackAllocated(), ' heap?:', slot.canBeHeapAllocated(), ' global?:', slot.canBeGloballyAllocated()));
      if (slot.needsAllocation()) {
        if (slot.canBeStackAllocated()) {
          // TODO emit a comment giving the stack layout for this stack frame
          slot.assignLocation(StackAllocatedVot(slot.staticType, stackSize));
          if (slot.staticType.hasDynamicType()) {
            stackSize += 0x10;
          } else {
            stackSize += 0x08;
          }
        } else if (slot.canBeGloballyAllocated()) {
          String valueLabel = environment().generateLabel(concat('global', len(bssSlots), 'Value'));
          String typeLabel = environment().generateLabel(concat('global', len(bssSlots), 'Type'));
          slot.assignLocation(GlobalVariableVot(slot.staticType, valueLabel, typeLabel));
          append(bssSlots, slot);
        } else {
          throw(concat('not sure what to do with ', slot, ' in terms of allocation'));
        }
      }
    }
  }

  // Returns (a new copy of) the list of the registers to save/restore in the prolog/epilog.
  // These are the non-volatile registers that are modified in this scope.
  // The list may be modified by the caller.
  // The rbp register must come first.
  StringList nonvolatileRegistersUsed() {
    return ['rbp'];
  }

  Null generatePrologAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, 'Prolog');
    StringList registers = nonvolatileRegistersUsed();
    assert(registers[0] == 'rbp', 'nonvolatileRegistersUsed() did not return rbp first');
    for (register in registers) {
      assembler.addCode(blockId, concat('push ', register), 'save non-volatile registers');
    }
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      // TODO: if stackSize > 8KB (0x2000), call __chkstk__
      assert(stackSize < 0x2000, 'need to implement calling __chkstk__');
      assembler.addCode(blockId, concat('sub rsp, ', hex8(stackSize)), 'allocate space for stack');
    }
    assembler.addCode(blockId, concat('lea rbp, [rsp+', hex8(stackSize), ']'), 'set up frame pointer');
  }

  Null generateEpilogAssembler(Assembler assembler, Integer blockId) {
    //xxx add string decrefs
    assembler.addComment(blockId, 'Epilog');
    if (stackSize > 0) {
      assembler.addCode(blockId, concat('add rsp, ', hex8(stackSize)), 'free space for stack');
    }
    StringList registers = nonvolatileRegistersUsed();
    Integer index = len(registers);
    while (index > 0) {
      index -= 1;
      assembler.addCode(blockId, concat('pop ', registers[index]), 'restore non-volatile registers');
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    for (slot in bssSlots) {
      assembler.addBss((slot.location as GlobalVariableVot).valueLabel, 4, slot.debugName);
      assembler.addBss((slot.location as GlobalVariableVot).typeLabel, 4, concat('dynamic type of ', slot.debugName));
    }
    generatePrologAssembler(assembler, blockId);
    super.generateAssembler(assembler, blockId);
    generateEpilogAssembler(assembler, blockId);
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class ReturnInstruction extends JumpInstruction {
  Null constructor(CompiledScope scopeArg, String commentArg) { 
    CompiledStackFrameScope stackFrame = scopeArg.stackFrame();
    assert(stackFrame is CompiledSubroutine, 'cannot return from non-subroutine');
    super.constructor(scopeArg, (stackFrame as CompiledSubroutine).epilogLabel, commentArg);
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineTypeWithSpecificParameters type; // subroutine signature
  String label;
  String epilogLabel;

  Slot returnValue;

  String labelPrefix() {
    return concat('func$', name);
  }

  SlotNullable inline(CompiledScope scope, ValueHandleList arguments) {
    return null;
  }

  StringList nonvolatileRegistersUsed() {
    StringList result = super.nonvolatileRegistersUsed();
    append(result, 'r15');
    return result;
  }

  Null generatePrologAssembler(Assembler assembler, Integer blockId) {
    super.generatePrologAssembler(assembler, blockId);
    Integer savedRegisterCount = len(nonvolatileRegistersUsed());
    Integer offset = 0x08 /* return address */ + 0x20 /* shadow space */ + 0x08 * savedRegisterCount;
    assembler.addMov(blockId, r15, Operand(concat('rbp+', hex8(offset)), otIndirect), 'prepare return value');
  }

  Null generateEpilogAssembler(Assembler assembler, Integer blockId) {
    // xxxx set default return value, fail if there's no explicit return value in method that can't return null
    assembler.addCode(blockId, concat(epilogLabel, ':'), null);
    assembler.addMov(blockId, rax, r15, 'report address of return value');
    super.generateEpilogAssembler(assembler, blockId);
    assembler.addCode(blockId, 'ret', 'return from subroutine');
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.addLabel(label, name));
  }

  Null emitReturnFrom(CompiledScope scope, ValueHandle value) {
    // xxxx verify the type of value statically
    scope.emitTypeCheck(value, type.returnType, environment().intrinsicsLibrary!.returnValueTypeCheckFailureMessage as Slot, concat('return value of ', name));
    returnValue.write(scope, value);
    scope.emitInstruction(ReturnInstruction(this, 'return'));
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
    label = environment().generateLabel(labelPrefix());
    epilogLabel = environment().generateLabel(concat(labelPrefix(), '$epilog'));
    returnValue = registerDynamicValue(type.returnType, 'return value');
    returnValue.assignLocation(OperandPairVot(type.returnType, Operand('r15-08h', otIndirect), Operand('r15', otIndirect)));
    // XXX need to exempt returnValue from decreffing (but it SHOULD incref)
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class CompiledSubroutineWithSpecificParameters extends CompiledSubroutine {
  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = Slot(type, this, name, false, true); // named, immutable
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.writeStatic(this, ParameterVot(type, len(nonvolatileRegistersUsed()), position));
    return slot;
  }

  Null emitParameterChecks(SlotList parameters) {
    // xxxx verify the types statically
    // check for parameter count
    emitInstruction(CommentInstruction(this, 'Check parameter count'));
    Slot paramCount = registerStaticValue(OperandVot(environment().intrinsicsLibrary!.coreIntegerType as Type, rcx), 'parameter count');
    ValueHandle paramCountValue = paramCount.read(this);
    ValueHandle expectedParamCountValue = environment().integer(len(parameters));
    CompiledNestedScope block = createErrorHandlerBlock(
      environment().intrinsicsLibrary!.parameterCountCheckFailureMessage,
      'parameter count',
    );
    emitConditionalBlock(block, paramCountValue, expectedParamCountValue, 'parameter count', 'check number of parameters is as expected');
    Integer index = 0;
    for (parameter in parameters) {
      emitInstruction(CommentInstruction(this, concat('Check type of parameter ', index, ', ', parameter.debugName, ' (expecting ', parameter.staticType, ')')));
      emitTypeCheck(parameter.read(this), parameter.staticType, environment().intrinsicsLibrary!.parameterTypeCheckFailureMessage, parameter.debugName);
      index += 1;
    }
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class CompiledVarArgsSubroutine extends CompiledSubroutine {
  StringList nonvolatileRegistersUsed() {
    StringList result = super.nonvolatileRegistersUsed();
    append(result, 'rsi');
    append(result, 'rdi');
    return result;
  }

  Slot registerVarArgsParameter(String name, Type type) {
    Type listType = createOrFindReadOnlyListType(environment(), type);
    listType.markConstructed();
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter name');
    Slot slot = Slot(listType, this, name, false, true); // named, immutable
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.writeStatic(this, VarArgsParameterVot(listType, len(nonvolatileRegistersUsed())));
    return slot;
  }

  Null emitVarArgsParameterChecks(Type parameterType) {
    // xxxx verify the types statically
    CompiledScope block = createErrorHandlerBlock(environment().intrinsicsLibrary!.parameterTypeCheckFailureMessage, 'vararg types');
    emitInstruction(DoIfVarArgsTypeMismatchInstruction(this, parameterType, concat(labelPrefix(), '$varargTypeChecks'), block, 'vararg types'));
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithVarArgs signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters {
  SlotList parameters;

  StringList parameterDescriptions() {
    return []:String;
  }

  Null generateInstructions() { }

  Null prepareInstructions() {
    parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    StringList descriptions = parameterDescriptions();
    assert(len(descriptions) == len(signature.parameterTypes), concat(className, '.parameterDescriptions() returned an unexpected number of descriptions (descriptions were ', descriptions, '; parameter types were ', signature.parameterTypes, ')'));
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, registerStaticValue(
        ParameterVot(signature.parameterTypes[index], len(nonvolatileRegistersUsed()), index),
        descriptions[index],
      ));
      index += 1;
    }
    emitParameterChecks(parameters);
    generateInstructions();
    super.prepareInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutineInstructions extends Instruction {
  ValueHandle lpNumberOfCharsWritten;
  ValueHandle parameter;

  Null prepareInstructions() {
    super.prepareInstructions();
    lpNumberOfCharsWritten.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetStdHandle');
    assembler.addExternProc('WriteConsoleA');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling GetStdHandle');
    assembler.addCode(blockId, 'mov rcx, -11', 'argument #1: STD_OUTPUT_HANDLE');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call GetStdHandle', 'handle returned in rax');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    assembler.addComment(blockId, 'Calling WriteConsoleA');
    assembler.addCode(blockId, 'push 0', 'argument #5: Reserved, must be NULL (lpReserved)');
    assembler.addLea(blockId, r9, lpNumberOfCharsWritten.value!.asOperand(), 'argument #4: Number of characters written (lpNumberOfCharsWritten)');
    assembler.addMov(blockId, r10, parameter.value!.asOperand(), 'get address of string structure');
    assembler.addCode(blockId, 'mov r8, [r10+08h]', 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure');
    assembler.addCode(blockId, 'lea rdx, [r10+10h]', 'argument #2: Pointer to buffer to write (*lpBuffer)');
    assembler.addCode(blockId, 'mov rcx, rax', 'argument #1: Handle from GetStdHandle (hConsoleOutput)');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call WriteConsoleA', 'returns boolean representing success in rax');
    assembler.addCode(blockId, 'add rsp, 28h', 'release shadow space and arguments');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle lpNumberOfCharsWrittenArg, ValueHandle parameterArg) {
    super.constructor(scopeArg);
    lpNumberOfCharsWritten = lpNumberOfCharsWrittenArg;
    parameter = parameterArg;
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['message to print to console'];
  }

  Null generateInstructions() {
    Slot lpNumberOfCharsWritten = registerDynamicValue((parent! as CompiledIntrinsicsLibrary).coreSystemType as Type, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    ValueHandle lpNumberOfCharsWrittenPointer = lpNumberOfCharsWritten.read(this);
    ValueHandle parameterValue = parameters[0].read(this);
    emitInstruction(BuiltInPrintSubroutineInstructions(this, lpNumberOfCharsWrittenPointer, parameterValue));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [parentArg.coreStringType]:Type),
      '__print',
    );
  }
}

class BuiltInExitSubroutineInstructions extends Instruction {
  ValueHandle exitCode;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('ExitProcess');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling ExitProcess');
    assembler.addMov(blockId, rcx, exitCode.value!.asOperand(), 'exit code');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call ExitProcess', 'process should terminate at this point');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle exitCodeArg) {
    super.constructor(scopeArg);
    exitCode = exitCodeArg;
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['exit code parameter'];
  }

  Null generateInstructions() {
    Slot exitCode = parameters[0];
    ValueHandle exitCodeValue = exitCode.read(this);
    emitInstruction(BuiltInExitSubroutineInstructions(this, exitCodeValue));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [ parentArg.coreIntegerType ]:Type),
      'exit',
    );
  }
}

class KernelGetProcessHeapInstruction extends Instruction {
  ValueHandle result;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetProcessHeap');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling GetProcessHeap');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call GetProcessHeap', 'handle returned in rax');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    assembler.addMov(blockId, result.value!.asOperand(), rax, 'heap handle');
    assembler.addMov(blockId, result.type.type!.asOperand(), scope.environment().intrinsicsLibrary!.coreIntegerType.asOperand(), 'heap handle is an integer');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle resultArg) {
    super.constructor(scopeArg);
    result = resultArg;
  }
}

class KernelGetProcessHeapSubroutine extends BuiltInSubroutine {
  Null generateInstructions() {
    emitInstruction(KernelGetProcessHeapInstruction(this, returnValue.prepareWrite(this)));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreIntegerType, []:Type),
      '__getProcessHeap',
    );
  }
}

class KernelHeapAllocInstruction extends Instruction {
  ValueHandle heapHandle;
  ValueHandle flags;
  ValueHandle size;
  ValueHandle result;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('HeapAlloc');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling HeapAlloc');
    assembler.addMov(blockId, rcx, heapHandle.value!.asOperand(), 'hHeap argument');
    assembler.addMov(blockId, rdx, flags.value!.asOperand(), 'dwFlags argument');
    assembler.addMov(blockId, r8, size.value!.asOperand(), 'dwBytes argument');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call HeapAlloc', 'pointer returned in rax');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    assembler.addMov(blockId, result.value!.asOperand(), rax, 'pointer');
    assembler.addMov(blockId, result.type.type!.asOperand(), scope.environment().intrinsicsLibrary!.coreIntegerType.asOperand(), 'pointer is an integer');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle heapHandleArg, ValueHandle flagsArg, ValueHandle sizeArg, ValueHandle resultArg) {
    super.constructor(scopeArg);
    heapHandle = heapHandleArg;
    flags = flagsArg;
    size = sizeArg;
    result = resultArg;
  }
}

class KernelHeapAllocSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['heapHandle', 'flags', 'size'];
  }

  Null generateInstructions() {
    emitInstruction(KernelHeapAllocInstruction(this, parameters[0].read(this), parameters[1].read(this), parameters[2].read(this), returnValue.prepareWrite(this)));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__heapAlloc',
    );
  }
}

class KernelHeapFreeInstruction extends Instruction {
  ValueHandle heapHandle;
  ValueHandle flags;
  ValueHandle pointer;
  ValueHandle result;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('HeapFree');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling HeapFree');
    assembler.addMov(blockId, rcx, heapHandle.value!.asOperand(), 'hHeap argument');
    assembler.addMov(blockId, rdx, flags.value!.asOperand(), 'dwFlags argument');
    assembler.addMov(blockId, r8, pointer.value!.asOperand(), 'lpMem argument');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call HeapFree', 'result (positive for success, zero for failure) is in rax');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    assembler.addMov(blockId, result.value!.asOperand(), rax, 'result (positive for success, zero for failure)');
    assembler.addMov(blockId, result.type.type!.asOperand(), scope.environment().intrinsicsLibrary!.coreIntegerType.asOperand(), 'result is an integer');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle heapHandleArg, ValueHandle flagsArg, ValueHandle pointerArg, ValueHandle resultArg) {
    super.constructor(scopeArg);
    heapHandle = heapHandleArg;
    flags = flagsArg;
    pointer = pointerArg;
    result = resultArg;
  }
}

class KernelHeapFreeSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['heapHandle', 'flags', 'pointer'];
  }

  Null generateInstructions() {
    emitInstruction(KernelHeapFreeInstruction(this, parameters[0].read(this), parameters[1].read(this), parameters[2].read(this), returnValue.prepareWrite(this)));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__heapFree',
    );
  }
}

class KernelGetLastErrorInstruction extends Instruction {
  ValueHandle result;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetLastError');
    saveVolatileRegisters(assembler, blockId);
    assembler.addComment(blockId, 'Calling GetLastError');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call GetLastError', 'error code returned in rax');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
    assembler.addMov(blockId, result.value!.asOperand(), rax, 'error code');
    assembler.addMov(blockId, result.type.type!.asOperand(), scope.environment().intrinsicsLibrary!.coreIntegerType.asOperand(), 'error code is an integer');
    restoreVolatileRegisters(assembler, blockId);
  }

  Null constructor(CompiledScope scopeArg, ValueHandle resultArg) {
    super.constructor(scopeArg);
    result = resultArg;
  }
}

class KernelGetLastErrorSubroutine extends BuiltInSubroutine {
  Null generateInstructions() {
    emitInstruction(KernelGetLastErrorInstruction(this, returnValue.prepareWrite(this)));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreIntegerType, []:Type),
      '__getLastError',
    );
  }
}

class BuiltInLenSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['list'];
  }

  SlotNullable inline(CompiledScope scope, ValueHandleList arguments) {
    if (len(arguments) == 1 && arguments[0].value is VarArgsParameterVot) {
      return scope.registerStaticValue(OperandVot(environment().intrinsicsLibrary!.coreIntegerType as Type, rcx), 'parameter count');
    }
    assert(false, 'non-inline len() not yet implemented');
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    // TODO: implement
    emitInstruction(CommentInstruction(this, 'TODO: implement "len" function'));
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ createOrFindReadOnlyListType(parentArg.environment(), parentArg.coreWhateverType) ]:Type,
      ),
      'len',
    );
  }
}

class Interrupt3Instruction extends Instruction {
  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, 'int 3', 'call debugger');
  }
}

class BuiltInDebuggerSubroutine extends BuiltInSubroutine {
  SlotNullable inline(CompiledScope scope, ValueHandleList arguments) {
    if (len(arguments) == 0) {
      scope.emitInstruction(Interrupt3Instruction(scope));
      return environment().intrinsicsLibrary!.coreNull;
    }
    assert(false, 'non-inline debugger() not yet implemented');
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    // TODO: implement
    emitInstruction(CommentInstruction(this, 'TODO: implement "debugger" function'));
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ ]:Type,
      ),
      '__debugger',
    );
  }
}

class CompilerIntrinsic extends BuiltInSubroutine {
  Slot inlineBody(CompiledScope scope, ValueHandleList arguments) {
    abstract();
  }

  Boolean verifyArguments(ValueHandleList arguments, TypeList parameters) {
    assert(len(parameters) == len(arguments), 'unexpected number of arguments');
    Integer index = 0;
    while (index < len(arguments)) {
      assert(
        arguments[index].source.staticType.isSubtypeOf(parameters[index]),
        concat('argument ', index, ' has unexpected type (wanted ', arguments[index].source.staticType, ' but got ', parameters[index], ')'),
      );
      index += 1;
    }
    return true;
  }

  SlotNullable inline(CompiledScope scope, ValueHandleList arguments) {
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    assert(verifyArguments(arguments, signature.parameterTypes), 'unexpected arguments');
    Slot result = inlineBody(scope, arguments);
    assert(result.staticType == signature.returnType, concat(this, ' returned slot of wrong type (expected ', signature.returnType, ' but got ', result.staticType, ')'));
    return result;
  }
}

class BuiltInReadFromAddressIntrinsicInstruction extends Instruction {
  ValueHandle address;
  Slot returnValue;

  Null prepareInstructions() {
    super.prepareInstructions();
    returnValue.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (returnValue.location == null) {
      // value isn't read, so no need to do anything
      return;
    }
    assembler.addMov(blockId, r10, address.value!.asOperand(), concat('value of ', address.source.debugName));
    assembler.addMov(blockId, returnValue.location!.asOperand(), r10Dereference, concat('dereference ', address.source.debugName, ' and put result in ', returnValue.debugName));
    assembler.addMov(blockId, returnValue.location!.dynamicType().asOperand(), returnValue.staticType.asOperand(), concat('type of ', returnValue.debugName));
  }

  Null constructor(CompiledScope scopeArg, ValueHandle addressArg, Slot returnValueArg) {
    super.constructor(scopeArg);
    address = addressArg;
    returnValue = returnValueArg;
  }
}

class BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address'];
  }

  Slot inlineBody(CompiledScope scope, ValueHandleList arguments) {
    Slot returnValue = scope.registerDynamicValue(
      environment().intrinsicsLibrary!.coreIntegerType,
      concat('address of ', arguments[0].source.debugName),
    );
    // TODO: tell the instruction stream that we're writing to the slot...
    scope.emitInstruction(BuiltInReadFromAddressIntrinsicInstruction(scope, arguments[0], returnValue));
    return returnValue;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType ]:Type,
      ),
      '__readFromAddress',
    );
  }
}

class BuiltInWriteToAddressIntrinsicInstruction extends Instruction {
  ValueHandle address;
  ValueHandle value;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, r10, address.value!.asOperand(), concat('value of ', address.source.debugName));
    assembler.addMov(blockId, r10Dereference, value.value!.asOperand(), concat('put ', value.source.debugName, ' in ', address.source.debugName));
  }

  Null constructor(CompiledScope scopeArg, ValueHandle addressArg, ValueHandle valueArg) {
    super.constructor(scopeArg);
    address = addressArg;
    value = valueArg;
  }
}

class BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address', 'value'];
  }

  Slot inlineBody(CompiledScope scope, ValueHandleList arguments) {
    scope.emitInstruction(BuiltInWriteToAddressIntrinsicInstruction(scope, arguments[0], arguments[1]));
    return scope.environment().intrinsicsLibrary!.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__writeToAddress',
    );
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  String labelPrefix() {
    return camelCase(name);
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable result = super.lookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.lookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = library.lookupType(name);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addBlankLine(blockId);
    assembler.addComment(blockId, name);
    assembler.addComment(blockId, stringTimes('=', len(scalarValues(name))));
    super.generateAssembler(assembler, blockId);
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.mainBlockId);
  }  

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(null, nameArg);
    compilationEnvironment = compilationEnvironmentArg;
    CompiledIntrinsicsLibraryNullable intrinsicsLibrary = compilationEnvironment.intrinsicsLibrary;
    if (intrinsicsLibrary != null) {
      importLibrary(intrinsicsLibrary!);
    }
    CompiledLibraryNullable runtimeLibrary = compilationEnvironment.runtimeLibrary;
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}
