import 'core.syd';
import 'syd-operands.syd';
import 'syd-assembler.syd';
import 'syd-slots.syd';
import 'syd-slot-manager.syd';
import 'syd-types.syd';
import 'syd-instructions.syd';
import 'syd-utils.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+60h : rbp+50h : (local variable from previous stack frame)
     *                      (maybe arg 2 here)
     *  rsp+58h : rbp+48h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+50h : rbp+40h : type of arg 1
     *  rsp+48h : rbp+38h : pointer to return value
     *  rsp+40h : rbp+30h : pointer to return value type
     *  rsp+38h : rbp+28h : shadow r9
     *  rsp+30h : rbp+20h : shadow r8
     *  rsp+28h : rbp+18h : shadow rdx
     *  rsp+20h : rbp+10h : shadow rcx
     *  rsp+18h : rbp +8h : return address
     *  rsp+10h : rbp     : saved non-volatile register rbp                      
                            (maybe other saved registers here)
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */

     // on the heap, a 16 byte entry has the value second, and the type 8 bytes "earlier" (heap grows up)
     //    so if the value is at p, type at p-0x08
     // on the stack, a 16 byte entry has the value first, then the type 8 bytes "later" (stack grows down)
     //    so if the value is at p, type at p-0x08


// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================
fwdclass Constant extends Object;
fwdclass CompilationEnvironment extends TypeRegistry;
fwdclass CompiledScope extends SlotContext;
fwdclass CompiledNestedScope(CompiledScope, String) extends CompiledScope;
fwdclass CompiledStackFrameScope extends CompiledScope;
fwdclass CompiledSubroutine extends CompiledStackFrameScope;
fwdclass CompiledLibrary(CompilationEnvironment, String) extends CompiledStackFrameScope;
fwdclass CompiledIntrinsicsLibrary extends CompiledLibrary;
fwdclass Instruction extends Object;
fwdclass CompiledSubroutineWithSpecificParameters extends CompiledSubroutine;
fwdclass BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters;
fwdclass BuiltInPrintSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInExitSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInLenSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInDebuggerSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass CompilerIntrinsic extends BuiltInSubroutine;
fwdclass BuiltInReadFromAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass BuiltInWriteToAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass CompiledVarArgsSubroutine extends CompiledSubroutine;
fwdclass SubroutineSlot extends CompileTimeLabelSlot;
fwdclass CompiledInternalProcedure extends CompiledStackFrameScope;
fwdclass CompiledInternalProcedureSlot extends CompileTimeLabelSlot;
fwdclass ConstantSlot(Type, Constant, String) extends ImmediateDataLabelSlot;

// CompiledScope
fwdclassprop CompiledScopeNullable CompiledScope.parent;
fwdclassprop String CompiledScope.name;
fwdclassprop Set CompiledScope.references;
fwdclassprop Set CompiledScope.subscopes;
fwdclassprop CompilationEnvironmentFunction CompiledScope.environment;
fwdclassprop CompiledStackFrameScopeFunction CompiledScope.stackFrame;
fwdclassprop CompiledLibraryFunction CompiledScope.globalScope;
fwdclassprop NullFunction CompiledScope.prepareSlots;
fwdclassprop SlotNullableFunction CompiledScope.internalLookupIdentifier;
fwdclassprop NullFunction CompiledScope.prepareInstructions;
fwdclassprop NullFunction CompiledScope.generateAssemblerBlock;
fwdclassprop NullFunction CompiledScope.emitInstruction;
fwdclassprop DynamicSlotFunction CompiledScope.registerDynamicValue;
fwdclassprop SlotFunction CompiledScope.registerStaticValue;
fwdclassprop SubroutineSlotFunction CompiledScope.registerSubroutine;
fwdclassprop NullFunction CompiledScope.registerNestedScope;
fwdclassprop StringFunction CompiledScope.labelPrefix;
fwdclassprop DynamicSlotFunction CompiledScope.registerSlot;
fwdclassprop NullFunction CompiledScope.emitIsOperatorCheck;
fwdclassprop NullFunction CompiledScope.emitBlock;

// CompiledStackFrameScope
fwdclassprop Boolean CompiledStackFrameScope.isUsed;
fwdclassprop NullFunction CompiledStackFrameScope.markUsed;
fwdclassprop NullFunction CompiledStackFrameScope.declareType;
fwdclassprop NullFunction CompiledStackFrameScope.allocateSlots;
fwdclassprop SlotManager CompiledStackFrameScope.slotManager;
fwdclassprop NullFunction CompiledStackFrameScope.generateAssembler;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackFramePointer;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackPointer;

// CompiledSubroutine
fwdclassprop String CompiledSubroutine.label;
fwdclassprop String CompiledSubroutine.epilogLabel;
fwdclassprop AbstractSubroutineTypeWithSpecificParameters CompiledSubroutine.type;
fwdclassprop SlotNullableFunction CompiledSubroutine.inline;
fwdclassprop DynamicSlot CompiledSubroutine.parameterCount;

// CompiledLibrary
fwdclassprop CompilationEnvironment CompiledLibrary.compilationEnvironment;
fwdclassprop TypeNullableFunction CompiledLibrary.lookupType;

// CompiledIntrinsicsLibrary
fwdclassprop BooleanType CompiledIntrinsicsLibrary.coreBooleanType;
fwdclassprop IntegerType CompiledIntrinsicsLibrary.coreIntegerType;
fwdclassprop SentinelType CompiledIntrinsicsLibrary.coreSentinelType;
fwdclassprop StringType CompiledIntrinsicsLibrary.coreStringType;
fwdclassprop NullType CompiledIntrinsicsLibrary.coreNullType;
fwdclassprop WhateverType CompiledIntrinsicsLibrary.coreWhateverType;
fwdclassprop SystemType CompiledIntrinsicsLibrary.coreSystemType;
fwdclassprop GarbageCollectableType CompiledIntrinsicsLibrary.coreGarbageCollectableType;
fwdclassprop AnythingType CompiledIntrinsicsLibrary.coreAnythingType;
fwdclassprop NullFunction CompiledIntrinsicsLibrary.generateScopes;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreSentinel;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreNull;
fwdclassprop Slot CompiledIntrinsicsLibrary.corePrint;
fwdclassprop Slot CompiledIntrinsicsLibrary.coreExit;
fwdclassprop Slot CompiledIntrinsicsLibrary.boundsFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.returnValueTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterCountCheckFailureMessage;
fwdclassprop CompiledInternalProcedureSlotFunction CompiledIntrinsicsLibrary.lookupInternalProcedureSlot;

// CompilationEnvironment
fwdclassprop CompiledIntrinsicsLibrary CompilationEnvironment.intrinsicsLibrary;
fwdclassprop StringFunction CompilationEnvironment.generateLabel;
fwdclassprop SlotFunction CompilationEnvironment.integer;

// SubroutineSlot
fwdclassprop CompiledSubroutine SubroutineSlot.subroutine;

// CompiledInternalProcedure
fwdclassprop TypeFunction CompiledInternalProcedure.type;

// CompiledInternalProcedureSlot
fwdclassprop CompiledInternalProcedure CompiledInternalProcedureSlot.compiledInternalProcedure;

// ConstantSlot
fwdclassprop Constant ConstantSlot.constant;


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class Constant extends Object {
  String label;
  StringList data;
  StringNullableList comments;

  Boolean isUsed = false;

  Null markUsed() {
    isUsed = true;
  }

  Null constructor(String labelArg, StringList dataArg, StringNullableList commentsArg) {
    super.constructor();
    label = labelArg;
    data = dataArg;
    comments = commentsArg;
  }
}

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Slot integer(Integer value) {
    intrinsicsLibrary.coreIntegerType.markConstructed();
    return ImmediateIntegerSlot(intrinsicsLibrary.coreIntegerType, value, concat(hex(value), ' (integer)'));
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  CompiledIntrinsicsLibrary intrinsicsLibrary;

  Map stringAtomTable = Map(); // String -> Constant
  ConstantList constants = []:Constant;

  ConstantSlot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    ConstantNullable maybeConstant = stringAtomTable.get(value) as ConstantNullable;
    if (maybeConstant == null) {
      SourceLocation source = SourceLocation(line, col, file);
      String label = generateLabel(labelBase);
      // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
      StringList data = ['dq -01h', concat('dq ', len(scalarValues(value)))]:String;
      StringNullableList comments = ['String constant (reference count)', 'Length']:StringNullable;
      if (value != '') {
        append(data, concat('db ', stringLiteral(value)));
        append(comments, concat(source));
        Integer padding = 8 - len(scalarValues(value)) % 8;
        if (padding > 0) {
          StringList buffer = []:String;
          append(buffer, 'db ');
          while (padding > 0) {
            append(buffer, '00h');
            if (padding > 1) {
              append(buffer, ', ');
            }
            padding -= 1;
          }
          append(data, joinList(buffer));
          append(comments, 'padding to align to 8-byte boundary');
        }
      }
      maybeConstant = Constant(label, data, comments);
      stringAtomTable.set(value, maybeConstant);
      append(constants, maybeConstant);
      intrinsicsLibrary.coreStringType.markConstructed();
    }
    return ConstantSlot(intrinsicsLibrary.coreStringType, maybeConstant!, /* debugName: */ labelBase);
  }

  CompiledLibraryNullable runtimeLibrary = null; 

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
  }

  Null defineLibrary(String filename, CompiledLibrary library) { 
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
    append(libraryNames, filename);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is CompiledLibrary, 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  CompiledLibrary getLibrary(String filename) { 
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  Null setRuntimeLibrary(CompiledLibrary runtimeLibraryArg) { 
    runtimeLibrary = runtimeLibraryArg;
  }

  String freeIntrinsicName = '_free';
  String listConstructorIntrinsicName = '_listConstructor';
  String iteratorIntrinsicName = 'iterator';
  String currentIntrinsicName = 'current';
  String nextIntrinsicName = 'next';

  // use CompiledScope.lookupIntrinsic() to reference this
  Map intrinsics = Map(); // String -> SubroutineSlot

  Null registerIntrinsic(SubroutineSlot intrinsic) {
    intrinsics.set(intrinsic.subroutine.name, intrinsic);
  }

  Null markUsedScopesFor(CompiledScope scope) {
    for (slot in scope.references.values()) {
      if (slot is SubroutineSlot) {
        CompiledSubroutine subroutine = (slot as SubroutineSlot).subroutine;
        if (!subroutine.isUsed) {
          subroutine.markUsed();
          markUsedScopesFor(subroutine);
        }
      } else if (slot is CompiledInternalProcedureSlot) {
        CompiledInternalProcedure internalProcedure = (slot as CompiledInternalProcedureSlot).compiledInternalProcedure;
        if (!internalProcedure.isUsed) {
          internalProcedure.markUsed();
          markUsedScopesFor(internalProcedure);
        }
      } else if (slot is ConstantSlot) {
        (slot as ConstantSlot).constant.markUsed();
      }
    }
    for (subscope in scope.subscopes.values()) {
      markUsedScopesFor(subscope as CompiledScope);
    }
  }

  Null markUsedScopes() {
    markUsedScopesFor(intrinsicsLibrary);
    markUsedScopesFor(runtimeLibrary!);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      markUsedScopesFor(library as CompiledLibrary);
    }
  }

  CompiledSubroutineList subroutines = []:CompiledSubroutine; 

  Null addSubroutine(CompiledSubroutine subroutine) { 
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    intrinsicsLibrary.prepareInstructions();
    runtimeLibrary!.prepareInstructions();
    for (libraryName in libraryNames) {
      (libraries.get(libraryName) as CompiledLibrary).prepareInstructions();
    }
    for (subroutine in subroutines) {
      if (subroutine.isUsed) {
        subroutine.prepareInstructions();
      }
    }
  }

  AbstractSubroutineType subroutineType;
  AbstractListType subscriptableType;
  IterableType iterableType;

  String typeTableLabel;
  String iteratorTypeTableLabel;
  String listTypeTableLabel;
  Integer typeTableOffset;
  Integer typeTableWidth;

  Null _generateTypeTable(Assembler assembler, String label) {
    StringList comment = []:String;
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, '   ; Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        append(comment, concat(' ', supertype));
      }
    }
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(comment, '   ; ');
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        append(bytes, byte);
        byte = 0;
        bits = 0;
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    while (len(bytes) % 8 != 0) {
      append(bytes, 0); // padding to keep things 8-byte aligned
    }
    IntegerListList data = [[]:Integer]:IntegerList;
    for (byte in bytes) {
      if (len(last(data) as WhateverList) >= 8) {
        append(data, []:Integer);
      }
      append(last(data) as WhateverList, byte);
    }
    String genBytes(IntegerList bytes) {
      return concat('db ', join(map(bytes, hex8) as StringList, ', '));
    }
    StringNullable genComments(IntegerList bytes) {
      return '...';
    }
    StringList generatedBytes = map(data, genBytes) as StringList;
    StringNullableList comments = map(data, genComments) as StringNullableList;
    comments[0] = 'Type table';
    comments[len(comments) - 1] = concat(comments[len(comments) - 1], '\n', join(comment, ''));
    assembler.addConst(label, generatedBytes, comments);
    typeTableOffset = offset;
    typeTableWidth = width;
  }

  Null _generateIteratorTypeTable(Assembler assembler, String label) {
    IntegerListList iteratorTypes = []:IntegerList;
    IntegerList buffer = []:Integer;
    IntegerList debugCodes = []:Integer;
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(debugCodes, type.code);
        if (type.isSubtypeOf(iterableType)) {
          if (type is IterableType) {
            Type iteratorType = createOrFindIteratorType(this, (type as IterableType).elementType);
            append(buffer, iteratorType.code);
          } else if (type is AbstractListType) {
            Type iteratorType = createOrFindIteratorType(this, (type as AbstractListType).elementType);
            append(buffer, iteratorType.code);
          } else {
            throw(concat('Unrecognized iterable type: ', type));
          }
        } else {
          append(buffer, 0xffffffff);
        }
      }
      if (len(buffer) % 4 == 0) {
        append(iteratorTypes, buffer);
        buffer = []:Integer;
      }
    }
    if (len(buffer) > 0) {
      append(iteratorTypes, buffer);
      buffer = []:Integer;
    }
    assert(first(debugCodes) == 0, 'expected sorted type codes to start at zero');
    assert(last(debugCodes) == len(debugCodes) - 1, 'expected sorted type codes to be consecutive');
    String genLines(IntegerList buffer) {
      return concat('dd ', join(map(buffer, hex32) as StringList, ', '));
    }
    StringNullable genComment(IntegerList buffer) {
      return null;
    }
    StringList data = copy(map(iteratorTypes, genLines)) as StringList;
    StringNullableList comments = copy(map(iteratorTypes, genComment)) as StringNullableList;
    comments[0] = 'Table mapping iterable types to iterator types';
    assembler.addConst(label, data, comments);
  }

  Null _generateListTypeTable(Assembler assembler, String label) {
    IntegerListList listTypes = []:IntegerList;
    IntegerList buffer = []:Integer;
    IntegerList debugCodes = []:Integer;
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(debugCodes, type.code);
        if (type.isSubtypeOf(iterableType)) {
          if (type is IterableType) {
            Type listType = createOrFindListType(this, (type as IterableType).elementType);
            append(buffer, listType.code);
          } else if (type is AbstractListType) {
            Type listType = createOrFindListType(this, (type as AbstractListType).elementType);
            append(buffer, listType.code);
          } else {
            throw(concat('Unrecognized iterable type: ', type));
          }
        } else {
          append(buffer, 0xffffffff);
        }
      }
      if (len(buffer) % 4 == 0) {
        append(listTypes, buffer);
        buffer = []:Integer;
      }
    }
    if (len(buffer) > 0) {
      append(listTypes, buffer);
      buffer = []:Integer;
    }
    assert(first(debugCodes) == 0, 'expected sorted type codes to start at zero');
    assert(last(debugCodes) == len(debugCodes) - 1, 'expected sorted type codes to be consecutive');
    String genLines(IntegerList buffer) {
      return concat('dd ', join(map(buffer, hex32) as StringList, ', '));
    }
    StringNullable genComment(IntegerList buffer) {
      return null;
    }
    StringList data = copy(map(listTypes, genLines)) as StringList;
    StringNullableList comments = copy(map(listTypes, genComment)) as StringNullableList;
    comments[0] = 'Table mapping iterable types to list types';
    assembler.addConst(label, data, comments);
  }

  Null generateTypeTables(Assembler assembler) {
    _generateTypeTable(assembler, typeTableLabel);
    _generateIteratorTypeTable(assembler, iteratorTypeTableLabel);
    _generateListTypeTable(assembler, listTypeTableLabel);
  }
  
  Null allocateSlots(Assembler assembler) {
    intrinsicsLibrary.allocateSlots(assembler);
    runtimeLibrary!.allocateSlots(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).allocateSlots(assembler);
    }
    for (subroutine in subroutines) {
      if (subroutine.isUsed) {
        subroutine.allocateSlots(assembler);
      }
    }
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock mainBlock = assembler.createBlock();
    for (constant in constants) {
      assembler.addConst(constant.label, constant.data, constant.comments);
    }
    intrinsicsLibrary.generateAssembler(assembler); // generates decrefs
    intrinsicsLibrary.generateAssemblerBlock(mainBlock);
    runtimeLibrary!.generateAssemblerBlock(mainBlock);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).generateAssemblerBlock(mainBlock);
    }
    mainBlock.addBlankLine();
    mainBlock.addComment('End of global scope');
    mainBlock.addCode('ret', [], 'exit application');
    assembler.addLabeledBlock('main', mainBlock, null, null);
    for (subroutine in subroutines) {
      if (subroutine.isUsed) {
        subroutine.generateAssembler(assembler);
      }
    }
  }

  Null compile(Assembler assembler) {
    // the phase before this is Library.generateScopes() in syd_ast.syd
    stderr('markUsedScopes...');
    markUsedScopes();
    stderr('prepareInstructions...');
    prepareInstructions();
    stderr('assignTypeCodes...');
    assignTypeCodes();
    stderr('generateTypeTable...');
    generateTypeTables(assembler);
    stderr('allocateSlots...');
    allocateSlots(assembler);
    stderr('generateAssembler...');
    generateAssembler(assembler);
  }

  Null constructor() {
    super.constructor();
    typeTableLabel = generateLabel('typeTable');
    iteratorTypeTableLabel = generateLabel('iteratorTypeTable');
    listTypeTableLabel = generateLabel('listTypeTable');
    intrinsicsLibrary = CompiledIntrinsicsLibrary(this, 'intrinsics');
    intrinsicsLibrary.generateScopes();
    subroutineType = createOrFindSubroutineTypeWithAnyArgs(this, intrinsicsLibrary.coreAnythingType);
    subscriptableType = createOrFindReadOnlyListType(this, intrinsicsLibrary.coreWhateverType);
    iterableType = createOrFindIterableType(this, intrinsicsLibrary.coreWhateverType);
  }
}


// ============================================================================
// SPECIALIZED SLOTS
// ============================================================================

class TypeTableWidthSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;

  Integer numericValue() {
    Integer width = environment.typeTableWidth;
    if (width % 8 > 0) {
      return width / 8 + 1;
    }
    return width / 8;
  }

  Null constructor(CompilationEnvironment environmentArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, 'type table width in bytes');
    environment = environmentArg;
  }
}

class TypeBitSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type staticType;

  Integer numericValue() {
    return (staticType.code - environment.typeTableOffset) % 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type staticTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('bit offset for ', staticTypeArg));
    environment = environmentArg;
    staticType = staticTypeArg;
    staticType.markUsedInTypeCheck();
  }
}

class TypeByteSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type staticType;

  Integer numericValue() {
    assert(staticType.code != null, concat(staticType, ' does not have an assigned code'));
    return (staticType.code - environment.typeTableOffset) / 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type staticTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('byte offset for ', staticTypeArg));
    environment = environmentArg;
    staticType = staticTypeArg;
    staticType.markUsedInTypeCheck();
  }
}

class TypeCodeSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type typeArg;

  Integer numericValue() {
    assert(typeArg.code != null, concat(typeArg, ' does not have an assigned code'));
    return typeArg.code;
  }

  Operand dynamicType() {
    return ImmediateIntegerOperand(staticType.code!);
  }

  Null constructor(CompilationEnvironment environmentArg, Type typeArgArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('code of ', typeArgArg));
    environment = environmentArg;
    typeArg = typeArgArg;
    typeArg.markUsedInTypeCheck();
  }
}

class SubroutineSlot extends CompileTimeLabelSlot {
  CompiledSubroutine subroutine;

  String labelValue() {
    return subroutine.label;
  }

  Operand value() {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(CompiledSubroutine subroutineArg) {
    subroutine = subroutineArg;
    super.constructor(subroutine.type, subroutine.name);
  }
}

class CompiledInternalProcedureSlot extends CompileTimeLabelSlot {
  CompiledInternalProcedure compiledInternalProcedure;

  String labelValue() {
    return compiledInternalProcedure.name;
  }

  Operand value() {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(CompiledInternalProcedure compiledInternalProcedureArg) {
    compiledInternalProcedure = compiledInternalProcedureArg;
    super.constructor(compiledInternalProcedure.type(), compiledInternalProcedure.name);
  }
}

class ConstantSlot extends ImmediateDataLabelSlot {
  Constant constant;

  Null constructor(Type typeArg, Constant constantArg, String debugNameArg) {
    super.constructor(typeArg, constantArg.label, debugNameArg);
    constant = constantArg;
  }
}


// ============================================================================
// SPECIALIZED INSTRUCTIONS
// ============================================================================

// use emitBlock instead
class DoBlockInstruction extends Instruction {
  CompiledNestedScope nestedBlock;

  Null prepare(SlotContext scope) {
    nestedBlock.prepareInstructions();
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    nestedBlock.generateAssemblerBlock(block);
  }

  Null constructor(CompiledNestedScope nestedBlockArg) { 
    super.constructor();
    nestedBlock = nestedBlockArg;
  }
}


// ============================================================================
// SCOPES
// ============================================================================

class CompiledScope extends SlotContext {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name; // TODO: rethink exactly what this means

  SlotContextNullable getParent() {
    return parent;
  }

  CompiledLibrary globalScope() { 
    assert(parent != null, 'compiled scope chain failure');
    return parent!.globalScope();
  }

  CompiledStackFrameScope stackFrame() { 
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = parent!.stackFrame() as CompiledScope;
    return result;
  }

  SlotContext slotScope() {
    return stackFrame();
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return parent!.environment();
  }

  String labelPrefix() {
    abstract();
  }

  Null prepareSlots() { }

  // REGISTRIES

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  Set references = Set(); // Slots

  SlotNullable lookupIdentifier(String name) {
    SlotNullable result = internalLookupIdentifier(name);
    if (result != null) {
      references.add(result!);
    }
    return result;
  }

  SlotNullable internalLookupIdentifier(String name) {
    SlotNullable value = identifiers.get(name) as SlotNullable;
    if (value == null && parent != null) {
      value = parent!.internalLookupIdentifier(name);
    }
    return value;
  }

  Slot lookupIntrinsic(String name) {
    SlotNullable result = environment().intrinsics.get(name) as SlotNullable;
    if (result == null) {
      throw(concat('Compiler intrinsic "', name, '" is not declared.'));
    }
    references.add(result!);
    return result!;
  }

  String lookupInternalProcedureLabel(ip procedure) {
    CompiledInternalProcedureSlot slot = environment().intrinsicsLibrary.lookupInternalProcedureSlot(procedure);
    references.add(slot);
    return slot.compiledInternalProcedure.name;
  }

  Set subscopes = Set(); // CompiledScope

  Null registerNestedScope(CompiledNestedScope nestedScope) {
    subscopes.add(nestedScope);
  }

  DynamicSlot registerSlot(DynamicSlot slot) {
    return stackFrame().registerSlot(slot);
    // CompiledStackFrameScope overrides this to add more behaviour
  }

  DynamicSlot registerDynamicValue(Type type, rc referenceCountStyle, String debugName) {
    return registerSlot(DynamicSlot(type, this, referenceCountStyle, null, debugName));
  }

  // Caller must incref variable if appropriate.
  DynamicSlot registerVariable(String name, Type type) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    rc referenceCountStyle;
    if (type.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot slot = DynamicSlot(type, this, referenceCountStyle, name, concat(name, ' variable'));
    identifiers.set(name, slot);
    return registerSlot(slot);
  }

  ImmediateSlot registerNumericConstant(String name, Integer value, Type staticType) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    Slot slot = ImmediateIntegerSlot(staticType, value, name);
    identifiers.set(name, slot);
    staticType.markConstructed();
    return slot;
  }

  SubroutineSlot registerSubroutine(CompiledSubroutine subroutine) { 
    assert(!isIdentifierDeclaredInLocalScope(subroutine.name), concat('tried to redeclare an identifier (', subroutine.name, ') within a scope'));
    SubroutineSlot slot = SubroutineSlot(subroutine);
    identifiers.set(subroutine.name, slot);
    environment().addSubroutine(subroutine);
    return slot;
  }


  // INSTRUCTION GENERATION

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }
  
  Null markSourceLocation(AstNode statement) {
    emitInstruction(PendingCommentInstruction(concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), 64))));
  }
  
  Null emitBlock(CompiledNestedScope block) {
    registerNestedScope(block);
    emitInstruction(DoBlockInstruction(block));
  }

  // does not set the type of target!
  // caller is responsible for setting it to Boolean!
  Null storeEquality(Slot a, Slot b, Slot target, Boolean negate) {
    // TODO: hard-code result for literal comparisons
    // TODO: make this work for strings
    Slot valueTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, rcNever, concat('value result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    Slot typeTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, rcNever, concat('type result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    emitInstruction(SetSlotIfEqualInstruction(a, b, valueTemp, environment().intrinsicsLibrary.coreBooleanType, 'values equal?'));
    emitInstruction(SetSlotIfTypesEqualInstruction(a, b, typeTemp, environment().intrinsicsLibrary.coreBooleanType, 'types equal?'));
    emitInstruction(AndInstruction(valueTemp, typeTemp, target, '&& type temp and value temp'));
    if (negate) {
      emitInstruction(BiOperandInstruction('xor', target, environment().integer(1), target, concat('negating ', target)));
    }
  }

  Null emitIncref(Slot value, Boolean isGCRoot) {
    Type stringType = environment().intrinsicsLibrary.coreStringType;
    Type garbageCollectableType = environment().intrinsicsLibrary.coreGarbageCollectableType;
    Boolean doGCIncref = (garbageCollectableType.isSubtypeOf(value.staticType) || value.staticType.isSubtypeOf(garbageCollectableType)) && (!value is VarArgsParameterSlot) && isGCRoot;
    Boolean doStringIncref = stringType.isSubtypeOf(value.staticType) && !(value is ImmediateDataLabelSlot);
    if (doGCIncref || doStringIncref) {
      emitInstruction(CommentInstruction(concat('increment reference count for ', value.debugName, ' if necessary')));
    }
    if (doGCIncref) {
      String increfAfterGCLabel = environment().generateLabel(concat(labelPrefix(), '$AfterGCIncref'));
      emitIsOperatorCheck(garbageCollectableType, value, 'possibly GarbageCollectable value'); // actual type check is here
      emitInstruction(JncInstruction(increfAfterGCLabel, 'if not a GarbageCollectable, skip incref'));
      CompiledNestedScope subblock = CompiledNestedScope(this, 'gc');
        subblock.emitInstruction(IncrefInstruction(value));
      emitBlock(subblock);
      emitInstruction(LabelInstruction(increfAfterGCLabel, 'after GarbageCollectable incref'));
    }
    if (doStringIncref) {
      String increfAfterStringLabel = environment().generateLabel(concat(labelPrefix(), '$AfterStringIncref'));
      String increfStringLabel = environment().generateLabel(concat(labelPrefix(), '$StringIncref'));
      emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, stringType, increfAfterStringLabel, 'if not a String, skip incref'));
      CompiledNestedScope subblock = CompiledNestedScope(this, 'string');
        Slot temp = subblock.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'string reference count');
        subblock.emitInstruction(MoveDerefInstruction(temp, value, 0, 'dereference string to get to reference count'));
        subblock.emitInstruction(ConditionalJumpInstruction(temp, null, ccPositive, increfStringLabel, 'if reference count is negative (constant strings), skip incref'));
        subblock.emitInstruction(SyntheticNestedScopeExitInstruction(subblock));
        subblock.emitInstruction(JumpInstruction(increfAfterStringLabel, 'skip incref for string constants'));
        subblock.emitInstruction(LabelInstruction(increfStringLabel, 'real String'));
        CompiledNestedScope subsubblock = CompiledNestedScope(this, 'string');
          subsubblock.emitInstruction(IncrefInstruction(value));
        subblock.emitBlock(subsubblock);
      emitBlock(subblock);
      emitInstruction(LabelInstruction(increfAfterStringLabel, 'after String incref'));
    }
  }

  // Emits an instruction that does the equivalent of "lhs is staticType", puts the result in the CF flag.
  //
  // Must be followed by jc or setc.
  Null emitIsOperatorCheck(Type staticType, Slot lhs, String what) {
    CompilationEnvironment environment = environment();
    staticType.markUsedInTypeCheck();
    Slot typeTableWidth = TypeTableWidthSlot(environment);
    Slot typeBit = TypeBitSlot(environment, staticType);
    Slot typeByte = TypeByteSlot(environment, staticType);
    Slot typeTablePointer = ImmediateDataLabelSlot(environment.intrinsicsLibrary.coreIntegerType, environment.typeTableLabel, 'type table pointer');

    // byte of lhs's type's row in the type table containing the bit for staticType
    Slot testByte = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'testByte');
    emitInstruction(MoveTypeToValueInstruction(testByte, lhs, concat('move type of ', lhs.debugName, ' to testByte')));
    emitInstruction(UnsignedMultiplyInstruction(typeTableWidth, testByte, testByte, 'adjust to the relative start of that type\'s entry in the type table'));
    emitInstruction(AddInstruction(testByte, typeByte, testByte, 'adjust to the byte containing the bit to check against'));
    emitInstruction(AddInstruction(testByte, typeTablePointer, testByte, 'finally offset all of that by the start of the type table itself'));
    emitInstruction(BtDerefInstruction(testByte, typeBit, concat('check that ', what, ' is ', staticType))); // to be followed by jc or setc
  }
  
  Null doIfVarArgsTypeMismatch(Type staticType, VarArgsParameterSlot varArgs, String labelBase, CompiledNestedScope block, String what) {
    // TODO: xxxx we could also check if we can statically disprove compatibility
    emitInstruction(CommentInstruction(concat('Varargs parameter type check; expecting parameters to be ', staticType.name)));
    CompilationEnvironment environment = environment();
    String loopTopLabel = environment.generateLabel(concat(labelBase, '$Loop'));
    String continueLabel = environment.generateLabel(concat(labelBase, '$TypeMatch'));
    String loopBottomLabel = environment.generateLabel(concat(labelBase, '$TypesAllMatch'));
    // variable that holds a pointer to the index'th argument's type
    Slot pointerToIndexthArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to indexth argument');
    // variable that holds the last value that pointerToIndexthArg should have (pointer past the last argument)
    Slot pointerToLastArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to last argument');
    emitInstruction(LeaInstruction(pointerToIndexthArg, varArgs.baseAddress(environment.intrinsicsLibrary.coreIntegerType), 0, true, 'get base address of varargs, where loop will start'));
    emitInstruction(UnsignedMultiplyInstruction(varArgs.length(), environment.integer(0x10), pointerToLastArg, 'end of loop is the number of arguments times the width of each argument (010h)...'));
    emitInstruction(AddInstruction(pointerToIndexthArg, pointerToLastArg, pointerToLastArg, '...offset from the initial index'));
    emitInstruction(LabelInstruction(loopTopLabel, 'top of loop'));
    CompiledNestedScope loopBlock = CompiledNestedScope(this, 'loop');
    Slot indexthArg = loopBlock.registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'indexth argument');
    loopBlock.emitInstruction(JumpIfEqualInstruction(pointerToIndexthArg, pointerToLastArg, loopBottomLabel, 'we have type-checked all the arguments'));
    loopBlock.emitInstruction(MoveDerefToTypeInstruction(indexthArg, pointerToIndexthArg, 0, concat('load type of indexth argument into ', indexthArg.debugName)));
    loopBlock.emitIsOperatorCheck(staticType, indexthArg, what); // actual type check is here
    loopBlock.emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    loopBlock.emitBlock(block);
    loopBlock.emitInstruction(LabelInstruction(continueLabel, 'after block'));
    loopBlock.emitInstruction(AddInstruction(pointerToIndexthArg, environment.integer(0x10), pointerToIndexthArg, 'next argument'));
    loopBlock.emitInstruction(SyntheticNestedScopeExitInstruction(loopBlock));
    loopBlock.emitInstruction(JumpInstruction(loopTopLabel, 'return to top of loop'));
    loopBlock.emitInstruction(LabelInstruction(loopBottomLabel, 'after loop'));
    emitBlock(loopBlock);
  }
  
  Null emitStoreTypeCheck(Type staticType, Slot lhs, Slot target, String what) {
    CompilationEnvironment environment = environment();
    emitIsOperatorCheck(staticType, lhs, what);
    emitInstruction(MoveInstruction(target, environment.integer(0), concat('clear ', target.debugName)));
    emitInstruction(SetcInstruction(target, concat('store result in ', target.debugName)));
    emitInstruction(SetTypeInstruction(target, environment.intrinsicsLibrary.coreBooleanType));
  }
  
  // Caller should emit static and dynamic type checks on target.
  Slot emitSubroutineCall(Slot target, SlotList arguments) {
    assert(target.staticType.isSubtypeOf(environment().subroutineType), 'cannot call a non-function');
    emitInstruction(CommentInstruction(concat('Call ', target.debugName, ' with ', len(arguments), ' arguments')));
    // xxxx statically check arguments are the right type if the types are known
    if (target is SubroutineSlot) {
      SlotNullable result = (target as SubroutineSlot).subroutine.inline(this, arguments);
      if (result != null) {
        return result;
      }
    }
    Slot thisPointer = environment().intrinsicsLibrary.coreSentinel; // placeholder code
    Slot closurePointer = environment().intrinsicsLibrary.coreSentinel; // placeholder code
    Type returnType = environment().intrinsicsLibrary.coreAnythingType;
    if (target.staticType is AbstractSubroutineType) {
      AbstractSubroutineType subroutineType = target.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    }
    // If the type of the return value is one that can be reference counted, the callee will
    // increment the reference count before returning, and we must match that with a corresponding
    // decrement. This is handled by the slot manager when it cleans up returnValue.
    rc referenceCountStyle;
    if (returnType.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot returnValue = registerDynamicValue(returnType, referenceCountStyle, concat(target.debugName, ' return value'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      emitInstruction(PushInstruction(arguments[argumentIndex], concat('value of argument #', argumentIndex + 1, ' (', arguments[argumentIndex].debugName, ')')));
      emitInstruction(PushTypeInstruction(arguments[argumentIndex], environment(), concat('type of argument #', argumentIndex + 1)));
      argumentIndex -= 1;
    }
    DynamicSlot temporarySlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'temporary slot');
    emitInstruction(MoveToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s value'));
    emitInstruction(PinSlotValueInstruction(returnValue));
    emitInstruction(LeaInstruction(temporarySlot, returnValue, 0, false, 'load address of return value\'s value'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 6: pointer to return value slot\'s value')); // (also does some RecordPushes)
    emitInstruction(MoveTypeToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s type'));
    emitInstruction(PinSlotTypeInstruction(returnValue));
    emitInstruction(LeaTypeInstruction(temporarySlot, returnValue, false, 'load address of return value\'s type'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 5: pointer to return value slot\'s type')); // (also does some RecordPushes)
    // TODO: "sub rsp, 8h; align to 16 byte boundary" XXX need to also implement this on callee side
    emitInstruction(SubInstruction(stackFrame().stackPointer, environment().integer(0x20), stackFrame().stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // ("fake" pushes from changing the stack pointer)
    emitInstruction(MoveToSpecificOperandInstruction(r9.bit, thisPointer, true, 'internal argument 4: "this" pointer'));
    //emitInstruction(PinSlotValueInstruction(thisPointer)); // TODO uncomment once we implement "this"
    emitInstruction(MoveTypeToSpecificOperandInstruction(r8.bit, thisPointer, true, 'internal argument 3: "this" pointer type'));
    //emitInstruction(PinSlotTypeInstruction(thisPointer)); // TODO uncomment once we implement "this"
    emitInstruction(MoveToSpecificOperandInstruction(rdx.bit, closurePointer, true, 'internal argument 2: closure pointer'));
    //emitInstruction(PinSlotValueInstruction(closurePointer)); // TODO uncomment once we implement closures
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, environment().integer(len(arguments)), true, 'internal argument 1: number of actual arguments'));
    emitInstruction(CallInstruction(target, 'jump to subroutine'));
    //emitInstruction(UnpinSlotValueInstruction(closurePointer)); // TODO uncomment once we implement closures
    //emitInstruction(UnpinSlotTypeInstruction(thisPointer)); // TODO uncomment once we implement "this"
    //emitInstruction(UnpinSlotValueInstruction(thisPointer)); // TODO uncomment once we implement "this"
    emitInstruction(UnpinSlotValueInstruction(returnValue));
    emitInstruction(UnpinSlotTypeInstruction(returnValue));
    emitInstruction(AddInstruction(stackFrame().stackPointer, environment().integer(0x20 + 8 * 2 * len(arguments) + 16), stackFrame().stackPointer, 'release shadow space and arguments'));
    emitInstruction(RecordPopsInstruction(len(arguments) * 2 + 6)); // arguments, return value (and type), and shadow space
    return returnValue;
  }

  CompiledNestedScope createErrorHandlerBlock(Slot errorMessage, String what) {
    CompiledScope block = CompiledNestedScope(this, concat(camelCase(what), '$Error'));
    block.emitInstruction(CommentInstruction(concat('Error handling block for ', what)));
    block.emitInstruction(Interrupt3Instruction());
    String label = environment().generateLabel(concat(block.labelPrefix(), '$', camelCase(what), '$Ok'));
    Slot printHandle = environment().intrinsicsLibrary.corePrint;
    block.emitInstruction(CommentInstruction(concat(' - print(', errorMessage.debugName, ')')));
    block.references.add(printHandle);
    block.references.add(errorMessage);
    block.emitSubroutineCall(printHandle, [ errorMessage ]);
    Slot exitHandle = environment().intrinsicsLibrary.coreExit;
    Slot failureExitCode = environment().integer(0x01);
    block.emitInstruction(CommentInstruction(concat(' - exit(1)')));
    block.references.add(exitHandle);
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    return block;
  }

  Null emitTypeCheck(Slot value, Type staticType, Slot errorMessage, String what, Boolean trustSlotStaticType) {
    CompiledNestedScope block = createErrorHandlerBlock(errorMessage, what);
    String continueLabelArg = concat(labelPrefix(), '$', camelCase(what));
    // TODO: xxxx we could also check if we can statically disprove compatibility
    // (or maybe assert that we can't, because if we can why is someone calling us)
    String continueLabel = environment().generateLabel(concat(continueLabelArg, '$TypeMatch'));
    if (!trustSlotStaticType || !value.canStaticallyProveTypeCompatibilityWith(staticType)) {
      emitIsOperatorCheck(staticType, value, what); // actual type check is here
      emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    } else {
      // just check for sentinel (which might be present even if we trust the static type)
      // TODO: slots should track if they might be sentinel, so we can skip even this
      emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, environment().intrinsicsLibrary.coreSentinelType, continueLabel, concat('skip next block if ', value.debugName, ' is not sentinel')));
    }
    emitBlock(block);
    emitInstruction(LabelInstruction(continueLabel, 'after block'));
  }

  // runs block if a != b
  Null emitConditionalBlock(CompiledNestedScope block, CompiledNestedScopeNullable elseBlock, Slot a, Slot b, String what, String comment) {
    String labelElse;
    String labelEnd = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$continuation'));
    if (elseBlock == null) {
      labelElse = labelEnd;
    } else {
      labelElse = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$else'));
    }
    emitInstruction(JumpIfEqualInstruction(a, b, labelElse, comment));
    emitBlock(block);
    if (elseBlock != null) {
      emitInstruction(JumpInstruction(labelEnd, concat('jump past else part of ', what)));
      emitInstruction(LabelInstruction(labelElse, concat('else of ', what)));
      emitBlock(elseBlock!);
    }
    emitInstruction(LabelInstruction(labelEnd, concat('end of ', what)));
  }

  // jumps to label if a == b
  Null emitConditionalJump(String label, Slot a, Slot b, String comment) {
    emitInstruction(JumpIfEqualInstruction(a, b, label, comment));
  }
  
  // Computes the pointer for subscripting a list.
  // Returned slot is a pointer to the type/value pair, not the actual value.
  Slot emitSubscriptEvaluation(Slot list, Slot index) {
    // Caller must apply static and dynamic type checks for list and index.
    String labelBase = concat(labelPrefix(), '$subscript');
    String boundsErrorLabel = environment().generateLabel(concat(labelBase, '$boundsError'));
    String continueLabel = environment().generateLabel(concat(labelBase, '$inBounds'));
    CompiledNestedScope boundsErrorBlock = createErrorHandlerBlock(environment().intrinsicsLibrary.boundsFailureMessage, 'subscript bounds error');
    Slot lengthSlot;
    Slot baseAddressSlot;
    if (list is VarArgsParameterSlot) {
      lengthSlot = (stackFrame() as CompiledSubroutine).parameterCount;
      baseAddressSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'base address of varargs');
      emitInstruction(LeaInstruction(baseAddressSlot, (list as VarArgsParameterSlot).baseAddress(environment().intrinsicsLibrary.coreIntegerType), 0, true, 'base address of varargs'));
    } else {
      // list -> ...
      //         ...
      //         ...
      //         ldp -> ...
      //                length
      //                ...
      //                actual list data
      Slot listDataPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to list data');
      lengthSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'length of list');
      baseAddressSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'base address of list');
      emitInstruction(MoveDerefInstruction(listDataPointer, list, _listBlockData, 'list data is the second field in its block'));
      emitInstruction(MoveDerefInstruction(lengthSlot, listDataPointer, _gcBlockHeaderLength, 'read length from the list data block\'s metadata'));
      emitInstruction(LeaInstruction(baseAddressSlot, listDataPointer, _gcBlockData, true, 'compute address of 0th entry in list data block'));
    }
    emitInstruction(ConditionalJumpInstruction(index, lengthSlot, ccGreaterThanOrEqual, boundsErrorLabel, 'index out of range (too high)'));
    emitInstruction(ConditionalJumpInstruction(index, environment().integer(0), ccGreaterThanOrEqual, continueLabel, 'index not out of range (not negative)'));
    emitInstruction(LabelInstruction(boundsErrorLabel, 'invalid index'));
    emitBlock(boundsErrorBlock); // execution never leaves this block
    emitInstruction(LabelInstruction(continueLabel, 'valid index'));
    Slot shiftedIndex = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'index into list * 16');
    emitInstruction(ShiftInstruction('shl', index, environment().integer(4), shiftedIndex, 'multiply by 8*2'));
    Slot resultPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('pointer to ', list.debugName, '[', index.debugName, ']'));
    emitInstruction(AddInstruction(baseAddressSlot, shiftedIndex, resultPointer, concat('compute address of specified list entry')));
    return resultPointer;
  }


  // COMPILER PHASES

  Null prepareInstructions() {
    for (instruction in instructions) {
      stderr('preparing ', instruction, ' for ', this);
      instruction.prepare(this);
    }
    stderr('done preparing instructions for ', this);
  }

  Null generateAssemblerBlockPreamble(AssemblerBlock block) { }
  Null generateAssemblerBlockPostamble(AssemblerBlock block) { }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    SlotManager manager = stackFrame().slotManager;
    manager.enterNestedScope(this, block);
    generateAssemblerBlockPreamble(block);
    for (instruction in instructions) {
      if (instruction is PendingCommentInstruction) {
        stderr('generating assembler of', instruction, 'for', this);
      }
      instruction.generateAssemblerBlock(block, manager);
      manager.endOfInstruction();
    }
    generateAssemblerBlockPostamble(block);
    manager.exitNestedScope(this);
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
    prepareSlots();
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', labelPrefix(), ':', className, '@', internalObjectId, '>');
  }
}

class CompiledNestedScope extends CompiledScope {
  String labelPrefix() {
    return concat(parent!.labelPrefix(), '$', name);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    block.indent(super.generateAssemblerBlock);
  }

  Null constructor(CompiledScope parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledStackFrameScope extends CompiledScope {
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  // whether anything that is itself used references this
  Boolean isUsed = false;

  Null markUsed() {
    isUsed = true;
  }

  DynamicSlotList slots = []:DynamicSlot;

  DynamicSlot registerSlot(DynamicSlot slot) {
    append(slots, slot);
    return slot;
  }

  SlotManager slotManager;
  RegisterSlot stackPointer;
  RegisterSlot stackFramePointer;

  Null prepareSlots() {
    super.prepareSlots();
    stackPointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rsp, 'stack pointer');
    stackFramePointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rbp, 'stack frame pointer');
  }

  Null allocateSlots(Assembler assembler) {
    Slot sentinel = environment().intrinsicsLibrary.coreSentinel;
    assert((sentinel.value() as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    assert((sentinel.dynamicType() as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    for (slot in slots) {
      if (slot.referencedFromMultipleStackFrames) {
        assert(slot.homeScope is CompiledLibrary, 'closures not implemented');
        assert(slot.name != null, concat('slot has no name: ', slot));
        String valueLabel = environment().generateLabel(concat(slot.name, 'Value'));
        String typeLabel = environment().generateLabel(concat(slot.name, 'Type'));
        slot.initialize(DereferenceLabelOperand(valueLabel), DereferenceLabelOperand(typeLabel));
        assembler.addBss(typeLabel, 4, concat('dynamic type of ', slot.debugName));
        assembler.addBss(valueLabel, 4, slot.debugName);
      } else {
        if (!slot.initializeScheduled) { // e.g. parameter count
          slot.initialize(sentinel.value(), sentinel.dynamicType());
        }
      }
    }
  }

  Null generatePrologAssemblerBlock(AssemblerBlock block) {
    block.addComment('Prolog');
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    for (register in registers) {
      block.addCode('push', [register], 'save non-volatile registers');
    }
    Integer stackSize = slotManager.stackSize();
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      // TODO: if stackSize > 8KB (0x2000), call __chkstk__
      assert(stackSize < 0x2000, 'need to implement calling __chkstk__');
      block.addCode('sub', [rsp, hex8(stackSize)], 'allocate space for stack');
    }
    block.addCode('lea', [rbp, concat('qword ptr [rsp + ', hex8(stackSize + len(registers) * 0x08), ']')], 'set up frame pointer');
    assert(stackSize == slotManager.stackSize(), concat('prolog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    block.addComment('Epilog');
    Integer stackSize = slotManager.stackSize();
    if (stackSize > 0) {
      block.addCode('add', [rsp, hex8(stackSize)], 'free space for stack');
    }
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    Integer index = len(registers);
    while (index > 0) {
      index -= 1;
      block.addCode('pop', [registers[index]], 'restore non-volatile registers');
    }
    assert(stackSize == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null initializeParameters() {
    // e.g. slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
  }

  Null clearRegisters(AssemblerBlock subblock) {
    // e.g. slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateAssemblerBlockPreamble(AssemblerBlock block) {
    initializeParameters();
  }

  Null generateAssemblerBlockPostamble(AssemblerBlock block) {
    clearRegisters(block);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    slotManager = SlotManager(environment().intrinsicsLibrary.coreStringType, environment().intrinsicsLibrary.coreGarbageCollectableType, environment().intrinsicsLibrary.coreSentinelType, concat(name, ' (slot manager)'));
    slotManager.pin(stackPointer);
    slotManager.pin(stackFramePointer);
    AssemblerBlock subblock = block.createBlock();
    super.generateAssemblerBlock(subblock);
    generatePrologAssemblerBlock(block);
    Integer debugOriginalStackSize = slotManager.stackSize();
    block.addBlock(subblock);
    generateEpilogAssemblerBlock(block);
    assert(debugOriginalStackSize == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', debugOriginalStackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.dispose();
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineTypeWithSpecificParameters type; // subroutine signature
  String label;
  String epilogLabel;

  // The parameter that contains a pointer to the return value.
  Slot returnValuePointer;
  // The parameter that contains a pointer to the return value type.
  Slot returnValueTypePointer;

  Null markUsed() {
    super.markUsed();
    type.markConstructed();
  }

  String labelPrefix() {
    return concat('func$', name);
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    return null;
  }

  // This is called from other scopes (where we need to emit the instructions),
  // hence the scope argument.
  Null emitReturnFrom(CompiledScope scope, Slot value) {
    // xxxx verify the type of value statically
    scope.emitTypeCheck(value, type.returnType, environment().intrinsicsLibrary.returnValueTypeCheckFailureMessage as Slot, concat(name, ' return value'), true);
    scope.emitInstruction(MoveToDerefInstruction(returnValuePointer, value, 0, concat(name, ' return value')));
    scope.emitInstruction(MoveTypeToDerefInstruction(returnValueTypePointer, value, 0, environment(), concat('type of ', name, ' return value')));
    scope.emitIncref(value, true); // matched by DynamicSlot doing a decref on the receiving end (see emitSubroutineCall)
    scope.emitInstruction(SyntheticNestedAllScopesExitInstruction(scope));
    scope.emitInstruction(JumpInstruction(epilogLabel, 'return'));
  }

  DynamicSlot parameterCount;
  ConstantSlot nameConstant;

  Null prepareSlots() {
    label = environment().generateLabel(labelPrefix());
    epilogLabel = environment().generateLabel(concat(labelPrefix(), '$epilog'));
    returnValuePointer = ReturnValuePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value of ', name));
    returnValueTypePointer = ReturnValueTypePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value type of ', name));
    parameterCount = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('parameter count of ', name));
    parameterCount.willInitialize();
    nameConstant = environment().registerStringConstant(concat(label, '$annotation'), name, __LINE__, __COL__, __FILE__);
    references.add(nameConstant);
    super.prepareSlots();
  }

  Null prepareInstructions() {
    if (len(instructions) == 0 || !(last(instructions) is JumpInstruction)) {
      emitInstruction(CommentInstruction(concat('Implicit return from ', name)));
      emitReturnFrom(this, environment().intrinsicsLibrary.coreNull);
    }
    super.prepareInstructions();
  }

  Null initializeParameters() {
    slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
  }

  Null clearRegisters(AssemblerBlock subblock) {
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    Integer stackSize = slotManager.stackSize();
    block.addLabel(epilogLabel, null);
    assert(stackSize == slotManager.stackSize(), concat('addCode changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.enterNestedScope(this, block);
    assert(stackSize == slotManager.stackSize(), concat('enterNestedScope changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.read(returnValuePointer, rax.bit, 'report address of return value').release();
    assert(stackSize == slotManager.stackSize(), concat('read into rax changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.exitNestedScope(this);
    assert(stackSize == slotManager.stackSize(), concat('exitNestedScope changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    super.generateEpilogAssemblerBlock(block);
    block.addCode('ret', [], 'return from subroutine');
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock block = assembler.createBlock();
    generateAssemblerBlock(block);
    assembler.addLabeledBlock(label, block, name, nameConstant.label);
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class CompiledSubroutineWithSpecificParameters extends CompiledSubroutine {
  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = ParameterSlot(type, position, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitParameterChecks(SlotList parameters) {
    // xxxx verify the types statically
    // check for parameter count
    emitInstruction(CommentInstruction('Check parameter count'));
    Slot expectedParamCountValue = environment().integer(len(parameters));
    CompiledNestedScope block = createErrorHandlerBlock(
      environment().intrinsicsLibrary.parameterCountCheckFailureMessage,
      'parameter count',
    );
    emitConditionalBlock(block, null, parameterCount, expectedParamCountValue, 'parameter count check', 'check number of parameters is as expected');
    Integer index = 0;
    for (parameter in parameters) {
      emitInstruction(CommentInstruction(concat('Check type of parameter ', index, ', ', parameter.debugName, ' (expecting ', parameter.staticType, ')')));
      emitTypeCheck(parameter, parameter.staticType, environment().intrinsicsLibrary.parameterTypeCheckFailureMessage, parameter.debugName, false);
      index += 1;
    }
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class CompiledVarArgsSubroutine extends CompiledSubroutine {
  Slot registerVarArgsParameter(String name, Type type) {
    ReadOnlyListType listType = createOrFindReadOnlyListType(environment(), type);
    listType.markConstructed();
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter name');
    Slot slot = VarArgsParameterSlot(listType, parameterCount, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitVarArgsParameterChecks(Type parameterType, VarArgsParameterSlot varargs) {
    // xxxx verify the types statically
    CompiledNestedScope block = createErrorHandlerBlock(environment().intrinsicsLibrary.parameterTypeCheckFailureMessage, 'vararg types');
    doIfVarArgsTypeMismatch(parameterType, varargs, concat(labelPrefix(), '$varargTypeChecks'), block, 'vararg types');
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithVarArgs signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters {
  SlotList parameters;

  StringList parameterDescriptions() {
    return []:String;
  }

  RegisterSlot arg4;
  RegisterSlot arg3;
  RegisterSlot arg2;
  RegisterSlot arg1;

  Null prepareSlots() {
    super.prepareSlots();
    arg4 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, r9, 'x64 calling convention arg #4');
    arg3 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, r8, 'x64 calling convention arg #3');
    arg2 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rdx, 'x64 calling convention arg #2');
    arg1 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rcx, 'x64 calling convention arg #1');
  }

  // used to generate the instructions for the subroutine
  Null generateInstructions() { }

  Null prepareInstructions() {
    parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    StringList descriptions = parameterDescriptions();
    assert(len(descriptions) == len(signature.parameterTypes), concat(className, '.parameterDescriptions() returned an unexpected number of descriptions (descriptions were ', descriptions, '; parameter types were ', signature.parameterTypes, ')'));
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, descriptions[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    generateInstructions();
    super.prepareInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['message to print to console'];
  }

  Null generateInstructions() {
    DynamicSlot stdHandle = registerDynamicValue((parent! as CompiledIntrinsicsLibrary).coreSystemType, rcNever, 'stdHandle, out param of GetStdHandle');
    DynamicSlot lpNumberOfCharsWritten = registerDynamicValue((parent! as CompiledIntrinsicsLibrary).coreSystemType, rcNever, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    Slot message = parameters[0];
    emitInstruction(CommentInstruction('Calling GetStdHandle'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, environment().integer(-11), true, 'argument #1: STD_OUTPUT_HANDLE'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'GetStdHandle', stdHandle, 'handle returned in rax'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20), stackPointer, 'release shadow space'));
    emitInstruction(CommentInstruction('Calling WriteConsoleA'));
    emitInstruction(PushInstruction(environment().integer(0), 'argument #5: Reserved, must be NULL (lpReserved)'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // shadow space
    emitInstruction(MoveToSpecificOperandInstruction(memory, lpNumberOfCharsWritten, false, 'allocate memory for lpNumberOfCharsWritten'));
    emitInstruction(PinSlotValueInstruction(lpNumberOfCharsWritten));
    emitInstruction(PinRegisterSlotInstruction(arg4));
    emitInstruction(LeaInstruction(arg4, lpNumberOfCharsWritten, 0, false, 'argument #4: Number of characters written (lpNumberOfCharsWritten)'));
    emitInstruction(PinRegisterSlotInstruction(arg3));
    emitInstruction(MoveDerefInstruction(arg3, message, 0x08, 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure'));
    emitInstruction(PinRegisterSlotInstruction(arg2));
    emitInstruction(AddInstruction(message, environment().integer(0x10), arg2, 'argument #2: Pointer to buffer to write (*lpBuffer)'));
    emitInstruction(PinRegisterSlotInstruction(arg1));
    emitInstruction(MoveInstruction(arg1, stdHandle, 'argument #1: Handle from GetStdHandle (hConsoleOutput)'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'WriteConsoleA', null, 'returns Booleanean representing success in rax'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x28), stackPointer, 'release shadow space'));
    emitInstruction(UnpinSlotValueInstruction(lpNumberOfCharsWritten));
    emitInstruction(RecordPopsInstruction(5)); // shadow space and lpReserved
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [parentArg.coreStringType]:Type),
      '__print',
    );
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['exit code parameter'];
  }

  Null generateInstructions() {
    Slot exitCode = parameters[0];
    emitInstruction(CommentInstruction('Calling ExitProcess'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, exitCode, true, 'exit code'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'ExitProcess', null, 'process should terminate at this point'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20), stackPointer, 'release shadow space, just in case'));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [ parentArg.coreIntegerType ]:Type),
      'exit',
    );
  }
}

class BuiltInLenSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['list'];
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 1 && arguments[0] is VarArgsParameterSlot) {
      return (arguments[0] as VarArgsParameterSlot).length();
    }
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    Slot listDataPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to list data');
    emitInstruction(MoveDerefInstruction(listDataPointer, parameters[0], _listBlockData, 'list data is the second field in its block'));
    Slot length = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'length of list');
    emitInstruction(MoveDerefInstruction(length, listDataPointer, _gcBlockHeaderLength, 'list length is a field in the list data'));
    emitInstruction(SetTypeInstruction(length, environment().intrinsicsLibrary.coreIntegerType));
    emitReturnFrom(this, length);
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ createOrFindReadOnlyListType(parentArg.environment(), parentArg.coreWhateverType) ]:Type,
      ),
      'len',
    );
  }
}

class BuiltInDebuggerSubroutine extends BuiltInSubroutine {
  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 0) {
      scope.emitInstruction(Interrupt3Instruction());
      return environment().intrinsicsLibrary.coreNull;
    }
    assert(false, concat('inline __debugger() takes 0 arguments, got ', len(arguments)));
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    emitInstruction(Interrupt3Instruction());
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        []:Type,
      ),
      '__debugger',
    );
  }
}

class CompilerIntrinsic extends BuiltInSubroutine {
  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    abstract();
  }

  Boolean verifyArguments(SlotList arguments, TypeList parameters) {
    assert(len(parameters) == len(arguments), 'unexpected number of arguments');
    Integer index = 0;
    while (index < len(arguments)) {
      assert(
        arguments[index].staticType.isSubtypeOf(parameters[index]),
        concat('argument ', index+1, ' of ', name, '() has unexpected type (wanted ', parameters[index], ' but got ', arguments[index].staticType, ')'),
      );
      index += 1;
    }
    return true;
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    assert(verifyArguments(arguments, signature.parameterTypes), 'unexpected arguments');
    Slot result = inlineBody(scope, arguments);
    assert(result.staticType == signature.returnType, concat(this, ' returned slot of wrong type (expected ', signature.returnType, ' but got ', result.staticType, ')'));
    return result;
  }
}

class BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    Slot returnValue = scope.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('dereferenced ', arguments[0].debugName));
    scope.emitInstruction(MoveDerefInstruction(returnValue, arguments[0], 0, 'dereference first argument of __readFromAddress'));
    scope.emitInstruction(SetTypeInstruction(returnValue, returnValue.staticType));
    return returnValue;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType ]:Type,
      ),
      '__readFromAddress',
    );
  }
}

// this is for increffing strings if they are strings.
class BuiltInIncrefIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['value'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    scope.emitIncref(arguments[0], false);
    return scope.environment().intrinsicsLibrary.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreAnythingType ]:Type,
      ),
      '__incref',
    );
  }
}

class BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address', 'value'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    scope.emitInstruction(MoveToDerefInstruction(arguments[0], arguments[1], 0, '__writeToAddress'));
    return scope.environment().intrinsicsLibrary.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__writeToAddress',
    );
  }
}

class GenericSystemCallSubroutine extends CompiledSubroutineWithSpecificParameters {
  StringList parameterNames;
  String externalName;
  String library;

  Null prepareInstructions() {
    SlotList parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, parameterNames[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    emitInstruction(CommentInstruction(concat('Calling ', externalName)));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // shadow space
    index -= 1;
    while (index > 3) {
      emitInstruction(PushInstruction(parameters[index], concat('argument #', index + 1)));
      index -= 1;
    }
    Register64OperandList parameterRegisters = [rcx, rdx, r8, r9];
    while (index >= 0) {
      emitInstruction(MoveToSpecificOperandInstruction(parameterRegisters[index].bit, parameters[index], true, concat('argument #', index + 1)));
      index -= 1;
    }
    // It doesn't really make sense for the return value to ever be GarbageCollectable or String but if it is then
    // the emitReturnFrom below will incref it for us. Therefore we don't bother making our temporary reference counted.
    Slot returnValue = registerDynamicValue(type.returnType, rcNever, concat('return value of ', externalName, ' system call'));
    emitInstruction(CallSystemInstruction(library, externalName, returnValue, concat('calls ', externalName, ' from ', library)));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20 + 0x08 * max(0, len(parameters) - 4)), stackPointer, 'release shadow space and arguments if there were more than four'));
    emitInstruction(RecordPopsInstruction(4 + max(0, len(parameters) - 4))); // shadow space and any arguments that didn't fit in the registers
    emitInstruction(SetTypeInstruction(returnValue, type.returnType));
    emitReturnFrom(this, returnValue);
    super.prepareInstructions();
  }

  Null constructor(CompiledScope parentArg, Type returnTypeArg, TypeList argumentTypesArg, StringList parameterNamesArg, String libraryArg, String externalNameArg, String internalNameArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), returnTypeArg, argumentTypesArg),
      internalNameArg,
    );
    parameterNames = parameterNamesArg;
    library = libraryArg;
    externalName = externalNameArg;
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  String labelPrefix() {
    return camelCase(name);
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  SlotNullable internalLookupIdentifier(String name) {
    SlotNullable result = super.internalLookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.internalLookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(!environment().isCompoundType(type.name), 'tried to declare a type that ends with a generic suffix');
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = library.lookupType(name);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    block.addBlankLine();
    block.addComment(name);
    block.addComment(stringTimes('=', len(scalarValues(name))));
    super.generateAssemblerBlock(block);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    compilationEnvironment = compilationEnvironmentArg;
    super.constructor(null, nameArg);
    if (!(this is CompiledIntrinsicsLibrary)) {
      importLibrary(compilationEnvironment.intrinsicsLibrary);
    }
    CompiledLibraryNullable runtimeLibrary = compilationEnvironment.runtimeLibrary;
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledInternalProcedure extends CompiledStackFrameScope {
  String labelPrefix() {
    return name;
  }

  Type type() {
    return environment().intrinsicsLibrary.coreSystemType;
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    super.generateEpilogAssemblerBlock(block);
    block.addCode('ret', [], 'return from compiler-internal function');
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock block = assembler.createBlock();
    generateAssemblerBlock(block);
    assembler.addLabeledBlock(name, block, null, null);
  }

  Null constructor(String labelArg, CompiledScope parentArg) {
    super.constructor(parentArg, labelArg);
  }
}

class DecrefCompiledInternalProcedure extends CompiledInternalProcedure {
  DynamicSlot value;
  Boolean canBeGarbageCollectable;
  Boolean canBeString;
  Boolean checkFirst;

  Null prepareSlots() {
    // We don't want our parameter to be automatically reference counted since we are going to manually decrement its reference count.
    value = registerDynamicValue(environment().intrinsicsLibrary.coreAnythingType, rcNever, 'value');
    value.willInitialize();
    super.prepareSlots();
  }

  Null initializeParameters() {
    slotManager.initialize(value, rcx, rdx);
  }

  Null prepareInstructions() {
    emitInstruction(CommentInstruction('Body'));
    // This intentionally skips doing the synthetic block exits for simplicity, but as a result
    // this code is technically wrong. We should find a way to make the slot manager's block
    // management to be unnecessary or at least less invasive so as to make this correct while
    // remaining more simple than it would be with all the correct blocks.
    String decrefEndLabel = environment().generateLabel(concat(name, '$end'));
    Slot valueDeref = SimpleMemorySlot(environment().intrinsicsLibrary.coreIntegerType, value, 'value dereferenced');
    // if value is a string or garbage-collectable then valueDeref is the reference count
    if (canBeGarbageCollectable) {
      assert(checkFirst, 'should have used a direct "dec" instead');
      emitIsOperatorCheck(environment().intrinsicsLibrary.coreGarbageCollectableType, value, value.debugName);
      String notGarbageCollectableLabel;
      if (canBeString) {
        notGarbageCollectableLabel = environment().generateLabel(concat(name, '$string'));
      } else {
        notGarbageCollectableLabel = decrefEndLabel;
      }
      emitInstruction(JncInstruction(notGarbageCollectableLabel, concat(value.debugName, 'skip GC decref block if the value is not GarbageCollectable')));
      emitInstruction(DecInstruction(valueDeref, concat('decref GarbageCollectable reference count of ', value.debugName)));
      emitInstruction(JumpInstruction(decrefEndLabel, 'return'));
      if (canBeString) {
        emitInstruction(LabelInstruction(notGarbageCollectableLabel, 'string decref'));
      }
    }
    if (canBeString) {
      if (checkFirst) {
        emitInstruction(ConditionalDynamicTypeJumpInstruction(value, environment().intrinsicsLibrary.coreStringType, ccNotEqual, decrefEndLabel, 'skip string decref block if the value is not a String'));
      }
      emitInstruction(ConditionalJumpInstruction(valueDeref, environment().integer(0), ccLessThan, decrefEndLabel, 'skip string decref block for string constants'));
      emitInstruction(DecJccInstruction(valueDeref, ccNonZero, decrefEndLabel, concat('decrement reference count of ', value.debugName)));  
      Slot pointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat(value.debugName, ' cast to integer'));
      emitInstruction(MoveInstruction(pointer, value, 'copy value of value to pointer'));  
      emitInstruction(SetTypeInstruction(pointer, environment().intrinsicsLibrary.coreIntegerType));  
      emitSubroutineCall(lookupIntrinsic(environment().freeIntrinsicName), [pointer]);
    }
    emitInstruction(LabelInstruction(decrefEndLabel, 'end of function'));
    super.prepareInstructions();
  }

  Null constructor(Boolean canBeGarbageCollectableArg, Boolean canBeStringArg, Boolean checkFirstArg, String labelArg, CompiledScope parentArg) {
    super.constructor(labelArg, parentArg);
    canBeGarbageCollectable = canBeGarbageCollectableArg;
    canBeString = canBeStringArg;
    checkFirst = checkFirstArg;
    assert(!canBeGarbageCollectable || checkFirst, 'Instead of using a DecrefCompiledInternalProcedure for the case of decreffing a known GC-able refrence, just use "dec". (true, x, false)');
    assert(canBeGarbageCollectable || canBeString, 'This decref would be pointless... (false, false, x)');
  }
}

class CompiledIntrinsicsLibrary extends CompiledLibrary {
  String labelPrefix() {
    return 'intrinsics';
  }

  AnythingType coreAnythingType;
  WhateverType coreWhateverType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;
  ListDataType coreListDataType;
  GarbageCollectableType coreGarbageCollectableType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;
  SentinelType coreSentinelType;

  ImmediateSlot coreSentinel;
  ImmediateSlot coreNull;
  ImmediateSlot coreTrue;
  ImmediateSlot coreFalse;

  Slot corePrint; // actually __print; the real print is in the rtl
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;
  Slot returnValueTypeCheckFailureMessage;
  Slot operandTypeCheckFailureMessage;
  Slot assignmentTypeCheckFailureMessage;
  Slot subscriptTypeCheckFailureMessage;
  Slot forLoopIterableTypeCheckFailureMessage;
  Slot subroutineCallTypeCheckFailureMessage;
  Slot asOperatorFailureMessage;
  Slot boundsFailureMessage;

  Map internalProcedures = Map(); // ip -> CompiledInternalProcedureSlot

  CompiledInternalProcedureSlot lookupInternalProcedureSlot(ip procedure) {
    return internalProcedures.get(procedure);
  }

  Null prepareSlots() {
    // We don't call super.prepareSlots yet.
    // We do it after we build intrinsicsLibrary instead
    // see below (mid way through generateScopes).
  }

  Null prepareInstructions() {
    super.prepareInstructions();
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.prepareInstructions();
      }
    }
  }

  Null allocateSlots(Assembler assembler) {
    super.allocateSlots(assembler);
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.allocateSlots(assembler);
      }
    }
  }

  Null generateAssembler(Assembler assembler) {
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.generateAssembler(assembler);
      }
    }
  }

  Null generateScopes() {
    CompilationEnvironment environment = environment();
    // internal types
    coreClassType = RootClassType(environment);
    coreClosureType = ClosureType(environment);
    coreSystemType = SystemType(environment);
    coreSentinelType = SentinelType(environment);
    // built-in types
    coreAnythingType = AnythingType(environment);
    declareType(coreAnythingType);
    coreWhateverType = WhateverType(environment);
    declareType(coreWhateverType);
    coreSentinel = ImmediateIntegerSlot(coreSentinelType, 0, 'sentinel slot');
    coreSentinelType.markConstructed();
    coreNullType = NullType(environment);
    declareType(coreNullType);
    coreNull = registerNumericConstant('null', 0x00, coreNullType);
    coreBooleanType = BooleanType(environment);
    declareType(coreBooleanType);
    coreFalse = registerNumericConstant('false', 0x00, coreBooleanType);
    coreTrue = registerNumericConstant('true', 0x01, coreBooleanType);
    coreIntegerType = IntegerType(environment);
    declareType(coreIntegerType);
    coreStringType = StringType(environment);
    declareType(coreStringType);
    coreListDataType = ListDataType(environment);
    declareType(coreListDataType);
    coreGarbageCollectableType = GarbageCollectableType(environment);
    declareType(coreGarbageCollectableType);

    // now that we have the types ready, set up the slots (like stackFramePointer)
    // which are used by the built-in functions
    super.prepareSlots();

    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));

    // built-in functions not used from compiler
    registerSubroutine(BuiltInLenSubroutine(this));
    registerSubroutine(BuiltInDebuggerSubroutine(this));

    // intrinsic functions (functions that only work when inlined)
    registerSubroutine(BuiltInReadFromAddressIntrinsic(this));
    registerSubroutine(BuiltInWriteToAddressIntrinsic(this));
    registerSubroutine(BuiltInIncrefIntrinsic(this));

    // compiler-internal functions
    internalProcedures.set(ipDecrefMaybeGCOrString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(true, true, true, 'decrefMaybeGCOrString', this)));
    internalProcedures.set(ipDecrefMaybeGC, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(true, false, true, 'decrefMaybeGC', this)));
    internalProcedures.set(ipDecrefMaybeString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(false, true, true, 'decrefMaybeString', this)));
    internalProcedures.set(ipDecrefString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(false, true, false, 'decrefString', this)));
    for (slot in internalProcedures.values()) {
      references.add(slot); // TODO: this is a hack to keep these as referenced since the slot manager happens too late currently to track this
      // (eventually the right fix is to do the dead code elimination after we insert reference counting instructions)
      (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.prepareSlots();
    }

    // messages
    parameterCountCheckFailureMessage = environment.registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = environment.registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    returnValueTypeCheckFailureMessage = environment.registerStringConstant(
      'returnValueTypeCheckFailureMessage',
      'error: type mismatch for function return value, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    operandTypeCheckFailureMessage = environment.registerStringConstant(
      'operandTypeCheckFailureMessage',
      'error: type mismatch for operand, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    assignmentTypeCheckFailureMessage = environment.registerStringConstant(
      'assignmentTypeCheckFailureMessage',
      'error: type mismatch for assignment, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    subscriptTypeCheckFailureMessage = environment.registerStringConstant(
      'subscriptTypeCheckFailureMessage',
      'error: subscript index must be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    forLoopIterableTypeCheckFailureMessage = environment.registerStringConstant(
      'forLoopIterableTypeCheckFailureMessage',
      'error: for loop iterable must be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    subroutineCallTypeCheckFailureMessage = environment.registerStringConstant(
      'subroutineCallTypeCheckFailureMessage',
      'error: function calls expect target to be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    asOperatorFailureMessage = environment.registerStringConstant(
      'asOperatorFailureMessage',
      'error: type mismatch for as operator, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    boundsFailureMessage = environment.registerStringConstant(
      'boundsFailureMessage',
      'error: subscript index out of range (%d is not in range %d..%d)\n',
      __LINE__, __COL__, __FILE__,
    );
  }
}
