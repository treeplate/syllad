import 'core.syd';
import 'syd-operands.syd';
import 'syd-assembler.syd';
import 'syd-slots.syd';
import 'syd-slot-manager.syd';
import 'syd-types.syd';
import 'syd-instructions.syd';
import 'syd-utils.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+60h : rbp+50h : (local variable from previous stack frame)
     *                      (maybe arg 2 here)
     *  rsp+58h : rbp+48h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+50h : rbp+40h : type of arg 1
     *  rsp+48h : rbp+38h : pointer to return value
     *  rsp+40h : rbp+30h : pointer to return value type
     *  rsp+38h : rbp+28h : shadow r9
     *  rsp+30h : rbp+20h : shadow r8
     *  rsp+28h : rbp+18h : shadow rdx
     *  rsp+20h : rbp+10h : shadow rcx
     *  rsp+18h : rbp +8h : return address
     *  rsp+10h : rbp     : saved non-volatile register rbp                      
                            (maybe other saved registers here)
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */

     // on the heap, a 16 byte entry has the value first, then the type 8 bytes "later" (positive address)
     //    so if the value is at p, type at p+0x08
     // on the stack, a 16 byte entry has the value first, then the type 8 bytes "later" (negative address)
     //    so if the value is at p, type at p-0x08


// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================
fwdclass CompilationEnvironment extends TypeRegistry;
fwdclass CompiledScope extends SlotContext;
fwdclass CompiledNestedScope(CompiledScope, String) extends CompiledScope;
fwdclass CompiledStackFrameScope extends CompiledScope;
fwdclass CompiledSubroutine extends CompiledStackFrameScope;
fwdclass CompiledLibrary(CompilationEnvironment, String) extends CompiledStackFrameScope;
fwdclass CompiledIntrinsicsLibrary extends CompiledLibrary;
fwdclass Instruction extends Object;
fwdclass CompiledSubroutineWithSpecificParameters extends CompiledSubroutine;
fwdclass BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters;
fwdclass BuiltInPrintSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInExitSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInLenSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInDebuggerSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass CompilerIntrinsic extends BuiltInSubroutine;
fwdclass BuiltInReadFromAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass BuiltInWriteToAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass CompiledVarArgsSubroutine extends CompiledSubroutine;

// CompiledScope
fwdclassprop CompiledScopeNullable CompiledScope.parent;
fwdclassprop String CompiledScope.name;
fwdclassprop CompilationEnvironmentFunction CompiledScope.environment;
fwdclassprop CompiledStackFrameScopeFunction CompiledScope.stackFrame;
fwdclassprop CompiledLibraryFunction CompiledScope.globalScope;
fwdclassprop NullFunction CompiledScope.prepareSlots;
fwdclassprop SlotNullableFunction CompiledScope.lookupIdentifier;
fwdclassprop NullFunction CompiledScope.prepareInstructions;
fwdclassprop NullFunction CompiledScope.generateAssemblerBlock;
fwdclassprop NullFunction CompiledScope.emitInstruction;
fwdclassprop DynamicSlotFunction CompiledScope.registerDynamicValue;
fwdclassprop SlotFunction CompiledScope.registerStaticValue;
fwdclassprop SlotFunction CompiledScope.registerSubroutine;
fwdclassprop NullFunction CompiledScope.registerNestedScope;
fwdclassprop StringFunction CompiledScope.labelPrefix;
fwdclassprop DynamicSlotFunction CompiledScope.registerSlot;
fwdclassprop NullFunction CompiledScope.emitIsOperatorCheck;

// CompiledStackFrameScope
fwdclassprop NullFunction CompiledStackFrameScope.declareType;
fwdclassprop NullFunction CompiledStackFrameScope.allocateSlots;
fwdclassprop SlotManager CompiledStackFrameScope.slotManager;
fwdclassprop NullFunction CompiledStackFrameScope.generateAssembler;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackFramePointer;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackPointer;

// CompiledSubroutine
fwdclassprop String CompiledSubroutine.label;
fwdclassprop String CompiledSubroutine.epilogLabel;
fwdclassprop AbstractSubroutineTypeWithSpecificParameters CompiledSubroutine.type;
fwdclassprop SlotNullableFunction CompiledSubroutine.inline;
fwdclassprop DynamicSlot CompiledSubroutine.parameterCount;

// CompiledLibrary
fwdclassprop CompilationEnvironment CompiledLibrary.compilationEnvironment;
fwdclassprop TypeNullableFunction CompiledLibrary.lookupType;

// CompiledIntrinsicsLibrary
fwdclassprop BooleanType CompiledIntrinsicsLibrary.coreBooleanType;
fwdclassprop IntegerType CompiledIntrinsicsLibrary.coreIntegerType;
fwdclassprop SentinelType CompiledIntrinsicsLibrary.coreSentinelType;
fwdclassprop StringType CompiledIntrinsicsLibrary.coreStringType;
fwdclassprop NullType CompiledIntrinsicsLibrary.coreNullType;
fwdclassprop WhateverType CompiledIntrinsicsLibrary.coreWhateverType;
fwdclassprop SystemType CompiledIntrinsicsLibrary.coreSystemType;
fwdclassprop AnythingType CompiledIntrinsicsLibrary.coreAnythingType;
fwdclassprop NullFunction CompiledIntrinsicsLibrary.generateScopes;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreSentinel;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreNull;
fwdclassprop Slot CompiledIntrinsicsLibrary.corePrint;
fwdclassprop Slot CompiledIntrinsicsLibrary.coreExit;
fwdclassprop Slot CompiledIntrinsicsLibrary.boundsFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.returnValueTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterCountCheckFailureMessage;

// CompilationEnvironment
fwdclassprop CompiledIntrinsicsLibrary CompilationEnvironment.intrinsicsLibrary;
fwdclassprop Integer CompilationEnvironment.typeTableWidth;
fwdclassprop Integer CompilationEnvironment.typeTableOffset;
fwdclassprop String CompilationEnvironment.typeTableLabel;
fwdclassprop StringFunction CompilationEnvironment.generateLabel;
fwdclassprop SlotFunction CompilationEnvironment.integer;


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class Constant {
  String label;
  StringList data;
  StringNullableList comments;

  Null constructor(String labelArg, StringList dataArg, StringNullableList commentsArg) {
    label = labelArg;
    data = dataArg;
    comments = commentsArg;
  }
}

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  CompiledIntrinsicsLibrary intrinsicsLibrary;

  Map stringAtomTable = Map(); // String -> String
  ConstantList constants = []:Constant;

  Slot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    StringNullable maybeLabel = stringAtomTable.get(value) as StringNullable;
    if (maybeLabel == null) {
      SourceLocation source = SourceLocation(line, col, file);
      String label = generateLabel(labelBase);
      stringAtomTable.set(value, label);
      // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
      StringList data = ['dq -01h', concat('dq ', len(scalarValues(value)))]:String;
      StringNullableList comments = ['String constant (reference count)', 'Length']:StringNullable;
      if (value != '') {
        append(data, concat('db ', stringLiteral(value)));
        append(comments, concat(source));
        Integer padding = 8 - len(scalarValues(value)) % 8;
        if (padding > 0) {
          StringList buffer = []:String;
          append(buffer, 'db ');
          while (padding > 0) {
            append(buffer, '00h');
            if (padding > 1) {
              append(buffer, ', ');
            }
            padding -= 1;
          }
          append(data, joinList(buffer));
          append(comments, 'padding to align to 8-byte boundary');
        }
      }
      append(constants, Constant(label, data, comments));
      intrinsicsLibrary.coreStringType.markConstructed();
      maybeLabel = label;
    }
    return ImmediateDataLabelSlot(intrinsicsLibrary.coreStringType, maybeLabel!, labelBase);
  }

  CompiledLibraryNullable runtimeLibrary = null; 

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
  }

  Null defineLibrary(String filename, CompiledLibrary library) { 
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
    append(libraryNames, filename);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is CompiledLibrary, 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  CompiledLibrary getLibrary(String filename) { 
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  Null setRuntimeLibrary(CompiledLibrary runtimeLibraryArg) { 
    runtimeLibrary = runtimeLibraryArg;
  }

  CompiledSubroutineList subroutines = []:CompiledSubroutine; 

  String freeIntrinsicName = '_free';
  Map intrinsics = Map(); // String -> CompiledSubroutine

  Null registerIntrinsic(CompiledSubroutine intrinsic) {
    intrinsics.set(intrinsic.name, intrinsic);
  }

  Null addSubroutine(CompiledSubroutine subroutine) { 
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    intrinsicsLibrary.prepareInstructions();
    runtimeLibrary!.prepareInstructions();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).prepareInstructions();
    }
    for (subroutine in subroutines) {
      subroutine.prepareInstructions();
    }
  }

  Slot integer(Integer value) {
    intrinsicsLibrary.coreIntegerType.markConstructed();
    return ImmediateIntegerSlot(intrinsicsLibrary.coreIntegerType, value, concat(hex(value), ' (integer)'));
  }

  String typeTableLabel;
  Integer typeTableOffset;
  Integer typeTableWidth;

  Null generateTypeTable(Assembler assembler, String label) {
    StringList comment = []:String;
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, '   ; Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        append(comment, concat(' ', supertype));
      }
    }
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(comment, '   ; ');
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        append(bytes, byte);
        byte = 0;
        bits = 0;
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    while (len(bytes) % 8 != 0) {
      append(bytes, 0); // padding to keep things 8-byte aligned
    }
    IntegerListList data = [[]:Integer]:IntegerList;
    for (byte in bytes) {
      if (len(last(data) as WhateverList) >= 8) {
        append(data, []:Integer);
      }
      append(last(data) as WhateverList, byte);
    }
    String genBytes(IntegerList bytes) {
      return concat('db ', join(map(bytes, hex8) as StringList, ', '));
    }
    StringNullable genComments(IntegerList bytes) {
      return '...';
    }
    StringList generatedBytes = map(data, genBytes) as StringList;
    StringNullableList comments = map(data, genComments) as StringNullableList;
    comments[0] = 'Type table';
    comments[len(comments) - 1] = concat(comments[len(comments) - 1], '\n', join(comment, ''));
    assembler.addConst(
      label,
      generatedBytes,
      comments,
    );
    typeTableOffset = offset;
    typeTableWidth = width;
  }
  
  Null generateDecrefIntrinsic(Assembler assembler, String label) {
    AssemblerBlock block = assembler.createBlock();
    String decrefEndLabel = generateLabel(concat(label, '$end'));
    block.addComment('variable\'s type is in rdx');
    block.addComment('variable\'s value is in rcx');
    block.addComment('if variable is a string then it is actually a pointer to the reference count');
    block.addCode('cmp', [rdx, intrinsicsLibrary.coreStringType.code], 'verify that the variable is a string');
    block.addCode('jne', [decrefEndLabel], 'if not, abort');
    block.addComment('check reference count is not negative');
    block.addCode('cmp', [rcx.dereference(), 0], 'if the refcount is negative then this is a constant, not reference counted');
    block.addCode('js', [decrefEndLabel], '...so abort');
    block.addCode('dec', [rcx.dereference()], 'decrement the reference count');
    block.addCode('jnz', [decrefEndLabel], 'if we did not reach zero, then the string is still in use; abort');
    block.addComment('String reached zero reference count, so we must free it.');
    block.addCode('push', [rcx], 'argument #1 value: pointer to block we want to free.');
    block.addCode('push', [intrinsicsLibrary.coreIntegerType.code], 'argument #1 type: integer');
    block.addCode('lea', [r11, AddressComputationOperand(rsp, null, 1, 0x18)], 'use rcx shadow space for the return value');
    block.addCode('push', [r11], 'internal argument 6: pointer to return value\'s value');
    block.addCode('lea', [r11, AddressComputationOperand(rsp, null, 1, 0x28)], 'use rdx shadow space for the return type');
    block.addCode('push', [r11], 'internal argument 5: pointer to return value\'s type');
    block.addCode('sub', [rsp, '020h'], 'allocate shadow space');
    block.addCode('mov', [r9, '000h'], 'internal argument 4: "this" pointer');
    block.addCode('mov', [r8, '000h'], 'internal argument 3: "this" pointer type');
    block.addCode('mov', [rdx, '000h'], 'internal argument 2: closure pointer');
    block.addCode('mov', [rcx, '001h'], 'internal argument 1: number of actual arguments');
    CompiledSubroutine freeIntrinsic = intrinsics.get(freeIntrinsicName) as CompiledSubroutine;
    block.addCode('call', [freeIntrinsic.label], 'jump to subroutine');
    block.addCode('add', [rsp, '040h'], 'release shadow space and arguments (result in stack pointer)');
    block.addLabel(decrefEndLabel, null);
    block.addCode('ret', [], 'return from subroutine');
    assembler.addLabeledBlock(label, block, 'decref intrinsic; used to decrement the reference count of string variables', null);
  }

  Null allocateSlots(Assembler assembler) {
    intrinsicsLibrary.allocateSlots(assembler);
    runtimeLibrary!.allocateSlots(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).allocateSlots(assembler);
    }
    for (subroutine in subroutines) {
      subroutine.allocateSlots(assembler);
    }
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock mainBlock = assembler.createBlock();
    for (constant in constants) {
      assembler.addConst(constant.label, constant.data, constant.comments);
    }
    intrinsicsLibrary.generateAssemblerBlock(mainBlock);
    runtimeLibrary!.generateAssemblerBlock(mainBlock);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).generateAssemblerBlock(mainBlock);
    }
    mainBlock.addBlankLine();
    mainBlock.addComment('End of global scope');
    mainBlock.addCode('ret', [], 'exit application');
    assembler.addLabeledBlock('main', mainBlock, null, null);
    for (subroutine in subroutines) {
      subroutine.generateAssembler(assembler);
    }
  }

  Null compile(Assembler assembler) {
    // the phase before this is Library.generateScopes() in syd_ast.syd
    prepareInstructions();
    assignTypeCodes();
    generateTypeTable(assembler, typeTableLabel);
    generateDecrefIntrinsic(assembler, decrefLabel);
    allocateSlots(assembler);
    generateAssembler(assembler);
  }

  AbstractSubroutineType subroutineType;
  AbstractListType subscriptableType;

  Null constructor() {
    super.constructor();
    typeTableLabel = generateLabel('typeTable');
    intrinsicsLibrary = CompiledIntrinsicsLibrary(this, 'intrinsics');
    intrinsicsLibrary.generateScopes();
    subroutineType = createOrFindSubroutineTypeWithAnyArgs(this, intrinsicsLibrary.coreAnythingType);
    subscriptableType = createOrFindReadOnlyListType(this, intrinsicsLibrary.coreWhateverType);
  }
}


// ============================================================================
// SPECIALIZED SLOTS
// ============================================================================

class TypeTableWidthSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;

  Integer numericValue() {
    Integer width = environment.typeTableWidth;
    if (width % 8 > 0) {
      return width / 8 + 1;
    }
    return width / 8;
  }

  Null constructor(CompilationEnvironment environmentArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, 'type table width in bytes');
    environment = environmentArg;
  }
}

class TypeBitSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type staticType;

  Integer numericValue() {
    return (staticType.code - environment.typeTableOffset) % 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type staticTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('bit offset for ', staticTypeArg));
    environment = environmentArg;
    staticType = staticTypeArg;
    staticType.markUsedInTypeCheck();
  }
}

class TypeByteSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type staticType;

  Integer numericValue() {
    assert(staticType.code != null, concat(staticType, ' does not have an assigned code'));
    return (staticType.code - environment.typeTableOffset) / 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type staticTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('byte offset for ', staticTypeArg));
    environment = environmentArg;
    staticType = staticTypeArg;
    staticType.markUsedInTypeCheck();
  }
}

class SubroutineSlot extends CompileTimeLabelSlot {
  CompiledSubroutine subroutine;

  String labelValue() {
    return subroutine.label;
  }

  Operand value() {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(CompiledSubroutine subroutineArg) {
    subroutine = subroutineArg;
    super.constructor(subroutine.type, subroutine.name);
  }
}


// ============================================================================
// SPECIALIZED INSTRUCTIONS
// ============================================================================

class DoBlockInstruction extends Instruction {
  CompiledNestedScope nestedBlock;

  Null prepare(SlotContext scope) {
    assert(scope is CompiledScope, 'DoBlockInstruction expects a CompiledScope');
    (scope as CompiledScope).registerNestedScope(nestedBlock);
    nestedBlock.prepareInstructions();
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    nestedBlock.generateAssemblerBlock(block);
  }

  Null constructor(CompiledNestedScope nestedBlockArg) { 
    super.constructor();
    nestedBlock = nestedBlockArg;
  }
}


// ============================================================================
// SCOPES
// ============================================================================

class CompiledScope extends SlotContext {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name; // TODO: rethink exactly what this means

  SlotContextNullable getParent() {
    return parent;
  }

  CompiledLibrary globalScope() { 
    assert(parent != null, 'compiled scope chain failure');
    return parent!.globalScope();
  }

  CompiledStackFrameScope stackFrame() { 
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = parent!.stackFrame() as CompiledScope;
    return result;
  }

  SlotContext slotScope() {
    return stackFrame();
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return parent!.environment();
  }

  String labelPrefix() {
    abstract();
  }

  Null prepareSlots() { }

  // REGISTRIES

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable value = identifiers.get(name) as SlotNullable;
    if (value == null && parent != null) {
      value = parent!.lookupIdentifier(name);
    }
    return value;
  }

  Null registerNestedScope(CompiledNestedScope nestedScope) {
    stackFrame().registerNestedScope(nestedScope);
    // CompiledStackFrameScope overrides this to add more behaviour
  }

  DynamicSlot registerSlot(DynamicSlot slot) {
    return stackFrame().registerSlot(slot);
    // CompiledStackFrameScope overrides this to add more behaviour
  }

  DynamicSlot registerDynamicValue(Type type, String debugName) {
    return registerSlot(DynamicSlot(type, this, null, debugName));
  }

  DynamicSlot registerVariable(String name, Type type) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    DynamicSlot slot = DynamicSlot(type, this, name, concat(name, ' variable'));
    identifiers.set(name, slot);
    return registerSlot(slot);
  }

  ImmediateSlot registerNumericConstant(String name, Integer value, Type staticType) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    Slot slot = ImmediateIntegerSlot(staticType, value, name);
    identifiers.set(name, slot);
    staticType.markConstructed();
    return slot;
  }

  Slot registerSubroutine(CompiledSubroutine subroutine) { 
    assert(!isIdentifierDeclaredInLocalScope(subroutine.name), concat('tried to redeclare an identifier (', subroutine.name, ') within a scope'));
    Slot slot = SubroutineSlot(subroutine);
    identifiers.set(subroutine.name, slot);
    environment().addSubroutine(subroutine);
    subroutine.type.markConstructed();
    return slot;
  }


  // INSTRUCTION GENERATION

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }
  
  Null markSourceLocation(SourceCode statement) {
    emitInstruction(PendingCommentInstruction(concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), 64))));
  }
  
  // does not set the type of target!
  // caller is responsible for setting it to boolean!
  Null storeEquality(Slot a, Slot b, Slot target, Boolean negate) {
    // TODO: hard-code result for literal comparisons
    // TODO: make this work for strings
    Slot valueTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, concat('value result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    Slot typeTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, concat('type result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    emitInstruction(SetSlotIfEqualInstruction(a, b, valueTemp, environment().intrinsicsLibrary.coreBooleanType, 'values equal?'));
    emitInstruction(SetSlotIfTypesEqualInstruction(a, b, typeTemp, environment().intrinsicsLibrary.coreBooleanType, 'types equal?'));
    emitInstruction(AndInstruction(valueTemp, typeTemp, target, '&& type temp and value temp'));
    if (negate) {
      emitInstruction(BiOperandInstruction('xor', target, environment().integer(1), target, concat('negating', target)));
    }
  }

  Null emitIncref(Slot string) {
    Type stringType = environment().intrinsicsLibrary.coreStringType;
    if (stringType.isSubtypeOf(string.staticType) && !(string is ImmediateDataLabelSlot)) {
      append(instructions, CommentInstruction(concat('increment reference count for ', string.debugName, ' if necessary')));
      String increfEndLabel = environment().generateLabel(concat(labelPrefix(), '$AfterIncref'));
      append(instructions, JumpIfDynamicTypeNotEqualStaticTypeInstruction(string, stringType, increfEndLabel, 'if not a string, skip incref'));
      Slot temp = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, 'string refcount temporary');
      append(instructions, MoveDerefInstruction(temp, string, 0, 'dereference string to get to ref count'));
      append(instructions, ConditionalJumpInstruction(temp, null, ccNegative, increfEndLabel, 'if ref count is negative (constant strings), skip incref'));
      append(instructions, AddInstruction(temp, environment().integer(1), temp, 'increment ref count'));
      append(instructions, MoveToDerefInstruction(string, temp, 0, 'put it back in the string'));
      append(instructions, LabelInstruction(increfEndLabel, 'after incref'));
    }
  }

  // Emits an instruction that does the equivalent of "lhs is staticType", puts the result in the CF flag.
  //
  // Must be followed by jc or setc.
  Null emitIsOperatorCheck(Type staticType, Slot lhs, String what) {
    CompilationEnvironment environment = environment();
    staticType.markUsedInTypeCheck();
    Slot typeTableWidth = TypeTableWidthSlot(environment);
    Slot typeBit = TypeBitSlot(environment, staticType);
    Slot typeByte = TypeByteSlot(environment, staticType);
    Slot typeTablePointer = ImmediateDataLabelSlot(environment.intrinsicsLibrary.coreIntegerType, environment.typeTableLabel, 'type table pointer');

    // byte of lhs's type's row in the type table containing the bit for staticType
    Slot testByte = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, 'testByte');
    emitInstruction(MoveTypeToValueInstruction(testByte, lhs, concat('move type of ', lhs.debugName, ' to testByte')));
    emitInstruction(UnsignedMultiplyInstruction(typeTableWidth, testByte, testByte, 'adjust to the relative start of that type\'s entry in the type table'));
    emitInstruction(AddInstruction(testByte, typeByte, testByte, 'adjust to the byte containing the bit to check against'));
    emitInstruction(AddInstruction(testByte, typeTablePointer, testByte, 'finally offset all of that by the start of the type table itself'));
    emitInstruction(BtDerefInstruction(testByte, typeBit, concat('check that ', what, ' is ', staticType))); // to be followed by jc or setc
  }
  
  Null doIfVarArgsTypeMismatch(Type staticType, VarArgsParameterSlot varArgs, String labelBase, CompiledNestedScope block, String what) {
    // TODO: xxxx we could also check if we can statically disprove compatibility
    emitInstruction(CommentInstruction(concat('Varargs parameter type check; expecting parameters to be ', staticType.name)));
    CompilationEnvironment environment = environment();
    String loopTopLabel = environment.generateLabel(concat(labelBase, '$Loop'));
    String continueLabel = environment.generateLabel(concat(labelBase, '$TypeMatch'));
    String loopBottomLabel = environment.generateLabel(concat(labelBase, '$TypesAllMatch'));
    // variable that holds a pointer to the index'th argument's type
    Slot pointerToIndexthArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, 'pointer to indexth argument');
    // variable that holds the last value that pointerToIndexthArg should have (pointer past the last argument)
    Slot pointerToLastArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, 'pointer to last argument');
    emitInstruction(LeaInstruction(pointerToIndexthArg, varArgs.baseAddress(environment.intrinsicsLibrary.coreIntegerType), true, 'get base address of varargs, where loop will start'));
    emitInstruction(UnsignedMultiplyInstruction(varArgs.length(), environment.integer(0x10), pointerToLastArg, 'end of loop is the number of arguments times the width of each argument (010h)...'));
    emitInstruction(AddInstruction(pointerToIndexthArg, pointerToLastArg, pointerToLastArg, '...offset from the initial index'));
    emitInstruction(LabelInstruction(loopTopLabel, 'top of loop'));
    CompiledNestedScope loopBlock = CompiledNestedScope(this, 'loop');
    Slot indexthArg = loopBlock.registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, 'indexth argument');
    loopBlock.emitInstruction(JumpIfEqualInstruction(pointerToIndexthArg, pointerToLastArg, loopBottomLabel, 'we have type-checked all the arguments'));
    loopBlock.emitInstruction(MoveDerefToTypeInstruction(indexthArg, pointerToIndexthArg, -0x08, concat('load type of indexth argument into ', indexthArg.debugName)));
    loopBlock.emitIsOperatorCheck(staticType, indexthArg, what); // actual type check is here
    loopBlock.emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    loopBlock.emitInstruction(DoBlockInstruction(block));
    loopBlock.emitInstruction(LabelInstruction(continueLabel, 'after block'));
    loopBlock.emitInstruction(AddInstruction(pointerToIndexthArg, environment.integer(0x10), pointerToIndexthArg, 'next argument'));
    loopBlock.emitInstruction(SyntheticNestedScopeExitInstruction(loopBlock));
    loopBlock.emitInstruction(JumpInstruction(loopTopLabel, 'return to top of loop'));
    loopBlock.emitInstruction(LabelInstruction(loopBottomLabel, 'after loop'));
    emitInstruction(DoBlockInstruction(loopBlock));
  }
  
  Null emitStoreTypeCheck(Type staticType, Slot lhs, Slot target, String what) {
    CompilationEnvironment environment = environment();
    emitIsOperatorCheck(staticType, lhs, what);
    emitInstruction(MoveInstruction(target, environment.integer(0), concat('clear ', target.debugName)));
    emitInstruction(SetcInstruction(target, concat('store result in ', target.debugName)));
    emitInstruction(SetTypeInstruction(target, environment.intrinsicsLibrary.coreBooleanType));
  }
  
  // Caller should emit static and dynamic type checks on target.
  Slot emitSubroutineCall(Slot target, SlotList arguments) {
    assert(target.staticType.isSubtypeOf(environment().subroutineType), 'cannot call a non-function');
    emitInstruction(CommentInstruction(concat('Call ', target.debugName, ' with ', len(arguments), ' arguments')));
    // xxxx statically check arguments are the right type if the types are known
    if (target is SubroutineSlot) {
      SlotNullable result = (target as SubroutineSlot).subroutine.inline(this, arguments);
      if (result != null) {
        return result;
      }
    }
    Slot thisPointer = environment().intrinsicsLibrary.coreSentinel; // placeholder code
    Slot closurePointer = environment().intrinsicsLibrary.coreSentinel; // placeholder code
    Type returnType = environment().intrinsicsLibrary.coreAnythingType;
    if (target.staticType is AbstractSubroutineType) {
      AbstractSubroutineType subroutineType = target.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    }
    DynamicSlot returnValue = registerDynamicValue(returnType, concat(target.debugName, ' return value'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      emitInstruction(PushInstruction(arguments[argumentIndex], concat('value of argument #', argumentIndex + 1, ' (', arguments[argumentIndex].debugName, ')')));
      emitInstruction(PushTypeInstruction(arguments[argumentIndex], environment(), concat('type of argument #', argumentIndex + 1)));
      argumentIndex -= 1;
    }
    DynamicSlot temporarySlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, 'temporary slot');
    emitInstruction(MoveToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s value'));
    emitInstruction(PinSlotValueInstruction(returnValue));
    emitInstruction(LeaInstruction(temporarySlot, returnValue, false, 'load address of return value\'s value'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 6: pointer to return value slot\'s value')); // (also does some RecordPushes)
    emitInstruction(MoveTypeToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s type'));
    emitInstruction(PinSlotTypeInstruction(returnValue));
    emitInstruction(LeaTypeInstruction(temporarySlot, returnValue, false, 'load address of return value\'s type'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 5: pointer to return value slot\'s type')); // (also does some RecordPushes)
    // TODO: "sub rsp, 8h; align to 16 byte boundary" XXX need to also implement this on callee side
    emitInstruction(SubInstruction(stackFrame().stackPointer, environment().integer(0x20), stackFrame().stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // ("fake" pushes from changing the stack pointer)
    emitInstruction(MoveToSpecificOperandInstruction(r9.bit, thisPointer, true, 'internal argument 4: "this" pointer'));
    //emitInstruction(PinSlotValueInstruction(thisPointer)); // TODO uncomment once we implement this
    emitInstruction(MoveTypeToSpecificOperandInstruction(r8.bit, thisPointer, true, 'internal argument 3: "this" pointer type'));
    //emitInstruction(PinSlotTypeInstruction(thisPointer)); // TODO uncomment once we implement this
    emitInstruction(MoveToSpecificOperandInstruction(rdx.bit, closurePointer, true, 'internal argument 2: closure pointer'));
    //emitInstruction(PinSlotValueInstruction(closurePointer)); // TODO uncomment once we implement this
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, environment().integer(len(arguments)), true, 'internal argument 1: number of actual arguments'));
    emitInstruction(CallInstruction(target, 'jump to subroutine'));
    emitInstruction(UnpinSlotValueInstruction(returnValue));
    emitInstruction(UnpinSlotTypeInstruction(returnValue));
    emitInstruction(AddInstruction(stackFrame().stackPointer, environment().integer(0x20 + 8 * 2 * len(arguments) + 16), stackFrame().stackPointer, 'release shadow space and arguments'));
    emitInstruction(RecordPopsInstruction(len(arguments) * 2 + 6)); // arguments, return value (and type), and shadow space
    return returnValue;
  }

  CompiledNestedScope createErrorHandlerBlock(Slot errorMessage, String what) {
    CompiledScope block = CompiledNestedScope(this, concat(camelCase(what), '$Error'));
    block.emitInstruction(CommentInstruction(concat('Error handling block for ', what)));
    String label = environment().generateLabel(concat(block.labelPrefix(), '$', camelCase(what), '$Ok'));
    Slot printHandle = environment().intrinsicsLibrary.corePrint;
    block.emitInstruction(CommentInstruction(concat(' - print(', errorMessage.debugName, ')')));
    block.emitSubroutineCall(printHandle, [ errorMessage ]);
    Slot exitHandle = environment().intrinsicsLibrary.coreExit;
    Slot failureExitCode = environment().integer(0x01);
    block.emitInstruction(CommentInstruction(concat(' - exit(1)')));
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    return block;
  }

  Null emitTypeCheck(Slot value, Type staticType, Slot errorMessage, String what, Boolean trustSlotStaticType) {
    CompiledNestedScope block = createErrorHandlerBlock(errorMessage, what);
    String continueLabelArg = concat(labelPrefix(), '$', camelCase(what));
    // TODO: xxxx we could also check if we can statically disprove compatibility
    // (or maybe assert that we can't, because if we can why is someone calling us)
    String continueLabel = environment().generateLabel(concat(continueLabelArg, '$TypeMatch'));
    if (!trustSlotStaticType || !value.canStaticallyProveTypeCompatibilityWith(staticType)) {
      emitIsOperatorCheck(staticType, value, what); // actual type check is here
      emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    } else {
      // just check for sentinel (which might be present even if we trust the static type)
      // TODO: slots should track if they might be sentinel, so we can skip even this
      emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, environment().intrinsicsLibrary.coreSentinelType, continueLabel, concat('skip next block if ', value.debugName, ' is not sentinel')));
    }
    emitInstruction(DoBlockInstruction(block));
    emitInstruction(LabelInstruction(continueLabel, 'after block'));
  }

  Null emitBlock(CompiledNestedScope block) {
    emitInstruction(DoBlockInstruction(block));
  }

  // runs block if a != b
  Null emitConditionalBlock(CompiledNestedScope block, CompiledNestedScopeNullable elseBlock, Slot a, Slot b, String what, String comment) {
    String labelElse;
    String labelEnd = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$continuation'));
    if (elseBlock == null) {
      labelElse = labelEnd;
    } else {
      labelElse = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$else'));
    }
    emitInstruction(JumpIfEqualInstruction(a, b, labelElse, comment));
    emitInstruction(DoBlockInstruction(block));
    if (elseBlock != null) {
      emitInstruction(JumpInstruction(labelEnd, concat('jump past else part of ', what)));
      emitInstruction(LabelInstruction(labelElse, concat('else of ', what)));
      emitInstruction(DoBlockInstruction(elseBlock!));
    }
    emitInstruction(LabelInstruction(labelEnd, concat('end of ', what)));
  }

  // jumps to label if a == b
  Null emitConditionalJump(String label, Slot a, Slot b, String comment) {
    emitInstruction(JumpIfEqualInstruction(a, b, label, comment));
  }
  
  Null emitSubscriptEvaluation(Slot list, Slot index, Slot target) {
    String labelBase = concat(labelPrefix(), '$subscript');
    String boundsErrorLabel = environment().generateLabel(concat(labelBase, '$boundsError'));
    String continueLabel = environment().generateLabel(concat(labelBase, '$inBounds'));
    CompiledNestedScope boundsErrorBlock = createErrorHandlerBlock(environment().intrinsicsLibrary.boundsFailureMessage, 'subscript bounds error');
    if (list is VarArgsParameterSlot) {
      emitInstruction(ConditionalJumpInstruction(index, (stackFrame() as CompiledSubroutine).parameterCount, ccGreaterThanOrEqual, boundsErrorLabel, 'index out of range (too high)'));
      emitInstruction(ConditionalJumpInstruction(index, environment().integer(0), ccGreaterThanOrEqual, continueLabel, 'index not out of range (not negative)'));
      emitInstruction(LabelInstruction(boundsErrorLabel, 'invalid index'));
      emitInstruction(DoBlockInstruction(boundsErrorBlock)); // execution never leaves this block
      emitInstruction(LabelInstruction(continueLabel, 'valid index'));
      Slot baseAddressSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, 'base address of varargs');
      emitInstruction(LeaInstruction(baseAddressSlot, (list as VarArgsParameterSlot).baseAddress(environment().intrinsicsLibrary.coreIntegerType), true, 'base address of varargs'));
      Slot shiftedIndex = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, 'index into list * 16');
      Slot resultPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, 'pointer to value (and type, later)');
      emitInstruction(ShiftInstruction('shl', index, environment().integer(4), shiftedIndex, 'multiply by 8*2'));
      emitInstruction(AddInstruction(baseAddressSlot, shiftedIndex, resultPointer, 'get pointer to value'));
      emitInstruction(MoveDerefInstruction(target, resultPointer, 0, 'store value'));
      emitInstruction(MoveDerefToTypeInstruction(target, resultPointer, -0x08, 'store type'));
      emitIncref(target);
    } else {
      // TODO: implement
      throw('list subscript not implemented for this list type');
    }
  }



  // COMPILER PHASES

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepare(this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    SlotManager manager = stackFrame().slotManager;
    manager.enterNestedScope(this, block);
    for (instruction in instructions) {
      instruction.generateAssemblerBlock(block, manager);
      manager.endOfInstruction();
    }
    manager.exitNestedScope(this);
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
    prepareSlots();
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', name, ':', className, '@', internalObjectId, '>');
  }
}

class CompiledNestedScope extends CompiledScope {
  String labelPrefix() {
    return concat(parent!.labelPrefix(), '$', name);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    block.indent(super.generateAssemblerBlock);
  }

  Null constructor(CompiledScope parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledStackFrameScope extends CompiledScope {
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  Null prepareInstructions() {
    // xxx add string decrefs instruction
    super.prepareInstructions();
  }

  CompiledNestedScopeList compiledNestedScopes = []:CompiledNestedScope;

  Null registerNestedScope(CompiledNestedScope nestedScope) {
    append(compiledNestedScopes, nestedScope);
  }

  DynamicSlotList slots = []:DynamicSlot;

  DynamicSlot registerSlot(DynamicSlot slot) {
    append(slots, slot);
    return slot;
  }

  SlotManager slotManager;
  RegisterSlot stackPointer;
  RegisterSlot stackFramePointer;

  Null prepareSlots() {
    super.prepareSlots();
    stackPointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rsp, 'stack pointer');
    stackFramePointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rbp, 'stack frame pointer');
  }

  Null allocateSlots(Assembler assembler) {
    Slot sentinel = environment().intrinsicsLibrary.coreSentinel;
    assert((sentinel.value() as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    assert((sentinel.dynamicType() as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    for (slot in slots) {
      if (slot.referencedFromMultipleStackFrames) {
        assert(slot.homeScope is CompiledLibrary, 'closures not implemented');
        assert(slot.name != null, concat('slot has no name: ', slot));
        String valueLabel = environment().generateLabel(concat(slot.name, 'Value'));
        String typeLabel = environment().generateLabel(concat(slot.name, 'Type'));
        slot.initialize(DereferenceLabelOperand(valueLabel), DereferenceLabelOperand(typeLabel));
        assembler.addBss(valueLabel, 4, slot.debugName);
        assembler.addBss(typeLabel, 4, concat('dynamic type of ', slot.debugName));
      } else {
        if (!slot.initializeScheduled) { // e.g. parameter count
          slot.initialize(sentinel.value(), sentinel.dynamicType());
        }
      }
    }
  }

  Null generatePrologAssemblerBlock(AssemblerBlock block) {
    block.addComment('Prolog');
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    for (register in registers) {
      block.addCode('push', [register], 'save non-volatile registers');
    }
    Integer stackSize = slotManager.stackSize();
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      // TODO: if stackSize > 8KB (0x2000), call __chkstk__
      assert(stackSize < 0x2000, 'need to implement calling __chkstk__');
      block.addCode('sub', [rsp, hex8(stackSize)], 'allocate space for stack');
    }
    block.addCode('lea', [rbp, concat('qword ptr [rsp + ', hex8(stackSize + len(registers) * 0x08), ']')], 'set up frame pointer');
    assert(stackSize == slotManager.stackSize(), concat('prolog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    block.addComment('Epilog');
    Integer stackSize = slotManager.stackSize();
    if (stackSize > 0) {
      block.addCode('add', [rsp, hex8(stackSize)], 'free space for stack');
    }
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    Integer index = len(registers);
    while (index > 0) {
      index -= 1;
      block.addCode('pop', [registers[index]], 'restore non-volatile registers');
    }
    assert(stackSize == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null initializeParameters() {
    // e.g. slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
  }

  Null clearRegisters(AssemblerBlock subblock) {
    // e.g. slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    slotManager = SlotManager(environment().intrinsicsLibrary.coreStringType);
    slotManager.pin(stackPointer);
    slotManager.pin(stackFramePointer);
    AssemblerBlock subblock = block.createBlock();
    initializeParameters();
    super.generateAssemblerBlock(subblock);
    slotManager.enterNestedScope(this, subblock);
    clearRegisters(subblock);
    slotManager.exitNestedScope(this);
    generatePrologAssemblerBlock(block);
    Integer oss = slotManager.stackSize();
    block.addBlock(subblock);
    generateEpilogAssemblerBlock(block);
    assert(oss == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', oss, ' now is ', slotManager.stackSize(), ')'));
    slotManager.dispose();
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineTypeWithSpecificParameters type; // subroutine signature
  String label;
  String epilogLabel;

  // The parameter that contains a pointer to the return value.
  Slot returnValuePointer;
  // The parameter that contains a pointer to the return value type.
  Slot returnValueTypePointer;

  String labelPrefix() {
    return concat('func$', name);
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    return null;
  }

  // This is called from other scopes (where we need to emit the instructions),
  // hence the scope argument.
  Null emitReturnFrom(CompiledScope scope, Slot value) {
    // xxxx verify the type of value statically
    scope.emitTypeCheck(value, type.returnType, environment().intrinsicsLibrary.returnValueTypeCheckFailureMessage as Slot, concat(name, ' return value'), true);
    scope.emitInstruction(MoveToDerefInstruction(returnValuePointer, value, 0, concat(name, ' return value')));
    scope.emitInstruction(MoveTypeToDerefInstruction(returnValueTypePointer, value, 0, environment(), concat('type of ', name, ' return value')));
    scope.emitIncref(value);
    scope.emitInstruction(SyntheticNestedAllScopesExitInstruction(scope));
    scope.emitInstruction(JumpInstruction(epilogLabel, 'return'));
  }

  DynamicSlot parameterCount;
  ImmediateDataLabelSlot nameConstant;

  Null prepareSlots() {
    label = environment().generateLabel(labelPrefix());
    epilogLabel = environment().generateLabel(concat(labelPrefix(), '$epilog'));
    returnValuePointer = ReturnValuePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value of ', name));
    returnValueTypePointer = ReturnValueTypePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value type of ', name));
    parameterCount = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, concat('parameter count of ', name));
    parameterCount.willInitialize();
    nameConstant = environment().registerStringConstant(concat(label, '$annotation'), name, __LINE__, __COL__, __FILE__) as ImmediateDataLabelSlot;
    super.prepareSlots();
  }

  Null prepareInstructions() {
    if (len(instructions) == 0 || !(last(instructions) is JumpInstruction)) {
      emitInstruction(CommentInstruction(concat('Implicit return from ', name)));
      emitReturnFrom(this, environment().intrinsicsLibrary.coreNull);
    }
    super.prepareInstructions();
  }

  Null initializeParameters() {
    slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
  }

  Null clearRegisters(AssemblerBlock subblock) {
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    Integer stackSize = slotManager.stackSize();
    block.addLabel(epilogLabel, null);
    assert(stackSize == slotManager.stackSize(), concat('addCode changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.enterNestedScope(this, block);
    assert(stackSize == slotManager.stackSize(), concat('enterNestedScope changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.read(returnValuePointer, rax.bit, 'report address of return value').release();
    assert(stackSize == slotManager.stackSize(), concat('read into rax changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.exitNestedScope(this);
    assert(stackSize == slotManager.stackSize(), concat('exitNestedScope changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
    super.generateEpilogAssemblerBlock(block);
    block.addCode('ret', [], 'return from subroutine');
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock block = assembler.createBlock();
    generateAssemblerBlock(block);
    assembler.addLabeledBlock(label, block, name, nameConstant.label);
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class CompiledSubroutineWithSpecificParameters extends CompiledSubroutine {
  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = ParameterSlot(type, position, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitParameterChecks(SlotList parameters) {
    // xxxx verify the types statically
    // check for parameter count
    emitInstruction(CommentInstruction('Check parameter count'));
    Slot expectedParamCountValue = environment().integer(len(parameters));
    CompiledNestedScope block = createErrorHandlerBlock(
      environment().intrinsicsLibrary.parameterCountCheckFailureMessage,
      'parameter count',
    );
    emitConditionalBlock(block, null, parameterCount, expectedParamCountValue, 'parameter count check', 'check number of parameters is as expected');
    Integer index = 0;
    for (parameter in parameters) {
      emitInstruction(CommentInstruction(concat('Check type of parameter ', index, ', ', parameter.debugName, ' (expecting ', parameter.staticType, ')')));
      emitTypeCheck(parameter, parameter.staticType, environment().intrinsicsLibrary.parameterTypeCheckFailureMessage, parameter.debugName, false);
      index += 1;
    }
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class CompiledVarArgsSubroutine extends CompiledSubroutine {
  Slot registerVarArgsParameter(String name, Type type) {
    ReadOnlyListType listType = createOrFindReadOnlyListType(environment(), type);
    listType.markConstructed();
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter name');
    Slot slot = VarArgsParameterSlot(listType, parameterCount, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitVarArgsParameterChecks(Type parameterType, VarArgsParameterSlot varargs) {
    // xxxx verify the types statically
    CompiledNestedScope block = createErrorHandlerBlock(environment().intrinsicsLibrary.parameterTypeCheckFailureMessage, 'vararg types');
    doIfVarArgsTypeMismatch(parameterType, varargs, concat(labelPrefix(), '$varargTypeChecks'), block, 'vararg types');
  }

  Null constructor(CompiledScope parentArg, SubroutineTypeWithVarArgs signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters {
  SlotList parameters;

  StringList parameterDescriptions() {
    return []:String;
  }

  RegisterSlot arg4;
  RegisterSlot arg3;
  RegisterSlot arg2;
  RegisterSlot arg1;

  Null prepareSlots() {
    super.prepareSlots();
    arg4 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, r9, 'x64 calling convention arg #4');
    arg3 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, r8, 'x64 calling convention arg #3');
    arg2 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rdx, 'x64 calling convention arg #2');
    arg1 = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rcx, 'x64 calling convention arg #1');
  }

  // used to generate the instructions for the subroutine
  Null generateInstructions() { }

  Null prepareInstructions() {
    parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    StringList descriptions = parameterDescriptions();
    assert(len(descriptions) == len(signature.parameterTypes), concat(className, '.parameterDescriptions() returned an unexpected number of descriptions (descriptions were ', descriptions, '; parameter types were ', signature.parameterTypes, ')'));
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, descriptions[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    generateInstructions();
    super.prepareInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, SubroutineTypeWithSpecificParameters signature, String name) { 
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['message to print to console'];
  }

  Null generateInstructions() {
    DynamicSlot stdHandle = registerDynamicValue((parent! as CompiledIntrinsicsLibrary).coreSystemType, 'stdHandle, out param of GetStdHandle');
    DynamicSlot lpNumberOfCharsWritten = registerDynamicValue((parent! as CompiledIntrinsicsLibrary).coreSystemType, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    Slot message = parameters[0];
    emitInstruction(CommentInstruction('Calling GetStdHandle'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, environment().integer(-11), true, 'argument #1: STD_OUTPUT_HANDLE'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'GetStdHandle', stdHandle, 'handle returned in rax'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20), stackPointer, 'release shadow space'));
    emitInstruction(CommentInstruction('Calling WriteConsoleA'));
    emitInstruction(PushInstruction(environment().integer(0), 'argument #5: Reserved, must be NULL (lpReserved)'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // shadow space
    emitInstruction(MoveToSpecificOperandInstruction(memory, lpNumberOfCharsWritten, false, 'allocate memory for lpNumberOfCharsWritten'));
    emitInstruction(PinSlotValueInstruction(lpNumberOfCharsWritten));
    emitInstruction(PinRegisterSlotInstruction(arg4));
    emitInstruction(LeaInstruction(arg4, lpNumberOfCharsWritten, false, 'argument #4: Number of characters written (lpNumberOfCharsWritten)'));
    emitInstruction(PinRegisterSlotInstruction(arg3));
    emitInstruction(MoveDerefInstruction(arg3, message, 0x08, 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure'));
    emitInstruction(PinRegisterSlotInstruction(arg2));
    emitInstruction(AddInstruction(message, environment().integer(0x10), arg2, 'argument #2: Pointer to buffer to write (*lpBuffer)'));
    emitInstruction(PinRegisterSlotInstruction(arg1));
    emitInstruction(MoveInstruction(arg1, stdHandle, 'argument #1: Handle from GetStdHandle (hConsoleOutput)'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'WriteConsoleA', null, 'returns boolean representing success in rax'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x28), stackPointer, 'release shadow space'));
    emitInstruction(RecordPopsInstruction(5)); // shadow space and lpReserved
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [parentArg.coreStringType]:Type),
      '__print',
    );
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['exit code parameter'];
  }

  Null generateInstructions() {
    Slot exitCode = parameters[0];
    emitInstruction(CommentInstruction('Calling ExitProcess'));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, exitCode, true, 'exit code'));
    emitInstruction(CallSystemInstruction('kernel32.lib', 'ExitProcess', null, 'process should terminate at this point'));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20), stackPointer, 'release shadow space, just in case'));
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, [ parentArg.coreIntegerType ]:Type),
      'exit',
    );
  }
}

class BuiltInLenSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['list'];
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 1 && arguments[0] is VarArgsParameterSlot) {
      return (arguments[0] as VarArgsParameterSlot).length();
    }
    // TODO: implement inline len for non-varargs
    assert(false, 'non-inline len() not yet implemented because Lists aren\'t yet implemented.');
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    // TODO: implement non-inline len()
    emitInstruction(CommentInstruction('TODO: implement \'len\' function'));
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ createOrFindReadOnlyListType(parentArg.environment(), parentArg.coreWhateverType) ]:Type,
      ),
      'len',
    );
  }
}

class BuiltInDebuggerSubroutine extends BuiltInSubroutine {
  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 0) {
      scope.emitInstruction(Interrupt3Instruction());
      return environment().intrinsicsLibrary.coreNull;
    }
    assert(false, 'non-inline debugger() not yet implemented');
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    emitInstruction(Interrupt3Instruction());
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        []:Type,
      ),
      '__debugger',
    );
  }
}

class CompilerIntrinsic extends BuiltInSubroutine {
  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    abstract();
  }

  Boolean verifyArguments(SlotList arguments, TypeList parameters) {
    assert(len(parameters) == len(arguments), 'unexpected number of arguments');
    Integer index = 0;
    while (index < len(arguments)) {
      assert(
        arguments[index].staticType.isSubtypeOf(parameters[index]),
        concat('argument ', index, ' has unexpected type (wanted ', arguments[index].staticType, ' but got ', parameters[index], ')'),
      );
      index += 1;
    }
    return true;
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    assert(verifyArguments(arguments, signature.parameterTypes), 'unexpected arguments');
    Slot result = inlineBody(scope, arguments);
    assert(result.staticType == signature.returnType, concat(this, ' returned slot of wrong type (expected ', signature.returnType, ' but got ', result.staticType, ')'));
    return result;
  }
}

class BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    Slot returnValue = scope.registerDynamicValue(
      environment().intrinsicsLibrary.coreIntegerType,
      concat('dereferenced ', arguments[0].debugName),
    );

    scope.emitInstruction(MoveDerefInstruction(returnValue, arguments[0], 0, 'dereference first argument of __readFromAddress'));
    scope.emitInstruction(SetTypeInstruction(returnValue, returnValue.staticType));
    return returnValue;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType ]:Type,
      ),
      '__readFromAddress',
    );
  }
}

class BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address', 'value'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    scope.emitInstruction(MoveToDerefInstruction(arguments[0], arguments[1], 0, '__writeToAddress'));
    return scope.environment().intrinsicsLibrary.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__writeToAddress',
    );
  }
}

class GenericSystemCallSubroutine extends CompiledSubroutineWithSpecificParameters {
  StringList parameterNames;
  String externalName;
  String library;

  Null prepareInstructions() {
    SlotList parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, parameterNames[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    emitInstruction(CommentInstruction(concat('Calling ', externalName)));
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // shadow space
    index -= 1;
    while (index > 3) {
      emitInstruction(PushInstruction(parameters[index], concat('argument #', index + 1)));
      index -= 1;
    }
    Register64OperandList parameterRegisters = [rcx, rdx, r8, r9];
    while (index >= 0) {
      emitInstruction(MoveToSpecificOperandInstruction(parameterRegisters[index].bit, parameters[index], true, concat('argument #', index + 1)));
      index -= 1;
    }
    Slot returnValue = registerDynamicValue(type.returnType, concat('return value of ', externalName, ' system call'));
    emitInstruction(CallSystemInstruction(library, externalName, returnValue, concat('calls ', externalName, ' from ', library)));
    emitInstruction(SetTypeInstruction(returnValue, type.returnType));
    emitInstruction(AddInstruction(stackPointer, environment().integer(0x20 + 0x08 * max(0, len(parameters) - 4)), stackPointer, 'release shadow space and arguments if there were more than four'));
    emitInstruction(RecordPopsInstruction(4 + max(0, len(parameters) - 4))); // shadow space and any arguments that didn't fit in the registers
    emitReturnFrom(this, returnValue);
    super.prepareInstructions();
  }

  Null constructor(CompiledScope parentArg, Type returnTypeArg, TypeList argumentTypesArg, StringList parameterNamesArg, String libraryArg, String externalNameArg, String internalNameArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), returnTypeArg, argumentTypesArg),
      internalNameArg,
    );
    parameterNames = parameterNamesArg;
    library = libraryArg;
    externalName = externalNameArg;
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  String labelPrefix() {
    return camelCase(name);
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable result = super.lookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.lookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(!environment().isCompoundType(type.name), 'tried to declare a type that ends with a generic suffix');
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = library.lookupType(name);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    block.addBlankLine();
    block.addComment(name);
    block.addComment(stringTimes('=', len(scalarValues(name))));
    super.generateAssemblerBlock(block);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    compilationEnvironment = compilationEnvironmentArg;
    super.constructor(null, nameArg);
    if (!(this is CompiledIntrinsicsLibrary)) {
      importLibrary(compilationEnvironment.intrinsicsLibrary);
    }
    CompiledLibraryNullable runtimeLibrary = compilationEnvironment.runtimeLibrary;
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledIntrinsicsLibrary extends CompiledLibrary {
  String labelPrefix() {
    return 'intrinsics';
  }

  AnythingType coreAnythingType;
  WhateverType coreWhateverType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;
  SentinelType coreSentinelType;

  ImmediateSlot coreSentinel;
  ImmediateSlot coreNull;
  ImmediateSlot coreTrue;
  ImmediateSlot coreFalse;

  Slot corePrint; // actually __print; the real print is in the rtl
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;
  Slot returnValueTypeCheckFailureMessage;
  Slot operandTypeCheckFailureMessage;
  Slot asOperatorFailureMessage;
  Slot boundsFailureMessage;

  Null prepareSlots() {
    // nope, not doing it at the usual time!
    // we'll do it after we build intrinsicsLibrary instead
    // see below (mid way through generateScopes).
  }

  Null generateScopes() {
    CompilationEnvironment environment = environment();
    // internal types
    coreClassType = RootClassType(environment);
    coreClosureType = ClosureType(environment);
    coreSystemType = SystemType(environment);
    coreSentinelType = SentinelType(environment);
    // built-in types
    coreAnythingType = AnythingType(environment);
    declareType(coreAnythingType);
    coreWhateverType = WhateverType(environment);
    declareType(coreWhateverType);
    coreSentinel = ImmediateIntegerSlot(coreSentinelType, 0, 'sentinel slot');
    coreSentinelType.markConstructed();
    coreNullType = NullType(environment);
    declareType(coreNullType);
    coreNull = registerNumericConstant('null', 0x00, coreNullType);
    coreBooleanType = BooleanType(environment);
    declareType(coreBooleanType);
    coreFalse = registerNumericConstant('false', 0x00, coreBooleanType);
    coreTrue = registerNumericConstant('true', 0x01, coreBooleanType);
    coreIntegerType = IntegerType(environment);
    declareType(coreIntegerType);
    coreStringType = StringType(environment);
    declareType(coreStringType);

    // now that we have the types ready, set up the slots (like stackFramePointer)
    // which are used by the built-in functions
    super.prepareSlots();

    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));
    // built-in functions not used from compiler
    registerSubroutine(BuiltInLenSubroutine(this));
    registerSubroutine(BuiltInDebuggerSubroutine(this));
    // intrinsics (functions that only work when inlined)
    registerSubroutine(BuiltInReadFromAddressIntrinsic(this));
    registerSubroutine(BuiltInWriteToAddressIntrinsic(this));
    // messages
    parameterCountCheckFailureMessage = environment.registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = environment.registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    returnValueTypeCheckFailureMessage = environment.registerStringConstant(
      'returnValueTypeCheckFailureMessage',
      'error: type mismatch for function return value, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    operandTypeCheckFailureMessage = environment.registerStringConstant(
      'operandTypeCheckFailureMessage',
      'error: type mismatch for operand, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    asOperatorFailureMessage = environment.registerStringConstant(
      'asOperatorFailureMessage',
      'error: type mismatch for as operator, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    boundsFailureMessage = environment.registerStringConstant(
      'boundsFailureMessage',
      'error: subscript index out of range (%d is not in range %d..%d)\n',
      __LINE__, __COL__, __FILE__,
    );
  }
}