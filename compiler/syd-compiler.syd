import 'core.syd';
import 'syd-operands.syd';
import 'syd-assembler.syd';
import 'syd-slots.syd';
import 'syd-slot-manager.syd';
import 'syd-types.syd';
import 'syd-instructions.syd';
import 'syd-utils.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+60h : rbp+50h : (local variable from previous stack frame)
     *                      (maybe arg 2 here)
     *  rsp+58h : rbp+48h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+50h : rbp+40h : type of arg 1
     *  rsp+48h : rbp+38h : pointer to return value
     *  rsp+40h : rbp+30h : pointer to return value type
     *  rsp+38h : rbp+28h : "shadow r9", actually used as scratch space for class constructor return value
     *  rsp+30h : rbp+20h : "shadow r8", actually used as scratch space for class constructor return type
     *  rsp+28h : rbp+18h : "shadow rdx", actually used as scratch space for tail recursion code address
     *  rsp+20h : rbp+10h : shadow rcx
     *  rsp+18h : rbp +8h : return address
     *  rsp+10h : rbp     : saved non-volatile register rbp                      
                            (maybe other saved registers here)
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */

     // on the heap, a 16 byte entry has the value second, and the type 8 bytes "earlier" (heap grows up)
     //    so if the value is at p, type at p-0x08
     // on the stack, a 16 byte entry has the value first, then the type 8 bytes "later" (stack grows down)
     //    so if the value is at p, type at p-0x08


// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================
fwdclass Constant(String, StringList, StringNullableList) extends Object;
fwdclass ClassType(TypeRegistry, String, TypeNullable) extends Type;
fwdclass CompilationEnvironment extends TypeRegistry;
fwdclass CompiledScope(SlotContextNullable, String) extends SlotContext;
fwdclass CompiledNestedScope(CompiledScope, String) extends CompiledScope;
fwdclass CompiledStackFrameScope(CompiledScopeNullable, String) extends CompiledScope;
fwdclass CompiledSubroutine(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends CompiledStackFrameScope;
fwdclass CompiledLibrary(CompilationEnvironment, String) extends CompiledStackFrameScope;
fwdclass CompiledIntrinsicsLibrary(CompilationEnvironment, String) extends CompiledLibrary;
fwdclass Instruction extends Object;
fwdclass CompiledSubroutineWithSpecificParameters(CompiledScope, SubroutineTypeWithSpecificParameters, String, Null) extends CompiledSubroutine;
fwdclass CompiledGeneratedConstructorSubroutine extends CompiledSubroutine;
fwdclass BuiltInSubroutine(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends CompiledSubroutineWithSpecificParameters;
fwdclass BuiltInLenSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInDebuggerSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass MemberDescription(String, Type, Boolean) extends Object;
fwdclass BuiltInGetterMethod(CompiledIntrinsicsLibrary, ClassType, MemberDescription) extends BuiltInSubroutine;
fwdclass BuiltInSetterMethod(CompiledIntrinsicsLibrary, ClassType, MemberDescription) extends BuiltInSubroutine;
fwdclass CompilerIntrinsic(CompiledIntrinsicsLibrary, SubroutineTypeWithSpecificParameters, String, Null) extends BuiltInSubroutine;
fwdclass BuiltInReadFromAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass BuiltInWriteToAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass CompiledVarArgsSubroutine extends CompiledSubroutine;
fwdclass SubroutineSlot(CompiledSubroutine, Boolean) extends CompileTimeLabelSlot;
fwdclass CompiledInternalProcedure(CompiledScope, String) extends CompiledStackFrameScope;
fwdclass CompiledInternalProcedureSlot(CompiledInternalProcedure) extends CompileTimeLabelSlot;
fwdclass ConstantSlot(Type, Constant, String) extends ImmediateDataLabelSlot;
fwdclass IdentifierEntity extends Object;

// CompiledScope
fwdclassprop CompiledScopeNullable CompiledScope.parent;
fwdclassprop String CompiledScope.name;
fwdclassprop Set CompiledScope.references;
fwdclassprop Set CompiledScope.subscopes;
fwdclassprop CompilationEnvironmentFunction CompiledScope.environment;
fwdclassprop CompiledStackFrameScopeFunction CompiledScope.stackFrame;
fwdclassprop CompiledLibraryFunction CompiledScope.globalScope;
fwdclassprop NullFunction CompiledScope.prepareSlots;
fwdclassprop IdentifierEntityNullableFunction CompiledScope.internalLookupIdentifier;
fwdclassprop NullFunction CompiledScope.addRemainingReferences;
fwdclassprop NullFunction CompiledScope.prepareInstructions;
fwdclassprop NullFunction CompiledScope.generateAssemblerBlock;
fwdclassprop NullFunction CompiledScope.emitInstruction;
fwdclassprop DynamicSlotFunction CompiledScope.registerDynamicValue;
fwdclassprop SubroutineSlotFunction CompiledScope.registerSubroutine;
fwdclassprop SlotFunction CompiledScope.emitSubroutineCall;
fwdclassprop NullFunction CompiledScope.registerNestedScope;
fwdclassprop StringFunction CompiledScope.labelPrefix;
fwdclassprop DynamicSlotFunction CompiledScope.registerSlot;
fwdclassprop NullFunction CompiledScope.emitIsOperatorCheck;
fwdclassprop NullFunction CompiledScope.emitBlock;
fwdclassprop NullFunction CompiledScope.emitIncref;
fwdclassprop SlotFunction CompiledScope.lookupIntrinsic;
fwdclassprop ClassTypeFunction CompiledScope.lookupIntrinsicClass;

// CompiledStackFrameScope
fwdclassprop Boolean CompiledStackFrameScope.isUsed;
fwdclassprop NullFunction CompiledStackFrameScope.markUsed;
fwdclassprop NullFunction CompiledStackFrameScope.declareType;
fwdclassprop NullFunction CompiledStackFrameScope.allocateSlots;
fwdclassprop SlotManager CompiledStackFrameScope.slotManager;
fwdclassprop NullFunction CompiledStackFrameScope.generateAssembler;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackFramePointer;
fwdclassprop RegisterSlot CompiledStackFrameScope.stackPointer;

// CompiledSubroutine
fwdclassprop String CompiledSubroutine.label;
fwdclassprop String CompiledSubroutine.functionPointerLabel;
fwdclassprop String CompiledSubroutine.epilogLabel;
fwdclassprop AbstractSubroutineTypeWithSpecificParameters CompiledSubroutine.type;
fwdclassprop SlotNullableFunction CompiledSubroutine.inline;
fwdclassprop DynamicSlot CompiledSubroutine.parameterCount;
fwdclassprop NullFunction CompiledSubroutine.adoptSlot;

// CompiledLibrary
fwdclassprop CompilationEnvironment CompiledLibrary.compilationEnvironment;
fwdclassprop TypeNullableFunction CompiledLibrary.lookupType;

// CompiledIntrinsicsLibrary
fwdclassprop BooleanType CompiledIntrinsicsLibrary.coreBooleanType;
fwdclassprop IntegerType CompiledIntrinsicsLibrary.coreIntegerType;
fwdclassprop SentinelType CompiledIntrinsicsLibrary.coreSentinelType;
fwdclassprop StringType CompiledIntrinsicsLibrary.coreStringType;
fwdclassprop NullType CompiledIntrinsicsLibrary.coreNullType;
fwdclassprop WhateverType CompiledIntrinsicsLibrary.coreWhateverType;
fwdclassprop SystemType CompiledIntrinsicsLibrary.coreSystemType;
fwdclassprop SubroutineCodeAddressType CompiledIntrinsicsLibrary.coreSubroutineCodeAddressType;
fwdclassprop GarbageCollectableType CompiledIntrinsicsLibrary.coreGarbageCollectableType;
fwdclassprop AnythingType CompiledIntrinsicsLibrary.coreAnythingType;
fwdclassprop NullFunction CompiledIntrinsicsLibrary.generateScopes;
fwdclassprop SubroutineSlot CompiledIntrinsicsLibrary.coreError;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreSentinel;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreNull;
fwdclassprop ImmediateSlot CompiledIntrinsicsLibrary.coreFalse;
fwdclassprop Slot CompiledIntrinsicsLibrary.boundsFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.returnValueTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterTypeCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.parameterCountCheckFailureMessage;
fwdclassprop Slot CompiledIntrinsicsLibrary.assignToMethodMessage;
fwdclassprop CompiledInternalProcedureSlotFunction CompiledIntrinsicsLibrary.lookupInternalProcedureSlot;

// CompilationEnvironment
fwdclassprop CompiledIntrinsicsLibrary CompilationEnvironment.intrinsicsLibrary;
fwdclassprop StringFunction CompilationEnvironment.generateLabel;
fwdclassprop SlotFunction CompilationEnvironment.integer;

// SubroutineSlot
fwdclassprop CompiledSubroutine SubroutineSlot.subroutine;

// CompiledInternalProcedure
fwdclassprop TypeFunction CompiledInternalProcedure.type;

// CompiledInternalProcedureSlot
fwdclassprop CompiledInternalProcedure CompiledInternalProcedureSlot.compiledInternalProcedure;

// ConstantSlot
fwdclassprop Constant ConstantSlot.constant;

// ClassType
fwdclassprop NullFunction ClassType.propagateNeedsMethodsFor;
fwdclassprop NullFunction ClassType.assignIndicies;
fwdclassprop NullFunction ClassType.populateMembers;
fwdclassprop Map ClassType.members;
fwdclassprop NullFunction ClassType.generateVmt;
fwdclassprop String ClassType.vmtLabel;
fwdclassprop Set ClassType.subtypes;
fwdclassprop SubroutineSlot ClassType.constructorSubroutine;

// MemberDescription
fwdclassprop IntegerNullable MemberDescription.fieldIndex;
fwdclassprop IntegerNullable MemberDescription.methodsIndex;
fwdclassprop String MemberDescription.name;
fwdclassprop Type MemberDescription.staticType;
fwdclassprop Boolean MemberDescription.isField;
fwdclassprop Boolean MemberDescription.needsField;
fwdclassprop Boolean MemberDescription.needsMethods;
fwdclassprop CompiledSubroutine MemberDescription.methodImplementation;
fwdclassprop BooleanFunction MemberDescription.isDefined;

// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class Constant extends Object {
  String label;
  StringList data;
  StringNullableList comments;

  Boolean isUsed = false;

  Null markUsed() {
    isUsed = true;
  }

  Null constructor(String labelArg, StringList dataArg, StringNullableList commentsArg) {
    super.constructor();
    label = labelArg;
    data = dataArg;
    comments = commentsArg;
  }
}

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Slot integer(Integer value) {
    assert(intrinsicsLibrary.coreIntegerType.isConstructed, 'integer caller must call IntegerType.isConstructed');
    return ImmediateIntegerSlot(intrinsicsLibrary.coreIntegerType, value, concat(hex(value), ' (integer)'));
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  CompiledIntrinsicsLibrary intrinsicsLibrary;

  Map stringAtomTable = Map(); // String -> Constant
  ConstantList constants = []:Constant;

  ConstantSlot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    ConstantNullable maybeConstant = stringAtomTable.get(value) as ConstantNullable;
    if (maybeConstant == null) {
      SourceLocation source = SourceLocation(line, col, file);
      String label = generateLabel(labelBase);
      // TODO: length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
      StringList data = ['dq -01h', concat('dq ', len(scalarValues(value)))]:String;
      StringNullableList comments = ['String constant (reference count)', 'Length']:StringNullable;
      if (value != '') {
        append(data, concat('db ', stringLiteral(value)));
        append(comments, concat(source));
        Integer padding = 8 - len(scalarValues(value)) % 8;
        if (padding > 0) {
          StringList buffer = []:String;
          append(buffer, 'db ');
          while (padding > 0) {
            append(buffer, '00h');
            if (padding > 1) {
              append(buffer, ', ');
            }
            padding -= 1;
          }
          append(data, joinList(buffer));
          append(comments, 'padding to align to 8-byte boundary');
        }
      }
      maybeConstant = Constant(label, data, comments);
      stringAtomTable.set(value, maybeConstant);
      append(constants, maybeConstant);
      assert(intrinsicsLibrary.coreStringType.isConstructed, 'caller of registerStringConstant must markConstructed string type');
    }
    return ConstantSlot(intrinsicsLibrary.coreStringType, maybeConstant!, /* debugName: */ labelBase);
  }

  Map dynamicDispatchAtomTable = Map(); // String -> Integer
  Integer atomizeForDynamicDispatch(String identifier) {
    if (dynamicDispatchAtomTable.get(identifier) != null) {
      return dynamicDispatchAtomTable.get(identifier) as Integer;
    }
    dynamicDispatchAtomTable.set(identifier, dynamicDispatchAtomTable.length);
    return dynamicDispatchAtomTable.length - 1;
  }
  Boolean neededForDynamicDispatch(String identifier) {
    return dynamicDispatchAtomTable.get(identifier) != null;
  }

  CompiledLibraryNullable runtimeLibrary = null; 

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
  }

  Null defineLibrary(String filename, CompiledLibrary library) { 
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
    append(libraryNames, filename);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is CompiledLibrary, 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  CompiledLibrary getLibrary(String filename) { 
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  Null setRuntimeLibrary(CompiledLibrary runtimeLibraryArg) { 
    runtimeLibrary = runtimeLibraryArg;
  }

  String errorIntrinsicName = '_error';
  String exitIntrinsicName = 'exit';
  String freeIntrinsicName = '_free';
  String listConstructorIntrinsicName = '_listConstructor';
  String classAllocatorIntrinsicName = '_classAllocator';
  String appendIntrinsicName = 'append';
  String iteratorIntrinsicName = 'iterator';
  String currentIntrinsicName = 'current';
  String nextIntrinsicName = 'next';
  String createMethodPointerIntrinsicName = '_createMethodPointer';
  String dynamicLookupIntrinsicName = '_dynamicLookup';

  // use CompiledScope.lookupIntrinsic() to reference this
  Map intrinsics = Map(); // String -> SubroutineSlot

  Null registerIntrinsic(SubroutineSlot intrinsic) {
    intrinsics.set(intrinsic.subroutine.name, intrinsic);
  }

  String coreClassTypeIntrinsicName = '__Object';

  // use CompiledScope.lookupIntrinsicClass() to reference this
  Map classIntrinsics = Map(); // String -> ClassType

  Null registerClassIntrinsic(ClassType intrinsic) {
    classIntrinsics.set(intrinsic.name, intrinsic);
  }

  Boolean prepareInstructionsHappened = false;

  Null markUsedScopesFor(CompiledScope scope) {
    //stderr('markUsedScopesFor', scope, 'with references', scope.references);
    for (slot in scope.references.values()) {
      assert(slot is Slot, concat('unexpected reference found in ', scope.name, '\'s references list; expected only Slots, but found a ', (slot as Whatever).className));
      if (slot is SubroutineSlot) {
        CompiledSubroutine subroutine = (slot as SubroutineSlot).subroutine;
        if (!subroutine.isUsed) {
          subroutine.markUsed();
          if (prepareInstructionsHappened) {
            subroutine.prepareInstructions();
          }
          markUsedScopesFor(subroutine);
        }
      } else if (slot is CompiledInternalProcedureSlot) {
        CompiledInternalProcedure internalProcedure = (slot as CompiledInternalProcedureSlot).compiledInternalProcedure;
        if (!internalProcedure.isUsed) {
          internalProcedure.markUsed();
          markUsedScopesFor(internalProcedure);
        }
      } else if (slot is ConstantSlot) {
        (slot as ConstantSlot).constant.markUsed();
      }
    }
    for (subscope in scope.subscopes.values()) {
      markUsedScopesFor(subscope as CompiledScope);
    }
  }

  Null markConstructedClasses(ClassType target) {
    if (target.constructorSubroutine.subroutine.isUsed) {
      target.markConstructed();
    }
    for (subclass in target.subtypes.values()) {
      markConstructedClasses(subclass as ClassType);
    }
  }

  Null markUsedScopes() {
    markUsedScopesFor(intrinsicsLibrary);
    markUsedScopesFor(runtimeLibrary!);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      markUsedScopesFor(library as CompiledLibrary);
    }
    markConstructedClasses(runtimeLibrary!.lookupIntrinsicClass(coreClassTypeIntrinsicName));
  }

  Set subroutines = Set(); // CompiledSubroutine
  CompiledSubroutineList subroutinesInDeclarationOrder = []:CompiledSubroutine;

  Null addSubroutine(CompiledSubroutine subroutine) { 
    assert(!subroutines.has(subroutine), ' redundant call to addSubroutine');
    subroutines.add(subroutine);
    append(subroutinesInDeclarationOrder, subroutine);
  }

  Null prepareInstructions() {
    intrinsicsLibrary.prepareInstructions();
    runtimeLibrary!.prepareInstructions();
    for (libraryName in libraryNames) {
      (libraries.get(libraryName) as CompiledLibrary).prepareInstructions();
    }
    for (subroutine in subroutinesInDeclarationOrder) {
      if (subroutine.isUsed) {
        stderr('  preparing', subroutine.name);
        subroutine.prepareInstructions();
      }
    }
  }

  Null addRemainingReferences() {
    intrinsicsLibrary.addRemainingReferences();
    runtimeLibrary!.addRemainingReferences();
    for (libraryName in libraryNames) {
      (libraries.get(libraryName) as CompiledLibrary).addRemainingReferences();
    }
    for (subroutine in subroutinesInDeclarationOrder) {
      subroutine.addRemainingReferences();
    }
  }

  AbstractSubroutineType subroutineType;
  AbstractListType subscriptableType;
  IterableType iterableType;

  String typeTableLabel;
  String iteratorTypeTableLabel;
  String listTypeTableLabel;
  Integer typeTableOffset;
  Integer typeTableWidth;

  Null _generateTypeTable(Assembler assembler, String label) {
    StringList comment = []:String;
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, '   ; Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        bits += 1;
        if (bits > 8) {
          append(comment, '\n   ;         ');
          bits = 0;
        }
        append(comment, concat(' ', supertype));
      }
    }
    bits = 0;
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(comment, '   ; ');
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        if (bits > 0) {
          append(bytes, byte);
          byte = 0;
          bits = 0;
        }
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    while (len(bytes) % 8 != 0) {
      append(bytes, 0); // padding to keep things 8-byte aligned
    }
    IntegerListList data = [[]:Integer]:IntegerList;
    for (byte in bytes) {
      if (len(last(data) as WhateverList) >= 8) {
        append(data, []:Integer);
      }
      append(last(data) as WhateverList, byte);
    }
    String genBytes(IntegerList bytes) {
      return concat('db ', join(map(bytes, hex8) as StringList, ', '));
    }
    StringNullable genComments(IntegerList bytes) {
      return '...';
    }
    StringList generatedBytes = map(data, genBytes) as StringList;
    StringNullableList comments = map(data, genComments) as StringNullableList;
    comments[0] = 'Type table';
    comments[len(comments) - 1] = concat(comments[len(comments) - 1], '\n', join(comment, ''));
    assembler.addConst(label, generatedBytes, comments);
    typeTableOffset = offset;
    typeTableWidth = width;
  }

  Null _generateIteratorTypeTable(Assembler assembler, String label) {
    IntegerListList iteratorTypes = []:IntegerList;
    IntegerList buffer = []:Integer;
    IntegerList debugCodes = []:Integer;
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(debugCodes, type.code);
        if (type.isSubtypeOf(iterableType)) {
          if (type is IterableType) {
            Type iteratorType = createOrFindIteratorType(this, (type as IterableType).elementType);
            append(buffer, iteratorType.code);
          } else if (type is AbstractListType) {
            Type iteratorType = createOrFindIteratorType(this, (type as AbstractListType).elementType);
            append(buffer, iteratorType.code);
          } else {
            throw(concat('Unrecognized iterable type: ', type));
          }
        } else {
          append(buffer, 0xffffffff);
        }
      }
      if (len(buffer) == 4) {
        append(iteratorTypes, buffer);
        buffer = []:Integer;
      }
    }
    if (len(buffer) > 0) {
      append(iteratorTypes, buffer);
      buffer = []:Integer;
    }
    assert(first(debugCodes) == 0, 'expected sorted type codes to start at zero');
    assert(last(debugCodes) == len(debugCodes) - 1, 'expected sorted type codes to be consecutive');
    String genLines(IntegerList buffer) {
      return concat('dd ', join(map(buffer, hex32) as StringList, ', '));
    }
    StringNullable genComment(IntegerList buffer) {
      return null;
    }
    StringList data = copy(map(iteratorTypes, genLines)) as StringList;
    StringNullableList comments = copy(map(iteratorTypes, genComment)) as StringNullableList;
    comments[0] = 'Table mapping iterable types to iterator types';
    assembler.addConst(label, data, comments);
  }

  Null _generateListTypeTable(Assembler assembler, String label) {
    IntegerListList listTypes = []:IntegerList;
    IntegerList buffer = []:Integer;
    IntegerList debugCodes = []:Integer;
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(debugCodes, type.code);
        if (type.isSubtypeOf(iterableType)) {
          if (type is IterableType) {
            Type listType = createOrFindListType(this, (type as IterableType).elementType);
            append(buffer, listType.code);
          } else if (type is AbstractListType) {
            Type listType = createOrFindListType(this, (type as AbstractListType).elementType);
            append(buffer, listType.code);
          } else {
            throw(concat('Unrecognized iterable type: ', type));
          }
        } else {
          append(buffer, 0xffffffff);
        }
      }
      if (len(buffer) == 4) {
        append(listTypes, buffer);
        buffer = []:Integer;
      }
    }
    if (len(buffer) > 0) {
      append(listTypes, buffer);
      buffer = []:Integer;
    }
    assert(first(debugCodes) == 0, 'expected sorted type codes to start at zero');
    assert(last(debugCodes) == len(debugCodes) - 1, 'expected sorted type codes to be consecutive');
    String genLines(IntegerList buffer) {
      return concat('dd ', join(map(buffer, hex32) as StringList, ', '));
    }
    StringNullable genComment(IntegerList buffer) {
      return null;
    }
    StringList data = copy(map(listTypes, genLines)) as StringList;
    StringNullableList comments = copy(map(listTypes, genComment)) as StringNullableList;
    comments[0] = 'Table mapping iterable types to list types';
    assembler.addConst(label, data, comments);
  }

  Null generateTypeTables(Assembler assembler) {
    _generateTypeTable(assembler, typeTableLabel);
    _generateIteratorTypeTable(assembler, iteratorTypeTableLabel);
    _generateListTypeTable(assembler, listTypeTableLabel);
  }

  Null finalizeClassTypes(Assembler assembler) {
    ClassType rootClass = intrinsicsLibrary.lookupIntrinsicClass(coreClassTypeIntrinsicName);
    rootClass.assignIndicies(this, 0, 0);
    rootClass.populateMembers(this);
  }

  Null generateVmts(Assembler assembler) {
    ClassType rootClass = intrinsicsLibrary.lookupIntrinsicClass(coreClassTypeIntrinsicName);
    rootClass.generateVmt(this, assembler);
  }
  
  Null allocateSlots(Assembler assembler) {
    intrinsicsLibrary.allocateSlots(assembler);
    runtimeLibrary!.allocateSlots(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).allocateSlots(assembler);
    }
    for (subroutine in subroutinesInDeclarationOrder) {
      if (subroutine.isUsed) {
        subroutine.allocateSlots(assembler);
      }
    }
  }

  Null generateAssembler(Assembler assembler) {
    stderr('  compiling constants...');
    AssemblerBlock mainBlock = assembler.createBlock();
    for (constant in constants) {
      if (constant.isUsed) {
        assembler.addConst(constant.label, constant.data, constant.comments);
      }
    }
    stderr('  compiling intrinsics library...');
    intrinsicsLibrary.generateAssembler(assembler); // generates decrefs
    intrinsicsLibrary.generateAssemblerBlock(mainBlock);
    stderr('  compiling runtime library...');
    runtimeLibrary!.generateAssemblerBlock(mainBlock);
    for (libraryName in libraryNames) {
      stderr('  compiling', libraryName, 'library...');
      Anything library = libraries.get(libraryName);
      assert(library is CompiledLibrary, concat(libraryName, ' was never fully compiled'));
      (library as CompiledLibrary).generateAssemblerBlock(mainBlock);
    }
    mainBlock.addBlankLine();
    mainBlock.addComment('End of global scope');
    mainBlock.addCode('ret', [], 'exit application');
    assembler.addLabeledBlock('main', mainBlock, null, null);
    Integer index = 0;
    for (subroutine in subroutinesInDeclarationOrder) {
      index += 1;
      if (subroutine.isUsed) {
        stderr(concat('  compiling ', subroutine.name, ' (', index, '/', len(subroutinesInDeclarationOrder), ')'));
        subroutine.generateAssembler(assembler);
      }
    }
  }

  Null compile(Assembler assembler) {
    // the phase before this is Library.generateScopes() in syd_ast.syd
    stderr('addRemainingReferences...');
    addRemainingReferences();
    stderr('markUsedScopes...');
    markUsedScopes();
    stderr('prepareInstructions...');
    prepareInstructionsHappened = true;
    prepareInstructions();
    stderr('finalizeClassTypes...');
    finalizeClassTypes(assembler);
    stderr('assignTypeCodes...');
    assignTypeCodes();
    stderr('generateTypeTable...');
    generateTypeTables(assembler);
    stderr('generateVmts...');
    generateVmts(assembler);
    stderr('allocateSlots...');
    allocateSlots(assembler);
    stderr('generateAssembler...');
    generateAssembler(assembler);
  }

  Null constructor() {
    super.constructor();
    typeTableLabel = generateLabel('typeTable');
    iteratorTypeTableLabel = generateLabel('iteratorTypeTable');
    listTypeTableLabel = generateLabel('listTypeTable');
    intrinsicsLibrary = CompiledIntrinsicsLibrary(this, 'intrinsics');
    intrinsicsLibrary.generateScopes();
    subroutineType = createOrFindSubroutineTypeWithAnyArgs(this, intrinsicsLibrary.coreAnythingType);
    subscriptableType = createOrFindReadOnlyListType(this, intrinsicsLibrary.coreWhateverType);
    iterableType = createOrFindIterableType(this, intrinsicsLibrary.coreWhateverType);
  }
}


// ============================================================================
// SPECIALIZED SLOTS
// ============================================================================

class TypeTableWidthSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;

  Integer numericValue() {
    Integer width = environment.typeTableWidth;
    if (width % 8 > 0) {
      return width / 8 + 1;
    }
    return width / 8;
  }

  Null constructor(CompilationEnvironment environmentArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, 'type table width in bytes');
    environment = environmentArg;
  }
}

class VmtSlot extends CompileTimeLabelSlot {
  ClassType classType;

  String labelValue() {
    return classType.vmtLabel;
  }

  Operand value(SlotContext scope) {
    return DataAddressOperand(labelValue());
  }

  Null constructor(CompilationEnvironment environmentArg, ClassType classTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('vmt pointer for ', classTypeArg.name));
    classType = classTypeArg;
  }
}

enum MemberProperty { Type Getter Setter MethodImplementation }

class VmtMemberSlot extends CompileTimeIntegerSlot {
  MemberDescription member;
  MemberProperty property;

  Integer propertyIndex() {
    if (property == MemberPropertyType) { return 0; }
    if (property == MemberPropertySetter) { return 1; }
    if (property == MemberPropertyGetter) { return 2; }
    assert(property == MemberPropertyMethodImplementation, 'invalid MemberProperty');
    return 3;
  }

  Integer numericValue() {
    return vmtHeaderFieldCount * 8 + member.methodsIndex * 4 * 8 + propertyIndex() * 8; // header + method offset + member property
  }

  Null constructor(CompilationEnvironment environmentArg, MemberDescription memberArg, MemberProperty propertyArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat(propertyArg, ' method offset from start of vmt'));
    member = memberArg;
    property = propertyArg;
  }
}

class TypeBitSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type sourceType;

  Integer numericValue() {
    return (sourceType.code - environment.typeTableOffset) % 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type sourceTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('bit offset for ', sourceTypeArg));
    environment = environmentArg;
    sourceType = sourceTypeArg;
    assert(sourceType.isUsedInTypeCheck, 'caller of TypeBitSlot must mark type as used in type check');
  }
}

class TypeByteSlot extends CompileTimeIntegerSlot {
  CompilationEnvironment environment;
  Type sourceType;

  Integer numericValue() {
    assert(sourceType.code != null, concat(sourceType, ' does not have an assigned code'));
    return (sourceType.code - environment.typeTableOffset) / 8;
  }

  Null constructor(CompilationEnvironment environmentArg, Type sourceTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('byte offset for ', sourceTypeArg));
    environment = environmentArg;
    sourceType = sourceTypeArg;
    assert(sourceType.isUsedInTypeCheck, 'caller of TypeByteSlot must mark type as used in type check');
  }
}

class TypeCodeSlot extends CompileTimeIntegerSlot {
  Type sourceType;

  Integer numericValue() {
    assert(sourceType.code != null, concat(sourceType, ' does not have an assigned code'));
    return sourceType.code;
  }

  Null constructor(CompilationEnvironment environmentArg, Type sourceTypeArg) {
    super.constructor(environmentArg.intrinsicsLibrary.coreIntegerType, concat('code of ', sourceTypeArg));
    sourceType = sourceTypeArg;
  }
}

// slot that points to a function pointer block
class SubroutineSlot extends CompileTimeLabelSlot {
  CompiledSubroutine subroutine;

  String labelValue() {
    assert(subroutine.isUsed, concat('can\'t get label of unused subroutine (', subroutine.name, ' is not mark as used)'));
    return subroutine.functionPointerLabel;
  }

  // Pointer to a function pointer block.
  Operand value(SlotContext scope) {
    return DataAddressOperand(labelValue());
  }

  Boolean _isConstructor;
  Boolean _isDefined = false;
  Boolean isDefined() {
    return !_isConstructor || _isDefined;
  }

  Null markAsDefined() {
    assert(_isConstructor, 'cannot mark non-constructor as defined, those are always defined on declaration');
    _isDefined = true;
  }

  Null constructor(CompiledSubroutine subroutineArg, Boolean isConstructorArg) {
    subroutine = subroutineArg;
    super.constructor(subroutine.type, subroutine.name);
    assert(!isConstructorArg || subroutineArg is CompiledGeneratedConstructorSubroutine, 'wrong type for constructor subroutine');
    _isConstructor = isConstructorArg;
  }
}

// dynamic slot that happens to let us smuggle a "this" pointer and subroutine type
class MethodSlot extends DynamicSlot {
  DynamicSlot thisSlot;
  Type subroutineType;
  
  Null constructor(Type staticTypeArg, SlotContext homeScopeArg, rc referenceCountStyleArg, StringNullable nameArg, String debugNameArg, DynamicSlot thisSlotArg, Type subroutineTypeArg) {
    super.constructor(staticTypeArg, homeScopeArg, referenceCountStyleArg, nameArg, debugNameArg);
    thisSlot = thisSlotArg;
    subroutineType = subroutineTypeArg;
  }
}

// pointer to actual code for internal procedures
class CompiledInternalProcedureSlot extends CompileTimeLabelSlot {
  CompiledInternalProcedure compiledInternalProcedure;

  String labelValue() {
    return compiledInternalProcedure.name;
  }

  Operand value(SlotContext scope) {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(CompiledInternalProcedure compiledInternalProcedureArg) {
    compiledInternalProcedure = compiledInternalProcedureArg;
    super.constructor(compiledInternalProcedure.type(), compiledInternalProcedure.name);
  }
}

// pointer to actual code for user functions
class CompiledSubroutineSlot extends CompileTimeLabelSlot {
  CompiledSubroutine subroutine;
  DynamicSlotNullable thisSlot;

  String labelValue() {
    return subroutine.label;
  }

  Operand value(SlotContext scope) {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(CompiledSubroutine subroutineArg, DynamicSlotNullable thisSlotArg) {
    subroutine = subroutineArg;
    thisSlot = thisSlotArg;
    super.constructor(subroutine.environment().intrinsicsLibrary.coreSubroutineCodeAddressType, subroutine.name);
  }
}

class ConstantSlot extends ImmediateDataLabelSlot {
  Constant constant;

  Null constructor(Type typeArg, Constant constantArg, String debugNameArg) {
    super.constructor(typeArg, constantArg.label, debugNameArg);
    constant = constantArg;
  }
}

// thisSlot points to the value with the type 8 bytes earlier
class FieldSlot extends Slot {
  MemberDescription member;
  Slot thisSlot;

  Boolean isMutable() {
    return true;
  }

  Operand value(SlotContext scope) {
    assert(thisSlot.value(scope) is Register64Operand, concat('FieldSlot expects thisSlot to be pinned to a Register64Operand, operand is ', thisSlot.value(scope)));
    return (thisSlot.value(scope) as Register64Operand).dereference().withOffset(_gcBlockData + member.fieldIndex * 16 + 8);
  }

  Operand dynamicType(SlotContext scope) {
    assert(thisSlot.value(scope) is Register64Operand, concat('FieldSlot expects thisSlot to be pinned to a Register64Operand, operand is ', thisSlot.value(scope)));
    return (thisSlot.value(scope) as Register64Operand).dereference().withOffset(_gcBlockData + member.fieldIndex * 16);
  }

  Null constructor(Slot thisSlotArg, MemberDescription memberArg, String debugNameArg) {
    super.constructor(memberArg.staticType, debugNameArg);
    thisSlot = thisSlotArg;
    member = memberArg;
  }
}


// ============================================================================
// SPECIALIZED TYPES
// ============================================================================

class IdentifierEntity extends Object {
  Boolean isDefined() { abstract(); }
  Type staticType() { abstract(); }
  Slot forRead(CompiledScope scope) { abstract(); }
  Slot forCall(CompiledScope scope) { abstract(); }
  Null write(CompiledScope scope, Slot value) { abstract(); }
}

class SlotIdentifierEntity extends IdentifierEntity {
  Slot slot;

  Boolean isDefined() { return slot.isDefined(); }

  Type staticType() { return slot.staticType; }

  Slot forRead(CompiledScope scope) { return slot; }

  Slot forCall(CompiledScope scope) { return slot; }

  Null write(CompiledScope scope, Slot value) { 
    scope.emitInstruction(DecrefInstruction(slot));
    scope.emitInstruction(MoveInstruction(slot, value, 'store value'));
    scope.emitInstruction(MoveTypeToTypeInstruction(slot, value, scope.environment(), 'store type'));
    scope.emitIncref(slot, true);
  }

  Null constructor(Slot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class MemberIdentifierEntity extends IdentifierEntity {
  DynamicSlot thisSlot;
  MemberDescription member;
  String debugName;

  Boolean isDefined() { return member.isDefined(); }

  Type staticType() { return member.staticType; }

  Null debugCheckInvariants() { }

  Null constructor(DynamicSlot thisSlotArg, MemberDescription memberArg, String debugNameArg) {
    super.constructor();
    thisSlot = thisSlotArg;
    member = memberArg;
    debugName = debugNameArg;
    debugCheckInvariants();
  }
}

class FieldIdentifierEntity extends MemberIdentifierEntity {
  Slot forRead(CompiledScope scope) {
    Slot field = FieldSlot(thisSlot, member, debugName);
    rc referenceCountStyle;
    if (field.staticType.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot copy = scope.registerDynamicValue(field.staticType, referenceCountStyle, concat('copy of ', debugName));
    scope.emitInstruction(MoveToSpecificOperandInstruction(nonvolatileRegister, thisSlot, true, 'move "this" pointer to register to dereference a field'));
    scope.emitInstruction(PinSlotValueInstruction(thisSlot));
    scope.emitInstruction(MoveInstruction(copy, field, concat('make a copy of ', debugName, '\'s value in case it changes before we use it')));
    scope.emitInstruction(MoveTypeToTypeInstruction(copy, field, scope.environment(), concat('make a copy of ', debugName, '\'s type in case it changes before we use it')));
    scope.emitInstruction(UnpinSlotValueInstruction(thisSlot));
    if (!copy.staticType.neverReferenceCounted()) {
      scope.emitIncref(copy, true /* isGCRoot */);
    }
    copy.freeze(); // so that generateVariable doesn't copy it again
    return copy;
  }

  Slot forCall(CompiledScope scope) {
    return forRead(scope);
  }

  Null write(CompiledScope scope, Slot value) {
    Slot field = FieldSlot(thisSlot, member, debugName);
    scope.emitInstruction(MoveToSpecificOperandInstruction(nonvolatileRegister, thisSlot, true, 'move "this" pointer to register to derefrence a field'));
    scope.emitInstruction(PinSlotValueInstruction(thisSlot));
    scope.emitInstruction(DecrefInstruction(field));
    scope.emitInstruction(MoveInstruction(field, value, concat('store ', value.debugName, ' value in ', field.debugName)));
    scope.emitInstruction(MoveTypeToTypeInstruction(field, value, scope.environment(), concat('store ', value.debugName, ' type in ', field.debugName)));
    scope.emitIncref(field, false);
    scope.emitInstruction(UnpinSlotValueInstruction(thisSlot));
  }

  Null debugCheckInvariants() {
    super.debugCheckInvariants();
    assert(member.needsField, 'inconsistency');
  }
}

class MethodIdentifierEntity extends MemberIdentifierEntity {
  Slot forRead(CompiledScope scope) {
    member.staticType.markConstructed();
    return scope.emitSubroutineCall(
      scope.lookupIntrinsic(scope.environment().createMethodPointerIntrinsicName),
      [
        thisSlot,
        forCall(scope),
        TypeCodeSlot(scope.environment(), member.staticType),
      ]:Slot,
      null,
    );
  }

  MethodSlot forCall(CompiledScope scope) {
    MethodSlot slot = MethodSlot(scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType, scope, rcNever, null, concat('code address for ', debugName), thisSlot, member.staticType);
    scope.registerSlot(slot);
    scope.emitInstruction(MoveDerefInstruction(slot, thisSlot, _gcBlockData + 8, 'get vmt'));
    scope.emitInstruction(AddInstruction(slot, VmtMemberSlot(scope.environment(), member, MemberPropertyMethodImplementation), slot, 'add offset for dereference'));
    scope.emitInstruction(MoveDerefInstruction(slot, slot, 0, 'get call method'));
    scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType.markConstructed();
    scope.emitInstruction(MoveValueToTypeInstruction(slot, TypeCodeSlot(scope.environment(), scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType)));
    return slot;
  }

  Null write(CompiledScope scope, Slot value) {
    throw('cannot write to a guaranteed method');
  }

  Null debugCheckInvariants() {
    super.debugCheckInvariants();
    assert(member.needsMethods, 'inconsistency');
  }
}

class AmbiguousMemberIdentifierEntity extends MemberIdentifierEntity {
  Slot forRead(CompiledScope scope) {
    MethodSlot slot = MethodSlot(scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType, scope, rcNever, null, 'temporary for AmbiguousMemberIdentifierEntity.forRead', thisSlot, createOrFindSubroutineTypeWithSpecificParameters(scope.environment(), member.staticType, []:Type));
    scope.registerSlot(slot);
    scope.emitInstruction(MoveDerefInstruction(slot, thisSlot, _gcBlockData + 8, 'get vmt'));
    scope.emitInstruction(AddInstruction(slot, VmtMemberSlot(scope.environment(), member, MemberPropertyGetter), slot, 'add offset for dereference'));
    scope.emitInstruction(MoveDerefInstruction(slot, slot, 0, concat('get getter method for ', member.name)));
    return scope.emitSubroutineCall(slot, []:Slot, null);
  }

  Slot forCall(CompiledScope scope) {
    return forRead(scope);
  }

  Null write(CompiledScope scope, Slot value) {
    MethodSlot slot = MethodSlot(scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType, scope, rcNever, null, 'temporary for AmbiguousMemberIdentifierEntity.write', thisSlot, member.staticType);
    scope.registerSlot(slot);
    scope.emitInstruction(MoveDerefInstruction(slot, thisSlot, _gcBlockData + 8, 'get vmt'));
    scope.emitInstruction(AddInstruction(slot, VmtMemberSlot(scope.environment(), member, MemberPropertySetter), slot, 'add offset for dereference'));
    scope.emitInstruction(MoveDerefInstruction(slot, slot, 0, 'get setter method'));
    scope.emitSubroutineCall(slot, []:Slot, null);
    Slot field = FieldSlot(thisSlot, member, debugName);
    scope.emitInstruction(MoveToSpecificOperandInstruction(nonvolatileRegister, thisSlot, true, 'move "this" pointer to register to dereference a field for writing'));
    scope.emitInstruction(PinSlotValueInstruction(thisSlot));
    scope.emitInstruction(DecrefInstruction(field));
    scope.emitInstruction(MoveInstruction(field, value, concat('store ', value.debugName, ' value in ', field.debugName)));
    scope.emitInstruction(MoveTypeToTypeInstruction(field, value, scope.environment(), concat('store ', value.debugName, ' type in ', field.debugName)));
    scope.emitIncref(field, false);
    scope.emitInstruction(UnpinSlotValueInstruction(thisSlot));
  }
}

class MemberDescription extends Object {
  String name;
  Type staticType;
  Boolean isInherited;
  Boolean hasSuperclassMember = false;
  Boolean isField; // whether this class specifically has a method or a field with this name
  Boolean needsField = false; // this member needs storage in this class OR a superclass
  Boolean needsMethods = false; // this member has methods in this class OR a superclass OR a subclass
  Boolean isAmbiguous = false; // this member is a field/method in this class, and the opposite in a subclass
  Boolean needsDynamicDispatch = false;

  IntegerNullable fieldIndex = null;
  IntegerNullable methodsIndex = null;
  CompiledSubroutineNullable getter = null; // generated method used when a method is used as a field, or in general for getting the member when it is both a field and a method
  CompiledSubroutineNullable setter = null; // generated method called immediately prior to setting the field, if it is both a field and a method
  CompiledSubroutineNullable methodImplementation = null; // actual method implementation when we have one

  Boolean setNeedsField() {
    if (needsField) {
      return false;
    }
    needsField = true;
    return true;
  }

  Boolean setNeedsMethods() {
    if (needsMethods) {
      return false;
    }
    needsMethods = true;
    return true;
  }

  Null setIsField() {
    assert(needsField, 'cannot be a field if it does not need a field');
    isField = true;
  }

  Null setIsMethod() {
    assert(needsMethods, 'cannot be a method if it does not need methods');
    isField = false;
  }

  Null setIsAmbiguous() {
    isAmbiguous = true;
  }

  Null prepareForAssignIndicies(CompilationEnvironment environment) {
    needsDynamicDispatch = environment.neededForDynamicDispatch(name);
    if (needsDynamicDispatch) {
      setNeedsMethods();
    }
  }

  Null assignIndicies(CompilationEnvironment environment, Integer fieldIndexArg, Integer methodsIndexArg) {
    assert(fieldIndex == null && methodsIndex == null, 'assignIndicies called redundantly');
    assert(needsField || needsMethods, 'assignIndicies called before setNeedsField/setNeedsMethods');
    if (needsField) {
      fieldIndex = fieldIndexArg;
    }
    if (needsMethods) {
      methodsIndex = methodsIndexArg;
    }
  }

  Null setSetter(CompiledSubroutine subroutineArg) {
    setter = subroutineArg;
  }

  Null setGetter(CompiledSubroutine subroutineArg) {
    getter = subroutineArg;
  }

  Null setMethodImplementation(CompiledSubroutine subroutineArg) {
    methodImplementation = subroutineArg;
  }

  Boolean _isDefined = false;

  Boolean isDefined() {
    return isInherited || hasSuperclassMember || _isDefined;
  }

  Null define() {
    assert(!isInherited, concat('use override() before define() for reintroduced inherited members'));
    assert(!_isDefined, concat('tried to mark member ', name, ' as defined twice'));
    _isDefined = true;
  }

  Null override(Type staticTypeArg) {
    assert(!_isDefined, concat('tried to mark member ', name, ' as defined twice'));
    assert(staticTypeArg.isSubtypeOf(staticType), 'type mismatch');
    staticType = staticTypeArg;
    isInherited = false;
    hasSuperclassMember = true;
    getter = null;
    setter = null;
    methodImplementation = null;
  }

  MemberDescription inherit() {
    MemberDescription result = MemberDescription(name, staticType, true);
    if (needsField) {
      result.setNeedsField();
    }
    if (needsMethods) {
      result.setNeedsMethods();
    }
    if (isField) {
      result.setIsField();
    } else {
      result.setIsMethod();
    }
    if (getter != null) {
      result.setGetter(getter!);
    }
    if (setter != null) {
      result.setSetter(setter!);
    }
    if (methodImplementation != null) {
      result.setMethodImplementation(methodImplementation!);
    }
    return result;
  }

  String toString() {
    return concat('MemberDescription: ', staticType, ' ', name, ' (methodsIndex=', methodsIndex, '; fieldIndex=', fieldIndex, ')');
  }

  Null constructor(String nameArg, Type staticTypeArg, Boolean isInheritedArg) {
    super.constructor();
    name = nameArg;
    staticType = staticTypeArg;
    isInherited = isInheritedArg;
  }
}

class ClassType extends Type {
  ClassType supertype;

  Boolean isDefined = false;

  Null markAsDefined() {
    assert(!isDefined, 'cannot mark a class as defined twice');
    isDefined = true;
  }

  Set subtypes = Set();

  Map members = Map(); // name to MemberDescription
  Boolean isConstructedOrSubclassIsConstructed = false;

  Null markConstructed() {
    super.markConstructed();
    if (!isConstructedOrSubclassIsConstructed && supertype != this) {
      supertype.markConstructed();
    }
    isConstructedOrSubclassIsConstructed = true;
  }

  // This is the generated constructor (the one with the name of the class),
  // not the method called constructor (which this one calls).
  SubroutineSlot constructorSubroutine;

  Null setConstructorSubroutine(SubroutineSlot constructorSubroutineArg) {
    constructorSubroutine = constructorSubroutineArg;
  }

  Null inheritMembersFromSupertype() {
    assert(members.length == 0, 'cannot inherit members twice');
    for (member in supertype.members.values()) {
      members.set((member as MemberDescription).name, (member as MemberDescription).inherit());
    }
  }

  Null propagateNeedsMethodsFor(String name) {
    assert(members.get(name) != null, 'propagateNeedsMethodsFor called with name that did not exist');
    if ((members.get(name) as MemberDescription).setNeedsMethods()) {
      for (subclass in subtypes.values()) {
        (subclass as ClassType).propagateNeedsMethodsFor(name);
      }
    }
  }

  NullFunctionList initializers = []:NullFunction;

  Null registerMember(String name, Type type, Boolean isField, NullFunctionNullable initializer) {
    assert(supertype.members.get(name) == null || type.isSubtypeOf((supertype.members.get(name) as MemberDescription).staticType),
           'tried to register overriding member with broader type than inherited type');
    MemberDescriptionNullable inheritedMember = members.get(name) as MemberDescriptionNullable;
    MemberDescription member;
    Boolean isInherited = inheritedMember != null;
    assert(inheritedMember == null || inheritedMember!.isInherited == true, 'inconsistent inheritance status');
    if (isInherited) {
      inheritedMember!.override(type);
      member = inheritedMember!;
    } else {
      member = MemberDescription(name, type, false);
      members.set(name, member);
    }
    if (isField) {
      if (member.setNeedsField() && isInherited) {
        ClassType node = this;
        while (node != node.supertype && node.supertype.members.get(name) != null) {
          node = node.supertype;
          (node.members.get(name) as MemberDescription).setIsAmbiguous();
        }
      }
      member.setIsField();
      append(initializers, initializer);
    } else {
      assert(initializer == null, 'Initializers can only be used with fields.');
      if (member.setNeedsMethods()) {
        if (isInherited) {  
          // also require methods for it in the rest of the class hierarchy
          // TODO: this propagation logic should wait until we've computed which classes are used
          ClassType node = this;
          while (node != node.supertype && node.supertype.members.get(name) != null) {
            node = node.supertype;
            (node.members.get(name) as MemberDescription).setIsAmbiguous();
          }
          node.propagateNeedsMethodsFor(name);
        }
      }
      member.setIsMethod();
    }
  }

  MemberDescriptionNullable getMember(String name) {
    return members.get(name) as MemberDescriptionNullable;
  }

  Integer fieldCount;
  Integer methodCount;

  Null assignIndicies(CompilationEnvironment environment, Integer nextField, Integer nextMethods) {
    fieldCount = 0;
    methodCount = 0;
    for (member in members.values()) {
      MemberDescriptionNullable inheritedMember = supertype.members.get((member as MemberDescription).name) as MemberDescriptionNullable;
      (member as MemberDescription).prepareForAssignIndicies(environment);
      Integer fieldIndex = -1;
      Integer methodsIndex = -1;
      if (inheritedMember != null && supertype != this && inheritedMember!.needsField) {
        assert((member as MemberDescription).needsField, 'inconsistency in needsField');
        fieldIndex = inheritedMember!.fieldIndex!;
      } else if ((member as MemberDescription).needsField) {
        fieldIndex = nextField;
        nextField += 1;
      }
      if (inheritedMember != null && supertype != this && inheritedMember!.needsMethods) {
        assert((member as MemberDescription).needsMethods, 'inconsistency in needsMethods');
        methodsIndex = inheritedMember!.methodsIndex!;
      } else if ((member as MemberDescription).needsMethods) {
        methodsIndex = nextMethods;
        nextMethods += 1;
      }
      (member as MemberDescription).assignIndicies(environment, fieldIndex, methodsIndex);
      if ((member as MemberDescription).needsField) {
        fieldCount += 1;
      }
      if ((member as MemberDescription).needsMethods) {
        methodCount += 1;
      }
    }
    assert(methodCount == nextMethods, concat('inconsistent method count: ', methodCount, ' vs ', nextMethods));
    for (subtype in subtypes.values()) {
      (subtype as ClassType).assignIndicies(environment, nextField, nextMethods);
    }
  }

  Null populateMembers(CompilationEnvironment environment) {
    if (!isConstructedOrSubclassIsConstructed) {
      return;
    }
    for (member in members.values() as MemberDescriptionList) {
      if (member.needsMethods) {
        assert(member.getter == null, 'where did you come from');
        if (member.getter == null) {
          member.setGetter(BuiltInGetterMethod(environment.intrinsicsLibrary, this, member));
          environment.addSubroutine(member.getter!);
          environment.markUsedScopesFor(member.getter!); // TODO: track use more properly
        }
        assert(member.setter == null, 'where did you come from');
        if (member.setter == null) {
          member.setSetter(BuiltInSetterMethod(environment.intrinsicsLibrary, this, member));
          environment.addSubroutine(member.setter!);
          environment.markUsedScopesFor(member.setter!); // TODO: track use more properly
        }
      }
    }
    for (subtype in subtypes.values()) {
      (subtype as ClassType).populateMembers(environment);
    }
  }

  IdentifierEntity createIdentifierEntity(CompiledScope scope, DynamicSlot thisSlot, String name) {
    MemberDescription member = getMember(name)!;
    if (member.isAmbiguous) {
      return AmbiguousMemberIdentifierEntity(thisSlot, member, concat(this.name, '.', name));
    }
    if (member.isField) {
      return FieldIdentifierEntity(thisSlot, member, concat(this.name, '.', name));
    }
    return MethodIdentifierEntity(thisSlot, member, concat(this.name, '.', name));
  }

  String vmtLabel;
  String ddtLabel;

  Null generateVmt(CompilationEnvironment environment, Assembler assembler) {
    if (constructorSubroutine.subroutine.isUsed) {
      vmtLabel = environment.generateLabel(concat(name, '$vmt')); // virtual method table
      ddtLabel = environment.generateLabel(concat(name, '$ddt')); // dynamic dispatch table
  
      // VMT
      StringList vmtLines = []:String;
      StringNullableList vmtComments = []:StringNullable;
  
      append(vmtComments, 'type code');
      if (code != null) {
        append(vmtLines, concat('dq ', hex32(code!)));
      } else {
        // this class is never constructed or type checked, so has no type code
        append(vmtLines, 'dq -1');
      }
  
      append(vmtComments, 'number of fields to allocate during construction');
      append(vmtLines, concat('dq ', fieldCount));
  
      append(vmtComments, 'pointer to class name');
      assert(environment.intrinsicsLibrary.coreStringType.isConstructed, 'Cannot encode string into VMT; strings are not used anywhere in this program.');
      ConstantSlot classNameSlot = environment.registerStringConstant(concat(name, '$className'), name, __LINE__, __COL__, __FILE__);
      append(vmtLines, concat('dq ', classNameSlot.label));

      // Pointer to parent VMT
      // TODO: we should remove this  
      if (supertype.constructorSubroutine.subroutine.isUsed) {
        append(vmtLines, concat('dq ', supertype.vmtLabel));
        append(vmtComments, 'pointer to parent VMT');
      } else {
        append(vmtLines, concat('dq 0'));
        append(vmtComments, 'pointer to parent VMT is bogus because parent VMT is not included in binary');
      }
  
      append(vmtComments, 'pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)');
      append(vmtLines, concat('dq ', ddtLabel));
  
      // there must be exactly vmtHeaderFieldCount * 8 bytes from the label to here.
  
      MemberDescriptionList sortedMethods = []:MemberDescription;
      for (member in members.values()) {
        if ((member as MemberDescription).needsMethods) {
          append(sortedMethods, member);
        }
      }
      Integer indexComparator(MemberDescription a, MemberDescription b) {
        return a.methodsIndex! - b.methodsIndex;
      }
      sortWithComparator(sortedMethods, indexComparator);
      Integer debugIndex = 0;
      for (member in sortedMethods) {
        if ((member as MemberDescription).needsMethods) {
          assert((member as MemberDescription).methodsIndex == debugIndex, concat('methods out of sync: method ', name, '.', (member as MemberDescription).name, ' has index ', (member as MemberDescription).methodsIndex, ' but we have seen ', debugIndex, ' method(s) so far'));
          append(vmtComments, concat(name, '.', (member as MemberDescription).name));
          String methodLabel;
          if ((member as MemberDescription).methodImplementation == null) {
            methodLabel = '0h';
          } else {
            methodLabel = (member as MemberDescription).methodImplementation!.label;
          }
          String typeCode;
          if ((member as MemberDescription).isField) {
            typeCode = '-1';
          } else {
            typeCode = hex32((member as MemberDescription).staticType.code!);
          }
          append(vmtLines, concat('dq ', typeCode, ', ', (member as MemberDescription).setter!.label, ', ', (member as MemberDescription).getter!.label, ', ', methodLabel));
          debugIndex++;
        }
      }
  
      assembler.addConst(vmtLabel, vmtLines, vmtComments);
  
      // DDT
      StringList ddtLines = []:String;
      StringNullableList ddtComments = []:StringNullable;
      MemberDescriptionList sortedMembers = []:MemberDescription;
      for (member in members.values()) {
        if ((member as MemberDescription).needsDynamicDispatch) {
          append(sortedMembers, member);
        }
      }
      Integer atomComparator(MemberDescription a, MemberDescription b) {
        return environment.atomizeForDynamicDispatch(a.name) - environment.atomizeForDynamicDispatch(b.name);
      }
      sortWithComparator(sortedMembers, atomComparator);
      append(ddtLines, concat('dq ', len(sortedMembers)));
      append(ddtComments, 'Number of members used in dynamic dispatch');
      for (member in sortedMembers) {
        append(ddtLines, concat(
          'dd ', environment.atomizeForDynamicDispatch(member.name), // low bits, member identifier
           ', ', hex32(vmtHeaderFieldCount * 8 + member.methodsIndex * 4 * 8 + 16), // high bits, offset into vmt to getter function, from vmt pointer
        ));
        append(ddtComments, concat('dynamic dispatch data for ', name, '.', member.name));
      } 
      assembler.addConst(ddtLabel, ddtLines, ddtComments);
    }

    for (subtype in subtypes.values()) {
      (subtype as ClassType).generateVmt(environment, assembler);
    }
  }

  Boolean isSubtypeOf(Type other) {
    if (this == other) {
      return true;
    }
    if (supertype != this) {
      return supertype.isSubtypeOf(other);
    }
    return other is AnythingType
        || other is WhateverType
        || other is GarbageCollectableType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype));
  }
  
  Boolean neverReferenceCounted() {
    return false;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg, TypeNullable supertypeArg) {
    super.constructor(typeRegistryArg, nameArg);
    assert(supertypeArg is ClassTypeNullable, 'passed in non-class type to classtype constructor');
    if (supertypeArg == null) {
      supertype = this;
    } else {
      supertype = supertypeArg as ClassType;
      supertype.subtypes.add(this);
    }
  }
}

// ============================================================================
// SPECIALIZED INSTRUCTIONS
// ============================================================================

// use emitBlock instead
class DoBlockInstruction extends Instruction {
  CompiledNestedScope nestedBlock;

  Null prepare(SlotContext scope) {
    nestedBlock.prepareInstructions();
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    nestedBlock.generateAssemblerBlock(block);
  }

  Null constructor(CompiledNestedScope nestedBlockArg) { 
    super.constructor();
    nestedBlock = nestedBlockArg;
  }
}

// ============================================================================
// SCOPES
// ============================================================================

class CompiledScope extends SlotContext {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name; // TODO: rethink exactly what this means

  CompiledLibrary globalScope() { 
    assert(parent != null, 'compiled scope chain failure');
    return parent!.globalScope();
  }

  CompiledStackFrameScope stackFrame() { 
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = parent!.stackFrame() as CompiledScope;
    return result;
  }

  SlotContext slotScope() {
    return stackFrame();
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return parent!.environment();
  }

  String labelPrefix() {
    abstract();
  }

  Null prepareSlots() { }

  // REGISTRIES

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  Set references = Set(); // Slots

  IdentifierEntityNullable lookupIdentifier(String name) {
    IdentifierEntityNullable result = internalLookupIdentifier(name);
    if (result is SlotIdentifierEntity) {
      references.add((result as SlotIdentifierEntity).slot);
    }
    return result;
  }

  IdentifierEntityNullable localLookupIdentifier(String name) {
    SlotNullable slot = identifiers.get(name) as SlotNullable;
    if (slot == null) {
      return null;
    }
    return SlotIdentifierEntity(slot!);
  }

  IdentifierEntityNullable internalLookupIdentifier(String name) {
    IdentifierEntityNullable value = localLookupIdentifier(name);
    if (value == null && parent != null) {
      value = parent!.internalLookupIdentifier(name);
    }
    return value;
  }

  Slot lookupIntrinsic(String name) {
    SlotNullable result = environment().intrinsics.get(name) as SlotNullable;
    if (result == null) {
      // TODO: this should be an assert, and we should verify all the intrinsics are defined when we're done reading the standard library.
      throw(concat('Compiler intrinsic "', name, '" is not declared.'));
    }
    references.add(result!);
    return result!;
  }

  ClassType lookupIntrinsicClass(String name) {
    ClassTypeNullable result = environment().classIntrinsics.get(name) as ClassTypeNullable;
    if (result == null) {
      // TODO: this should be an assert, and we should verify all the intrinsics are defined when we're done reading the standard library.
      throw(concat('Compiler intrinsic "', name, '" is not declared.'));
    }
    return result!;
  }

  String lookupInternalProcedureLabel(ip procedure) {
    CompiledInternalProcedureSlot slot = environment().intrinsicsLibrary.lookupInternalProcedureSlot(procedure);
    references.add(slot);
    return slot.compiledInternalProcedure.name;
  }

  Set subscopes = Set(); // CompiledScope

  Null registerNestedScope(CompiledScope nestedScope) {
    subscopes.add(nestedScope);
  }

  DynamicSlot registerSlot(DynamicSlot slot) {
    return stackFrame().registerSlot(slot);
    // CompiledStackFrameScope overrides this to add more behaviour
  }

  DynamicSlot registerDynamicValue(Type type, rc referenceCountStyle, String debugName) {
    return registerSlot(DynamicSlot(type, this, referenceCountStyle, null, debugName));
  }

  // Caller must incref variable if appropriate.
  DynamicSlot registerVariable(String name, Type type) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    rc referenceCountStyle;
    if (type.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot slot = DynamicSlot(type, this, referenceCountStyle, name, concat(name, ' variable'));
    identifiers.set(name, slot);
    emitInstruction(TrackSlotInstruction(slot));
    return registerSlot(slot);
  }

  ImmediateSlot registerNumericConstant(String name, Integer value, Type staticType) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    Slot slot = ImmediateIntegerSlot(staticType, value, name);
    identifiers.set(name, slot);
    staticType.markConstructed();
    return slot;
  }

  SubroutineSlot registerSubroutine(CompiledSubroutine subroutine, Boolean isConstructor) { 
    assert(!isIdentifierDeclaredInLocalScope(subroutine.name), concat('tried to redeclare an identifier (', subroutine.name, ') within a scope'));
    SubroutineSlot slot = SubroutineSlot(subroutine, isConstructor);
    identifiers.set(subroutine.name, slot);
    environment().addSubroutine(subroutine);
    subroutine.adoptSlot(slot);
    return slot;
  }


  // INSTRUCTION GENERATION

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }
  
  Null markSourceLocation(AstNode statement) {
    emitInstruction(PendingCommentInstruction(concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), 64))));
  }
  
  Null emitBlock(CompiledNestedScope block) {
    registerNestedScope(block);
    emitInstruction(DoBlockInstruction(block));
  }

  // does not set the type of target!
  // caller is responsible for setting it to Boolean!
  Null storeEquality(Slot a, Slot b, Slot target, Boolean negate) {
    // TODO: hard-code result for literal comparisons
    Slot valueTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, rcNever, concat('value result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    Slot typeTemp = registerDynamicValue(environment().intrinsicsLibrary.coreBooleanType, rcNever, concat('type result of == (testing ', a.debugName, ' and ', b.debugName, ')'));
    emitInstruction(SetSlotIfEqualInstruction(a, b, valueTemp, environment().intrinsicsLibrary.coreBooleanType, 'values equal?'));
    emitInstruction(SetSlotIfTypesEqualInstruction(a, b, typeTemp, environment().intrinsicsLibrary.coreBooleanType, 'types equal?'));
    emitInstruction(BiOperandInstruction('and', valueTemp, typeTemp, target, '&& type temp and value temp'));
    // String comparisons
    if (environment().intrinsicsLibrary.coreStringType.isSubtypeOf(a.staticType) && 
        environment().intrinsicsLibrary.coreStringType.isSubtypeOf(b.staticType)) {
      String afterBlockLabel = environment().generateLabel(concat(labelPrefix(), '$stringCompareEnd'));
      emitInstruction(ConditionalJumpInstruction(target, environment().intrinsicsLibrary.coreFalse, ccNotEqual, afterBlockLabel, 'skip string compare if values definitely equal by pointer comparison'));
      CompiledNestedScope block = CompiledNestedScope(this, 'string comparison');
      // check that a is actually a string
      String aIsStringLabel = environment().generateLabel(concat(labelPrefix(), '$aIsString'));
      block.emitInstruction(ConditionalDynamicTypeJumpInstruction(a, environment().intrinsicsLibrary.coreStringType, ccEqual, aIsStringLabel, concat('verify that ', a.debugName, ' is a string before string compare')));
      block.emitInstruction(SyntheticNestedScopeExitInstruction(block));
      block.emitInstruction(JumpInstruction(afterBlockLabel, 'skip string compare; not a string'));
      block.emitInstruction(LabelInstruction(aIsStringLabel, 'continue string comparison'));
      // check that b is actually a string
      String bIsStringLabel = environment().generateLabel(concat(labelPrefix(), '$bIsString'));
      block.emitInstruction(ConditionalDynamicTypeJumpInstruction(b, environment().intrinsicsLibrary.coreStringType, ccEqual, bIsStringLabel, concat('verify that ', b.debugName, ' is a string before string compare')));
      block.emitInstruction(SyntheticNestedScopeExitInstruction(block));
      block.emitInstruction(JumpInstruction(afterBlockLabel, 'skip string compare; not a string'));
      block.emitInstruction(LabelInstruction(bIsStringLabel, 'continue string comparison'));
      // check that a and b have the same length
      String abEqualLength = environment().generateLabel(concat(labelPrefix(), '$abEqualLength'));
      Slot lengthA = block.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('length of ', a.debugName));
      block.emitInstruction(MoveDerefInstruction(lengthA, a, _gcBlockHeaderLength, concat('read length of ', a.debugName)));
      Slot lengthB = block.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('length of ', b.debugName));
      block.emitInstruction(MoveDerefInstruction(lengthB, b, _gcBlockHeaderLength, concat('read length of ', b.debugName)));
      block.emitInstruction(ConditionalJumpInstruction(lengthA, lengthB, ccEqual, abEqualLength, concat('verify that ', a.debugName, ' and ', b.debugName, ' have the same length')));
      block.emitInstruction(SyntheticNestedScopeExitInstruction(block));
      block.emitInstruction(JumpInstruction(afterBlockLabel, 'skip string compare; strings do not have the same length'));
      block.emitInstruction(LabelInstruction(abEqualLength, 'continue string comparison'));
      block.emitInstruction(StringComparisonInstruction(target, a, _gcBlockStringData, b, _gcBlockStringData, lengthA, concat('verify that ', a.debugName, ' and ', b.debugName, ' are string-equal')));
      emitBlock(block);
      emitInstruction(LabelInstruction(afterBlockLabel, 'after string comparison block'));
    }
    if (negate) {
      emitInstruction(BiOperandInstruction('xor', target, environment().integer(1), target, concat('negating ', target)));
    }
  }

  Null emitIncref(Slot value, Boolean isGCRoot) {
    Type stringType = environment().intrinsicsLibrary.coreStringType;
    Type garbageCollectableType = environment().intrinsicsLibrary.coreGarbageCollectableType;
    Boolean doGCIncref = (garbageCollectableType.isSubtypeOf(value.staticType) || value.staticType.isSubtypeOf(garbageCollectableType)) && (!value is VarArgsParameterSlot) && isGCRoot;
    Boolean doStringIncref = stringType.isSubtypeOf(value.staticType) && !(value is ImmediateDataLabelSlot);
    if (doGCIncref || doStringIncref) {
      emitInstruction(CommentInstruction(concat('increment reference count for ', value.debugName, ' if necessary')));
    }
    if (doGCIncref) {
      String increfAfterGCLabel = environment().generateLabel(concat(labelPrefix(), '$AfterGCIncref'));
      emitIsOperatorCheck(garbageCollectableType, value, 'possibly GarbageCollectable value'); // actual type check is here
      emitInstruction(JncInstruction(increfAfterGCLabel, 'if not a GarbageCollectable, skip incref'));
      CompiledNestedScope subblock = CompiledNestedScope(this, 'gc');
        subblock.emitInstruction(IncrefInstruction(value));
      emitBlock(subblock);
      emitInstruction(LabelInstruction(increfAfterGCLabel, 'after GarbageCollectable incref'));
    }
    if (doStringIncref) {
      String increfAfterStringLabel = environment().generateLabel(concat(labelPrefix(), '$AfterStringIncref'));
      String increfStringLabel = environment().generateLabel(concat(labelPrefix(), '$StringIncref'));
      emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, stringType, increfAfterStringLabel, 'if not a String, skip incref'));
      CompiledNestedScope subblock = CompiledNestedScope(this, 'string');
        Slot temp = subblock.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'string reference count');
        subblock.emitInstruction(MoveDerefInstruction(temp, value, 0, 'dereference string to get to reference count'));
        subblock.emitInstruction(ConditionalJumpInstruction(temp, null, ccPositive, increfStringLabel, 'if reference count is negative (constant strings), skip incref'));
        subblock.emitInstruction(SyntheticNestedScopeExitInstruction(subblock));
        subblock.emitInstruction(JumpInstruction(increfAfterStringLabel, 'skip incref for string constants'));
        subblock.emitInstruction(LabelInstruction(increfStringLabel, 'real String'));
        CompiledNestedScope subsubblock = CompiledNestedScope(this, 'string');
          subsubblock.emitInstruction(IncrefInstruction(value));
        subblock.emitBlock(subsubblock);
      emitBlock(subblock);
      emitInstruction(LabelInstruction(increfAfterStringLabel, 'after String incref'));
    }
  }

  // Emits an instruction that does the equivalent of "lhs is staticType", puts the result in the CF flag.
  //
  // Must be followed by jc or setc.
  Null emitIsOperatorCheck(Type staticType, Slot lhs, String what) {
    // TODO: check if check can be hard-coded and handle accordingly if so
    CompilationEnvironment environment = environment();
    staticType.markUsedInTypeCheck();
    Slot typeTableWidth = TypeTableWidthSlot(environment);
    Slot typeBit = TypeBitSlot(environment, staticType);
    Slot typeByte = TypeByteSlot(environment, staticType);
    Slot typeTablePointer = ImmediateDataLabelSlot(environment.intrinsicsLibrary.coreIntegerType, environment.typeTableLabel, 'type table pointer');

    // byte of lhs's type's row in the type table containing the bit for staticType
    Slot testByte = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'testByte');
    emitInstruction(MoveTypeToValueInstruction(testByte, lhs));
    emitInstruction(UnsignedMultiplyInstruction(typeTableWidth, testByte, testByte, 'adjust to the relative start of that type\'s entry in the type table'));
    emitInstruction(AddInstruction(testByte, typeByte, testByte, 'adjust to the byte containing the bit to check against'));
    emitInstruction(AddInstruction(testByte, typeTablePointer, testByte, 'finally offset all of that by the start of the type table itself'));
    emitInstruction(BtDerefInstruction(testByte, typeBit, concat('check that ', what, ' is ', staticType))); // to be followed by jc or setc
  }
  
  Null doIfVarArgsTypeMismatch(Type staticType, VarArgsParameterSlot varArgs, String labelBase, CompiledNestedScope block, String what) {
    // TODO: xxxx we could also check if we can statically disprove compatibility
    emitInstruction(CommentInstruction(concat('Varargs parameter type check; expecting parameters to be ', staticType.name)));
    CompilationEnvironment environment = environment();
    String loopTopLabel = environment.generateLabel(concat(labelBase, '$Loop'));
    String continueLabel = environment.generateLabel(concat(labelBase, '$TypeMatch'));
    String loopBottomLabel = environment.generateLabel(concat(labelBase, '$TypesAllMatch'));
    // variable that holds a pointer to the index'th argument's type
    Slot pointerToIndexthArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to indexth argument');
    // variable that holds the last value that pointerToIndexthArg should have (pointer past the last argument)
    Slot pointerToLastArg = registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to last argument');
    emitInstruction(LeaInstruction(pointerToIndexthArg, varArgs.baseAddress(environment.intrinsicsLibrary.coreIntegerType), 0, true, 'get base address of varargs, where loop will start'));
    emitInstruction(UnsignedMultiplyInstruction(varArgs.length(), environment.integer(0x10), pointerToLastArg, 'end of loop is the number of arguments times the width of each argument (010h)...'));
    emitInstruction(AddInstruction(pointerToIndexthArg, pointerToLastArg, pointerToLastArg, '...offset from the initial index'));
    emitInstruction(LabelInstruction(loopTopLabel, 'top of loop'));
    CompiledNestedScope loopBlock = CompiledNestedScope(this, 'loop');
    Slot indexthArg = loopBlock.registerDynamicValue(environment.intrinsicsLibrary.coreIntegerType, rcNever, 'indexth argument');
    loopBlock.emitInstruction(JumpIfEqualInstruction(pointerToIndexthArg, pointerToLastArg, loopBottomLabel, 'we have type-checked all the arguments'));
    loopBlock.emitInstruction(MoveDerefToTypeInstruction(indexthArg, pointerToIndexthArg, 0, concat('load type of indexth argument into ', indexthArg.debugName)));
    loopBlock.emitIsOperatorCheck(staticType, indexthArg, what); // actual type check is here
    loopBlock.emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    loopBlock.emitBlock(block);
    loopBlock.emitInstruction(LabelInstruction(continueLabel, 'after block'));
    loopBlock.emitInstruction(AddInstruction(pointerToIndexthArg, environment.integer(0x10), pointerToIndexthArg, 'next argument'));
    loopBlock.emitInstruction(SyntheticNestedScopeExitInstruction(loopBlock));
    loopBlock.emitInstruction(JumpInstruction(loopTopLabel, 'return to top of loop'));
    loopBlock.emitInstruction(LabelInstruction(loopBottomLabel, 'after loop'));
    emitBlock(loopBlock);
  }
  
  Null emitStoreTypeCheck(Type staticType, Slot lhs, Slot target, String what) {
    CompilationEnvironment environment = environment();
    emitIsOperatorCheck(staticType, lhs, what);
    emitInstruction(MoveInstruction(target, environment.integer(0), concat('clear ', target.debugName)));
    emitInstruction(SetcInstruction(target, concat('store result in ', target.debugName)));
    emitInstruction(SetTypeInstruction(target, environment.intrinsicsLibrary.coreBooleanType));
  }
  
  // Caller should emit static and dynamic type checks on target.
  Slot emitSubroutineCall(Slot target, SlotList arguments, SourceLocationListNullable sourceLocations) {
    Type subroutineType;
    if (target is MethodSlot) {
      // we're dealing with a code address pointer
      subroutineType = (target as MethodSlot).subroutineType;
    } else if (target is CompiledSubroutineSlot) {
      subroutineType = (target as CompiledSubroutineSlot).subroutine.type;
    } else {
      subroutineType = target.staticType;
    }
    assert(subroutineType.isSubtypeOf(environment().subroutineType), 'cannot call a non-function');
    emitInstruction(CommentInstruction(concat('Call ', target.debugName, ' with ', len(arguments), ' arguments')));
    CompilationEnvironment env = environment();
    if (sourceLocations != null && subroutineType is AbstractSubroutineTypeWithSpecificParameters) {
      TypeList argumentTypes = []:Type;
      for (argument in arguments) {
        append(argumentTypes, argument.staticType);
      }
      (subroutineType as AbstractSubroutineTypeWithSpecificParameters).verifyArguments(argumentTypes, sourceLocations!);
    }
    Slot codeAddress;
    Boolean codeAddressIsDirect;
    DynamicSlot thisPointer;
    if (target is SubroutineSlot) {
      // As an optimization, if we know the target precisely, we can pull out its slot and
      // jump directly to it instead of dereferencing through the function pointer block.
      SlotNullable result = (target as SubroutineSlot).subroutine.inline(this, arguments);
      if (result != null) {
        return result;
      }
      codeAddress = CodeLabelSlot(env.intrinsicsLibrary.coreSubroutineCodeAddressType, (target as SubroutineSlot).subroutine.label, concat('code address of ', target.debugName));
      env.intrinsicsLibrary.coreSubroutineCodeAddressType.markConstructed();
      codeAddressIsDirect = true;
      thisPointer = registerDynamicValue(environment().intrinsicsLibrary.coreSentinelType, rcNever, 'this');
    } else if (target is CompiledSubroutineSlot) {
      // This is just a label directly, known at compile time, optionally with a "this" pointer.
      codeAddress = target;
      codeAddressIsDirect = true;
      if ((target as CompiledSubroutineSlot).thisSlot == null) {
        thisPointer = registerDynamicValue(environment().intrinsicsLibrary.coreSentinelType, rcNever, 'this');
      } else {
        thisPointer = (target as CompiledSubroutineSlot).thisSlot!;
      }
    } else if (target is MethodSlot) {
      // This is just a label directly, determined at runtime.
      codeAddress = target;
      codeAddressIsDirect = true;
      thisPointer = (target as MethodSlot).thisSlot;
    } else {
      codeAddress = target;
      codeAddressIsDirect = false; // meaning codeAddress is a pointer to the actual code address
      thisPointer = registerDynamicValue(lookupIntrinsicClass(environment().coreClassTypeIntrinsicName), rcNever, 'this');
      emitInstruction(MoveDerefInstruction(thisPointer, target, _subroutineReceiverPointer, 'read receiver pointer'));
      emitInstruction(MoveDerefToTypeInstruction(thisPointer, target, _subroutineReceiverType, 'read receiver type'));
    }
    Slot closurePointer = env.intrinsicsLibrary.coreSentinel; // placeholder code
    Type returnType = env.intrinsicsLibrary.coreAnythingType;
    if (subroutineType is AbstractSubroutineType) {
      returnType = (subroutineType as AbstractSubroutineType).returnType;
    }
    // If the type of the return value is one that can be reference counted, the callee will
    // increment the reference count before returning, and we must match that with a corresponding
    // decrement. This is handled by the slot manager when it cleans up returnValue.
    rc referenceCountStyle;
    if (returnType.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot returnValue = registerDynamicValue(returnType, referenceCountStyle, concat(target.debugName, ' return value'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      emitInstruction(PushInstruction(arguments[argumentIndex], concat('value of argument #', argumentIndex + 1, ' (', arguments[argumentIndex].debugName, ')')));
      emitInstruction(PushTypeInstruction(arguments[argumentIndex], env, concat('type of argument #', argumentIndex + 1)));
      argumentIndex -= 1;
    }
    DynamicSlot temporarySlot = registerDynamicValue(env.intrinsicsLibrary.coreIntegerType, rcNever, 'temporary slot');
    emitInstruction(MoveToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s value'));
    emitInstruction(PinSlotValueInstruction(returnValue));
    emitInstruction(LeaInstruction(temporarySlot, returnValue, 0, false, 'load address of return value\'s value'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 6: pointer to return value slot\'s value')); // (also does some RecordPushes)
    emitInstruction(MoveTypeToSpecificOperandInstruction(memory, returnValue, false, 'allocate space for return value\'s type'));
    emitInstruction(PinSlotTypeInstruction(returnValue));
    emitInstruction(LeaTypeInstruction(temporarySlot, returnValue, false, 'load address of return value\'s type'));
    emitInstruction(PushInstruction(temporarySlot, 'internal argument 5: pointer to return value slot\'s type')); // (also does some RecordPushes)
    env.intrinsicsLibrary.coreIntegerType.markConstructed(); // for env.integer call
    emitInstruction(SubInstruction(stackFrame().stackPointer, env.integer(0x20), stackFrame().stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // ("fake" pushes from changing the stack pointer)
    emitInstruction(MoveToSpecificOperandInstruction(r9.bit, thisPointer, true, 'internal argument 4: "this" pointer'));
    emitInstruction(PinSlotValueInstruction(thisPointer)); 
    emitInstruction(MoveTypeToSpecificOperandInstruction(r8.bit, thisPointer, true, 'internal argument 3: "this" pointer type'));
    emitInstruction(PinSlotTypeInstruction(thisPointer)); 
    emitInstruction(MoveToSpecificOperandInstruction(rdx.bit, closurePointer, true, 'internal argument 2: closure pointer'));
    //emitInstruction(PinSlotValueInstruction(closurePointer)); // TODO uncomment once we implement closures
    emitInstruction(MoveToSpecificOperandInstruction(rcx.bit, env.integer(len(arguments)), true, 'internal argument 1: number of actual arguments'));
    //emitInstruction(UnpinSlotValueInstruction(closurePointer)); // TODO uncomment once we implement closures
    emitInstruction(UnpinSlotTypeInstruction(thisPointer)); 
    emitInstruction(UnpinSlotValueInstruction(thisPointer));
    if (codeAddressIsDirect) {
      emitInstruction(CallInstruction(codeAddress, 'jump to subroutine'));
    } else {
      emitInstruction(CallDerefInstruction(codeAddress, _subroutineCodePointer, 'jump to subroutine'));
    }
    emitInstruction(UnpinSlotValueInstruction(returnValue));
    emitInstruction(UnpinSlotTypeInstruction(returnValue));
    emitInstruction(AddInstruction(stackFrame().stackPointer, env.integer(0x20 + 8 * 2 * len(arguments) + 16), stackFrame().stackPointer, 'release shadow space and arguments'));
    emitInstruction(RecordPopsInstruction(len(arguments) * 2 + 6)); // arguments, return value (and type), and shadow space
    return returnValue;
  }

  CompiledNestedScope createErrorHandlerBlock(SlotList arguments, String what) {
    CompiledScope block = CompiledNestedScope(this, concat(camelCase(what), '$Error'));
    block.emitInstruction(CommentInstruction(concat('Error handling block for ', what)));
    block.emitSubroutineCall(environment().intrinsicsLibrary.coreError, arguments, null /* sourceLocations */);
    block.references.add(environment().intrinsicsLibrary.coreError);
    return block;
  }

  Null emitTypeCheck(Slot value, Type staticType, Slot errorMessage, String what, Boolean trustSlotStaticType) {
    CompiledNestedScope block = createErrorHandlerBlock([errorMessage]:Slot, what); // TODO: need to include more arguments
    String continueLabelArg = concat(labelPrefix(), '$', camelCase(what));
    // TODO: xxxx we could also check if we can statically disprove compatibility
    // (or maybe assert that we can't, because if we can why is someone calling us)
    String continueLabel = environment().generateLabel(concat(continueLabelArg, '$TypeMatch'));
    if (!trustSlotStaticType || !value.canStaticallyProveTypeCompatibilityWith(staticType)) {
      emitInstruction(CommentInstruction(concat('type check of ', value.debugName, ' type ', value.staticType, ' expecting ', staticType)));
      emitIsOperatorCheck(staticType, value, what); // actual type check is here
      emitInstruction(JcInstruction(continueLabel, 'skip next block if the type matches'));
    } else {
      emitInstruction(CommentInstruction(concat('sentinel check of ', value.debugName, ' type ', value.staticType, ' expecting ', staticType)));
      // just check for sentinel (which might be present even if we trust the static type)
      // TODO: slots should track if they might be sentinel, so we can skip even this
      emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, environment().intrinsicsLibrary.coreSentinelType, continueLabel, concat('skip next block if ', value.debugName, ' is not sentinel')));
    }
    emitBlock(block);
    emitInstruction(LabelInstruction(continueLabel, 'after block'));
  }

  // runs block if a != b
  Null emitConditionalBlock(CompiledNestedScope block, CompiledNestedScopeNullable elseBlock, Slot a, Slot b, String what, String comment) {
    String labelElse;
    String labelEnd = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$continuation'));
    if (elseBlock == null) {
      labelElse = labelEnd;
    } else {
      labelElse = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$else'));
    }
    emitInstruction(JumpIfEqualInstruction(a, b, labelElse, comment));
    emitBlock(block);
    if (elseBlock != null) {
      emitInstruction(JumpInstruction(labelEnd, concat('jump past else part of ', what)));
      emitInstruction(LabelInstruction(labelElse, concat('else of ', what)));
      emitBlock(elseBlock!);
    }
    emitInstruction(LabelInstruction(labelEnd, concat('end of ', what)));
  }
  
  // Computes the pointer for subscripting a list.
  // Returned slot is a pointer to the type/value pair, not the actual value.
  Slot emitSubscriptEvaluation(Slot list, Slot index) {
    // Caller must apply static and dynamic type checks for list and index.
    String labelBase = concat(labelPrefix(), '$subscript');
    String boundsErrorLabel = environment().generateLabel(concat(labelBase, '$boundsError'));
    String continueLabel = environment().generateLabel(concat(labelBase, '$inBounds'));
    // TODO: add more arguments to createErrorHandlerBlock call
    references.add(environment().intrinsicsLibrary.boundsFailureMessage);
    CompiledNestedScope boundsErrorBlock = createErrorHandlerBlock([environment().intrinsicsLibrary.boundsFailureMessage]:Slot, 'subscript bounds error');
    Slot lengthSlot;
    Slot baseAddressSlot;
    if (list is VarArgsParameterSlot) {
      lengthSlot = (stackFrame() as CompiledSubroutine).parameterCount;
      baseAddressSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'base address of varargs');
      emitInstruction(LeaInstruction(baseAddressSlot, (list as VarArgsParameterSlot).baseAddress(environment().intrinsicsLibrary.coreIntegerType), 0, true, 'base address of varargs'));
    } else {
      // list -> ...
      //         ...
      //         ...
      //         ldp -> ...
      //                length
      //                ...
      //                actual list data
      Slot listDataPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to list data');
      lengthSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'length of list');
      baseAddressSlot = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'base address of list');
      emitInstruction(MoveDerefInstruction(listDataPointer, list, _listBlockData, 'list data is the second field in its block'));
      emitInstruction(MoveDerefInstruction(lengthSlot, listDataPointer, _gcBlockHeaderLength, 'read length from the list data block\'s metadata'));
      emitInstruction(LeaInstruction(baseAddressSlot, listDataPointer, _gcBlockData, true, 'compute address of 0th entry in list data block'));
    }
    emitInstruction(ConditionalJumpInstruction(index, lengthSlot, ccGreaterThanOrEqual, boundsErrorLabel, 'index out of range (too high)'));
    emitInstruction(ConditionalJumpInstruction(index, environment().integer(0), ccGreaterThanOrEqual, continueLabel, 'index not out of range (not negative)'));
    emitInstruction(LabelInstruction(boundsErrorLabel, 'invalid index'));
    emitBlock(boundsErrorBlock); // execution never leaves this block
    emitInstruction(LabelInstruction(continueLabel, 'valid index'));
    Slot shiftedIndex = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'index into list * 16');
    emitInstruction(ShiftInstruction('shl', index, environment().integer(4), shiftedIndex, 'multiply by 8*2'));
    Slot resultPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('pointer to ', list.debugName, '[', index.debugName, ']'));
    emitInstruction(AddInstruction(baseAddressSlot, shiftedIndex, resultPointer, concat('compute address of specified list entry')));
    return resultPointer;
  }


  // COMPILER PHASES

  Null addRemainingReferences() {
    // add any references that could not be added earlier
  }

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepare(this);
    }
  }

  Null generateAssemblerBlockPreamble(AssemblerBlock block) {
  }

  Null generateAssemblerBlockPostamble(AssemblerBlock block) {
  }

  // We tell the slot manager to move things out of certain registers so that we can tell the slot manager to do a read in the postamble
  // without trying to move whatever was in those registers into a stack slot (since doing so may affect the size of the stack, which is
  // not ideal when you're already figuring out the epilog).
  Null clearRegisters(AssemblerBlock subblock) {
    // e.g. slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    SlotManager manager = stackFrame().slotManager;
    manager.enterNestedScope(this, block);
    generateAssemblerBlockPreamble(block);
    for (instruction in instructions) {
      instruction.generateAssemblerBlock(block, manager);
      manager.endOfInstruction();
    }
    clearRegisters(block);
    manager.exitNestedScope(this, true);
    generateAssemblerBlockPostamble(block);
  }

  Null constructor(SlotContextNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg as CompiledScopeNullable;
    name = nameArg;
    prepareSlots();
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', labelPrefix(), ':', className, '@', internalObjectId, '>');
  }
}

class CompiledNestedScope extends CompiledScope {
  String labelPrefix() {
    return concat(parent!.labelPrefix(), '$', name);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    block.indent(super.generateAssemblerBlock);
  }

  Null constructor(CompiledScope parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledStackFrameScope extends CompiledScope {
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  // whether anything that is itself used references this
  Boolean isUsed = false;

  Null markUsed() {
    isUsed = true;
  }

  DynamicSlotList slots = []:DynamicSlot;

  DynamicSlot registerSlot(DynamicSlot slot) {
    append(slots, slot);
    return slot;
  }

  SlotManager slotManager;
  RegisterSlot stackPointer;
  RegisterSlot stackFramePointer;

  Null prepareSlots() {
    super.prepareSlots();
    stackPointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rsp, 'stack pointer');
    stackFramePointer = RegisterSlot(environment().intrinsicsLibrary.coreIntegerType, rbp, 'stack frame pointer');
  }

  Null allocateSlots(Assembler assembler) {
    Slot sentinel = environment().intrinsicsLibrary.coreSentinel;
    assert((sentinel.value(this) as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    assert((sentinel.dynamicType(this) as ImmediateIntegerOperand).value == 0, 'bss won\'t work with non-zero sentinel');
    for (slot in slots) {
      if (slot.referencedFromMultipleStackFrames) {
        assert(slot.homeScope is CompiledLibrary, 'closures not implemented');
        assert(slot.name != null, concat('slot has no name: ', slot));
        String valueLabel = environment().generateLabel(concat(slot.name, 'Value'));
        String typeLabel = environment().generateLabel(concat(slot.name, 'Type'));
        slot.initialize(null, DereferenceLabelOperand(valueLabel), DereferenceLabelOperand(typeLabel));
        assembler.addBss(typeLabel, 4, concat('dynamic type of ', slot.debugName));
        assembler.addBss(valueLabel, 4, slot.debugName);
      } else {
        if (!slot.initializeToRegisterScheduled) { // e.g. parameter count
          slot.initialize(this, sentinel.value(this), sentinel.dynamicType(this));
        }
      }
    }
  }

  Integer stackAdjustment;

  Null generatePrologAssemblerBlock(AssemblerBlock block) {
    block.addComment('Prolog');
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    for (register in registers) {
      block.addCode('push', [register], 'save non-volatile registers');
    }
    Integer stackSize = slotManager.stackSize();
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      // TODO: if stackSize > 8KB (0x2000), call __chkstk__
      assert(stackSize < 0x2000, 'need to implement calling __chkstk__');
      if ((stackSize + len(registers) * 0x08) % 0x10 != 0) {
        stackAdjustment = stackSize;
      } else {
        stackAdjustment = stackSize + 0x08;
      }
    } else if ((len(registers) * 0x08) % 0x10 != 0) {
      stackAdjustment = 0;
    } else {
      stackAdjustment = 0x08;
    }
    if (stackAdjustment != 0) {
      block.addCode('sub', [rsp, hex8(stackAdjustment)], 'allocate space for stack and align to 16 byte boundary');
    }
    block.addCode('lea', [rbp, concat('qword ptr [rsp + ', hex8(stackAdjustment + len(registers) * 0x08), ']')], 'set up frame pointer');
    assert(stackSize == slotManager.stackSize(), concat('prolog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    block.addComment('Epilog');
    Integer stackSize = slotManager.stackSize();
    if (stackAdjustment > 0) {
      block.addCode('add', [rsp, hex8(stackAdjustment)], 'free space for stack');
    }
    Register64OperandList registers = stackFrame().slotManager.usedRegisters.values() as Register64OperandList;
    Integer index = len(registers);
    while (index > 0) {
      index -= 1;
      block.addCode('pop', [registers[index]], 'restore non-volatile registers');
    }
    assert(stackSize == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', stackSize, ' now is ', slotManager.stackSize(), ')'));
  }

  Null initializeParameters() {
    // e.g. slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
  }

  Null generateAssemblerBlockPreamble(AssemblerBlock block) {
    initializeParameters();
    super.generateAssemblerBlockPreamble(block);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    slotManager = SlotManager(this, environment().intrinsicsLibrary.coreStringType, environment().intrinsicsLibrary.coreGarbageCollectableType, environment().intrinsicsLibrary.coreSentinelType, concat(name, ' (slot manager)'));
    slotManager.pin(stackPointer);
    slotManager.pin(stackFramePointer);
    AssemblerBlock subblock = block.createBlock();
    super.generateAssemblerBlock(subblock);
    generatePrologAssemblerBlock(block);
    Integer debugOriginalStackSize = slotManager.stackSize();
    block.addBlock(subblock);
    generateEpilogAssemblerBlock(block);
    assert(debugOriginalStackSize == slotManager.stackSize(), concat('epilog changed the stack size of ', name, ' (was ', debugOriginalStackSize, ' now is ', slotManager.stackSize(), ')'));
    slotManager.dispose();
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineTypeWithSpecificParameters type; // subroutine signature
  ClassTypeNullable parentClass;
  String label;
  String epilogLabel;

  // The parameter that contains a pointer to the return value.
  ReturnValuePointerSlot returnValuePointer;
  // The parameter that contains a pointer to the return value type.
  ReturnValueTypePointerSlot returnValueTypePointer;

  Null markUsed() {
    super.markUsed();
    type.markConstructed();
  }

  SubroutineSlotNullable slot = null;
  String functionPointerLabel;

  Null adoptSlot(SubroutineSlot slotArg) {
    slot = slotArg;
    environment().intrinsicsLibrary.coreSubroutineCodeAddressType.markConstructed();
  }

  Null allocateSlots(Assembler assembler) {
    super.allocateSlots(assembler);
    if (slot != null) {
      functionPointerLabel = environment().generateLabel(concat(labelPrefix(), '$', 'functionPointer'));
      assembler.addData(
        functionPointerLabel,
        [
          'dq 1',
          'dq 2',
          'dq 0',
          'dq -1',
          concat('dq ', environment().intrinsicsLibrary.coreNullType.code),
          'dq 0',
          concat('dq ', environment().intrinsicsLibrary.coreSubroutineCodeAddressType.code),
          concat('dq ', label),
        ]:String,
        [
          'reference count',
          'number of fields in function pointer block',
          'scratch space for garbage collector',
          'block list entry pointer (invalid for function pointers as they are not in the block list)',
          'type of receiver (Null)',
          'pointer to receiver (null)',
          'type of code pointer (Integer)',
          'code pointer',
        ]:StringNullable,
      );
    }
  }

  String labelPrefix() {
    if (parentClass == null) {
      return concat('func$', name);
    }
    return concat('method$', parentClass!.name, '$', name);
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    return null;
  }

  // This is called from other scopes (where we need to emit the instructions),
  // hence the scope argument.
  // Caller is expected to do any needed static type checks.
  Null emitReturnFrom(CompiledScope scope, Slot value) {
    scope.references.add(environment().intrinsicsLibrary.returnValueTypeCheckFailureMessage);
    scope.emitTypeCheck(value, type.returnType, environment().intrinsicsLibrary.returnValueTypeCheckFailureMessage as Slot, concat(name, ' return value'), true); // xxx mention the fact that it's a type check in the [what] argument
    scope.emitInstruction(MoveToDerefInstruction(returnValuePointer, value, 0, concat(name, ' return value')));
    scope.emitInstruction(MoveTypeToDerefInstruction(returnValueTypePointer, value, 0, environment(), concat('type of ', name, ' return value')));
    scope.emitIncref(value, true); // matched by DynamicSlot doing a decref on the receiving end (see emitSubroutineCall)
    scope.emitInstruction(SyntheticNestedAllScopesExitInstruction(scope));
    scope.emitInstruction(JumpInstruction(epilogLabel, 'return'));
  }

  DynamicSlot parameterCount;
  DynamicSlot thisPointer;
  ConstantSlot nameConstant;

  Boolean isMethod() {
    return parentClass != null;
  }

  Null prepareSlots() {
    label = environment().generateLabel(labelPrefix());
    epilogLabel = environment().generateLabel(concat(labelPrefix(), '$epilog'));
    returnValuePointer = ReturnValuePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value of ', name));
    returnValueTypePointer = ReturnValueTypePointerSlot(environment().intrinsicsLibrary.coreIntegerType, concat('pointer to return value type of ', name));
    parameterCount = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('parameter count of ', name));
    parameterCount.willInitializeToRegister(this);
    if (isMethod()) {
      thisPointer = registerVariable('this', parentClass!);
      thisPointer.willInitializeToRegister(this);
    }
    environment().intrinsicsLibrary.coreStringType.markConstructed();
    nameConstant = environment().registerStringConstant(concat(label, '$annotation'), name, __LINE__, __COL__, __FILE__);
    references.add(nameConstant);
    super.prepareSlots();
  }

  IdentifierEntityNullable localLookupIdentifier(String name) {
    IdentifierEntityNullable value = super.localLookupIdentifier(name);
    if (value == null && parentClass != null) { // explicitly _not_ using isMethod(), we don't know the runtime type!
      MemberDescriptionNullable member = parentClass!.getMember(name);
      if (member != null && member!.isDefined()) {
        return parentClass!.createIdentifierEntity(this, thisPointer, name);
      }
    }
    return value;
  }

  Null prepareInstructions() {
    if (len(instructions) == 0 || !(last(instructions) is JumpInstruction)) {
      emitInstruction(CommentInstruction(concat('Implicit return from ', name)));
      // xxxx should statically check that we don't get here if null is not a valid return value
      emitReturnFrom(this, environment().intrinsicsLibrary.coreNull);
    }
    super.prepareInstructions();
  }

  Null initializeParameters() {
    slotManager.initialize(parameterCount, rcx, parameterCount.staticType.asOperand());
    if (isMethod()) {
      slotManager.initialize(thisPointer, r9, r8);
    }
  }

  Null clearRegisters(AssemblerBlock subblock) {
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(rax.bit) as RegisterEntry);
  }

  Null generateFinalSlotManagerCleanup(AssemblerBlock block) {
    emitMov(block, rax, returnValuePointer.value(this), 'report address of return value');
  }

  Null generateAssemblerBlockPostamble(AssemblerBlock block) {
    super.generateAssemblerBlockPostamble(block);
    block.addLabel(epilogLabel, null);
    generateFinalSlotManagerCleanup(block);
  }

  Null generateFinalReturn(AssemblerBlock block) {
    block.addCode('ret', [], 'return from subroutine');
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    super.generateEpilogAssemblerBlock(block);
    generateFinalReturn(block);
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock block = assembler.createBlock();
    generateAssemblerBlock(block);
    assembler.addLabeledBlock(label, block, name, nameConstant.label);
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg, ClassTypeNullable parentClassArg) {
    parentClass = parentClassArg as ClassTypeNullable;
    super.constructor(parentArg, nameArg);
    type = typeArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class CompiledSubroutineWithSpecificParameters extends CompiledSubroutine {
  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = ParameterSlot(type, position, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitParameterChecks(SlotList parameters) {
    // check for parameter count
    emitInstruction(CommentInstruction('Check parameter count'));
    Slot expectedParamCountValue = environment().integer(len(parameters));
    // TODO: add more arguments to createErrorHandlerBlock call
    references.add(environment().intrinsicsLibrary.parameterCountCheckFailureMessage);
    CompiledNestedScope block = createErrorHandlerBlock(
      [ environment().intrinsicsLibrary.parameterCountCheckFailureMessage ]:Slot,
      'parameter count',
    );
    emitConditionalBlock(block, null, parameterCount, expectedParamCountValue, 'parameter count check', 'check number of parameters is as expected');
    Integer index = 0;
    for (parameter in parameters) {
      emitInstruction(CommentInstruction(concat('Check type of parameter ', index, ', ', parameter.debugName, ' (expecting ', parameter.staticType, ')')));
      references.add(environment().intrinsicsLibrary.parameterTypeCheckFailureMessage);
      emitTypeCheck(parameter, parameter.staticType, environment().intrinsicsLibrary.parameterTypeCheckFailureMessage, parameter.debugName, false); // xxx don't use debugName for [what] argument
      index += 1;
    }
  }
}

class CompiledVarArgsSubroutine extends CompiledSubroutine {
  Slot registerVarArgsParameter(String name, Type type) {
    ReadOnlyListType listType = createOrFindReadOnlyListType(environment(), type);
    listType.markConstructed();
    assert(identifiers.length == 0, 'varargs subroutine had multiple identifiers in scope');
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter name');
    Slot slot = VarArgsParameterSlot(listType, parameterCount, name);
    identifiers.set(name, slot);
    return slot;
  }

  Null emitVarArgsParameterChecks(Type parameterType, VarArgsParameterSlot varargs) {
    // TODO: add more arguments to createErrorHandlerBlock call
    references.add(environment().intrinsicsLibrary.parameterTypeCheckFailureMessage);
    CompiledNestedScope block = createErrorHandlerBlock([ environment().intrinsicsLibrary.parameterTypeCheckFailureMessage ]:Slot, 'vararg types');
    doIfVarArgsTypeMismatch(parameterType, varargs, concat(labelPrefix(), '$varargTypeChecks'), block, 'vararg types');
  }
}

class CompiledGeneratedConstructorSubroutine extends CompiledSubroutine {
  Slot actualConstructor;
  
  Null setActualConstructor(Slot slot) {
    actualConstructor = slot;
  }

  Null clearRegisters(AssemblerBlock subblock) {
    super.clearRegisters(subblock);
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(rcx.bit) as RegisterEntry);
    //slotManager.clearRegisterEntry(slotManager.registerStatus.get(rdx.bit) as RegisterEntry);
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(r8.bit) as RegisterEntry); // this type
    slotManager.clearRegisterEntry(slotManager.registerStatus.get(r9.bit) as RegisterEntry); // this value
  }

  Null generateFinalSlotManagerCleanup(AssemblerBlock block) {
    super.generateFinalSlotManagerCleanup(block);
    block.addComment('generateFinalSlotManagerCleanup!');
    emitMov(block, rcx, parameterCount.value(this), 'restore rcx (parameter count)');
    //emitMov(block, rdx, closure.value(this), 'restore rdx (closure pointer)');
    emitMov(block, r8, thisPointer.dynamicType(this), 'restore r8 (this type)');
    emitMov(block, r9, thisPointer.value(this), 'restore r9 (this value)');
  }

  Null prepareInstructions() {
    super.prepareInstructions();
    parameterCount.markNeededForever(this);
    thisPointer.markNeededForever(this);
  }

  Boolean isMethod() {
    return false;
  }

  Null setThisPointer(DynamicSlot thisPointerArg) {
    thisPointer = thisPointerArg;
  }

  Null generateFinalReturn(AssemblerBlock block) {
    Slot fakeReturnValue = FakeReturnValueSlot(environment().intrinsicsLibrary.coreNullType, 'return value for \'constructor\'');
    block.addCode('lea', [ r11, fakeReturnValue.dynamicType(this).toString() ], 'give \'constructor\' the location of our fake return type');
    block.addCode('mov', [ returnValueTypePointer.epilogValue(this).toString(), r11 ], 'give \'constructor\' the location of our fake return type');
    block.addCode('lea', [ r11, fakeReturnValue.value(this).toString() ], 'give \'constructor\' the location of our fake return value');
    block.addCode('mov', [ returnValuePointer.epilogValue(this).toString(), r11 ], 'give \'constructor\' the location of our fake return value');
    block.addCode('jmp', [ (actualConstructor as TailRecursionCodePointerSlot).epilogValue().toString() ], 'tail recurse into actual constructor');
  }
}

class BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters {
  SlotList parameters;

  StringList parameterDescriptions() {
    return []:String;
  }

  // used to generate the instructions for the subroutine
  Null generateInstructions() { }

  Null prepareInstructions() {
    parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    StringList descriptions = parameterDescriptions();
    assert(len(descriptions) == len(signature.parameterTypes), concat(className, '.parameterDescriptions() returned an unexpected number of descriptions (descriptions were ', descriptions, '; parameter types were ', signature.parameterTypes, ')'));
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, descriptions[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    generateInstructions();
    super.prepareInstructions();
  }
}

class BuiltInErrorSubroutine extends CompiledSubroutine {
  SlotNullable errorSlot;

  Null addRemainingReferences() {
    super.addRemainingReferences();
    errorSlot = lookupIntrinsic(environment().errorIntrinsicName);
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    assert(errorSlot != null, '"error" intrinsic undefined');
    assert(errorSlot is SubroutineSlot, '"error" intrinsic has wrong type');
    block.addCode('jmp', [ (errorSlot as SubroutineSlot).subroutine.label ], 'trampoline to error intrinsic');
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) {
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithVarArgs(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreWhateverType ]:Type,
      ),
      '__error',
      null /* parentClass */,
    );
  }
}

class BuiltInGetterMethod extends BuiltInSubroutine {
  MemberDescription member;

  StringList parameterDescriptions() {
    return []:String;
  }

  Null generateInstructions() {
    assert(isMethod(), 'BuiltInGetterMethod is not a method');
    if (member.isField) {
      assert(member.needsField, 'isField but !needsField ?!');
      Slot result = registerDynamicValue(type.returnType, rcNever, concat(parentClass!.name, '.', member.name));
      assert(_gcBlockData > 0, concat('invalid _gcBlockData: ', _gcBlockData));
      assert(member.fieldIndex! >= 0, concat('invalid field index for ', parentClass!.name, '.', member.name, ': ', member.fieldIndex));
      emitInstruction(MoveDerefInstruction(result, thisPointer, _gcBlockData + member.fieldIndex * 16 + 8, concat('fetch value of ', parentClass!.name, '.', member.name)));
      emitInstruction(MoveDerefToTypeInstruction(result, thisPointer, _gcBlockData + member.fieldIndex * 16, concat('fetch type of ', parentClass!.name, '.', member.name)));
      emitReturnFrom(this, result);
    } else {
      assert(member.methodImplementation != null, 'not field but has no method?');
      member.staticType.markConstructed();
      emitReturnFrom(this, emitSubroutineCall(
        lookupIntrinsic(environment().createMethodPointerIntrinsicName),
        [
          thisPointer,
          CompiledSubroutineSlot(member.methodImplementation!, thisPointer /* not used*/),
          TypeCodeSlot(environment(), member.staticType),
        ]:Slot,
        null /* sourceLocations */,
      ));
    }
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, ClassType classArg, MemberDescription memberArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), memberArg.staticType, []:Type),
      concat(classArg.name, '$', memberArg.name, '$getter'),
      classArg,
    );
    member = memberArg;
    assert(!isUsed, 'remove markUsed');
    markUsed(); // TODO: track usage of methods
    if (isUsed) {
      prepareInstructions();
    }
  }
}

class BuiltInSetterMethod extends BuiltInSubroutine {
  MemberDescription member;

  StringList parameterDescriptions() {
    return []:String;
  }

  Null generateInstructions() {
    if (!member.isField) {
      // TODO: provide more arguments to the createErrorHandlerBlock() call
      references.add(environment().intrinsicsLibrary.assignToMethodMessage);
      emitBlock(createErrorHandlerBlock([ environment().intrinsicsLibrary.assignToMethodMessage ]:Slot, 'method_assigning'));
    }
    super.generateInstructions();
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, ClassType classArg, MemberDescription memberArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.coreNullType, []:Type),
      concat(classArg.name, '$', memberArg.name, '$setter'),
      classArg,
    );
    member = memberArg;
    assert(!isUsed, 'remove markUsed');
    markUsed(); // TODO: track usage of methods
    if (isUsed) {
      prepareInstructions();
    }
  }
}

class BuiltInLenSubroutine extends BuiltInSubroutine {
  StringList parameterDescriptions() {
    return ['list'];
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 1 && arguments[0] is VarArgsParameterSlot) {
      return (arguments[0] as VarArgsParameterSlot).length();
    }
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    Slot listDataPointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'pointer to list data');
    emitInstruction(MoveDerefInstruction(listDataPointer, parameters[0], _listBlockData, 'list data is the second field in its block'));
    Slot length = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, 'length of list');
    emitInstruction(MoveDerefInstruction(length, listDataPointer, _gcBlockHeaderLength, 'list length is a field in the list data'));
    emitInstruction(SetTypeInstruction(length, environment().intrinsicsLibrary.coreIntegerType));
    emitReturnFrom(this, length);
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ createOrFindReadOnlyListType(parentArg.environment(), parentArg.coreWhateverType) ]:Type,
      ),
      'len',
      null /* parentClass */,
    );
  }
}

class BuiltInDebuggerSubroutine extends BuiltInSubroutine {
  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    if (len(arguments) == 0) {
      scope.emitInstruction(Interrupt3Instruction());
      return environment().intrinsicsLibrary.coreNull;
    }
    assert(false, concat('inline __debugger() takes 0 arguments, got ', len(arguments)));
    return null;
  }

  Null generateInstructions() {
    super.generateInstructions();
    emitInstruction(Interrupt3Instruction());
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        []:Type,
      ),
      '__debugger',
      null /* parentClass */,
    );
  }
}

class CompilerIntrinsic extends BuiltInSubroutine {
  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    abstract();
  }

  Boolean verifyArguments(SlotList arguments, TypeList parameters) {
    assert(len(parameters) == len(arguments), 'unexpected number of arguments');
    Integer index = 0;
    while (index < len(arguments)) {
      assert(
        arguments[index].staticType.isSubtypeOf(parameters[index]),
        concat('argument ', index+1, ' of ', name, '() has unexpected type (wanted ', parameters[index], ' but got ', arguments[index].staticType, ')'),
      );
      index += 1;
    }
    return true;
  }

  SlotNullable inline(CompiledScope scope, SlotList arguments) {
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    assert(verifyArguments(arguments, signature.parameterTypes), 'unexpected arguments');
    Slot result = inlineBody(scope, arguments);
    assert(result.staticType == signature.returnType, concat(this, ' returned slot of wrong type (expected ', signature.returnType, ' but got ', result.staticType, ')'));
    return result;
  }
}

class BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    Slot returnValue = scope.registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat('dereferenced ', arguments[0].debugName));
    scope.emitInstruction(MoveDerefInstruction(returnValue, arguments[0], 0, 'dereference first argument of __readFromAddress'));
    scope.emitInstruction(SetTypeInstruction(returnValue, returnValue.staticType));
    return returnValue;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreIntegerType,
        [ parentArg.coreIntegerType ]:Type,
      ),
      '__readFromAddress',
      null /* parentClass */,
    );
  }
}

// this is for increffing strings if they are strings.
class BuiltInIncrefIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['value'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    scope.emitIncref(arguments[0], false);
    return scope.environment().intrinsicsLibrary.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreAnythingType ]:Type,
      ),
      '__incref',
      null /* parentClass */,
    );
  }
}

class BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic {
  StringList parameterDescriptions() {
    return ['address', 'value'];
  }

  Slot inlineBody(CompiledScope scope, SlotList arguments) {
    scope.emitInstruction(MoveToDerefInstruction(arguments[0], arguments[1], 0, '__writeToAddress'));
    return scope.environment().intrinsicsLibrary.coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.coreNullType,
        [ parentArg.coreIntegerType, parentArg.coreIntegerType ]:Type,
      ),
      '__writeToAddress',
      null /* parentClass */,
    );
  }
}

class GenericSystemCallSubroutine extends CompiledSubroutineWithSpecificParameters {
  StringList parameterNames;
  String externalName;
  String library;

  Null prepareInstructions() {
    SlotList parameters = []:Slot;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterSlot(signature.parameterTypes[index], index, parameterNames[index]));
      index += 1;
    }
    emitParameterChecks(parameters);
    emitInstruction(CommentInstruction(concat('Calling ', externalName)));
    Integer stackAlignment;
    if (max(0, index - 4) % 2 == 0) {
      stackAlignment = 0x20;
    } else {
      emitInstruction(PushInstruction(environment().integer(0x8877665544332211), 'align stack'));
      stackAlignment = 0x28;
    }
    index -= 1;
    while (index > 3) {
      emitInstruction(PushInstruction(parameters[index], concat('argument #', index + 1)));
      index -= 1;
    }
    Register64OperandList parameterRegisters = [rcx, rdx, r8, r9];
    while (index >= 0) {
      emitInstruction(MoveToSpecificOperandInstruction(parameterRegisters[index].bit, parameters[index], true, concat('argument #', index + 1)));
      index -= 1;
    }
    emitInstruction(SubInstruction(stackPointer, environment().integer(0x20), stackPointer, 'allocate shadow space'));
    emitInstruction(RecordPushesInstruction(4)); // shadow space
    // It doesn't really make sense for the return value to ever be GarbageCollectable or String but if it is then
    // the emitReturnFrom below will incref it for us. Therefore we don't bother making our temporary reference counted.
    Slot returnValue = registerDynamicValue(type.returnType, rcNever, concat('return value of ', externalName, ' system call'));
    emitInstruction(CallSystemInstruction(library, externalName, returnValue, concat('calls ', externalName, ' from ', library)));
    emitInstruction(AddInstruction(stackPointer, environment().integer(stackAlignment + 0x08 * max(0, len(parameters) - 4)), stackPointer, 'release shadow space and arguments if there were more than four'));
    emitInstruction(RecordPopsInstruction((stackAlignment / 0x08) + max(0, len(parameters) - 4))); // shadow space and any arguments that didn't fit in the registers
    emitInstruction(SetTypeInstruction(returnValue, type.returnType));
    emitReturnFrom(this, returnValue);
    super.prepareInstructions();
  }

  Null constructor(CompiledScope parentArg, Type returnTypeArg, TypeList argumentTypesArg, StringList parameterNamesArg, String libraryArg, String externalNameArg, String internalNameArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), returnTypeArg, argumentTypesArg),
      internalNameArg,
      null /* parentClass */,
    );
    parameterNames = parameterNamesArg;
    library = libraryArg;
    externalName = externalNameArg;
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  String labelPrefix() {
    return camelCase(name);
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  IdentifierEntityNullable internalLookupIdentifier(String name) {
    IdentifierEntityNullable result = super.internalLookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.internalLookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(!environment().isCompoundType(type.name), 'tried to declare a type that ends with a generic suffix');
    assert(types.get(type.name) == null, 'tried to redefine a type name'); // TODO: hoist this into real error messages in the AST
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = library.lookupType(name);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssemblerBlock(AssemblerBlock block) {
    if (len(instructions) == 0) {
      return;
    }
    block.addBlankLine();
    block.addComment(name);
    block.addComment(stringTimes('=', len(scalarValues(name))));
    super.generateAssemblerBlock(block);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    compilationEnvironment = compilationEnvironmentArg;
    super.constructor(null, nameArg);
    if (!(this is CompiledIntrinsicsLibrary)) {
      importLibrary(compilationEnvironment.intrinsicsLibrary);
    }
    CompiledLibraryNullable runtimeLibrary = compilationEnvironment.runtimeLibrary;
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledInternalProcedure extends CompiledStackFrameScope {
  String labelPrefix() {
    return name;
  }

  Type type() {
    return environment().intrinsicsLibrary.coreSystemType;
  }

  Null generateEpilogAssemblerBlock(AssemblerBlock block) {
    super.generateEpilogAssemblerBlock(block);
    block.addCode('ret', [], 'return from compiler-internal function');
  }

  Null generateAssembler(Assembler assembler) {
    AssemblerBlock block = assembler.createBlock();
    generateAssemblerBlock(block);
    assembler.addLabeledBlock(name, block, null, null);
  }
}

class DecrefCompiledInternalProcedure extends CompiledInternalProcedure {
  DynamicSlot value;
  Boolean canBeGarbageCollectable;
  Boolean canBeString;
  Boolean checkFirst;

  Null prepareSlots() {
    // We don't want our parameter to be automatically reference counted since we are going to manually decrement its reference count.
    value = registerDynamicValue(environment().intrinsicsLibrary.coreAnythingType, rcNever, 'value');
    value.willInitializeToRegister(this);
    super.prepareSlots();
  }

  Null initializeParameters() {
    slotManager.initialize(value, rcx, rdx);
  }

  Null prepareInstructions() {
    emitInstruction(CommentInstruction('Body'));
    // This intentionally skips doing the synthetic block exits for simplicity, but as a result
    // this code is technically wrong. We should find a way to make the slot manager's block
    // management to be unnecessary or at least less invasive so as to make this correct while
    // remaining more simple than it would be with all the correct blocks.
    String decrefEndLabel = environment().generateLabel(concat(name, '$end'));
    Slot valueDeref = DerefSlot(environment().intrinsicsLibrary.coreIntegerType, value, 'value dereferenced');
    // if value is a string or garbage-collectable then valueDeref is the reference count
    if (canBeGarbageCollectable) {
      assert(checkFirst, 'should have used a direct "dec" instead');
      emitIsOperatorCheck(environment().intrinsicsLibrary.coreGarbageCollectableType, value, value.debugName);
      String notGarbageCollectableLabel;
      if (canBeString) {
        notGarbageCollectableLabel = environment().generateLabel(concat(name, '$string'));
      } else {
        notGarbageCollectableLabel = decrefEndLabel;
      }
      emitInstruction(JncInstruction(notGarbageCollectableLabel, concat(value.debugName, 'skip GC decref block if the value is not GarbageCollectable')));
      emitInstruction(DecInstruction(valueDeref, concat('decref GarbageCollectable reference count of ', value.debugName)));
      emitInstruction(JumpInstruction(decrefEndLabel, 'return'));
      if (canBeString) {
        emitInstruction(LabelInstruction(notGarbageCollectableLabel, 'string decref'));
      }
    }
    if (canBeString) {
      if (checkFirst) {
        emitInstruction(JumpIfDynamicTypeNotEqualStaticTypeInstruction(value, environment().intrinsicsLibrary.coreStringType, decrefEndLabel, 'skip string decref block if the value is not a String'));
      }
      emitInstruction(ConditionalJumpInstruction(valueDeref, environment().integer(0), ccLessThan, decrefEndLabel, 'skip string decref block for string constants'));
      emitInstruction(DecJccInstruction(valueDeref, ccNonZero, decrefEndLabel, concat('decrement reference count of ', value.debugName)));  
      Slot pointer = registerDynamicValue(environment().intrinsicsLibrary.coreIntegerType, rcNever, concat(value.debugName, ' cast to integer'));
      emitInstruction(MoveInstruction(pointer, value, 'copy value of value to pointer'));  
      emitInstruction(SetTypeInstruction(pointer, environment().intrinsicsLibrary.coreIntegerType));  
      emitSubroutineCall(lookupIntrinsic(environment().freeIntrinsicName), [pointer], null);
    }
    emitInstruction(LabelInstruction(decrefEndLabel, 'end of function'));
    super.prepareInstructions();
  }

  Null constructor(Boolean canBeGarbageCollectableArg, Boolean canBeStringArg, Boolean checkFirstArg, String labelArg, CompiledScope parentArg) {
    super.constructor(parentArg, labelArg);
    canBeGarbageCollectable = canBeGarbageCollectableArg;
    canBeString = canBeStringArg;
    checkFirst = checkFirstArg;
    assert(!canBeGarbageCollectable || checkFirst, 'Instead of using a DecrefCompiledInternalProcedure for the case of decreffing a known GC-able reference, just use "dec". (true, x, false)');
    assert(canBeGarbageCollectable || canBeString, 'This decref would be pointless... (false, false, x)');
  }
}

class CompiledIntrinsicsLibrary extends CompiledLibrary {
  String labelPrefix() {
    return 'intrinsics';
  }

  AnythingType coreAnythingType;
  WhateverType coreWhateverType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;
  ListDataType coreListDataType;
  GarbageCollectableType coreGarbageCollectableType;

  ClosureType coreClosureType; // will be used eventually, so #ignore_unused
  SystemType coreSystemType;
  SubroutineCodeAddressType coreSubroutineCodeAddressType;
  SentinelType coreSentinelType;

  ImmediateSlot coreSentinel;
  ImmediateSlot coreNull;
  ImmediateSlot coreTrue; // included for completeness, so #ignore_unused
  ImmediateSlot coreFalse;

  Slot coreError; // Trampoline to the intrinsic in the RTL, available before the RTL is compiled.

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;
  Slot returnValueTypeCheckFailureMessage;
  Slot operandTypeCheckFailureMessage;
  Slot assignmentTypeCheckFailureMessage;
  Slot subscriptTypeCheckFailureMessage;
  Slot forLoopIterableTypeCheckFailureMessage;
  Slot subroutineCallTypeCheckFailureMessage;
  Slot asOperatorFailureMessage;
  Slot boundsFailureMessage;
  Slot assignToMethodMessage;

  Map internalProcedures = Map(); // ip -> CompiledInternalProcedureSlot

  CompiledInternalProcedureSlot lookupInternalProcedureSlot(ip procedure) {
    return internalProcedures.get(procedure);
  }

  Null prepareSlots() {
    // We don't call super.prepareSlots yet.
    // We do it after we build intrinsicsLibrary instead
    // see below (mid way through generateScopes).
  }

  Null prepareInstructions() {
    super.prepareInstructions();
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.prepareInstructions();
      }
    }
  }

  Null allocateSlots(Assembler assembler) {
    super.allocateSlots(assembler);
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.allocateSlots(assembler);
      }
    }
  }

  Null generateAssembler(Assembler assembler) {
    for (slot in internalProcedures.values()) {
      if ((slot as CompiledInternalProcedureSlot).compiledInternalProcedure.isUsed) {
        (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.generateAssembler(assembler);
      }
    }
  }

  Null generateScopes() {
    CompilationEnvironment environment = environment();
    // internal types
    coreClosureType = ClosureType(environment);
    coreSystemType = SystemType(environment);
    coreSentinelType = SentinelType(environment);
    // built-in types
    coreAnythingType = AnythingType(environment);
    declareType(coreAnythingType);
    coreWhateverType = WhateverType(environment);
    declareType(coreWhateverType);
    coreSentinel = ImmediateIntegerSlot(coreSentinelType, 0, 'sentinel slot');
    coreSentinelType.markConstructed();
    coreNullType = NullType(environment);
    declareType(coreNullType);
    coreNull = registerNumericConstant('null', 0x00, coreNullType);
    coreBooleanType = BooleanType(environment);
    declareType(coreBooleanType);
    coreFalse = registerNumericConstant('false', 0x00, coreBooleanType);
    coreTrue = registerNumericConstant('true', 0x01, coreBooleanType);
    coreIntegerType = IntegerType(environment);
    declareType(coreIntegerType);
    coreStringType = StringType(environment);
    declareType(coreStringType);
    coreListDataType = ListDataType(environment);
    declareType(coreListDataType);
    coreGarbageCollectableType = GarbageCollectableType(environment);
    declareType(coreGarbageCollectableType);
    // intrinsic types
    coreSubroutineCodeAddressType = SubroutineCodeAddressType(environment);
    declareType(coreSubroutineCodeAddressType);

    // now that we have the types ready, set up the slots (like stackFramePointer)
    // which are used by the built-in functions
    super.prepareSlots();

    // built-in functions
    coreError = registerSubroutine(BuiltInErrorSubroutine(this), false);

    // built-in functions not used from compiler
    registerSubroutine(BuiltInLenSubroutine(this), false);
    registerSubroutine(BuiltInDebuggerSubroutine(this), false);

    // intrinsic functions (functions that only work when inlined)
    registerSubroutine(BuiltInReadFromAddressIntrinsic(this), false);
    registerSubroutine(BuiltInWriteToAddressIntrinsic(this), false);
    registerSubroutine(BuiltInIncrefIntrinsic(this), false);

    // compiler-internal functions
    internalProcedures.set(ipDecrefMaybeGCOrString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(true, true, true, 'decrefMaybeGCOrString', this)));
    internalProcedures.set(ipDecrefMaybeGC, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(true, false, true, 'decrefMaybeGC', this)));
    internalProcedures.set(ipDecrefMaybeString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(false, true, true, 'decrefMaybeString', this)));
    internalProcedures.set(ipDecrefString, CompiledInternalProcedureSlot(DecrefCompiledInternalProcedure(false, true, false, 'decrefString', this)));
    for (slot in internalProcedures.values()) {
      references.add(slot); // TODO: this is a hack to keep these as referenced since the slot manager happens too late currently to track this
      // (eventually the right fix is to do the dead code elimination after we insert reference counting instructions)
      (slot as CompiledInternalProcedureSlot).compiledInternalProcedure.prepareSlots();
    }

    // messages
    coreStringType.markConstructed();
    parameterCountCheckFailureMessage = environment.registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = environment.registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    returnValueTypeCheckFailureMessage = environment.registerStringConstant(
      'returnValueTypeCheckFailureMessage',
      'error: type mismatch for function return value, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    operandTypeCheckFailureMessage = environment.registerStringConstant(
      'operandTypeCheckFailureMessage',
      'error: type mismatch for operand, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    assignmentTypeCheckFailureMessage = environment.registerStringConstant(
      'assignmentTypeCheckFailureMessage',
      'error: type mismatch for assignment, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    subscriptTypeCheckFailureMessage = environment.registerStringConstant(
      'subscriptTypeCheckFailureMessage',
      'error: subscript index must be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    forLoopIterableTypeCheckFailureMessage = environment.registerStringConstant(
      'forLoopIterableTypeCheckFailureMessage',
      'error: for loop iterable must be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    subroutineCallTypeCheckFailureMessage = environment.registerStringConstant(
      'subroutineCallTypeCheckFailureMessage',
      'error: function calls expect target to be %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    asOperatorFailureMessage = environment.registerStringConstant(
      'asOperatorFailureMessage',
      'error: type mismatch for as operator, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    boundsFailureMessage = environment.registerStringConstant(
      'boundsFailureMessage',
      'error: subscript index out of range (%d is not in range %d..%d)\n',
      __LINE__, __COL__, __FILE__,
    );
    assignToMethodMessage = environment.registerStringConstant(
      'assignToMethodMessage',
      'error: tried to assign to a method',
      __LINE__, __COL__, __FILE__,
    );
  }
}
