import 'core.syd';
import 'syd-utils.syd';
import 'syd-types.syd';
import 'syd-vots.syd';
import 'syd-assembler.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

// ============================================================================
// VOT HANDLES
// ============================================================================

class TypeHandle extends Object {
  TypeVotNullable type = null;

  Null assign(TypeVot typeArg) {
    assert(type == null, 'cannot assign a type handle twice');
    type = typeArg;
  }

  Null constructor(TypeVotNullable typeArg) {
    super.constructor();
    if (typeArg != null) {
      assign(typeArg!);
    }
  }
}

class ValueHandle extends Object {
  VotSource source;
  ValueVotNullable value = null;
  TypeHandle type;

  Null forceAllocation() {
    source.forceAllocation();
  }

  Null assign(ValueVot valueArg) {
    assert(value == null, 'cannot assign a value handle twice');
    assert(valueArg.staticType.isSubtypeOf(source.staticType), concat('cannot assign ', valueArg.staticType, ' to ', source.staticType));
    value = valueArg;
    type.assign(valueArg.dynamicType());
  }

  Null constructor(VotSource sourceArg, ValueVotNullable valueArg) {
    super.constructor();
    source = sourceArg;
    type = TypeHandle(null);
    if (valueArg != null) {
      assign(valueArg!);
    }
  }
}

// ============================================================================
// INSTRUCTIONS
// ============================================================================

class Instruction extends Object {
  Null prepareInstructions() {}
  Null generateAssembler(Assembler assembler, Integer blockId) {}
}

class SourceLocationInstruction extends Instruction {
  SourceCode statement;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), assembler.lineLength)));
  }

  Null constructor(SourceCode statementArg) {
    super.constructor();
    statement = statementArg;
  }
}

class ReturnInstruction extends Instruction {
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, 'ret', comment);
  }

  Null constructor(String commentArg) {
    super.constructor();
    comment = commentArg;
  }
}

class DoIfNotEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String continueLabel;
  Object block; // XXX should be CompiledScope
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    (cast(block).prepareInstructions as NullFunction)();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat('cmp ', a.value!.asOperand().operand, ', ', b.value!.asOperand().operand), comment);
    assembler.addCode(blockId, concat('je ', continueLabel), 'skip next block if they are equal');
    (cast(block).generateAssembler as NullFunction)(assembler, blockId);
    assembler.addCode(blockId, concat(continueLabel, ':'), null);
  }

  Null constructor(ValueHandle aArg, ValueHandle bArg, String continueLabelArg, Object blockArg, String commentArg) { // XXX Object should be CompiledScope
    super.constructor();
    a = aArg;
    b = bArg;
    continueLabel = continueLabelArg;
    block = blockArg;
    comment = commentArg;
  }
}

class DoIfTypeMismatchInstruction extends Instruction {
  Type staticType;
  TypeHandle dynamicType;
  String continueLabel;
  Object block; // XXX should be CompiledScope
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    staticType.markUsedInTypeCheck();
    (cast(block).prepareInstructions as NullFunction)();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // xxxxx
    String byte = '00h';
    String bitInByte = '0';
    assembler.addCode(blockId, concat('bt ', byte, ', ', bitInByte), comment);
    assembler.addCode(blockId, concat('jc ', continueLabel), 'skip next block if the selected bit is set');
    (cast(block).generateAssembler as NullFunction)(assembler, blockId);
    assembler.addCode(blockId, concat(continueLabel, ':'), null);
  }

  Null constructor(Type staticTypeArg, TypeHandle dynamicTypeArg, String continueLabelArg, Object blockArg, String commentArg) { // XXX Object should be CompiledScope
    super.constructor();
    staticType = staticTypeArg;
    dynamicType = dynamicTypeArg;
    continueLabel = continueLabelArg;
    block = blockArg;
    comment = commentArg;
  }
}

class StringConstantDataInstruction extends Instruction {
  String label;
  String value;
  SourceLocation source;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addData(
      label,
      [
        'dq -01h',
        // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
        concat('dq ', len(scalarValues(value))), 
        concat('db ', stringLiteral(value)),
      ],
      [
        'String constant (reference count)',
        'Length',
        concat(source),
      ],
    );
  }  

  Null constructor(String labelArg, String valueArg, SourceLocation sourceArg) {
    super.constructor();
    label = labelArg;
    value = valueArg;
    source = sourceArg;
  }
}

class SlotInstruction extends Instruction {
  Object slot; // XXX Object should be Slot

  Null constructor(Object slotArg) {
    super.constructor();
    slot = slotArg;
  }

  String toString() {
    return concat('<', className, '(', slot, ')@', internalObjectId, '>');
  }
}

class ReadSlotInstruction extends SlotInstruction {
  ValueHandle handle;

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assert(handle.value == null, concat('tried to generate assembler for a ReadSlotInstruction (', this, ') after its handle (', handle, ') was already populated'));
    assert(cast(slot).location != sentinel, concat('tried to generate assembler for a ReadSlotInstruction (', this, ') before the slot\'s location was populated'));
    handle.assign(cast(slot).location as ValueVot);
  }

  Null constructor(Object slotArg, ValueHandle handleArg) {
    super.constructor(slotArg);
    handle = handleArg;
  }
}

class WriteSlotInstruction extends SlotInstruction {
  ValueVot value;

  Null prepareInstructions() {
    super.prepareInstructions();
    value.staticType.markConstructed();
  }

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (cast(slot).location != sentinel) {
      assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).asOperand(), value.asOperand(), concat('value of ', cast(slot).debugName as String));
      if ((cast(slot).staticType as Type).hasDynamicType()) {
        assert(value.staticType.hasDynamicType(), concat('unexpectedly tried to map value of normal type ', cast(slot).staticType as Type, ' to non-dynamic-supporting type ', value.staticType));
        assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).dynamicType().asOperand(), value.dynamicType().asOperand(), concat('type of ', cast(slot).debugName as String));
      }
    } else {
      cast(cast(slot).assignLocation)(value);
    }
  }

  Null constructor(Object slotArg, ValueVot valueArg) {
    super.constructor(slotArg);
    value = valueArg;
  }
}

class SubroutineCallInstruction extends Instruction {
  ValueHandle target; // points to a CompiledSubroutine
  ValueHandleList arguments;
  ValueHandle thisPointer;
  ValueHandle closurePointer;
  ValueHandle returnValue;

  Null prepareInstructions() {
    super.prepareInstructions();
    thisPointer.forceAllocation();
    closurePointer.forceAllocation();
    returnValue.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, concat('Calling ', target.value!.asOperand(), ' with ', len(arguments), ' arguments'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      assembler.addPush(blockId, arguments[argumentIndex].value!.asOperand(), concat('value of argument #', argumentIndex + 1));
      assembler.addPush(blockId, arguments[argumentIndex].value!.dynamicType().asOperand(), concat('type of argument #', argumentIndex + 1));
      argumentIndex -= 1;
    }
    // XXX why do we do addlea/addpush via r11 instead of just addpush?
    assembler.addLea(blockId, r11, returnValue.value!.asOperand(), 'pointer to return value (and type, 8 bytes later)');
    assembler.addPush(blockId, r11, '(that pointer is the last value pushed to the stack)');
    assembler.addLea(blockId, r9, thisPointer.value!.asOperand(), 'pointer to this');
    assembler.addMov(blockId, r8, thisPointer.value!.dynamicType().asOperand(), 'type of this');
    assembler.addLea(blockId, rdx, closurePointer.value!.asOperand(), 'pointer to closure');
    assembler.addCode(blockId, concat('mov rcx, ', len(arguments)), 'number of arguments');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, concat('call ', target.value!.asOperand()), 'jump to subroutine');
    assembler.addCode(blockId, concat('add rsp, ', hex8(32 + 8 * 2 * len(arguments) + 8)), 'release shadow space and arguments');
  }  

  Null constructor(ValueHandle targetArg, ValueHandleList argumentsArg, ValueHandle thisPointerArg, ValueHandle closurePointerArg, ValueHandle returnValueArg) {
    super.constructor();
    target = targetArg;
    arguments = argumentsArg;
    thisPointer = thisPointerArg;
    closurePointer = closurePointerArg;
    returnValue = returnValueArg;
  }
}

// ============================================================================
// SLOTS
// ============================================================================

class Slot extends VotSource {
  String debugName;
  Boolean isAnonymous;
  Boolean isStatic;

  Object homeScope; // XXX Object should be CompiledScope
  Set referencingStackFrames = Set(); // of CompiledStackFrameScope
  Boolean needsAllocation = false;
  Boolean isRead = false;

  ValueHandle read(Object currentScope) { // XXX Object should be CompiledScope
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    isRead = true;
    (cast(currentScope).emitInstruction as NullFunction)(ReadSlotInstruction(this, result));
    return result;
  }

  Null write(Object currentScope, ValueVot newValue) { // XXX Object should be CompiledScope
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    (cast(currentScope).emitInstruction as NullFunction)(WriteSlotInstruction(this, newValue));
  }

  Null forceAllocation() {
    needsAllocation = true;
  }

  Boolean canBeStackAllocated() {
    AnythingList stackFrames = referencingStackFrames.values();
    Boolean result = needsAllocation
        && (len(stackFrames) == 1)
        && (stackFrames[0] == cast(cast(homeScope).stackFrame)())
        && (isAnonymous || (homeScope.className != 'CompiledLibrary'));
    if (!result) {
      println(concat('cannot allocate: ', this, '\n', 'stackFrames: ', stackFrames, '\nhomeScope: ', homeScope, '\nisAnon: ', isAnonymous));
    }
    return result;
  }

  Boolean needsHeapAllocation() {
    return needsAllocation && !canBeStackAllocated();
  }

  ValueVot location;

  Null assignLocation(ValueVot locationArg) {
    location = locationArg;
  }

  Null constructor(Type staticTypeArg, Object homeScopeArg, String debugNameArg, Boolean isAnonymousArg, Boolean isStaticArg) { // XXX Object should be CompiledScope
    super.constructor(staticTypeArg);
    homeScope = homeScopeArg;
    debugName = debugNameArg;
    isAnonymous = isAnonymousArg;
    isStatic = isStaticArg;
  }

  String toString() {
    return concat('<slot ', staticType, ' at ', location, '>');
  }
}


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  ObjectNullable runtimeLibrary = null; // XXX Object should be CompiledRuntimeLibraryNullable

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
    append(libraryNames, filename);
  }

  Null defineLibrary(String filename, Object library) { // XXX Object should be CompiledLibrary
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is Object, 'library is not a CompiledLibrary, false, or null');
    assert(cast(library).className == 'CompiledLibrary', 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  Object getLibrary(String filename) { // XXX Object should be CompiledLibrary
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  ObjectList subroutines = []:Object; // XXX Object should be CompiledSubroutine

  Null addSubroutine(Object subroutine) { // XXX Object should be CompiledSubroutine
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    (cast(runtimeLibrary).prepareInstructions as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareInstructions as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareInstructions as NullFunction)();
    }
  }

  Null prepareSlots() {
    (cast(runtimeLibrary).prepareSlots as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareSlots as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareSlots as NullFunction)();
    }
  }

  Null generateAssemblerBlocks(Assembler assembler) {
    (cast(runtimeLibrary).generateAssemblerBlock as NullFunction)(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).generateAssemblerBlock as NullFunction)(assembler);
    }
    for (subroutine in subroutines) {
      (cast(subroutine).generateAssemblerBlock as NullFunction)(assembler);
    }
  }

  Null generateTypeTable(Assembler assembler, String label) {
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    for (type in sortedTypes) {
      for (supertype in sortedTypes) {
        if (supertype.isUsedInTypeCheck) {
          if (type.isSubtypeOf(supertype)) {
            byte += 1;
          }
          bits += 1;
          if (bits < 8) {
            byte = byte << 1;
          } else {
            append(bytes, byte);
            byte = 0;
            bits = 0;
          }
        }
      }
      append(bytes, byte);
      byte = 0;
      bits = 0;
    }
    assembler.addData(
      label,
      [
        concat('db ', join(map(bytes, hex8) as StringList, ', ')),
      ],
      [
        'Type table',
      ],
    );
  }

  VotSource integers;

  ValueHandle integer(Integer value) {
    integers.staticType.markConstructed();
    return ValueHandle(integers, LiteralIntegerVot(integers.staticType as NumericType, value));
  }

  String typeTableLabel;
  ValueHandle typeTableOffset;

  Null compile(Assembler assembler) {
    typeTableLabel = generateLabel('typeTable');
    typeTableOffset = ValueHandle(integers, null);
    prepareInstructions();
    typeTableOffset.assign(LiteralIntegerVot(integers.staticType as NumericType, assignTypeCodes()));
    generateTypeTable(assembler, typeTableLabel);
    prepareSlots();
    generateAssemblerBlocks(assembler);
  }

  Null constructor(Assembler assembler) {
    super.constructor();
    runtimeLibrary = cast(cast(cast(this).CompiledRuntimeLibrary)(this, 'rtl'));
    integers = VotSource(cast(runtimeLibrary).coreIntegerType as Type);
   }
}

// ============================================================================
// SCOPES
// ============================================================================
ObjectFunction makeCompiledScope;
class CompiledScope extends Object {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name;

  CompiledScope globalScope() { // XXX CompiledScope should be CompiledLibrary
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).globalScope)(); // XXX can't reference self on other instances yet
  }

  CompiledScope stackFrame() { // XXX CompiledScope should be CompiledStackFrameScope
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = cast(cast(parent!).stackFrame)() as CompiledScope;
    return result;
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).environment)();
  }

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable value = cast(identifiers.get(name));
    if (value == null && parent != null) {
      value = cast(cast(cast(parent!).lookupIdentifier)(name));
    }
    return value;
  }

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }

  Null registerSlot(Slot slot) {
    cast(cast(stackFrame()).registerSlot)(slot);
  }

  Slot registerDynamicValue(Type type, String debugName) {
    Slot slot = Slot(type, this, debugName, true, false);
    registerSlot(slot);
    return slot;
  }

  Slot registerStaticValue(ValueVot value, String debugName) {
    Slot slot = Slot(value.staticType, this, debugName, true, true);
    registerSlot(slot);
    slot.write(this, value);
    return slot;
  }

  Slot registerVariable(String name, Type type, ValueVot initialValue) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(type, this, name, false, false);
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, initialValue);
    return slot;
  }

  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = Slot(type, this, name, false, true);
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, ParameterVot(type, position));
    return slot;
  }

  Slot registerConstant(String name, ValueVot value) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(value.staticType, this, name, false, true);
    globalScope().registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, value);
    return slot;
  }

  Slot registerSubroutine(CompiledScope subroutine) { // XXX CompiledScope should be CompiledSubroutine
    assert(!isIdentifierDeclaredInLocalScope(cast(subroutine).name as String), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(cast(subroutine).type as Type, this, cast(subroutine).name as String, false, true);
    registerSlot(slot);
    identifiers.set(cast(subroutine).name, slot);
    slot.write(this, LabelVot(cast(subroutine).type as AbstractSubroutineType, cast(subroutine).label as String));
    environment().addSubroutine(subroutine);
    return slot;
  }

  ValueHandle emitSubroutineCall(ValueHandle target, ValueHandleList arguments) {
    Slot thisPointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClassType), 'this pointer');
    Slot closurePointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClosureType), 'closure pointer');
    thisPointer.write(this, SentinelVot(cast(environment().runtimeLibrary!).coreClassType as Type));
    closurePointer.write(this, SentinelVot(cast(environment().runtimeLibrary!).coreClosureType as Type));
    Type returnType;
    VotSource targetSlot = target.source;
    if (targetSlot.staticType.isSubroutineType()) {
      AbstractSubroutineType subroutineType = targetSlot.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    } else {
      returnType = cast(cast(environment().runtimeLibrary!).coreAnythingType);
    }
    ValueHandle thisPointerRead = thisPointer.read(this);
    ValueHandle closurePointerRead = closurePointer.read(this);
    Slot returnValue = registerDynamicValue(returnType, 'return value');
    ValueHandle returnValuePointer = returnValue.read(this);
    SubroutineCallInstruction call = SubroutineCallInstruction(
      target,
      arguments,
      thisPointerRead,
      closurePointerRead,
      returnValuePointer,
    );
    append(instructions, call);
    return returnValue.read(this);
  }

  Null emitParameterChecks(SlotList parameters) {
    // check for parameter count
    String label = environment().generateLabel(concat('func$', name, '$paramCountGood'));
    Slot paramCount = registerStaticValue(OperandVot(cast(environment().runtimeLibrary).coreIntegerType as Type, rcx), 'parameter count');
    ValueHandle paramCountValue = paramCount.read(this);
    ValueHandle expectedParamCountValue = environment().integer(len(parameters));
    CompiledScope block = makeCompiledScope(this, label) as CompiledScope;
    ValueHandle printHandle = (cast(environment().runtimeLibrary!).corePrint as Slot).read(block);
    ValueHandle messageHandle = (cast(environment().runtimeLibrary!).parameterCountCheckFailureMessage as Slot).read(block);
    block.emitSubroutineCall(printHandle, [ messageHandle ]);
    ValueHandle exitHandle = (cast(environment().runtimeLibrary!).coreExit as Slot).read(block);
    ValueHandle failureExitCode = environment().integer(0x01);
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    append(instructions, DoIfNotEqualInstruction(
      paramCountValue,
      expectedParamCountValue,
      label,
      block,
      'check number of parameters is as expected',
    ));
    Integer index = 0;
    for (parameter in parameters) {
      index += 1;
      String label = environment().generateLabel(concat('func$', name, '$param', index, '$TypeGood'));
      CompiledScope block = makeCompiledScope(this, label) as CompiledScope;
      ValueHandle printHandle = (cast(environment().runtimeLibrary!).corePrint as Slot).read(block);
      ValueHandle messageHandle = (cast(environment().runtimeLibrary!).parameterTypeCheckFailureMessage as Slot).read(block);
      block.emitSubroutineCall(printHandle, [ messageHandle ]);
      ValueHandle exitHandle = (cast(environment().runtimeLibrary!).coreExit as Slot).read(block);
      ValueHandle failureExitCode = environment().integer(0x01);
      block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
      // xxxxxxxxx
      //append(instructions, DoIfTypeMismatchInstruction(
      //  parameter.staticType,
      //  parameter.readType(this),
      //  label,
      //  block,
      //  concat('check type of parameter ', index, ' is as expected'),
      //));
    }
  }

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepareInstructions();
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    for (instruction in instructions) {
      instruction.generateAssembler(assembler, blockId);
    }
  }  

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', name, ':', className, '@', internalObjectId, '>');
  }
}
makeCompiledScope = CompiledScope;

class CompiledStackFrameScope extends CompiledScope {
  CompiledScope stackFrame() { // XXX CompiledScope should be CompiledStackFrameScope
    return this;
  }

  SlotList slots = []:Slot;

  Null registerSlot(Slot slot) {
    append(slots, slot);
  }

  Integer stackSize = 0x00;

  Null prepareSlots() {
    for (slot in slots) {
      if (slot.isRead && slot.needsAllocation && slot.canBeStackAllocated()) {
        // TODO emit a comment giving the stack layout for this stack frame
        slot.assignLocation(StackAllocatedVot(slot.staticType, stackSize));
        if (slot.staticType.hasDynamicType()) {
          stackSize += 0x10;
        } else {
          stackSize += 0x08;
        }
      }
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, 'Prolog');
    assembler.addCode(blockId, 'push rbp', 'save volatile registers');
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      assembler.addCode(blockId, concat('sub rsp, ', hex8(stackSize)), 'allocate space for stack');
    }
    assembler.addCode(blockId, concat('lea rbp, [rsp+', hex8(stackSize), ']'), 'set up frame pointer');
    super.generateAssembler(assembler, blockId);
    assembler.addComment(blockId, 'Epilog');
    if (stackSize > 0) {
      assembler.addCode(blockId, concat('add rsp, ', hex8(stackSize)), 'free space for stack');
    }
    assembler.addCode(blockId, 'pop rbp', 'restore volatile registers');
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineType type;
  String label;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    super.generateAssembler(assembler, blockId);
    assembler.addCode(blockId, 'ret', 'return from subroutine');
  }  

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.addLabel(label, name));
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
    label = environment().generateLabel(concat('func$', name));
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class BuiltInSubroutine extends CompiledSubroutine {
  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType signature, String name) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutineInstructions extends Instruction {
  ValueHandle lpNumberOfCharsWritten;
  ValueHandle parameter;

  Null prepareInstructions() {
    super.prepareInstructions();
    lpNumberOfCharsWritten.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetStdHandle');
    assembler.addExternProc('WriteConsoleA');
    /* This is what the stack looks like at this point:
     
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+68h : rbp+60h : value of this                                    
     *  rsp+60h : rbp+58h : type of this                                     
     *  rsp+58h : rbp+50h : value of closure                                 
     *  rsp+50h : rbp+48h : type of closure                                  
     *  rsp+48h : rbp+40h : value of arg 1 (pointer to string structure)     
     *  rsp+40h : rbp+38h : type of arg 1                                    
     *  rsp+38h : rbp+30h : pointer to return value                          
     *  rsp+30h : rbp+28h : shadow                                           
     *  rsp+28h : rbp+20h : shadow                                           
     *  rsp+20h : rbp+18h : shadow                                           
     *  rsp+18h : rbp+10h : shadow                                           
     *  rsp+10h : rbp +8h : return address                                   
     *  rsp +8h : rbp     : saved volatile register rbp                      
     *  rsp     : rbp -8h : lpNumberOfCharsWritten                           
     *      ... :     ... :
     *     0000 :    0000 :
     */
    assembler.addComment(blockId, 'TODO: check type of argument'); // TODO: check type of argument
    assembler.addComment(blockId, 'Calling GetStdHandle');
    assembler.addCode(blockId, 'mov rcx, -11', 'argument #1: STD_OUTPUT_HANDLE');
    assembler.addCode(blockId, 'call GetStdHandle', 'handle returned in rax');
    assembler.addComment(blockId, 'Calling WriteConsoleA');
    assembler.addCode(blockId, 'push 0', 'argument #5: Reserved, must be NULL (lpReserved)');
    assembler.addLea(blockId, r9, lpNumberOfCharsWritten.value!.asOperand(), 'argument #4: Number of characters written (lpNumberOfCharsWritten)');
    assembler.addMov(blockId, r10, parameter.value!.asOperand(), 'get address of string structure');
    assembler.addCode(blockId, 'mov r8, [r10+08h]', 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure');
    assembler.addCode(blockId, 'lea rdx, [r10+10h]', 'argument #2: Pointer to buffer to write (*lpBuffer)');
    assembler.addCode(blockId, 'mov rcx, rax', 'argument #1: Handle from GetStdHandle (hConsoleOutput)');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call WriteConsoleA', 'returns boolean representing success in rax');
    assembler.addCode(blockId, 'add rsp, 28h', 'release shadow space and arguments');
  }

  Null constructor(ValueHandle lpNumberOfCharsWrittenArg, ValueHandle parameterArg) {
    super.constructor();
    lpNumberOfCharsWritten = lpNumberOfCharsWrittenArg;
    parameter = parameterArg;
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot lpNumberOfCharsWritten = registerDynamicValue(cast(parent!).coreSystemType as Type, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    ValueHandle lpNumberOfCharsWrittenPointer = lpNumberOfCharsWritten.read(this);
    Slot parameter = registerStaticValue(ParameterVot(cast(parent!).coreStringType as Type, 0), 'message to print to console'); // (unnamed parameter)
    emitParameterChecks([parameter]);
    ValueHandle parameterValue = parameter.read(this);
    emitInstruction(BuiltInPrintSubroutineInstructions(lpNumberOfCharsWrittenPointer, parameterValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      SubroutineTypeWithVarArgs(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        cast(cast(parentArg).coreAnythingType),
      ),
      'print',
    );
  }
}

class BuiltInExitSubroutineInstructions extends Instruction {
  ValueHandle exitCode;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('ExitProcess');
    assembler.addComment(blockId, 'Calling ExitProcess');
    assembler.addMov(blockId, rcx, exitCode.value!.asOperand(), 'exit code');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call ExitProcess', 'process should terminate at this point');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
  }

  Null constructor(ValueHandle exitCodeArg) {
    super.constructor();
    exitCode = exitCodeArg;
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot exitCode = registerStaticValue(ParameterVot(cast(parent!).coreIntegerType as Type, 0), 'exit code parameter'); // (unnamed parameter)
    emitParameterChecks([exitCode]);
    ValueHandle exitCodeValue = exitCode.read(this);
    emitInstruction(BuiltInExitSubroutineInstructions(exitCodeValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      createOrFindSubroutineType(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        [ cast(parentArg).coreIntegerType as Type ]:Type,
      ),
      'exit',
    );
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable result = super.lookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.lookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = cast(cast(library).lookupType)(name) as TypeNullable;
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addBlankLine(blockId);
    assembler.addComment(blockId, name);
    assembler.addComment(blockId, stringTimes('=', len(scalarValues(name))));
    super.generateAssembler(assembler, blockId);
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.mainBlockId);
  }  

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(null, nameArg);
    compilationEnvironment = compilationEnvironmentArg;
    CompiledLibraryNullable runtimeLibrary = cast(compilationEnvironment.runtimeLibrary); // XXX CompiledLibrary should be CompiledRuntimeLibrary
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledRuntimeLibrary extends CompiledLibrary {
  AnythingType coreAnythingType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;

  Slot corePrint;
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;

  Slot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    String label = compilationEnvironment.generateLabel(labelBase);
    emitInstruction(StringConstantDataInstruction(
      label,
      value,
      SourceLocation(line, col, file),
    ));
    return registerStaticValue(LabelPointerVot(coreStringType, label), labelBase);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(compilationEnvironmentArg, nameArg);
    // internal types
    coreClassType = RootClassType(compilationEnvironmentArg);
    coreClosureType = ClosureType(compilationEnvironmentArg);
    coreSystemType = SystemType(compilationEnvironmentArg);
    // built-in types
    coreAnythingType = AnythingType(compilationEnvironmentArg);
    declareType(coreAnythingType);
    coreNullType = NullType(compilationEnvironmentArg);
    declareType(coreNullType);
    registerConstant('null', LiteralIntegerVot(coreNullType, 0x00));
    coreBooleanType = BooleanType(compilationEnvironmentArg);
    declareType(coreBooleanType);
    registerConstant('false', LiteralIntegerVot(coreBooleanType, 0x00));
    registerConstant('true', LiteralIntegerVot(coreBooleanType, 0x01));
    coreIntegerType = IntegerType(compilationEnvironmentArg);
    declareType(coreIntegerType);
    coreStringType = StringType(compilationEnvironmentArg);
    declareType(coreStringType);
    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));
    // messages
    parameterCountCheckFailureMessage = registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
  }
}
