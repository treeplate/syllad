import 'core.syd';
import 'syd-basic-types.syd';
import 'syd-types.syd';
import 'syd-assembler.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

// ============================================================================
// SOURCE CODE
// ============================================================================

class SourceCode extends Object {
  SourceLocation sourceLocation;

  Null constructor(SourceLocation sourceLocationArg) {
    super.constructor();
    sourceLocation = sourceLocationArg;
  }
}

String escapeString(String value) {
  StringList buffer = [];
  for (char in scalarValues(value)) {
    if (char == 0x0a) {
      append(buffer, '\\n');
    } else if (char == 0x0d) {
      append(buffer, '\\r');
    } else if (char == 0x27) {
      append(buffer, '\\\'');
    } else if (char < 0x20 || char > 0x7e) {
      append(buffer, '.');
    } else {
      append(buffer, chr(char));
    }
  }
  return joinList(buffer);
}

String truncateString(String value, Integer maxLength) {
  StringList buffer = [];
  Boolean terminated = false;
  for (char in scalarValues(value)) {
    if (char == 0x0a || char == 0x0d) {
      terminated = true;
    } else {
      append(buffer, chr(char));
      if (terminated || len(buffer) >= maxLength) {
        append(buffer, '...');
        break;
      }
    }
  }
  return joinList(buffer);
}


// ============================================================================
// VALUES
// ============================================================================

class ValueSource extends Object {
  Type staticType;

  Null forceAllocation() {
    throw(concat('Cannot force allocation of ', this));
  }

  Null constructor(Type staticTypeArg) {
    super.constructor();
    staticType = staticTypeArg;
  }
}

class Value extends Object {
  Type staticType;

  Operand valueAsOperand() {
    abstract();
  }

  Operand typeAsOperand() {
    abstract();
  }

  Null constructor(Type staticTypeArg) {
    super.constructor();
    staticType = staticTypeArg;
  }

  String toString() {
    return concat('[', className, ']');
  }
}

class StaticValue extends Value {
  Operand typeAsOperand() {
    return staticType.asOperand();
  }

  Null constructor(Type typeArg) {
    super.constructor(typeArg);
  }
}

class SentinelValue extends StaticValue {
  Operand valueAsOperand() {
    return Operand('0h', otImm32);
  }

  Null constructor(Type typeArg) {
    super.constructor(typeArg);
  }
}

class LiteralIntegerValue extends StaticValue {
  Integer value;

  Operand valueAsOperand() {
    if (value <= 0xFFFFFFFF) {
      return Operand(hex32(value), otImm32);
    }
    return Operand(hex64(value), otImm64);
  }

  String toString() {
    return concat("[LiteralIntegerValue type ", staticType, " value ", value, "@", internalObjectId, "]");
  }

  Null constructor(NumericType typeArg, Integer valueArg) {
    super.constructor(typeArg);
    value = valueArg;
  }
}

class LabelValue extends StaticValue {
  String label;

  Operand valueAsOperand() {
    return Operand(label, otLabel);
  }

  Null constructor(Type typeArg, String labelArg) {
    super.constructor(typeArg);
    label = labelArg;
  }
}

class LabelPointerValue extends StaticValue {
  String label;

  Operand valueAsOperand() {
    return Operand(label, otLabelOffset);
  }

  Null constructor(Type typeArg, String labelArg) {
    super.constructor(typeArg);
    label = labelArg;
  }
}

class StaticTypeRegisterValue extends StaticValue {
  Operand register;

  Operand valueAsOperand() {
    return register;
  }

  Null constructor(Type typeArg, Operand registerArg) {
    super.constructor(typeArg);
    assert(registerArg.kind == otRegister, 'StaticTypeRegisterValue given non-register operand');
    register = registerArg;
  }
}

class RegisterPairValue extends Value {
  Operand typeRegister;
  Operand valueRegister;

  Operand valueAsOperand() {
    return valueRegister;
  }

  Operand typeAsOperand() {
    return typeRegister;
  }

  Null constructor(Type staticTypeArg, Operand typeRegisterArg, Operand valueRegisterArg) {
    super.constructor(staticTypeArg);
    assert(typeRegister.kind == otRegister, 'RegisterPairValue given non-register type operand');
    typeRegister = typeRegisterArg;
    assert(valueRegister.kind == otRegister, 'RegisterPairValue given non-register value operand');
    valueRegister = valueRegisterArg;
  }
}

class StackAllocatedValue extends Value {
  Integer stackOffset;

  Operand valueAsOperand() {
    return Operand(concat('rbp-', hex8(stackOffset + 0x08)), otIndirect);
  }

  Operand typeAsOperand() {
    assert(staticType.size() >= 0x10, concat(staticType, ' does not have a dynamic type'));
    return Operand(concat('rbp-', hex8(stackOffset + 0x10)), otIndirect);
  }

  Null constructor(Type staticTypeArg, Integer stackOffsetArg) {
    super.constructor(staticTypeArg);
    stackOffset = stackOffsetArg;
  }
}

class ParameterValue extends StaticValue {
  Integer parameterNumber;

  Operand valueAsOperand() {
    return Operand(concat('rbp+', hex8(parameterNumber * 0x10 + 0x40)), otIndirect);
  }

  Operand typeAsOperand() {
    return Operand(concat('rbp+', hex8(parameterNumber * 0x10 + 0x40 - 0x08)), otIndirect);
  }

  Null constructor(Type staticTypeArg, Integer parameterNumberArg) {
    super.constructor(staticTypeArg);
    parameterNumber = parameterNumberArg;
  }
}

// ============================================================================
// VALUE HANDLES
// ============================================================================

class ValueHandle extends Object {
  ValueSource source;
  ValueNullable value = null;

  Null forceAllocation() {
    source.forceAllocation();
  }

  Null assign(Value valueArg) {
    assert(valueArg.staticType.isSubtypeOf(source.staticType), concat('cannot assign ', valueArg.staticType, ' to ', source.staticType));
    value = valueArg;
  }

  Null constructor(ValueSource sourceArg, ValueNullable valueArg) {
    super.constructor();
    source = sourceArg;
    if (valueArg != null) {
      assign(valueArg!);
    }
  }
}

// ============================================================================
// INSTRUCTIONS
// ============================================================================

class Instruction extends Object {
  Null prepareInstructions() {}
  Null generateAssembler(Assembler assembler, Integer blockId) {}
}

class SourceLocationInstruction extends Instruction {
  SourceCode statement;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), assembler.lineLength)));
  }

  Null constructor(SourceCode statementArg) {
    super.constructor();
    statement = statementArg;
  }
}

class ReturnInstruction extends Instruction {
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, 'ret', comment);
  }

  Null constructor(String commentArg) {
    super.constructor();
    comment = commentArg;
  }
}

class DoIfNotEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String continueLabel;
  Object block; // XXX should be CompiledScope
  String comment;

  Null prepareInstructions() {
    super.prepareInstructions();
    (cast(block).prepareInstructions as NullFunction)();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat('cmp ', a.value!.valueAsOperand().operand, ', ', b.value!.valueAsOperand().operand), comment);
    assembler.addCode(blockId, concat('je ', continueLabel), 'skip next block if they are equal');
    (cast(block).generateAssembler as NullFunction)(assembler, blockId);
    assembler.addCode(blockId, concat(continueLabel, ':'), null);
  }

  Null constructor(ValueHandle aArg, ValueHandle bArg, String continueLabelArg, Object blockArg, String commentArg) { // XXX Object should be CompiledScope
    super.constructor();
    a = aArg;
    b = bArg;
    continueLabel = continueLabelArg;
    block = blockArg;
    comment = commentArg;
  }
}

class StringConstantDataInstruction extends Instruction {
  String label;
  String value;
  SourceLocation source;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addData(
      label,
      [
        'dq -01h',
        // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
        concat('dq ', len(scalarValues(value))), 
        concat('db ', stringLiteral(value)),
      ],
      [
        'String constant (reference count)',
        'Length',
        concat(source),
      ],
    );
  }  

  Null constructor(String labelArg, String valueArg, SourceLocation sourceArg) {
    super.constructor();
    label = labelArg;
    value = valueArg;
    source = sourceArg;
  }
}

class SlotInstruction extends Instruction {
  Object slot; // XXX Object should be Slot

  Null constructor(Object slotArg) {
    super.constructor();
    slot = slotArg;
  }

  String toString() {
    return concat('<', className, '(', slot, ')@', internalObjectId, '>');
  }
}

class ReadSlotInstruction extends SlotInstruction {
  ValueHandle handle;

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assert(handle.value == null, concat('tried to generate assembler for a ReadSlotInstruction (', this, ') after its handle (', handle, ') was already populated'));
    assert(cast(slot).location != sentinel, concat('tried to generate assembler for a ReadSlotInstruction (', this, ') before the slot\'s location was populated'));
    handle.assign(cast(slot).location as Value);
  }

  Null constructor(Object slotArg, ValueHandle handleArg) {
    super.constructor(slotArg);
    handle = handleArg;
  }
}

class WriteSlotInstruction extends SlotInstruction {
  Value value;

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (cast(slot).location != sentinel) {
      assert((cast(slot).staticType as Type).size() >= 0x08, 'cannot write to slots with less than 64 bits of space');
      assembler.addMov(blockId, ((cast(cast(slot).location)) as Value).valueAsOperand(), value.valueAsOperand(), concat('value of ', cast(slot).debugName as String));
      if ((cast(slot).staticType as Type).size() > 0x08) {
        assembler.addMov(blockId, ((cast(cast(slot).location)) as Value).typeAsOperand(), value.typeAsOperand(), concat('type of ', cast(slot).debugName as String));
        // TODO what if it's bigger?
      }
    } else {
      cast(cast(slot).assignLocation)(value);
    }
  }

  Null constructor(Object slotArg, Value valueArg) {
    super.constructor(slotArg);
    value = valueArg;
  }
}

class SubroutineCallInstruction extends Instruction {
  ValueHandle target; // points to a CompiledSubroutine
  ValueHandleList arguments;
  ValueHandle thisPointer;
  ValueHandle closurePointer;
  ValueHandle returnValue;

  Null prepareInstructions() {
    super.prepareInstructions();
    thisPointer.forceAllocation();
    closurePointer.forceAllocation();
    returnValue.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, concat('Calling ', target.value!.valueAsOperand(), ' with ', len(arguments), ' arguments'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      assembler.addPush(blockId, arguments[argumentIndex].value!.valueAsOperand(), concat('value of argument #', argumentIndex + 1));
      assembler.addPush(blockId, arguments[argumentIndex].value!.typeAsOperand(), concat('type of argument #', argumentIndex + 1));
      argumentIndex -= 1;
    }
    // XXX why do we do addlea/addpush via r11 instead of just addpush?
    assembler.addLea(blockId, r11, returnValue.value!.valueAsOperand(), 'pointer to return value (and type, 8 bytes later)');
    assembler.addPush(blockId, r11, '(that pointer is the last value pushed to the stack)');
    assembler.addLea(blockId, r9, thisPointer.value!.valueAsOperand(), 'pointer to this');
    assembler.addMov(blockId, r8, thisPointer.value!.typeAsOperand(), 'type of this');
    assembler.addLea(blockId, rdx, closurePointer.value!.valueAsOperand(), 'pointer to closure');
    assembler.addCode(blockId, concat('mov rcx, ', len(arguments)), 'number of arguments');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, concat('call ', target.value!.valueAsOperand()), 'jump to subroutine');
    assembler.addCode(blockId, concat('add rsp, ', hex8(32 + 8 * 2 * len(arguments) + 8)), 'release shadow space and arguments');
  }  

  Null constructor(ValueHandle targetArg, ValueHandleList argumentsArg, ValueHandle thisPointerArg, ValueHandle closurePointerArg, ValueHandle returnValueArg) {
    super.constructor();
    target = targetArg;
    arguments = argumentsArg;
    thisPointer = thisPointerArg;
    closurePointer = closurePointerArg;
    returnValue = returnValueArg;
  }
}

// ============================================================================
// SLOTS
// ============================================================================

class Slot extends ValueSource {
  Object homeScope; // XXX Object should be CompiledScope
  Set referencingStackFrames = Set(); // of CompiledStackFrameScope
  Boolean needsAllocation = false;
  Boolean isRead = false;

  ValueHandle read(Object currentScope) { // XXX Object should be CompiledScope
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    isRead = true;
    (cast(currentScope).emitInstruction as NullFunction)(ReadSlotInstruction(this, result));
    return result;
  }

  Null forceAllocation() {
    needsAllocation = true;
  }

  // newValue is one of:
  //  - StaticTypeRegisterValue or RegisterPairValue, when we know where the
  //    value will be coming from (e.g. return value of a system call is
  //    always in RAX) -- XXX probably never RegisterPairValue?
  //  - StaticValue, e.g. when we have a constant in the code
  //  - null, when we'll use whatever register/memory location is going to be
  //    assigned to us later.
  Null write(Object currentScope, Value newValue) { // XXX Object should be CompiledScope
    assert((newValue is StaticTypeRegisterValue) || (newValue is RegisterPairValue) || (newValue is StaticValue) || (newValue == null), concat('write value (', newValue, ') is invalid'));
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    if (!(newValue is StaticValue)) {
      needsAllocation = true;
    }
    (cast(currentScope).emitInstruction as NullFunction)(WriteSlotInstruction(this, newValue));
  }

  Boolean isAnonymous() {
    abstract();
  }

  Boolean canBeStackAllocated() {
    AnythingList stackFrames = referencingStackFrames.values();
    Boolean result = needsAllocation
        && (len(stackFrames) == 1)
        && (stackFrames[0] == cast(cast(homeScope).stackFrame)())
        && (isAnonymous() || (homeScope.className != 'CompiledLibrary'));
    if (!result) {
      println(concat('cannot allocate: ', this, '\n', 'stackFrames: ', stackFrames, '\nhomeScope: ', homeScope, '\nisAnon: ', isAnonymous));
    }
    return result;
  }

  Boolean needsHeapAllocation() {
    return needsAllocation && !canBeStackAllocated();
  }

  Value location;

  Null assignLocation(Value locationArg) {
    assert(location == sentinel, concat('slots do not yet support varying locations; slot ', this, ' already had a location (', location, '), when an attempt was made to assign it ', locationArg));
    location = locationArg;
  }

  Null constructor(Type staticTypeArg, Object homeScopeArg) { // XXX Object should be CompiledScope
    super.constructor(staticTypeArg);
    homeScope = homeScopeArg;
  }

  String toString() {
    return concat('<slot ', staticType, ' at ', location, '>');
  }
}

class AnonymousSlot extends Slot {
  String debugName;

  Boolean isAnonymous() {
    return true;
  }

  Null constructor(Type staticTypeArg, Object homeScopeArg, String debugNameArg) { // XXX Object should be CompiledScope
    super.constructor(staticTypeArg, homeScopeArg);
    debugName = debugNameArg;
  }

  String toString() {
    return concat("<AnonymousSlot ", debugName, ", of ", homeScope, " (a ", staticType, " at ", location, ")@", internalObjectId, ">");
  }
}

class NamedSlot extends Slot {
  // xxx should probably track name, where it was defined

  Boolean isAnonymous() {
    return false;
  }
}

// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = [];
  ObjectNullable runtimeLibrary = null; // XXX Object should be CompiledRuntimeLibraryNullable

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
    append(libraryNames, filename);
  }

  Null defineLibrary(String filename, Object library) { // XXX Object should be CompiledLibrary
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is Object, 'library is not a CompiledLibrary, false, or null');
    assert(cast(library).className == 'CompiledLibrary', 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  Object getLibrary(String filename) { // XXX Object should be CompiledLibrary
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  ObjectList subroutines = []; // XXX Object should be CompiledSubroutine

  Null addSubroutine(Object subroutine) { // XXX Object should be CompiledSubroutine
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    (cast(runtimeLibrary).prepareInstructions as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareInstructions as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareInstructions as NullFunction)();
    }
  }

  Null prepareSlots() {
    (cast(runtimeLibrary).prepareSlots as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareSlots as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareSlots as NullFunction)();
    }
  }

  Null generateAssemblerBlocks(Assembler assembler) {
    (cast(runtimeLibrary).generateAssemblerBlock as NullFunction)(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).generateAssemblerBlock as NullFunction)(assembler);
    }
    for (subroutine in subroutines) {
      (cast(subroutine).generateAssemblerBlock as NullFunction)(assembler);
    }
  }

  Null compile(Assembler assembler) {
    prepareInstructions();
    prepareSlots();
    generateAssemblerBlocks(assembler);
  }

  ValueSource integers;

  ValueHandle integer(Integer value) {
    return ValueHandle(integers, LiteralIntegerValue(integers.staticType as NumericType, value));
  }

  Null constructor(Assembler assembler) {
    super.constructor();
    runtimeLibrary = cast(cast(cast(this).CompiledRuntimeLibrary)(this, 'rtl'));
    integers = ValueSource(cast(runtimeLibrary).coreIntegerType as Type);
   }
}

// ============================================================================
// SCOPES
// ============================================================================
ObjectFunction makeCompiledScope;
class CompiledScope extends Object {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name;

  CompiledScope globalScope() { // XXX CompiledScope should be CompiledLibrary
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).globalScope)(); // XXX can't reference self on other instances yet
  }

  CompiledScope stackFrame() { // XXX CompiledScope should be CompiledStackFrameScope
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = cast(cast(parent!).stackFrame)() as CompiledScope;
    return result;
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).environment)();
  }

  // variables namespace
  Map identifiers = Map(); // String -> NamedSlot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  NamedSlotNullable lookupIdentifier(String name) {
    NamedSlotNullable value = cast(identifiers.get(name));
    if (value == null && parent != null) {
      value = cast(cast(cast(parent!).lookupIdentifier)(name));
    }
    return value;
  }

  InstructionList instructions = [];

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }

  Null registerSlot(Slot slot) {
    cast(cast(stackFrame()).registerSlot)(slot);
  }

  AnonymousSlot registerDynamicValue(Type type, String debugName) {
    AnonymousSlot slot = AnonymousSlot(type, this, debugName);
    registerSlot(slot);
    return slot;
  }

  AnonymousSlot registerStaticValue(StaticValue value, String debugName) {
    AnonymousSlot slot = AnonymousSlot(value.staticType, this, debugName);
    registerSlot(slot);
    slot.write(this, value);
    return slot;
  }

  NamedSlot registerVariable(String name, Type type, StaticValue initialValue) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    NamedSlot slot = NamedSlot(type, this);
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, initialValue);
    return slot;
  }

  NamedSlot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    NamedSlot slot = NamedSlot(type, this);
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, ParameterValue(type, position));
    return slot;
  }

  // XXX prevent future writes to this
  NamedSlot registerConstant(String name, StaticValue value) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    NamedSlot slot = NamedSlot(value.staticType, this);
    globalScope().registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, value);
    return slot;
  }

  NamedSlot registerSubroutine(CompiledScope subroutine) { // XXX CompiledScope should be CompiledSubroutine
    assert(!isIdentifierDeclaredInLocalScope(cast(subroutine).name as String), 'tried to redeclare an identifier within a scope');
    NamedSlot slot = NamedSlot(cast(subroutine).type as Type, this);
    registerSlot(slot);
    identifiers.set(cast(subroutine).name, slot);
    slot.write(this, LabelValue(cast(subroutine).type as AbstractSubroutineType, cast(subroutine).label as String));
    environment().addSubroutine(subroutine);
    return slot;
  }

  ValueHandle emitSubroutineCall(ValueHandle target, ValueHandleList arguments) {
    Slot thisPointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClassType), 'this pointer');
    Slot closurePointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClosureType), 'closure pointer');
    thisPointer.write(this, SentinelValue(cast(environment().runtimeLibrary!).coreClassType as Type));
    closurePointer.write(this, SentinelValue(cast(environment().runtimeLibrary!).coreClosureType as Type));
    Type returnType;
    ValueSource targetSlot = target.source;
    if (targetSlot.staticType.isSubroutineType()) {
      AbstractSubroutineType subroutineType = targetSlot.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    } else {
      returnType = cast(cast(environment().runtimeLibrary!).coreAnythingType);
    }
    ValueHandle thisPointerRead = thisPointer.read(this);
    ValueHandle closurePointerRead = closurePointer.read(this);
    Slot returnValue = registerDynamicValue(returnType, 'return value');
    ValueHandle returnValuePointer = returnValue.read(this);
    SubroutineCallInstruction call = SubroutineCallInstruction(
      target,
      arguments,
      thisPointerRead,
      closurePointerRead,
      returnValuePointer,
    );
    append(instructions, call);
    return returnValue.read(this);
  }

  Null emitParameterChecks(SlotList parameters) {
    // check for parameter count
    String label = environment().generateLabel(concat('func$', name, '$paramCountGood'));
    Slot paramCount = registerStaticValue(StaticTypeRegisterValue(cast(environment().runtimeLibrary).coreIntegerType as Type, rcx), 'parameter count');
    ValueHandle paramCountValue = paramCount.read(this);
    Slot expectedParamCount = registerStaticValue(LiteralIntegerValue(cast(environment().runtimeLibrary).coreIntegerType as NumericType, len(parameters)), 'expected parameter count');
    ValueHandle expectedParamCountValue = expectedParamCount.read(this);
    CompiledScope block = makeCompiledScope(this, label) as CompiledScope;
    ValueHandle printHandle = (cast(environment().runtimeLibrary!).corePrint as Slot).read(block);
    ValueHandle messageHandle = (cast(environment().runtimeLibrary!).parameterCountCheckFailureMessage as Slot).read(block);
    block.emitSubroutineCall(printHandle, [ messageHandle ]);
    ValueHandle exitHandle = (cast(environment().runtimeLibrary!).coreExit as Slot).read(block);
    ValueHandle failureExitCode = environment().integer(0x01);
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    append(instructions, DoIfNotEqualInstruction(
      paramCountValue,
      expectedParamCountValue,
      label,
      block,
      'check number of parameters is as expected',
    ));
    Integer index = 0;
    for (parameter in parameters) {
      index += 1;
/*      String label = environment().generateLabel(concat('func$', name, '$param', index, '$TypeGood'));
      CompiledScope block = makeCompiledScope(this, label) as CompiledScope;
      ValueHandle printHandle = (cast(environment().runtimeLibrary!).corePrint as Slot).read(block);
      ValueHandle messageHandle = (cast(environment().runtimeLibrary!).parameterTypeCheckFailureMessage as Slot).read(block);
      block.emitSubroutineCall(printHandle, [ messageHandle ]);
      ValueHandle exitHandle = (cast(environment().runtimeLibrary!).coreExit as Slot).read(block);
      ValueHandle failureExitCode = environment().integer(0x01);
      block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
      append(instructions, DoIfNotEqualInstruction(
        parameter.staticType,
        parameter.readType(this),
        label,
        block,
        concat('check type of parameter ', index, ' is as expected'),
      ));
      */
    }
  }

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepareInstructions();
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    for (instruction in instructions) {
      instruction.generateAssembler(assembler, blockId);
    }
  }  

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = [];
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', name, ':', className, '@', internalObjectId, '>');
  }
}
makeCompiledScope = CompiledScope;

class CompiledStackFrameScope extends CompiledScope {
  CompiledScope stackFrame() { // XXX CompiledScope should be CompiledStackFrameScope
    return this;
  }

  SlotList slots = [];

  Null registerSlot(Slot slot) {
    append(slots, slot);
  }

  Integer stackSize = 0x00;

  Null prepareSlots() {
    for (slot in slots) {
      if (slot.isRead && slot.needsAllocation && slot.canBeStackAllocated()) {
        // TODO emit a comment giving the stack layout for this stack frame
        slot.assignLocation(StackAllocatedValue(slot.staticType, stackSize));
        stackSize += slot.staticType.size();
      }
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, 'Prolog');
    assembler.addCode(blockId, 'push rbp', 'save volatile registers');
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      assembler.addCode(blockId, concat('sub rsp, ', hex8(stackSize)), 'allocate space for stack');
    }
    assembler.addCode(blockId, concat('lea rbp, [rsp+', hex8(stackSize), ']'), 'set up frame pointer');
    super.generateAssembler(assembler, blockId);
    assembler.addComment(blockId, 'Epilog');
    if (stackSize > 0) {
      assembler.addCode(blockId, concat('add rsp, ', hex8(stackSize)), 'free space for stack');
    }
    assembler.addCode(blockId, 'pop rbp', 'restore volatile registers');
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineType type;
  String label;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    super.generateAssembler(assembler, blockId);
    assembler.addCode(blockId, 'ret', 'return from subroutine');
  }  

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.addLabel(label, name));
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
    label = environment().generateLabel(concat('func$', name));
  }

  String toStringIndent(Integer indent) {
    StringList buffer = [];
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class BuiltInSubroutine extends CompiledSubroutine {
  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType signature, String name) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutineInstructions extends Instruction {
  ValueHandle lpNumberOfCharsWritten;
  ValueHandle parameter;

  Null prepareInstructions() {
    super.prepareInstructions();
    lpNumberOfCharsWritten.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetStdHandle');
    assembler.addExternProc('WriteConsoleA');
    /* This is what the stack looks like at this point:
     
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+68h : rbp+60h : value of this                                    
     *  rsp+60h : rbp+58h : type of this                                     
     *  rsp+58h : rbp+50h : value of closure                                 
     *  rsp+50h : rbp+48h : type of closure                                  
     *  rsp+48h : rbp+40h : value of arg 1 (pointer to string structure)     
     *  rsp+40h : rbp+38h : type of arg 1                                    
     *  rsp+38h : rbp+30h : pointer to return value                          
     *  rsp+30h : rbp+28h : shadow                                           
     *  rsp+28h : rbp+20h : shadow                                           
     *  rsp+20h : rbp+18h : shadow                                           
     *  rsp+18h : rbp+10h : shadow                                           
     *  rsp+10h : rbp +8h : return address                                   
     *  rsp +8h : rbp     : saved volatile register rbp                      
     *  rsp     : rbp -8h : lpNumberOfCharsWritten                           
     *      ... :     ... :
     *     0000 :    0000 :
     */
    assembler.addComment(blockId, 'TODO: check type of argument'); // TODO: check type of argument
    assembler.addComment(blockId, 'Calling GetStdHandle');
    assembler.addCode(blockId, 'mov rcx, -11', 'argument #1: STD_OUTPUT_HANDLE');
    assembler.addCode(blockId, 'call GetStdHandle', 'handle returned in rax');
    assembler.addComment(blockId, 'Calling WriteConsoleA');
    assembler.addCode(blockId, 'push 0', 'argument #5: Reserved, must be NULL (lpReserved)');
    assembler.addLea(blockId, r9, lpNumberOfCharsWritten.value!.valueAsOperand(), 'argument #4: Number of characters written (lpNumberOfCharsWritten)');
    assembler.addMov(blockId, r10, parameter.value!.valueAsOperand(), 'get address of string structure');
    assembler.addCode(blockId, 'mov r8, [r10+08h]', 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure');
    assembler.addCode(blockId, 'lea rdx, [r10+10h]', 'argument #2: Pointer to buffer to write (*lpBuffer)');
    assembler.addCode(blockId, 'mov rcx, rax', 'argument #1: Handle from GetStdHandle (hConsoleOutput)');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call WriteConsoleA', 'returns boolean representing success in rax');
    assembler.addCode(blockId, 'add rsp, 28h', 'release shadow space and arguments');
  }

  Null constructor(ValueHandle lpNumberOfCharsWrittenArg, ValueHandle parameterArg) {
    super.constructor();
    lpNumberOfCharsWritten = lpNumberOfCharsWrittenArg;
    parameter = parameterArg;
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot lpNumberOfCharsWritten = registerDynamicValue(cast(parent!).coreSystemType as Type, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    ValueHandle lpNumberOfCharsWrittenPointer = lpNumberOfCharsWritten.read(this);
    Slot parameter = registerStaticValue(ParameterValue(cast(parent!).coreStringType as Type, 0), 'message to print to console');
    emitParameterChecks([parameter]);
    ValueHandle parameterValue = parameter.read(this);
    emitInstruction(BuiltInPrintSubroutineInstructions(lpNumberOfCharsWrittenPointer, parameterValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      SubroutineTypeWithVarArgs(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        cast(cast(parentArg).coreAnythingType),
      ),
      'print',
    );
  }
}

class BuiltInExitSubroutineInstructions extends Instruction {
  ValueHandle exitCode;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('ExitProcess');
    assembler.addComment(blockId, 'Calling ExitProcess');
    assembler.addMov(blockId, rcx, exitCode.value!.valueAsOperand(), 'exit code');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call ExitProcess', 'process should terminate at this point');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
  }

  Null constructor(ValueHandle exitCodeArg) {
    super.constructor();
    exitCode = exitCodeArg;
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot exitCode = registerStaticValue(ParameterValue(cast(parent!).coreIntegerType as Type, 0), 'exit code parameter');
    emitParameterChecks([exitCode]);
    ValueHandle exitCodeValue = exitCode.read(this);
    emitInstruction(BuiltInExitSubroutineInstructions(exitCodeValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      createOrFindSubroutineType(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        [ cast(cast(parentArg).coreIntegerType) ],
      ),
      'exit',
    );
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  CompiledLibraryList libraries = [];

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  NamedSlotNullable lookupIdentifier(String name) {
    NamedSlotNullable result = super.lookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.lookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = cast(cast(library).lookupType)(name) as TypeNullable;
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addBlankLine(blockId);
    assembler.addComment(blockId, name);
    assembler.addComment(blockId, stringTimes('=', len(scalarValues(name))));
    super.generateAssembler(assembler, blockId);
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.mainBlockId);
  }  

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(null, nameArg);
    compilationEnvironment = compilationEnvironmentArg;
    CompiledLibraryNullable runtimeLibrary = cast(compilationEnvironment.runtimeLibrary); // XXX CompiledLibrary should be CompiledRuntimeLibrary
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = [];
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledRuntimeLibrary extends CompiledLibrary {
  AnythingType coreAnythingType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;

  Slot corePrint;
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(compilationEnvironmentArg, nameArg);
    // internal types
    coreClassType = RootClassType(compilationEnvironmentArg);
    coreClosureType = ClosureType(compilationEnvironmentArg);
    coreSystemType = SystemType(compilationEnvironmentArg);
    // built-in types
    coreAnythingType = AnythingType(compilationEnvironmentArg);
    declareType(coreAnythingType);
    coreNullType = NullType(compilationEnvironmentArg);
    declareType(coreNullType);
    registerConstant('null', LiteralIntegerValue(coreNullType, 0x00));
    coreBooleanType = BooleanType(compilationEnvironmentArg);
    declareType(coreBooleanType);
    registerConstant('false', LiteralIntegerValue(coreBooleanType, 0x00));
    registerConstant('true', LiteralIntegerValue(coreBooleanType, 0x01));
    coreIntegerType = IntegerType(compilationEnvironmentArg);
    declareType(coreIntegerType);
    coreStringType = StringType(compilationEnvironmentArg);
    declareType(coreStringType);
    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));
    // messages
    String parameterCheckFailureMessageLabel = compilationEnvironmentArg.generateLabel('parameterCountCheckFailureMessage');
    emitInstruction(StringConstantDataInstruction(
      parameterCheckFailureMessageLabel,
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      SourceLocation(__LINE__, __COL__, __FILE__),
    ));
    parameterCountCheckFailureMessage = registerStaticValue(LabelPointerValue(coreStringType, parameterCheckFailureMessageLabel), 'parameterCountCheckFailureMessage');
  }
}
