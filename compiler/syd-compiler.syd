import 'core.syd';
import 'syd-utils.syd';
import 'syd-types.syd';
import 'syd-vots.syd';
import 'syd-assembler.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+58h : rbp+48h : (local variable from previous stack frame)
     *  rsp+50h : rbp+40h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+48h : rbp+38h : type of arg 1                                    
     *  rsp+40h : rbp+30h : pointer to return value (and type), to be filled in
     *  rsp+38h : rbp+28h : shadow                                           
     *  rsp+30h : rbp+20h : shadow                                           
     *  rsp+28h : rbp+18h : shadow                                           
     *  rsp+20h : rbp+10h : shadow                                           
     *  rsp+18h : rbp +8h : return address                                   
                            (maybe other saved registers here)
     *  rsp+10h : rbp     : saved volatile register rbp                      
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */


// ============================================================================
// INSTRUCTIONS
// ============================================================================

class Instruction extends Object {
  Null prepareInstructions() {}
  Null generateAssembler(Assembler assembler, Integer blockId) {}
}

class SourceLocationInstruction extends Instruction {
  SourceCode statement;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addPendingComment(blockId, concat('Line ', statement.sourceLocation.lineNo, ': ', truncateString(concat(statement), assembler.lineLength)));
  }

  Null constructor(SourceCode statementArg) {
    super.constructor();
    statement = statementArg;
  }
}

class CommentInstruction extends Instruction {
  String message;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, message);
  }

  Null constructor(String messageArg) {
    super.constructor();
    message = messageArg;
  }
}

class LabelInstruction extends Instruction {
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat(label, ':'), comment);
  }

  Null constructor(String labelArg, String commentArg) {
    super.constructor();
    label = labelArg;
    comment = commentArg;
  }
}

class DoBlockInstruction extends Instruction {
  Object block; // XXX should be CompiledNestedScope

  Null prepareInstructions() {
    super.prepareInstructions();
    (cast(block).prepareInstructions as NullFunction)();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    (cast(block).generateAssembler as NullFunction)(assembler, blockId);
  }

  Null constructor(Object blockArg) { // XXX Object should be CompiledScope
    super.constructor();
    block = blockArg;
  }
}

class JumpInstruction extends Instruction {
  String target;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCode(blockId, concat('jmp ', target), comment);
  }

  Null constructor(String targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

class JumpIfEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), comment);
    assembler.addCode(blockId, concat('je ', label), 'jump if they are equal');
  }

  Null constructor(ValueHandle aArg, ValueHandle bArg, String labelArg, String commentArg) {
    super.constructor();
    a = aArg;
    b = bArg;
    label = labelArg;
    comment = commentArg;
  }
}

class JumpUnlessEqualInstruction extends Instruction {
  ValueHandle a;
  ValueHandle b;
  String label;
  String comment;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addCmp(blockId, a.value!.asOperand(), b.value!.asOperand(), comment);
    assembler.addCode(blockId, concat('jne ', label), 'jump if they are equal');
  }

  Null constructor(ValueHandle aArg, ValueHandle bArg, String labelArg, String commentArg) {
    super.constructor();
    a = aArg;
    b = bArg;
    label = labelArg;
    comment = commentArg;
  }
}

class TypeCheckInstruction extends Instruction {
  Type staticType;
  TypeHandle dynamicType;
  String what;
  Whatever environment; // XXX Whatever should be CompilationEnvironment

  Null prepareInstructions() {
    super.prepareInstructions();
    staticType.markUsedInTypeCheck();
  }

  // sets CF if the type check is successful (dynamicType is staticType)
  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addMov(blockId, rax, dynamicType.type!.asOperand(), concat('load the dynamic type of ', what, ' into rax'));
    Integer width = environment.typeTableWidth / 8;
    if (environment.typeTableWidth % 8 > 0) {
      width += 1;
    }
    if (width > 1) {
      assembler.addCode(blockId, concat('mul ', width), 'adjust to the relative start of that type\'s entry in the type table');
    }
    Integer code = staticType.code - environment.typeTableOffset;
    if (code > 8) {
      assembler.addCode(blockId, concat('add rax, ', code / 8), concat('adjust to the byte containing the bit to check against'));
    }
    assembler.addCode(blockId, concat('lea r10, ', environment.typeTableLabel), 'move type table offset into r10');
    assembler.addCode(blockId, 'add rax, r10', 'adjust rax to point to the type table');
    assembler.addCode(blockId, concat('bt qword ptr [rax], ', concat(code % 8)), concat('check that ', what, ' is ', staticType));
  }

  Null constructor(Type staticTypeArg, TypeHandle dynamicTypeArg, String whatArg, Whatever environmentArg) {
    super.constructor();
    staticType = staticTypeArg;
    dynamicType = dynamicTypeArg;
    what = whatArg;
    environment = environmentArg;
  }
}

class DoIfTypeMismatchInstruction extends TypeCheckInstruction {
  String continueLabel;
  Object block; // XXX should be CompiledScope

  Null prepareInstructions() {
    super.prepareInstructions();
    (cast(block).prepareInstructions as NullFunction)();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    super.generateAssembler(assembler, blockId);
    assembler.addCode(blockId, concat('jc ', continueLabel), 'skip next block if the type matches');
    (cast(block).generateAssembler as NullFunction)(assembler, blockId);
    assembler.addCode(blockId, concat(continueLabel, ':'), null);
  }

  Null constructor(Type staticTypeArg, TypeHandle dynamicTypeArg, String continueLabelArg, Object blockArg, String whatArg) { // XXX Object should be CompiledScope
    super.constructor(staticTypeArg, dynamicTypeArg, whatArg, cast(cast(blockArg).environment)() as TypeRegistry);
    continueLabel = cast(environment.generateLabel)(concat(continueLabelArg, '$TypeMatch')) as String;
    block = blockArg;
  }
}

class StoreTypeCheckInstruction extends TypeCheckInstruction {
  ValueHandle target;

  Null prepareInstructions() {
    super.prepareInstructions();
    target.forceAllocation(); // TODO: can we allow this to use a register...?
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    super.generateAssembler(assembler, blockId);
    assembler.addMov(blockId, target.value!.asOperand(), (environment.integer as ValueHandleFunction)(0).value!.asOperand(), concat('clear ', target.source.debugName));
    assembler.addCode(blockId, concat('setc byte ptr ', target.value!.asOperand()), concat('store result in ', target.source.debugName));
    assembler.addMov(blockId, target.type.type!.asOperand(), (cast((environment.runtimeLibrary as WhateverNullable)!).coreBooleanType as Type).asOperand(), concat(target.source.debugName, ' is a Boolean'));
  }

  Null constructor(Type staticTypeArg, TypeHandle dynamicTypeArg, ValueHandle targetArg, String whatArg, Whatever environmentArg) { // XXX Whatever should be CompilationEnvironment
    super.constructor(staticTypeArg, dynamicTypeArg, whatArg, environmentArg);
    target = targetArg;
  }
}

class StringConstantDataInstruction extends Instruction {
  String label;
  String value;
  SourceLocation source;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    // XXX length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
    StringList data = ['dq -01h', concat('dq ', len(scalarValues(value)))]:String;
    StringList comments = ['String constant (reference count)', 'Length']:String;
    if (value != '') {
      append(data, concat('db ', stringLiteral(value)));
      append(comments, concat(source));
    }
    assembler.addData(label, data, comments);
  }  

  Null constructor(String labelArg, String valueArg, SourceLocation sourceArg) {
    super.constructor();
    label = labelArg;
    value = valueArg;
    source = sourceArg;
  }
}

class SlotInstruction extends Instruction {
  Object slot; // XXX Object should be Slot

  Null constructor(Object slotArg) {
    super.constructor();
    slot = slotArg;
  }

  String toString() {
    return concat('<', className, '(', slot, ')@', internalObjectId, '>');
  }
}

class PopulateValueHandleInstruction extends SlotInstruction {
  ValueHandle handle;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assert(handle.value == null, concat('tried to generate assembler for a PopulateValueHandleInstruction (', this, ') after its handle (', handle, ') was already populated'));
    assert(cast(slot).location != sentinel, concat('tried to generate assembler for a PopulateValueHandleInstruction (', this, ') before the slot\'s location was populated'));
    handle.assign(cast(slot).location as ValueVot);
  }

  Null constructor(Object slotArg, ValueHandle handleArg) {
    super.constructor(slotArg);
    handle = handleArg;
  }
}

class WriteStaticSlotInstruction extends SlotInstruction {
  ValueVot value;

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (cast(slot).location != sentinel) {
      assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).asOperand(), value.asOperand(), concat('value of ', cast(slot).debugName as String));
      if ((cast(slot).staticType as Type).hasDynamicType()) {
        assert(value.staticType.hasDynamicType(), concat('unexpectedly tried to map value of normal type ', cast(slot).staticType as Type, ' to non-dynamic-supporting type ', value.staticType));
        assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).dynamicType().asOperand(), value.dynamicType().asOperand(), concat('type of ', cast(slot).debugName as String));
      }
    } else {
      cast(cast(slot).assignLocation)(value);
    }
  }

  Null constructor(Object slotArg, ValueVot valueArg) {
    super.constructor(slotArg);
    value = valueArg;
  }
}

class WriteDynamicSlotInstruction extends SlotInstruction {
  ValueHandle value;

  // XXX when assembling, defer to slot.type
  // e.g. for ref counting management of Strings, GC of lists and objects

  Null generateAssembler(Assembler assembler, Integer blockId) {
    if (cast(slot).location != sentinel) {
      assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).asOperand(), value.value!.asOperand(), concat('value of ', cast(slot).debugName as String));
      if ((cast(slot).staticType as Type).hasDynamicType()) {
        assembler.addMov(blockId, ((cast(cast(slot).location)) as ValueVot).dynamicType().asOperand(), value.type.type!.asOperand(), concat('type of ', cast(slot).debugName as String));
      }
    } else {
      cast(cast(slot).assignLocation)(value.value!);
    }
  }

  Null constructor(Object slotArg, ValueHandle valueArg) {
    super.constructor(slotArg);
    value = valueArg;
  }
}

class SubroutineCallInstruction extends Instruction {
  ValueHandle target; // points to a CompiledSubroutine
  ValueHandleList arguments;
  ValueHandle thisPointer;
  ValueHandle closurePointer;
  ValueHandle returnValue;

  Null prepareInstructions() {
    super.prepareInstructions();
    thisPointer.forceAllocation();
    closurePointer.forceAllocation();
    returnValue.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, concat('Calling ', target.value!.asOperand(), ' with ', len(arguments), ' arguments'));
    Integer argumentIndex = len(arguments) - 1;
    while (argumentIndex >= 0) {
      assembler.addPush(blockId, arguments[argumentIndex].value!.asOperand(), concat('value of argument #', argumentIndex + 1));
      assembler.addPush(blockId, arguments[argumentIndex].value!.dynamicType().asOperand(), concat('type of argument #', argumentIndex + 1));
      argumentIndex -= 1;
    }
    // XXX why do we do addlea/addpush via r11 instead of just addpush?
    assembler.addLea(blockId, r11, returnValue.value!.asOperand(), 'pointer to return value (and type, 8 bytes earlier)');
    assembler.addPush(blockId, r11, '(that pointer is the last value pushed to the stack)');
    assembler.addLea(blockId, r9, thisPointer.value!.asOperand(), 'pointer to this');
    assembler.addMov(blockId, r8, thisPointer.value!.dynamicType().asOperand(), 'type of this');
    assembler.addLea(blockId, rdx, closurePointer.value!.asOperand(), 'pointer to closure');
    assembler.addCode(blockId, concat('mov rcx, ', len(arguments)), 'number of arguments');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, concat('call ', target.value!.asOperand()), 'jump to subroutine');
    assembler.addCode(blockId, concat('add rsp, ', hex8(32 + 8 * 2 * len(arguments) + 8)), 'release shadow space and arguments');
  }  

  Null constructor(ValueHandle targetArg, ValueHandleList argumentsArg, ValueHandle thisPointerArg, ValueHandle closurePointerArg, ValueHandle returnValueArg) {
    super.constructor();
    target = targetArg;
    arguments = argumentsArg;
    thisPointer = thisPointerArg;
    closurePointer = closurePointerArg;
    returnValue = returnValueArg;
  }
}

// ============================================================================
// SLOTS
// ============================================================================

class Slot extends VotSource {
  Boolean isAnonymous;
  Boolean isStatic;

  Object homeScope; // XXX Object should be CompiledScope
  Set referencingStackFrames = Set(); // of CompiledStackFrameScope
  Boolean needsAllocation = false;
  Boolean isRead = false;
  Boolean isInitialized = false;
  Boolean isWritten = false;

  Null forceAllocation() {
    needsAllocation = true;
  }

  Null recordWrite() {
    if (!isInitialized) {
      isInitialized = true;
    } else if (!isWritten) {
      isWritten = true;
      needsAllocation = true; // TODO: support using registers instead
    }
  }

  ValueHandle read(Object currentScope) { // XXX Object should be CompiledScope
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    isRead = true;
    (cast(currentScope).emitInstruction as NullFunction)(PopulateValueHandleInstruction(this, result));
    return result;
  }

  Null writeStatic(Object currentScope, ValueVot newValue) { // XXX Object should be CompiledScope
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    (cast(currentScope).emitInstruction as NullFunction)(WriteStaticSlotInstruction(this, newValue));
    recordWrite();
  }

  Null write(Object currentScope, ValueHandle newValue) { // XXX Object should be CompiledScope
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    (cast(currentScope).emitInstruction as NullFunction)(WriteDynamicSlotInstruction(this, newValue));
    recordWrite();
  }

  ValueHandle prepareWrite(Object currentScope) { // XXX Object should be CompiledScope
    ValueHandle result = ValueHandle(this, null);
    referencingStackFrames.add(cast(cast(currentScope).stackFrame)());
    (cast(currentScope).emitInstruction as NullFunction)(PopulateValueHandleInstruction(this, result));
    recordWrite();
    return result;
  }

  Boolean canBeStackAllocated() {
    AnythingList stackFrames = referencingStackFrames.values();
    Boolean result = needsAllocation
        && (len(stackFrames) == 1)
        && (stackFrames[0] == cast(cast(homeScope).stackFrame)())
        && (isAnonymous || (homeScope.className != 'CompiledLibrary'));
    return result;
  }

  Boolean needsHeapAllocation() {
    return needsAllocation && !canBeStackAllocated();
  }

  ValueVot location;

  Null assignLocation(ValueVot locationArg) {
    location = locationArg;
  }

  String toString() {
    return concat('<', debugName, ': ', staticType, ' at ', location, '>');
  }

  Null constructor(Type staticTypeArg, Object homeScopeArg, String debugNameArg, Boolean isAnonymousArg, Boolean isStaticArg) { // XXX Object should be CompiledScope
    super.constructor(staticTypeArg, debugNameArg);
    homeScope = homeScopeArg;
    isAnonymous = isAnonymousArg;
    isStatic = isStaticArg;
  }
}


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

// Library State
enum ls { Unknown Declared Defined }

class CompilationEnvironment extends TypeRegistry {
  Map labels = Map(); // String -> Integer

  String generateLabel(String name) {
    IntegerNullable sequenceId = labels.get(name) as IntegerNullable;
    String result;
    if (sequenceId == null) {
      sequenceId = 0;
      result = name;
    } else {
      sequenceId = sequenceId! + 1;
      result = concat(name, '$', sequenceId);
    }
    labels.set(name, sequenceId);
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  ObjectNullable runtimeLibrary = null; // XXX Object should be CompiledRuntimeLibraryNullable

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
    append(libraryNames, filename);
  }

  Null defineLibrary(String filename, Object library) { // XXX Object should be CompiledLibrary
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return lsUnknown;
    }
    if (library == false) {
      return lsDeclared;
    }
    assert(library is Object, 'library is not a CompiledLibrary, false, or null');
    assert(cast(library).className == 'CompiledLibrary', 'library is not a CompiledLibrary, false, or null');
    return lsDefined;
  }

  Object getLibrary(String filename) { // XXX Object should be CompiledLibrary
    assert(getLibraryState(filename) == lsDefined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  ObjectList subroutines = []:Object; // XXX Object should be CompiledSubroutine

  Null addSubroutine(Object subroutine) { // XXX Object should be CompiledSubroutine
    append(subroutines, subroutine);
  }

  Null prepareInstructions() {
    (cast(runtimeLibrary).prepareInstructions as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareInstructions as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareInstructions as NullFunction)();
    }
  }

  Null prepareSlots() {
    (cast(runtimeLibrary).prepareSlots as NullFunction)();
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).prepareSlots as NullFunction)();
    }
    for (subroutine in subroutines) {
      (cast(subroutine).prepareSlots as NullFunction)();
    }
  }

  Null generateAssemblerBlocks(Assembler assembler) {
    (cast(runtimeLibrary).generateAssemblerBlock as NullFunction)(assembler);
    for (libraryName in libraryNames) {
      Anything library = libraries.get(libraryName);
      assert(library is Object, concat(libraryName, ' was never fully compiled'));
      (cast(library).generateAssemblerBlock as NullFunction)(assembler);
    }
    for (subroutine in subroutines) {
      (cast(subroutine).generateAssemblerBlock as NullFunction)(assembler);
    }
  }

  VotSource integers;

  ValueHandle integer(Integer value) {
    integers.staticType.markConstructed();
    return ValueHandle(integers, LiteralIntegerVot(integers.staticType as NumericType, value));
  }

  String typeTableLabel;
  Integer typeTableOffset;
  Integer typeTableWidth;

  Null generateTypeTable(Assembler assembler, String label) {
    StringList comment = []:String;
    IntegerList bytes = []:Integer;
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, '   ; Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        append(comment, concat(' ', supertype));
      }
    }
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(comment, '   ; ');
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        append(bytes, byte);
        byte = 0;
        bits = 0;
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    assembler.addData(
      label,
      [
        concat('db ', join(map(bytes, hex8) as StringList, ', ')),
      ],
      [
        concat('Type table\n', join(comment, '')),
      ],
    );
    typeTableOffset = offset;
    typeTableWidth = width;
  }

  Null compile(Assembler assembler) {
    typeTableLabel = generateLabel('typeTable');
    prepareInstructions();
    assignTypeCodes();
    generateTypeTable(assembler, typeTableLabel);
    prepareSlots();
    generateAssemblerBlocks(assembler);
  }

  Null constructor(Assembler assembler) {
    super.constructor();
    runtimeLibrary = cast(cast(cast(this).CompiledRuntimeLibrary)(this, 'rtl'));
    integers = VotSource(cast(runtimeLibrary).coreIntegerType as Type, 'integers');
   }
}

// ============================================================================
// SCOPES
// ============================================================================
ObjectFunction makeCompiledNestedScope;
class CompiledScope extends Object {
  // parent scope, for lookups
  CompiledScopeNullable parent;
  String name; // TODO: rethink exactly what this means

  CompiledScope globalScope() { // XXX CompiledScope should be CompiledLibrary
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).globalScope)(); // XXX can't reference self on other instances yet
  }

  CompiledScope stackFrame() { // XXX CompiledScope should be CompiledStackFrameScope
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = cast(cast(parent!).stackFrame)() as CompiledScope;
    return result;
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return cast(cast(parent!).environment)();
  }

  String labelPrefix() {
    abstract();
  }

  // variables namespace
  Map identifiers = Map(); // String -> Slot (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable value = cast(identifiers.get(name));
    if (value == null && parent != null) {
      value = cast(cast(cast(parent!).lookupIdentifier)(name));
    }
    return value;
  }

  InstructionList instructions = []:Instruction;

  Null emitInstruction(Instruction instruction) {
    append(instructions, instruction);
  }

  Null registerSlot(Slot slot) {
    cast(cast(stackFrame()).registerSlot)(slot);
  }

  Slot registerDynamicValue(Type type, String debugName) {
    Slot slot = Slot(type, this, debugName, true, false); // anonymous, mutable
    registerSlot(slot);
    return slot;
  }

  Slot registerStaticValue(ValueVot value, String debugName) {
    Slot slot = Slot(value.staticType, this, debugName, true, true); // anonymous, immutable
    registerSlot(slot);
    slot.writeStatic(this, value);
    return slot;
  }

  Slot registerVariable(String name, Type type, ValueHandle initialValue) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(type, this, name, false, false); // named, mutable
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.write(this, initialValue);
    return slot;
  }

  Slot registerConstant(String name, ValueVot value) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(value.staticType, this, name, false, true); // named, immutable
    globalScope().registerSlot(slot);
    identifiers.set(name, slot);
    slot.writeStatic(this, value);
    value.staticType.markConstructed();
    return slot;
  }

  Slot registerSubroutine(CompiledScope subroutine) { // XXX CompiledScope should be CompiledSubroutine
    assert(!isIdentifierDeclaredInLocalScope(cast(subroutine).name as String), 'tried to redeclare an identifier within a scope');
    Slot slot = Slot(cast(subroutine).type as Type, this, cast(subroutine).name as String, false, true); // named, immutable
    registerSlot(slot);
    identifiers.set(cast(subroutine).name, slot);
    slot.writeStatic(this, LabelVot(cast(subroutine).type as AbstractSubroutineType, cast(subroutine).label as String));
    environment().addSubroutine(subroutine);
    (cast(subroutine).type as Type).markConstructed();
    return slot;
  }

  Slot emitSubroutineCall(ValueHandle target, ValueHandleList arguments) {
    append(instructions, CommentInstruction('Prepare local variables for function call'));
    Slot thisPointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClassType), 'this pointer');
    Slot closurePointer = registerDynamicValue(cast(cast(environment().runtimeLibrary!).coreClosureType), 'closure pointer');
    thisPointer.writeStatic(this, cast(environment().runtimeLibrary!).coreSentinel as ValueVot);
    closurePointer.writeStatic(this, cast(environment().runtimeLibrary!).coreSentinel as ValueVot);
    Type returnType;
    VotSource targetSlot = target.source;
    if (targetSlot.staticType.isSubroutineType()) {
      AbstractSubroutineType subroutineType = targetSlot.staticType as AbstractSubroutineType;
      returnType = subroutineType.returnType;
    } else {
      returnType = cast(cast(environment().runtimeLibrary!).coreAnythingType);
    }
    ValueHandle thisPointerRead = thisPointer.read(this);
    ValueHandle closurePointerRead = closurePointer.read(this);
    Slot returnValue = registerDynamicValue(returnType, 'return value');
    ValueHandle returnValuePointer = returnValue.read(this);
    SubroutineCallInstruction call = SubroutineCallInstruction(
      target,
      arguments,
      thisPointerRead,
      closurePointerRead,
      returnValuePointer,
    );
    append(instructions, call);
    return returnValue;
  }

  CompiledScope createErrorHandlerBlock(Slot errorMessage, String what) {
    CompiledScope block = makeCompiledNestedScope(this, concat(camelCase(what), '$Error')) as CompiledScope;
    String label = environment().generateLabel(concat(block.labelPrefix(), '$', camelCase(what), '$Ok'));
    ValueHandle printHandle = (cast(environment().runtimeLibrary!).corePrint as Slot).read(block);
    block.emitSubroutineCall(printHandle, [ errorMessage.read(block) ]);
    ValueHandle exitHandle = (cast(environment().runtimeLibrary!).coreExit as Slot).read(block);
    ValueHandle failureExitCode = environment().integer(0x01);
    block.emitSubroutineCall(exitHandle, [ failureExitCode ]);
    return block;
  }

  Null emitTypeCheck(ValueHandle value, Type type, Slot errorMessage, String what) {
    CompiledScope block = createErrorHandlerBlock(errorMessage, what);
    append(instructions, DoIfTypeMismatchInstruction(type, value.type, concat(labelPrefix(), '$', camelCase(what)), block, what));
  }

  Null emitBlock(CompiledScope block) {
    append(instructions, DoBlockInstruction(block));
  }

  // runs block if a != b
  Null emitConditionalBlock(CompiledScope block, ValueHandle a, ValueHandle b, String what, String comment) {
    String label = environment().generateLabel(concat(labelPrefix(), '$', camelCase(what), '$continuation'));
    append(instructions, JumpIfEqualInstruction(a, b, label, comment));
    append(instructions, DoBlockInstruction(block));
    append(instructions, LabelInstruction(label, concat('end of ', what)));
  }

  // jumps to label if a == b
  Null emitConditionalJump(String label, ValueHandle a, ValueHandle b, String comment) {
    append(instructions, JumpIfEqualInstruction(a, b, label, comment));
  }

  Null emitParameterChecks(SlotList parameters) {
    // xxxx verify the types statically
    // check for parameter count
    append(instructions, CommentInstruction('Check parameter count'));
    Slot paramCount = registerStaticValue(OperandVot(cast(environment().runtimeLibrary).coreIntegerType as Type, rcx), 'parameter count');
    ValueHandle paramCountValue = paramCount.read(this);
    ValueHandle expectedParamCountValue = environment().integer(len(parameters));
    CompiledScope block = createErrorHandlerBlock(
      cast(environment().runtimeLibrary!).parameterCountCheckFailureMessage as Slot,
      'parameter count',
    );
    emitConditionalBlock(block, paramCountValue, expectedParamCountValue, 'parameter count', 'check number of parameters is as expected');
    Integer index = 0;
    for (parameter in parameters) {
      append(instructions, CommentInstruction(concat('Check type of parameter ', index, ', ', parameter.debugName, ' (expecting ', parameter.staticType, ')')));
      emitTypeCheck(parameter.read(this), parameter.staticType, cast(environment().runtimeLibrary!).parameterTypeCheckFailureMessage as Slot, parameter.debugName);
      index += 1;
    }
  }

  Null prepareInstructions() {
    for (instruction in instructions) {
      instruction.prepareInstructions();
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    for (instruction in instructions) {
      instruction.generateAssembler(assembler, blockId);
    }
  }  

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    parent = parentArg;
    name = nameArg;
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  String toString() {
    return concat('<', name, ':', className, '@', internalObjectId, '>');
  }
}

class CompiledNestedScope extends CompiledScope {
  String labelPrefix() {
    return concat(parent!.labelPrefix(), '$', name);
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.indent(blockId, super.generateAssembler);
  }

  Null constructor(CompiledScope parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}
makeCompiledNestedScope = CompiledNestedScope;

class CompiledStackFrameScope extends CompiledScope {
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  SlotList slots = []:Slot;

  Null registerSlot(Slot slot) {
    append(slots, slot);
  }

  Integer stackSize = 0x00;

  Null prepareSlots() {
    for (slot in slots) {
      //stderr(concat(slot, ' read:', slot.isRead, ' needs:', slot.needsAllocation, ' stack?:', slot.canBeStackAllocated(), ' heap?:', slot.needsHeapAllocation()));
      if (slot.isRead) {
        if (slot.needsAllocation) {
          if (slot.canBeStackAllocated()) {
            // TODO emit a comment giving the stack layout for this stack frame
            slot.assignLocation(StackAllocatedVot(slot.staticType, stackSize));
            if (slot.staticType.hasDynamicType()) {
              stackSize += 0x10;
            } else {
              stackSize += 0x08;
            }
          } else {
            throw(concat('not sure what to do with ', slot, ' in terms of allocation'));
          }
        }
      }
    }
  }

  // Returns (a new copy of) the list of the registers to save/restore in the prolog/epilog.
  // These are the non-volatile registers that are modified in this scope.
  // The list may be modified by the caller.
  // The rbp register must come first.
  StringList nonvolatileRegistersUsed() {
    return ['rbp'];
  }

  Null generatePrologAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, 'Prolog');
    StringList registers = nonvolatileRegistersUsed();
    assert(registers[0] == 'rbp', 'nonvolatileRegistersUsed() did not return rbp first');
    for (register in registers) {
      assembler.addCode(blockId, concat('push ', register), 'save volatile registers');
    }
    if (stackSize > 0) {
      // TODO: should list what variables we're allocating space for here
      // TODO: if stackSize > 8KB (0x2000), call __chkstk__
      assert(stackSize < 0x2000, 'need to implement calling __chkstk__');
      assembler.addCode(blockId, concat('sub rsp, ', hex8(stackSize)), 'allocate space for stack');
    }
    assembler.addCode(blockId, concat('lea rbp, [rsp+', hex8(stackSize), ']'), 'set up frame pointer');
  }

  Null generateEpilogAssembler(Assembler assembler, Integer blockId) {
    assembler.addComment(blockId, 'Epilog');
    if (stackSize > 0) {
      assembler.addCode(blockId, concat('add rsp, ', hex8(stackSize)), 'free space for stack');
    }
    StringList registers = nonvolatileRegistersUsed();
    Integer index = len(registers);
    while (index > 0) {
      index -= 1;
      assembler.addCode(blockId, concat('pop ', registers[index]), 'restore volatile registers');
    }
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    generatePrologAssembler(assembler, blockId);
    super.generateAssembler(assembler, blockId);
    generateEpilogAssembler(assembler, blockId);
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }
}

class ReturnInstruction extends JumpInstruction {
  Null constructor(Object stackFrame, String commentArg) { // XXX Object should be CompiledSubroutine
    super.constructor(cast(stackFrame).epilogLabel as String, commentArg);
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineType type;
  String label;
  String epilogLabel;

  Slot returnValue;

  String labelPrefix() {
    return concat('func$', name);
  }

  StringList nonvolatileRegistersUsed() {
    StringList result = super.nonvolatileRegistersUsed();
    append(result, 'r15');
    return result;
  }

  Slot registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Slot slot = Slot(type, this, name, false, true);
    registerSlot(slot);
    identifiers.set(name, slot);
    slot.writeStatic(this, ParameterVot(type, len(nonvolatileRegistersUsed()), position));
    return slot;
  }

  Null generatePrologAssembler(Assembler assembler, Integer blockId) {
    super.generatePrologAssembler(assembler, blockId);
    Integer savedRegisterCount = len(nonvolatileRegistersUsed());
    Integer offset = 0x08 /* return address */ + 0x20 /* shadow space */ + 0x08 * savedRegisterCount;
    assembler.addMov(blockId, r15, Operand(concat('rbp+', hex8(offset)), otIndirect), 'prepare return value');
  }

  Null generateEpilogAssembler(Assembler assembler, Integer blockId) {
    // xxxx set default return value, fail if there's no explicit return value in method that can't return null
    assembler.addCode(blockId, concat(epilogLabel, ':'), null);
    assembler.addMov(blockId, rax, r15, 'report address of return value');
    super.generateEpilogAssembler(assembler, blockId);
    assembler.addCode(blockId, 'ret', 'return from subroutine');
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.addLabel(label, name));
  }

  Null emitReturnFrom(CompiledScope scope, ValueHandle value) {
    // xxxx verify the type of value statically
    scope.emitTypeCheck(value, type.returnType, cast(environment().runtimeLibrary!).returnValueTypeCheckFailureMessage as Slot, concat('return value of ', name));
    returnValue.write(scope, value);
    scope.emitInstruction(ReturnInstruction(this, 'return'));
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType typeArg, String nameArg) {
    super.constructor(parentArg, nameArg);
    type = typeArg;
    label = environment().generateLabel(labelPrefix());
    epilogLabel = environment().generateLabel(concat(labelPrefix(), '$epilog'));
    returnValue = registerDynamicValue(type.returnType, 'return value');
    returnValue.writeStatic(this, OperandPairVot(type.returnType, Operand('r15-08h', otIndirect), Operand('r15', otIndirect)));
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class BuiltInSubroutine extends CompiledSubroutine {
  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineType signature, String name) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(parentArg, signature, name);
  }
}

class BuiltInPrintSubroutineInstructions extends Instruction {
  ValueHandle lpNumberOfCharsWritten;
  ValueHandle parameter;

  Null prepareInstructions() {
    super.prepareInstructions();
    lpNumberOfCharsWritten.forceAllocation();
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('GetStdHandle');
    assembler.addExternProc('WriteConsoleA');
    assembler.addComment(blockId, 'Calling GetStdHandle');
    assembler.addCode(blockId, 'mov rcx, -11', 'argument #1: STD_OUTPUT_HANDLE');
    assembler.addCode(blockId, 'call GetStdHandle', 'handle returned in rax');
    assembler.addComment(blockId, 'Calling WriteConsoleA');
    assembler.addCode(blockId, 'push 0', 'argument #5: Reserved, must be NULL (lpReserved)');
    assembler.addLea(blockId, r9, lpNumberOfCharsWritten.value!.asOperand(), 'argument #4: Number of characters written (lpNumberOfCharsWritten)');
    assembler.addMov(blockId, r10, parameter.value!.asOperand(), 'get address of string structure');
    assembler.addCode(blockId, 'mov r8, [r10+08h]', 'argument #3: Length of buffer (nNumberOfCharsToWrite), from string structure');
    assembler.addCode(blockId, 'lea rdx, [r10+10h]', 'argument #2: Pointer to buffer to write (*lpBuffer)');
    assembler.addCode(blockId, 'mov rcx, rax', 'argument #1: Handle from GetStdHandle (hConsoleOutput)');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call WriteConsoleA', 'returns boolean representing success in rax');
    assembler.addCode(blockId, 'add rsp, 28h', 'release shadow space and arguments');
  }

  Null constructor(ValueHandle lpNumberOfCharsWrittenArg, ValueHandle parameterArg) {
    super.constructor();
    lpNumberOfCharsWritten = lpNumberOfCharsWrittenArg;
    parameter = parameterArg;
  }
}

class BuiltInPrintSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot lpNumberOfCharsWritten = registerDynamicValue(cast(parent!).coreSystemType as Type, 'lpNumberOfCharsWritten, out param of WriteConsoleA');
    ValueHandle lpNumberOfCharsWrittenPointer = lpNumberOfCharsWritten.read(this);
    Slot parameter = registerStaticValue(ParameterVot(cast(parent!).coreStringType as Type, len(nonvolatileRegistersUsed()), 0), 'message to print to console'); // (unnamed parameter)
    emitParameterChecks([parameter]);
    ValueHandle parameterValue = parameter.read(this);
    emitInstruction(BuiltInPrintSubroutineInstructions(lpNumberOfCharsWrittenPointer, parameterValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      SubroutineTypeWithSpecificParameters(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        [cast(parentArg).coreStringType as Type],
      ),
      'print',
    );
  }
}

class BuiltInExitSubroutineInstructions extends Instruction {
  ValueHandle exitCode;

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addIncludeLib('kernel32.lib');
    assembler.addExternProc('ExitProcess');
    assembler.addComment(blockId, 'Calling ExitProcess');
    assembler.addMov(blockId, rcx, exitCode.value!.asOperand(), 'exit code');
    assembler.addCode(blockId, 'sub rsp, 20h', 'allocate shadow space');
    assembler.addCode(blockId, 'call ExitProcess', 'process should terminate at this point');
    assembler.addCode(blockId, 'add rsp, 20h', 'release shadow space');
  }

  Null constructor(ValueHandle exitCodeArg) {
    super.constructor();
    exitCode = exitCodeArg;
  }
}

class BuiltInExitSubroutine extends BuiltInSubroutine {
  Null prepareInstructions() {
    Slot exitCode = registerStaticValue(ParameterVot(cast(parent!).coreIntegerType as Type, len(nonvolatileRegistersUsed()), 0), 'exit code parameter'); // (unnamed parameter)
    emitParameterChecks([exitCode]);
    ValueHandle exitCodeValue = exitCode.read(this);
    emitInstruction(BuiltInExitSubroutineInstructions(exitCodeValue));
    super.prepareInstructions();
  }

  Null constructor(CompiledScopeNullable parentArg) { // XXX parentArg should be CompiledRuntimeLibrary
    super.constructor(
      parentArg,
      createOrFindSubroutineType(
        cast(cast(cast(parentArg).environment)()),
        cast(cast(parentArg).coreNullType),
        [ cast(parentArg).coreIntegerType as Type ]:Type,
      ),
      'exit',
    );
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;

  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  String labelPrefix() {
    return camelCase(name);
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  SlotNullable lookupIdentifier(String name) {
    SlotNullable result = super.lookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.lookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(types.get(type.name) == null, 'tried to redefine a type name');
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = cast(cast(library).lookupType)(name) as TypeNullable;
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Null generateAssembler(Assembler assembler, Integer blockId) {
    assembler.addBlankLine(blockId);
    assembler.addComment(blockId, name);
    assembler.addComment(blockId, stringTimes('=', len(scalarValues(name))));
    super.generateAssembler(assembler, blockId);
  }

  Null generateAssemblerBlock(Assembler assembler) {
    generateAssembler(assembler, assembler.mainBlockId);
  }  

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(null, nameArg);
    compilationEnvironment = compilationEnvironmentArg;
    CompiledLibraryNullable runtimeLibrary = cast(compilationEnvironment.runtimeLibrary); // XXX CompiledLibrary should be CompiledRuntimeLibrary
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledRuntimeLibrary extends CompiledLibrary {
  String labelPrefix() {
    return 'rtl';
  }

  AnythingType coreAnythingType;
  NullType coreNullType;
  BooleanType coreBooleanType;
  IntegerType coreIntegerType;
  StringType coreStringType;

  RootClassType coreClassType;
  ClosureType coreClosureType;
  SystemType coreSystemType;
  SentinelType coreSentinelType;

  ValueVot coreSentinel;
  Slot coreNull;
  Slot coreTrue;
  Slot coreFalse;

  Slot corePrint;
  Slot coreExit;

  Slot parameterCountCheckFailureMessage;
  Slot parameterTypeCheckFailureMessage;
  Slot returnValueTypeCheckFailureMessage;

  Slot registerStringConstant(String labelBase, String value, Integer line, Integer col, String file) {
    String label = compilationEnvironment.generateLabel(labelBase);
    emitInstruction(StringConstantDataInstruction(
      label,
      value,
      SourceLocation(line, col, file),
    ));
    coreStringType.markConstructed();
    return registerStaticValue(LabelPointerVot(coreStringType, label), labelBase);
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    super.constructor(compilationEnvironmentArg, nameArg);
    // internal types
    coreClassType = RootClassType(compilationEnvironmentArg);
    coreClosureType = ClosureType(compilationEnvironmentArg);
    coreSystemType = SystemType(compilationEnvironmentArg);
    coreSentinelType = SentinelType(compilationEnvironmentArg);
    // built-in types
    coreAnythingType = AnythingType(compilationEnvironmentArg);
    declareType(coreAnythingType);
    coreSentinel = SentinelVot(coreSentinelType);
    coreSentinelType.markConstructed();
    coreNullType = NullType(compilationEnvironmentArg);
    declareType(coreNullType);
    coreNull = registerConstant('null', LiteralIntegerVot(coreNullType, 0x00));
    coreBooleanType = BooleanType(compilationEnvironmentArg);
    declareType(coreBooleanType);
    coreFalse = registerConstant('false', LiteralIntegerVot(coreBooleanType, 0x00));
    coreTrue = registerConstant('true', LiteralIntegerVot(coreBooleanType, 0x01));
    coreIntegerType = IntegerType(compilationEnvironmentArg);
    declareType(coreIntegerType);
    coreStringType = StringType(compilationEnvironmentArg);
    declareType(coreStringType);
    // built-in functions
    corePrint = registerSubroutine(BuiltInPrintSubroutine(this));
    coreExit = registerSubroutine(BuiltInExitSubroutine(this));
    // messages
    parameterCountCheckFailureMessage = registerStringConstant(
      'parameterCountCheckFailureMessage',
      'error: function call received the wrong number of parameters (expected %d, received %d)\n',
      __LINE__, __COL__, __FILE__,
    );
    parameterTypeCheckFailureMessage = registerStringConstant(
      'parameterTypeCheckFailureMessage',
      'error: type mismatch for function %s parameter %d, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
    returnValueTypeCheckFailureMessage = registerStringConstant(
      'returnValueTypeCheckFailureMessage',
      'error: type mismatch for function return value, expected %s, got %s\n',
      __LINE__, __COL__, __FILE__,
    );
  }
}
