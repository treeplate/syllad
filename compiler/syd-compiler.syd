import 'core.syd';
import 'syd-assembler.syd';
import 'syd-types.syd';
import 'syd-datum.syd';
import 'syd-pseudo-instructions.syd';
import 'syd-bound-instructions.syd';
import 'syd-utils.syd';

// TODO
// exceptions should be done using this:
// https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

    /* This is what the stack looks like after a prolog:
     *     FFFF :    FFFF :
     *      ... :     ... :
     *  rsp+60h : rbp+50h : (local variable from previous stack frame)
     *                      (maybe arg 2 here)
     *  rsp+58h : rbp+48h : value of arg 1 (e.g. pointer to string structure)     
     *  rsp+50h : rbp+40h : type of arg 1
     *  rsp+48h : rbp+38h : pointer to return value
     *  rsp+40h : rbp+30h : pointer to return value type
     *  rsp+38h : rbp+28h : "shadow r9", actually used as scratch space for class constructor return value
     *  rsp+30h : rbp+20h : "shadow r8", actually used as scratch space for class constructor return type
     *  rsp+28h : rbp+18h : "shadow rdx", actually used as scratch space for tail recursion code address
     *  rsp+20h : rbp+10h : shadow rcx
     *  rsp+18h : rbp +8h : return address
     *  rsp+10h : rbp     : saved non-volatile register rbp                      
                            (maybe other saved registers here)
                            (maybe stack alignment gap)
     *  rsp +8h : rbp -8h : first local variable
     *  rsp     : rbp-10h : second local variable (or type of first local variable)
     *      ... :     ... :
     *     0000 :    0000 :
     */

     // on the heap, a 16 byte entry has the value second, and the type 8 bytes "earlier" (heap grows up)
     //    so if the value is at p, type at p-0x08
     // on the stack, a 16 byte entry has the value first, then the type 8 bytes "later" (stack grows down)
     //    so if the value is at p, type at p-0x08


    /* SYD CALLING CONVENTION
         Parameters:                                           x64 implementation
          0: number of syd parameters                           rcx
          1: pointer to closure objects (or sentinel)           rdx
          2: this type (or sentinel)                            r8
          3: this value (or sentinel)                           r9
          4: pointer to return type                             rbp+30h
          5: pointer to return value                            rbp+38h
          (N*2)+6: pointer to Nth parameter type                rbp+((N*2)+8)*8
          (N*2)+7: pointer to Nth parameter value               rbp+((N*2)+9)*8
     */


     /* COMMENT CONVENTIONS

        Given a variable foo, we refer to "foo" when talking about the value and "type of foo" when talking about the type.
        We avoid referring to "value of foo".

     */

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================
fwdclass CompilationEnvironment extends TypeRegistry;
fwdclass CompiledScope(CompiledScopeNullable, String) extends Object;
fwdclass ClassType(CompiledScope, String, TypeNullable) extends Type;
fwdclass CompiledStackFrameScope(CompiledScopeNullable, String) extends CompiledScope;
fwdclass CompiledSubroutine(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends CompiledStackFrameScope;
fwdclass CompiledLibrary(CompilationEnvironment, String) extends CompiledStackFrameScope;
fwdclass CompiledIntrinsicsLibrary(CompilationEnvironment, String) extends CompiledLibrary;
fwdclass CompiledSubroutineWithSpecificParameters(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends CompiledSubroutine;
fwdclass CompiledGeneratedConstructorSubroutine(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassType) extends CompiledSubroutine;
fwdclass BuiltInSubroutine(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends CompiledSubroutineWithSpecificParameters;
fwdclass BuiltInLenSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass BuiltInDebuggerSubroutine(CompiledIntrinsicsLibrary) extends BuiltInSubroutine;
fwdclass MemberDescription(ClassType, String, Type, Boolean, SourceLocation) extends Object;
fwdclass BuiltInGetterMethod(CompiledIntrinsicsLibrary, ClassType, MemberDescription) extends BuiltInSubroutine;
fwdclass BuiltInSetterMethod(CompiledIntrinsicsLibrary, ClassType, MemberDescription) extends BuiltInSubroutine;
fwdclass CompilerIntrinsic(CompiledScopeNullable, AbstractSubroutineTypeWithSpecificParameters, String, ClassTypeNullable) extends BuiltInSubroutine;
fwdclass BuiltInReadFromAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass BuiltInWriteToAddressIntrinsic(CompiledIntrinsicsLibrary) extends CompilerIntrinsic;
fwdclass CompiledVarArgsSubroutine extends CompiledSubroutine;
fwdclass IdentifierEntity extends Object;
fwdclass SubroutinePointerBucket(CompiledSubroutine, Boolean) extends ConstantBucket;
fwdclass RootEnumPropertyType(TypeRegistry, String) extends NumericType;
fwdclass EnumPropertyType(TypeRegistry, String) extends NumericType;
fwdclass RootReifiedEnumType(TypeRegistry, String) extends NumericType;
fwdclass ReifiedEnumType(TypeRegistry, AssemblerLabel, StringBucket, EnumPropertyType, Map) extends NumericType;
fwdclass ReifiedEnumBucket(ReifiedEnumType) extends DataLabelBucket;

// CompiledScope
fwdclassprop AssemblerLabel CompiledScope.label;
fwdclassprop AssemblerLabel CompiledScope.classesLabel;
fwdclassprop AssemblerLabel CompiledScope.subroutinesLabel;
fwdclassprop CompiledScopeNullable CompiledScope.parent;
fwdclassprop String CompiledScope.name;
fwdclassprop Set CompiledScope.subscopes;
fwdclassprop CompilationEnvironmentFunction CompiledScope.environment;
fwdclassprop CompiledStackFrameScopeFunction CompiledScope.stackFrame;
fwdclassprop CompiledLibraryFunction CompiledScope.globalScope;
fwdclassprop IdentifierEntityNullableFunction CompiledScope.internalLookupIdentifier;
fwdclassprop NullFunction CompiledScope.finalizeInstructions;
fwdclassprop NullFunction CompiledScope.emit;
fwdclassprop SubroutinePointerBucketFunction CompiledScope.registerSubroutine;
fwdclassprop BucketFunction CompiledScope.emitCodePointerCall;
fwdclassprop BucketFunction CompiledScope.emitSubroutinePointerCall;
fwdclassprop BucketFunction CompiledScope.emitIntrinsicCall;
fwdclassprop NullFunction CompiledScope.registerNestedScope;
fwdclassprop NullFunction CompiledScope.extractInstructionsInto;
fwdclassprop BucketFunction CompiledScope.emitCopy;

// CompiledSubroutine
fwdclassprop AssemblerLabel CompiledSubroutine.functionPointerLabel;
fwdclassprop Bucket CompiledSubroutine.codePointer;
fwdclassprop AbstractSubroutineTypeWithSpecificParameters CompiledSubroutine.type;
fwdclassprop BucketNullableFunction CompiledSubroutine.inline;
fwdclassprop NullFunction CompiledSubroutine.adoptBucket;

// CompiledLibrary
fwdclassprop CompilationEnvironment CompiledLibrary.compilationEnvironment;
fwdclassprop TypeNullableFunction CompiledLibrary.lookupType;

// CompiledIntrinsicsLibrary
fwdclassprop NullFunction CompiledIntrinsicsLibrary.generateScopes;

// CompilationEnvironment
fwdclassprop BucketFunction CompilationEnvironment.integer;

// SubroutinePointerBucket
fwdclassprop CompiledSubroutine SubroutinePointerBucket.subroutine;

// ClassType
fwdclassprop NullFunction ClassType.propagateNeedsMethodsFor;
fwdclassprop NullFunction ClassType.assignIndicies;
fwdclassprop NullFunction ClassType.populateMembers;
fwdclassprop Map ClassType.members;
fwdclassprop NullFunction ClassType.generateVmt;
fwdclassprop AssemblerLabel ClassType.vmtLabel;
fwdclassprop Set ClassType.subtypes;
fwdclassprop SubroutinePointerBucket ClassType.constructorSubroutine;

// MemberDescription
fwdclassprop ClassType MemberDescription.classType;
fwdclassprop String MemberDescription.name;
fwdclassprop Type MemberDescription.staticType;
fwdclassprop Boolean MemberDescription.isField;
fwdclassprop Boolean MemberDescription.needsField;
fwdclassprop Boolean MemberDescription.needsMethods;
fwdclassprop IntegerNullable MemberDescription.fieldIndex;
fwdclassprop IntegerNullable MemberDescription.methodsIndex;
fwdclassprop CompiledSubroutineNullable MemberDescription.methodImplementation;
fwdclassprop BooleanFunction MemberDescription.isDeclared;
fwdclassprop CompiledSubroutineNullable MemberDescription.getter;
fwdclassprop CompiledSubroutineNullable MemberDescription.setter;

// IdentifierEntity
fwdclassprop BucketNullableFunction IdentifierEntity.inline;

// ReifiedEnumType
fwdclassprop StringBucket ReifiedEnumType.nameBucket;
fwdclassprop AssemblerLabel ReifiedEnumType.label;
fwdclassprop Map ReifiedEnumType.values;
fwdclassprop EnumPropertyType ReifiedEnumType.propertyType;


// ============================================================================
// COMPILATION ENVIRONMENT
// ============================================================================

String kConstructor = 'constructor';

// Library State
enum ls { Unknown Declared Defined }

fwdclass EnvironmentConversionContext(CompilationEnvironment) extends ConversionContext;

class CompilationEnvironment extends TypeRegistry {
  AssemblerLabel rootLabel = AssemblerLabel(null, '<root>');
  
  Bucket integer(Integer value) {
    assert(coreIntegerType.isConstructed, 'integer caller must call IntegerType.isConstructed');
    Bucket result = IntegerBucket(value, coreIntegerType);
    result.typeInference.setDefinitelyNotSentinel();
    return result;
  }

  Map libraries = Map(); // String -> false (actively being compiled) or CompiledLibrary
  StringList libraryNames = []:String;
  CompiledIntrinsicsLibrary intrinsicsLibrary;

  SentinelBucket coreSentinel;
  ConstantBucket coreNull;
  ConstantBucket coreTrue;
  ConstantBucket coreFalse;

  Map stringAtomTable = Map(); // String -> Constant
  ConstantList constants = []:Constant;

  StringBucket registerStringConstant(AssemblerLabel label, String value, Type type, String comment, String commentName) {
    StringConstantNullable maybeConstant = stringAtomTable.get(value) as StringConstantNullable;
    if (maybeConstant == null) {
      // TODO: length is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
      ConstantPartList lines = []:ConstantPart;
      append(lines, ConstantPart(ow.QWord, [IntegerDatum(-1, 'constant specifier')]:ImmediateDatum, 'String constant (reference count)'));
      Integer length = len(scalarValues(value));
      append(lines, ConstantPart(ow.QWord, [IntegerDatum(length, concat('length ', length))]:ImmediateDatum, 'Length'));
      if (value != '') {
        append(lines, ConstantPart(ow.Byte, [StringDatum(value, 'part of string')]:ImmediateDatum, comment));
      }
      maybeConstant = StringConstant(label, value, lines, null, commentName);
      stringAtomTable.set(value, maybeConstant);
      append(constants, maybeConstant);
      type.markConstructed();
    }
    return StringBucket(maybeConstant!, type);
  }

  Bucket errorMessage(String value) { 
    return registerStringConstant(rootLabel.deriveWith('error'), value, coreStringType, 'built-in error message', commentNameForString(value));
  }

  Map dynamicDispatchAtomTable = Map(); // String -> Integer
  Integer atomizeForDynamicDispatch(String identifier) {
    if (dynamicDispatchAtomTable.get(identifier) != null) {
      return dynamicDispatchAtomTable.get(identifier) as Integer;
    }
    dynamicDispatchAtomTable.set(identifier, dynamicDispatchAtomTable.length);
    return dynamicDispatchAtomTable.length - 1;
  }
  Boolean neededForDynamicDispatch(String identifier) {
    return dynamicDispatchAtomTable.get(identifier) != null;
  }

  Set reifiedEnumTypes = Set(); // ReifiedEnumType

  ConstantBucket registerEnumType(ReifiedEnumType reifiedEnumType) {
    assert(!reifiedEnumTypes.has(reifiedEnumType), 'tried to register enum constant that was already registered');
    reifiedEnumTypes.add(reifiedEnumType);
    return ReifiedEnumBucket(reifiedEnumType);
  }

  CompiledLibraryNullable runtimeLibrary = null; 
  CompiledLibraryNullable standardLibrary = null; 

  Null declareLibrary(String filename) {
    assert(libraries.get(filename) == null, 'tried to declare library that was already declared');
    libraries.set(filename, false);
  }

  Null defineLibrary(String filename, CompiledLibrary library) { 
    assert(library.className == 'CompiledLibrary', 'library is not a CompiledLibrary');
    assert(libraries.get(filename) == false, 'tried to define library that was not declared or was already defined');
    libraries.set(filename, library);
    append(libraryNames, filename);
  }

  ls getLibraryState(String filename) {
    Anything library = libraries.get(filename);
    if (library == null) {
      return ls.Unknown;
    }
    if (library == false) {
      return ls.Declared;
    }
    assert(library is CompiledLibrary, 'library is not a CompiledLibrary, false, or null');
    return ls.Defined;
  }

  CompiledLibrary getLibrary(String filename) { 
    assert(getLibraryState(filename) == ls.Defined, 'getLibrary called for undefined library');
    return libraries.get(filename);
  }

  Null setRuntimeLibrary(CompiledLibrary runtimeLibraryArg) { 
    runtimeLibrary = runtimeLibraryArg;
  }

  Null setStandardLibrary(CompiledLibrary standardLibraryArg) { 
    standardLibrary = standardLibraryArg;
  }

  String errorIntrinsicName = '_error';
  String exitIntrinsicName = 'exit';
  String freeIntrinsicName = '_free';
  String exponentiationIntrinsicName = 'pow#';
  String listConstructorIntrinsicName = '_listConstructor';
  String classAllocatorIntrinsicName = '_classAllocator';
  String appendIntrinsicName = 'append';
  String iteratorIntrinsicName = 'iterator';
  String currentIntrinsicName = 'current';
  String nextIntrinsicName = 'next';
  String createMethodPointerIntrinsicName = '_createMethodPointer';
  String dynamicLookupIntrinsicName = '_dynamicLookup';
  String listCastIntrinsicName = 'listCast#';

  Map intrinsics = Map(); // String -> CompiledSubroutine

  Null registerIntrinsic(CompiledSubroutine intrinsic) {
    intrinsics.set(intrinsic.name, intrinsic);
  }

  CompiledSubroutine lookupIntrinsicSubroutine(String name) {
    CompiledSubroutineNullable result = intrinsics.get(name) as CompiledSubroutineNullable;
    if (result == null) {
      // TODO: this should be an assert, and we should verify all the intrinsics are defined when we're done reading the standard library.
      throw(concat('Compiler intrinsic "', name, '" is not declared.'));
    }
    return result!;
  }

  String coreClassTypeIntrinsicName = '__Object';

  // use CompiledScope.lookupIntrinsicClass() to reference this
  Map classIntrinsics = Map(); // String -> ClassType

  Null registerClassIntrinsic(ClassType intrinsic) {
    classIntrinsics.set(intrinsic.name, intrinsic);
  }

  ClassType lookupIntrinsicClass(String name) {
    ClassTypeNullable result = classIntrinsics.get(name) as ClassTypeNullable;
    if (result == null) {
      // TODO: this should be an assert, and we should verify all the intrinsics are defined when we're done reading the standard library.
      throw(concat('Compiler intrinsic "', name, '" is not declared.'));
    }
    return result!;
  }

  Boolean finalizeInstructionsHappened = false;

  Set subroutines = Set(); // CompiledSubroutine
  CompiledSubroutineList subroutinesInDeclarationOrder = []:CompiledSubroutine;

  Null addSubroutine(CompiledSubroutine subroutine) { 
    assert(!subroutines.has(subroutine), ' redundant call to addSubroutine');
    subroutines.add(subroutine);
    append(subroutinesInDeclarationOrder, subroutine);
  }

  Null finalizeInstructions(Assembler assembler) {
    intrinsicsLibrary.finalizeInstructions(assembler);
    runtimeLibrary!.finalizeInstructions(assembler);
    standardLibrary!.finalizeInstructions(assembler);
    for (libraryName in libraryNames) {
      (libraries.get(libraryName) as CompiledLibrary).finalizeInstructions(assembler);
    }
    for (subroutine in subroutinesInDeclarationOrder) {
      subroutine.finalizeInstructions(assembler);
    }
    finalizeInstructionsHappened = true;
  }

  Null finalizeClassTypes(Assembler assembler) {
    ClassType rootClass = lookupIntrinsicClass(coreClassTypeIntrinsicName);
    rootClass.assignIndicies(this, 0, 0);
    rootClass.populateMembers(this);
  }

  BoundInstructionList extractInstructions() {
    BoundInstructionList result = []:BoundInstruction;
    intrinsicsLibrary.extractInstructionsInto(result);
    runtimeLibrary!.extractInstructionsInto(result);
    standardLibrary!.extractInstructionsInto(result);
    for (libraryName in libraryNames) {
      (libraries.get(libraryName) as CompiledLibrary).extractInstructionsInto(result);
    }
    for (subroutine in subroutinesInDeclarationOrder) {
      subroutine.extractInstructionsInto(result);
    }
    return result;
  }

  Null emitDecrefs(BucketList buckets, BoundInstructionList output, AssemblerLabel scopeLabel) {
    for (bucket in buckets) {
      BoundInstruction decref = DecrefInstruction(bucket);
      append(output, decref);
      decref.bind(scopeLabel);
    }
  }

  Null generateDecrefInstructionsForBlock(BoundInstructionList instructions, BoundInstructionList output, SetList localVariableStack, Integer nearestLoopDistance) {
    Integer depth = len(localVariableStack);
    Set currentLocalVariables = Set();
    append(localVariableStack, currentLocalVariables);
    for (instruction in instructions) {
      BoundInstruction newInstruction = instruction.freshClone();
      BoundInstructionListList subblocks = instruction.getSubblocks();
      for (localVariable in instruction.decrefCandidates()) {
        BucketNullable representative = localVariable.autoDecrefRepresentative();
        if (representative != null) {
          currentLocalVariables.add(representative);
        }
      }
      CodeFlow effect = instruction.codeFlowEffect();
      if (effect == CodeFlow.endsFunction) {
        for (localVariables in localVariableStack) {
          emitDecrefs(localVariables.values() as BucketList, output, instruction.scopeLabel);
        }
        if (depth >= 1) {
          assert(len(subblocks) == 0, 'invariant violation');
          append(output, newInstruction);
          pop(localVariableStack);
          return;
        }
        // else we're in the global scope, finished the main block and now looking for functions
        currentLocalVariables.clear();
      } else if (effect == CodeFlow.endsLoop) {
        assert(len(subblocks) == 0, 'invariant violation');
        assert(depth > 0, 'invariant violation - break or continue at top level');
        assert(nearestLoopDistance >= 0, 'invariant violation - break or continue not in loop');
        // emit decrefs for scopes inside loop (including loop itself)
        Integer index = depth - nearestLoopDistance;
        while (index < depth) {
          emitDecrefs(localVariableStack[index].values() as BucketList, output, instruction.scopeLabel);
          index += 1;
        }
        append(output, newInstruction);
        pop(localVariableStack);
        return;
      }
      if (len(subblocks) > 0) {
        BoundInstructionListList outputs = newInstruction.getSubblocks();
        Integer newNearestLoopDistance;
        if (instruction.isLoop()) {
          newNearestLoopDistance = 0;
        } else if (nearestLoopDistance >= 0) {
          newNearestLoopDistance = nearestLoopDistance + 1;
        } else {
          newNearestLoopDistance = -1; // not in loop
        }
        Integer subindex = 0;
        while (subindex < len(subblocks)) {
          generateDecrefInstructionsForBlock(subblocks[subindex], outputs[subindex], localVariableStack, newNearestLoopDistance);
          subindex += 1;
        }
      }
      append(output, newInstruction);
    }
    // reached end of block
    if (len(instructions) > 0) {
      emitDecrefs(currentLocalVariables.values() as BucketList, output, instructions[len(instructions) - 1].scopeLabel);
    }
    pop(localVariableStack);
  }
  
  // compiler phase
  BoundInstructionList generateDecrefInstructions(BoundInstructionList instructions) {
    BoundInstructionList result = []:BoundInstruction;
    SetList localVariableStack = []:Set;
    generateDecrefInstructionsForBlock(instructions, result, localVariableStack, -1);
    assert(len(localVariableStack) == 0, 'invariant violation');
    return result;
  }
  
  Set bucketsCreatedSoFar = Set();

  PseudoInstructionList convertBoundInstructions(BoundInstructionList instructions) {
    PseudoInstructionList output = []:PseudoInstruction;
    ConversionContext context = EnvironmentConversionContext(this);
    for (instruction in instructions) {
      for (newInstruction in instruction.convertToPseudoInstructions(context)) {
        append(output, newInstruction);
      }
    }
    return output;
  }

  PseudoInstructionList flattenInstructions(PseudoInstructionList instructions) {
    PseudoInstructionList result = []:PseudoInstruction;
    for (instruction in instructions) {
      if (instruction.flatten(result, Map(), []:BlockConfiguration)) {
        assert(false, concat('unexpected termination of block in ', instruction));
        break;
      }
    }
    return result;
  }

  PseudoInstructionList optimizePseudoInstructionsWithoutTypeCodes(PseudoInstructionList instructions) {
    return instructions;
  }

  AssemblerLabel typeTableLabel;
  Bucket typeTablePointer;
  AssemblerLabel elementTypeTableLabel;
  Bucket elementTypeTablePointer;
  AssemblerLabel iteratorTypeTableLabel;
  Bucket iteratorTypeTablePointer;
  AssemblerLabel listTypeTableLabel;
  Bucket listTypeTablePointer;
  Integer typeTableOffset; // the code of the first type to have bits in the type table (type code of type in first column)
  Integer typeTableWidth; // in bits

  Null _generateTypeTable(Assembler assembler, AssemblerLabel label) {
    StringList comment = []:String; // giant comment to put after the type table
    IntegerList bytes = []:Integer; // all the bytes; we line-wrap it later
    Integer byte = 0;
    Integer bits = 0;
    Integer width = 0;
    Integer offset = 0;
    append(comment, 'Columns:');
    for (supertype in sortedTypes) {
      if (supertype.isUsedInTypeCheck) {
        bits += 1;
        if (bits > 8) {
          append(comment, '\n        ');
          bits = 0;
        }
        append(comment, concat(' ', supertype));
      }
    }
    bits = 0;
    append(comment, '\n');
    for (type in sortedTypes) {
      if (type.isConstructed) {
        for (supertype in sortedTypes) {
          if (supertype.isUsedInTypeCheck) {
            if (type.isSubtypeOf(supertype)) {
              byte += 1 << bits;
              append(comment, '1');
            } else {
              append(comment, '0');
            }
            bits += 1;
            if (bits < 8) {
              append(comment, ' ');
            } else {
              append(comment, ' : ');
              append(bytes, byte);
              byte = 0;
              bits = 0;
            }
          }
        }
        append(comment, concat('  ', type, '\n'));
        if (bits > 0) {
          append(bytes, byte);
          byte = 0;
          bits = 0;
        }
      }
      if (type.isUsedInTypeCheck) {
        width += 1;
      } else {
        assert(type.isConstructed, 'sortedTypes is in an unexpected order');
        assert(width == 0, 'sortedTypes is in an unexpected order');
        offset += 1;
      }
    }
    while (len(bytes) % 8 != 0) {
      append(bytes, 0); // padding to keep things 8-byte aligned
    }
    // wrap bytes, 8 to a line, into a new array of arrays, data
    IntegerListList data = [[]:Integer]:IntegerList;
    for (byte in bytes) {
      if (len(last(data) as WhateverList) >= 8) {
        append(data, []:Integer);
      }
      append(last(data) as WhateverList, byte);
    }
    // generate Constant from newly created data array
    Boolean isFirst = true;
    ConstantPart genBytes(IntegerList bytes) {
      assert(len(bytes) > 0, 'unexpected length of bytes');
      assert(len(bytes) <= 8, 'unexpected length of bytes');
      String comment;
      if (isFirst) {
        isFirst = false;
        comment = 'Type table';
      } else {
        comment = '...';
      }
      return ConstantPart(ow.Byte, map(bytes, buildIntegerDatumNoCommentName) as ImmediateDatumList, comment);
    }
    ConstantPartList generatedBytes = map(data, genBytes) as ConstantPartList;
    String suffixComment = join(comment, '');
    assembler.addConst(Constant(label, generatedBytes, suffixComment, 'type table'));
    typeTableOffset = offset;
    typeTableWidth = width;
  }

  // mapper is a function with signature (Type) -> Type
  // it is passed the element type of every type that is IterableType or AbstractListType
  // the returned types have their codes put into the generated table
  ConstantPartList _generateIterableConversionTypeTable(TypeFunction mapper, String tableName) {
    IntegerListList iteratorTypes = []:IntegerList; // groups of 4 integers at a time
    IntegerList buffer = []:Integer;
    IntegerList debugCodes = []:Integer;
    for (type in sortedTypes) {
      if (type.isConstructed) {
        append(debugCodes, type.code);
        if (type.isSubtypeOf(coreIterableType)) {
          if (type is IterableType) {
            Type iteratorType = mapper((type as IterableType).elementType);
            append(buffer, iteratorType.code);
          } else if (type is AbstractListType) {
            Type iteratorType = mapper((type as AbstractListType).elementType);
            append(buffer, iteratorType.code);
          } else {
            throw(concat('Unrecognized iterable type: ', type));
          }
        } else {
          append(buffer, 0xffffffff); // not a valid code
        }
      }
      if (len(buffer) == 4) {
        // we only print four codes on each line, because MASM doesn't like long lines
        append(iteratorTypes, buffer);
        buffer = []:Integer;
      }
    }
    if (len(buffer) > 0) {
      append(iteratorTypes, buffer);
      buffer = []:Integer;
    }
    // now we generate the Constant from the iteratorTypes array
    assert(first(debugCodes) == 0, 'expected sorted type codes to start at zero');
    assert(last(debugCodes) == len(debugCodes) - 1, 'expected sorted type codes to be consecutive');
    Boolean isFirst = true;
    ConstantPart genLines(IntegerList buffer) {
      StringNullable comment;
      if (isFirst) {
        isFirst = false;
        comment = tableName;
      } else {
        comment = null;
      }
      // each code is 32 bits wide, so we use ow.DWord
      return ConstantPart(ow.DWord, map(buffer, buildIntegerDatumNoCommentName) as ImmediateDatumList, comment);
    }
    return map(iteratorTypes, genLines) as ConstantPartList;
  }

  Null _generateElementTypeTable(Assembler assembler, AssemblerLabel label) {
    Type mapper(Type elementType) {
      return elementType;
    }
    assembler.addConst(Constant(label, _generateIterableConversionTypeTable(mapper, 'Table mapping iterable types to element types'), null, 'element type table'));
  }

  Null _generateIteratorTypeTable(Assembler assembler, AssemblerLabel label) {
    Type mapper(Type elementType) {
      return createOrFindIteratorType(this, elementType);
    }
    assembler.addConst(Constant(label, _generateIterableConversionTypeTable(mapper, 'Table mapping iterable types to iterator types'), null, 'iterator type table'));
  }

  Null _generateListTypeTable(Assembler assembler, AssemblerLabel label) {
    Type mapper(Type elementType) {
      return createOrFindListType(this, elementType);
    }
    assembler.addConst(Constant(label, _generateIterableConversionTypeTable(mapper, 'Table mapping iterable types to list types'), null, 'list type table'));
  }

  Null _generateEnumTables(Assembler assembler) {
    for (reifiedEnumType in reifiedEnumTypes.values() as ReifiedEnumTypeList) {
      StringBucket enumNameBucket = reifiedEnumType.nameBucket;
      AssemblerLabel label = reifiedEnumType.label;
      ConstantPartList dynamicValues = []:ConstantPart;
      for (valueName in reifiedEnumType.values.keys() as StringList) {
        if (neededForDynamicDispatch(valueName)) {
          StringBucket valueTarget = reifiedEnumType.values.get(valueName) as StringBucket;
          ImmediateDatum atomCode = IntegerDatum(atomizeForDynamicDispatch(valueName), concat('dynamic dispatch code for "', valueTarget.value.value, '"'));
          ImmediateDatum stringPointer = valueTarget.currentValueDatum() as ImmediateDatum;
          append(dynamicValues, ConstantPart(ow.QWord, [atomCode, stringPointer]:ImmediateDatum, valueTarget.value.value));
        }
      }
      ConstantPartList lines = [
        ConstantPart(ow.QWord, [enumNameBucket.currentValueDatum() as ImmediateDatum]:ImmediateDatum, 'Enum constant name'),
        ConstantPart(ow.QWord, [IntegerDatum(len(dynamicValues), 'Number of reified values')]:ImmediateDatum, 'Number of reified values'),
      ]:ConstantPart;
      if (len(dynamicValues) > 0) {
        append(lines, ConstantPart(ow.QWord, [TypeCodeDatum(reifiedEnumType.propertyType)]:ImmediateDatum, concat(reifiedEnumType.propertyType.name, ' type code')));
        appendAll(lines, dynamicValues);
      }
      assembler.addConst(Constant(label, lines, null, concat(enumNameBucket.value.value, ' reified enum table')));
    }
  }

  Null generateTypeTables(Assembler assembler) {
    _generateTypeTable(assembler, typeTableLabel);
    _generateElementTypeTable(assembler, elementTypeTableLabel);
    _generateIteratorTypeTable(assembler, iteratorTypeTableLabel);
    _generateListTypeTable(assembler, listTypeTableLabel);
    _generateEnumTables(assembler);
  }

  Null generateVmts(Assembler assembler) {
    ClassType rootClass = lookupIntrinsicClass(coreClassTypeIntrinsicName);
    rootClass.generateVmt(this, assembler);
  }

  Null substituteTypeCodes(PseudoInstructionList instructions) {
    Datum replace(Datum original) {
      if (original is TypeTableWidthDatum) {
        Integer width = typeTableWidth;
        if (width % 8 > 0) {
          return IntegerDatum(width / 8 + 1, original.commentName);
        }
        return IntegerDatum(width / 8, original.commentName);
      }
      if (original is TypeTableOffsetDatum) {
        return IntegerDatum(typeTableOffset, original.commentName);
      }
      if (original is TypeTablePointerDatum) {
        return typeTablePointer.currentValueDatum();
      }
      if (original is TypeBitDatum) {
        return IntegerDatum(((original as TypeBitDatum).value.code - typeTableOffset) % 8, original.commentName);
      }
      if (original is TypeByteDatum) {
        return IntegerDatum(((original as TypeByteDatum).value.code - typeTableOffset) / 8, original.commentName);
      }
      return original;
    }
    for (instruction in instructions) {
      instruction.walkDatums(replace);
    }
  }

  PseudoInstructionList optimizePseudoInstructions(PseudoInstructionList instructions) {
    return instructions;
  }

  Null compile(Assembler assembler) {
    // the phase before this is Library.generateScopes() in syd_ast.syd
    // that phase creates a tree of CompiledScopes and fills them with BoundInstructions
    stderr('finalizeClassTypes...');
    finalizeClassTypes(assembler); // also prepares some instructions
    stderr('finalizeInstructions...');
    finalizeInstructions(assembler);
    stderr('extractInstructions...');
    BoundInstructionList boundInstructions = extractInstructions();
    stderr('generateDecrefInstructions...');
    boundInstructions = generateDecrefInstructions(boundInstructions);
    stderr('convertBoundInstructions...');
    PseudoInstructionList pseudoInstructions = convertBoundInstructions(boundInstructions);
    stderr('flattenInstructions...');
    pseudoInstructions = flattenInstructions(pseudoInstructions); // gets rid of if and loop and replaces with jumps and labels
    stderr('optimizePseudoInstructionsWithoutTypeCodes...');
    pseudoInstructions = optimizePseudoInstructionsWithoutTypeCodes(pseudoInstructions);
    stderr('assignTypeCodes...');
    assignTypeCodes(); // inherited from TypeRegistry
    stderr('generateTypeTables...');
    generateTypeTables(assembler);
    stderr('generateVmts...');
    generateVmts(assembler);
    stderr('substituteTypeCodes...');
    substituteTypeCodes(pseudoInstructions);
    stderr('optimizePseudoInstructions...');
    pseudoInstructions = optimizePseudoInstructions(pseudoInstructions);
    stderr('compiling constants...');
    for (constant in constants) {
      assembler.addConst(constant);
    }
    stderr('assembling...');
    assembler.assemble(pseudoInstructions);
  }

  RootEnumPropertyType coreRootEnumPropertyType;
  RootReifiedEnumType coreRootReifiedEnumType;

  Null constructor() {
    super.constructor();
    typeTableLabel = rootLabel.deriveWith('typeTable');
    typeTablePointer = DataLabelBucket(typeTableLabel, coreIntegerType);
    elementTypeTableLabel = rootLabel.deriveWith('elementTypeTable');
    elementTypeTablePointer = DataLabelBucket(elementTypeTableLabel, coreIntegerType);
    iteratorTypeTableLabel = rootLabel.deriveWith('iteratorTypeTable');
    iteratorTypeTablePointer = DataLabelBucket(iteratorTypeTableLabel, coreIntegerType);
    listTypeTableLabel = rootLabel.deriveWith('listTypeTable');
    listTypeTablePointer = DataLabelBucket(listTypeTableLabel, coreIntegerType);
    coreSentinel = SentinelBucket(coreSentinelType);
    coreSentinelType.markConstructed();
    coreRootEnumPropertyType = RootEnumPropertyType(this, 'EnumProperty#');
    coreRootReifiedEnumType = RootReifiedEnumType(this, 'ReifiedEnum#');
    coreNull = IntegerBucket(0x00, coreNullType);
    coreFalse = IntegerBucket(0x00, coreBooleanType);
    coreTrue = IntegerBucket(0x01, coreBooleanType);
    intrinsicsLibrary = CompiledIntrinsicsLibrary(this, 'intrinsics');
    intrinsicsLibrary.generateScopes();
  }
}

class EnvironmentConversionContext extends ConversionContext {
  CompilationEnvironment environment;

  //#override
  TypeRegistry types() { return environment; }
  //#override
  CodeLabelDatum freeIntrinsic() { return environment.lookupIntrinsicSubroutine(environment.freeIntrinsicName).codePointer.currentValueDatum() as CodeLabelDatum; }
  //#override
  CodeLabelDatum errorIntrinsic() { return environment.lookupIntrinsicSubroutine(environment.errorIntrinsicName).codePointer.currentValueDatum() as CodeLabelDatum; }
  //#override
  CodeLabelDatum exponentiationIntrinsic() { return environment.lookupIntrinsicSubroutine(environment.exponentiationIntrinsicName).codePointer.currentValueDatum() as CodeLabelDatum; }
  //#override
  Bucket errorMessage(String value) { return environment.errorMessage(value); }
  //#override
  Bucket coreSentinel() { return environment.coreSentinel; }
  //#override
  Bucket coreNull() { return environment.coreNull; }
  //#override
  Bucket coreTrue() { return environment.coreTrue; }
  //#override
  Bucket coreFalse() { return environment.coreFalse; }
  //#override
  Set bucketsCreatedSoFar() { return environment.bucketsCreatedSoFar; }

  //#override
  Null didCreateBucket(Bucket bucket) {
    environment.bucketsCreatedSoFar.add(bucket);
  }

  Null constructor(CompilationEnvironment environmentArg) {
    super.constructor();
    environment = environmentArg;
  }
}

// ============================================================================
// SUBROUTINE CALLS AND AST NODE SHENANIGANS
// ============================================================================

class Expression extends AstNode {
  // Expressions are expected to declare (or identify) a Bucket, and return it.
  Bucket generateInstructions(CompiledScope scope) {
    abstract();
  }
}

Null generateInstructionsForArguments(CompilationEnvironment environment, CompiledScope scope, Expression subroutineReference, SourceLocation sourceLocation, Type subroutineType, ExpressionList arguments, BucketList argumentValues, SourceLocationList sourceLocations) {
  if (!subroutineType.isSubtypeOf(environment.coreSubroutineType)) {
    throw(concat('"', subroutineReference.toStringIndent(0), '" is not a function pointer at ', sourceLocation, ' (is ', subroutineType.name, ')'));
  }
  for (argument in arguments) {
    append(sourceLocations, argument.sourceLocation);
    append(argumentValues, argument.generateInstructions(scope));
  }
}

Bucket generateInstructionsForSubroutinePointerCallExpression(CompiledScope scope, Bucket subroutinePointer, ExpressionList arguments, Expression subroutineReference, SourceLocation sourceLocation) {
  CompilationEnvironment environment = scope.environment();
  BucketList argumentValues = []:Bucket;
  SourceLocationList sourceLocations = []:SourceLocation;
  generateInstructionsForArguments(
    environment,
    scope,
    subroutineReference,
    sourceLocation,
    subroutinePointer.staticType,
    arguments,
    argumentValues,
    sourceLocations,
  );
  scope.emit(TypeCheckInstruction(
    subroutinePointer,
    environment.coreSubroutineType,
    'tried to call non-function', // TODO: better error message (e.g. what is the actual type of the thing being called?)
    true,
    LazyComment('check function call receiver is a function'),
  ));
  return scope.emitSubroutinePointerCall(subroutinePointer, argumentValues, sourceLocation, sourceLocations);
}

Bucket generateInstructionsForSubroutineCallExpression(CompiledScope scope, ForCallResult target, IdentifierEntityNullable entity, ExpressionList arguments, Expression subroutineReference, SourceLocation sourceLocation) {
  CompilationEnvironment environment = scope.environment();
  BucketList argumentValues = []:Bucket;
  SourceLocationList sourceLocations = []:SourceLocation;
  generateInstructionsForArguments(
    environment,
    scope,
    subroutineReference,
    sourceLocation,
    target.subroutineType,
    arguments,
    argumentValues,
    sourceLocations,
  );
  scope.emit(TypeCheckInstruction(
    target.codePointer,
    environment.coreSubroutineCodeAddressType,
    'tried to call non-function', // TODO: better error message (e.g. what is the actual type of the thing being called?)
    true,
    LazyComment('check function call receiver is a function'),
  ));
  if (entity != null) {
    BucketNullable inlined = entity!.inline(scope, argumentValues);
    if (inlined != null) {
      return inlined!;
    }
  }
  return scope.emitCodePointerCall(
    target.subroutineType as AbstractSubroutineTypeWithSpecificParameters,
    target.codePointer,
    null,
    target.thisPointer,
    argumentValues,
    sourceLocation,
    sourceLocations,
  );
}

// ============================================================================
// SPECIALIZED BUCKETS
// ============================================================================

class VmtPointerBucket extends ConstantBucket {
  ClassType classType;

  //#override
  String commentName() {
    return concat(classType.name, 'VMT');
  }

  //#override
  Datum currentValueDatum() {
    return DataLabelDatum(classType.vmtLabel, concat('vmt of ', classType.name));
  }

  Null constructor(CompilationEnvironment environmentArg, ClassType classTypeArg) {
    super.constructor(environmentArg.coreIntegerType);
    classType = classTypeArg;
  }
}

enum MemberProperty { Type Getter Setter MethodImplementation }

class VmtMemberBucket extends ConstantBucket {
  MemberDescription member;
  MemberProperty property;

  //#override
  String commentName() {
    if (property == MemberProperty.Type) { return concat(member.classType.name, '.', member.name, ' type'); }
    if (property == MemberProperty.Setter) { return concat(member.classType.name, '.', member.name, ' getter'); }
    if (property == MemberProperty.Getter) { return concat(member.classType.name, '.', member.name, ' setter'); }
    assert(property == MemberProperty.MethodImplementation, 'invalid MemberProperty');
    return concat(member.classType.name, '.', member.name, ' method');
  }

  Integer propertyIndex() {
    if (property == MemberProperty.Type) { return 0; }
    if (property == MemberProperty.Setter) { return 1; }
    if (property == MemberProperty.Getter) { return 2; }
    assert(property == MemberProperty.MethodImplementation, 'invalid MemberProperty');
    return 3;
  }

  //#override
  IntegerDatum currentValueDatum() {
    // header + method offset + member property 
    Integer offset = vmtHeaderFieldCount * 8 + member.methodsIndex * 4 * 8 + propertyIndex() * 8;
    return IntegerDatum(offset, hexH(offset));
  }

  Null constructor(CompilationEnvironment environmentArg, MemberDescription memberArg, MemberProperty propertyArg) {
    super.constructor(environmentArg.coreIntegerType);
    member = memberArg;
    property = propertyArg;
  }
}

class SubroutinePointerBucket extends ConstantBucket {
  CompiledSubroutine subroutine;

  //#override
  String commentName() {
    return subroutine.name;
  }

  Boolean _isDeclared = false;
  Boolean _isConstructor;

  Boolean isDeclared() {
    return !_isConstructor || _isDeclared;
  }

  Null markConstructorAsDeclared() {
    assert(_isConstructor, 'cannot mark non-constructor as defined, those are always defined on declaration');
    _isDeclared = true;
  }

  //#override
  Datum currentValueDatum() {
    return DataLabelDatum(subroutine.functionPointerLabel, concat('function pointer of ', subroutine.name));
  }

  Null constructor(CompiledSubroutine subroutineArg, Boolean isConstructorArg) {
    super.constructor(subroutineArg.type);
    assert(!isConstructorArg || subroutineArg is CompiledGeneratedConstructorSubroutine, 'wrong type for constructor subroutine');
    subroutine = subroutineArg;
    _isConstructor = isConstructorArg;
  }
}

class FieldBucket extends Bucket {
  MemberDescription member;
  Bucket thisBucket;

  //#override
  BucketNullable autoDecrefRepresentative() {
    return thisBucket.autoDecrefRepresentative();
  }

  //#override
  Boolean isGCRoot() {
    return false;
  }

  //#override
  String commentName() {
    return concat(member.classType.name, '.', member.name);
  }

  //#override
  Datum currentValueDatum() {
    return DereferenceDatum(thisBucket.currentValueDatum(), IntegerDatum(_gcBlockData + member.fieldIndex * 16 + 8, concat('offset to ', member.classType, '.', member.name)), ow.QWord, commentName());
  }

  //#override
  Datum currentTypeDatum() {
    return DereferenceDatum(thisBucket.currentValueDatum(), IntegerDatum(_gcBlockData + member.fieldIndex * 16, concat('offset to type of ', member.classType, '.', member.name)), ow.QWord, concat('type of ', commentName()));
  }

  Null constructor(Bucket thisBucketArg, MemberDescription memberArg) {
    super.constructor(memberArg.staticType);
    thisBucket = thisBucketArg;
    member = memberArg;
  }
}

class FieldPointerBucket extends Bucket {
  MemberDescription member;
  Bucket thisBucket;

  //#override
  String commentName() {
    return concat('@', member.classType.name, '.', member.name);
  }

  //#override
  BucketNullable autoDecrefRepresentative() {
    return thisBucket.autoDecrefRepresentative();
  }

  //#override
  Boolean isGCRoot() {
    return false;
  }

  //#override
  Datum currentValueDatum() {
    return ReferenceDatum(thisBucket.currentValueDatum(), IntegerDatum(_gcBlockData + member.fieldIndex * 16, concat('offset to ', member.classType, '.', member.name)), ow.QWord, commentName());
  }

  //#override
  Datum currentTypeDatum() {
    return TypeCodeDatum(staticType);
  }

  Null constructor(Bucket thisBucketArg, MemberDescription memberArg, Type staticTypeArg) {
    super.constructor(staticTypeArg);
    thisBucket = thisBucketArg;
    member = memberArg;
  }
}

// ============================================================================
// SPECIALIZED TYPES
// ============================================================================

class IdentifierEntity extends Object {
  Boolean isDeclared() { abstract(); }

  Type staticType() { abstract(); }

  Bucket forRead(CompiledScope scope) { abstract(); }

  ForCallResultNullable forCall(CompiledScope scope) { return null; } // if this returns null, callers are expected to call forRead() to get a function pointer and then invoke that

  BucketNullable inline(CompiledScope scope, BucketList arguments) { return null; } 

  Boolean writeable() { return false; }

  Null write(CompiledScope scope, Bucket value) { 
    assert(false, 'do not call write() on IdentifierEntities that return false from writable()');
  }

  Bucket emitCall(CompiledScope scope, ExpressionList arguments, Expression subroutineReference, SourceLocation sourceLocation) {
    // TODO assert that inlining entity here always returns null
    ForCallResultNullable subroutine = forCall(scope);
    if (subroutine != null) {
      return generateInstructionsForSubroutineCallExpression(scope, subroutine!, this, arguments, subroutineReference, sourceLocation);
    }
    Bucket bucket = scope.emitCopy(forRead(scope));
    return generateInstructionsForSubroutinePointerCallExpression(scope, bucket, arguments, subroutineReference, sourceLocation);
  }
}

class LocalVariableIdentifierEntity extends IdentifierEntity {
  LocalVariable localVariable;

  //#override
  Boolean isDeclared() { return true; }

  //#override
  Type staticType() { return localVariable.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { 
    return scope.emitCopy(localVariable);
  }

  //#override
  Boolean writeable() { return true; }

  //#override
  Null write(CompiledScope scope, Bucket value) { 
    scope.emit(UpdateVariableInstruction(localVariable, value));
  }

  Null constructor(LocalVariable localVariableArg) {
    super.constructor();
    localVariable = localVariableArg;
  }
}

class GlobalVariableIdentifierEntity extends IdentifierEntity {
  GlobalVariable globalVariable;

  //#override
  Boolean isDeclared() { return true; }

  //#override
  Type staticType() { return globalVariable.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { 
    return scope.emitCopy(globalVariable);
  }

  //#override
  Boolean writeable() { return true; }

  //#override
  Null write(CompiledScope scope, Bucket value) { 
    scope.emit(UpdateGlobalVariableInstruction(globalVariable, value));
  }

  Null constructor(GlobalVariable globalVariableArg) {
    super.constructor();
    globalVariable = globalVariableArg;
  }
}

class VarArgsIdentifierEntity extends IdentifierEntity {
  VarArgsParameterBucket value;

  //#override
  Boolean isDeclared() { return true; }

  //#override
  Type staticType() { return value.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { return value; }

  //#override
  Boolean writeable() { return false; }

  Null constructor(VarArgsParameterBucket valueArg) {
    super.constructor();
    value = valueArg;
  }
}

class ImmutableVariableIdentifierEntity extends IdentifierEntity {
  Bucket variable;

  //#override
  Boolean isDeclared() { return true; }

  //#override
  Type staticType() { return variable.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { return variable; }

  Null constructor(Bucket variableArg) {
    super.constructor();
    variable = variableArg;
  }
}

class ConstantIdentifierEntity extends IdentifierEntity {
  ConstantBucket constant;

  //#override
  Boolean isDeclared() { return true; }

  //#override
  Type staticType() { return constant.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { return constant; }

  Null constructor(ConstantBucket constantArg) {
    super.constructor();
    constant = constantArg;
  }
}

class SubroutineIdentifierEntity extends IdentifierEntity {
  SubroutinePointerBucket subroutinePointer;

  //#override
  Boolean isDeclared() { return subroutinePointer.isDeclared(); }

  //#override
  Type staticType() { return subroutinePointer.staticType; }

  //#override
  Bucket forRead(CompiledScope scope) { return subroutinePointer; }

  //#override
  ForCallResult forCall(CompiledScope scope) {
    return ForCallResult(subroutinePointer.subroutine.codePointer, subroutinePointer.subroutine.type, null);
  }
  
  //#override
  BucketNullable inline(CompiledScope scope, BucketList arguments) { 
    return subroutinePointer.subroutine.inline(scope, arguments);
  } 

  Null constructor(SubroutinePointerBucket subroutinePointerArg) {
    super.constructor();
    subroutinePointer = subroutinePointerArg;
  }
}

class MemberIdentifierEntity extends IdentifierEntity {
  Bucket thisBucket;
  MemberDescription member;
  String debugName;

  //#override
  Boolean isDeclared() { return member.isDeclared(); }

  //#override
  Type staticType() { return member.staticType; }

  Null debugCheckInvariants() { }

  Null constructor(Bucket thisBucketArg, MemberDescription memberArg, String debugNameArg) {
    super.constructor();
    thisBucket = thisBucketArg;
    member = memberArg;
    debugName = debugNameArg;
    debugCheckInvariants();
  }
}

class FieldIdentifierEntity extends MemberIdentifierEntity {
  //#override
  Bucket forRead(CompiledScope scope) {
    return scope.emitCopy(FieldBucket(thisBucket, member));
  }

  //#override
  Boolean writeable() { return true; }

  //#override
  Null write(CompiledScope scope, Bucket value) {
    scope.emit(HeapUpdateInstruction(FieldPointerBucket(thisBucket, member, scope.environment().coreIntegerType), value, member.staticType));
  }

  //#override
  Null debugCheckInvariants() {
    super.debugCheckInvariants();
    assert(member.needsField, 'inconsistency');
  }
}

class MethodIdentifierEntity extends MemberIdentifierEntity {
  //#override
  Bucket forRead(CompiledScope scope) {
    member.staticType.markConstructed();
    return scope.emitIntrinsicCall(
      scope.environment().createMethodPointerIntrinsicName,
      [
        thisBucket,
        forCall(scope)!.codePointer,
        TypeCodeBucket(member.staticType, scope.environment().coreIntegerType),
      ]:Bucket,
    );
  }

  //#override
  ForCallResult forCall(CompiledScope scope) {
    scope.environment().coreSubroutineCodeAddressType.markConstructed();
    return ForCallResult(
      DereferenceWithStaticTypeBucket(
        DereferenceWithOffsetsBucket(
          thisBucket, 
          scope.environment().integer(_fieldVmt + 8), 
          scope.environment().integer(_fieldVmt), 
          ow.QWord, 
          scope.environment().coreIntegerType, 
          LazyComment(member.classType.name, '.', member.name, ' data structure pointer'),
        ),
        VmtMemberBucket(scope.environment(), member, MemberProperty.MethodImplementation), 
        ow.QWord,
        scope.environment().coreSubroutineCodeAddressType,
        LazyComment(member.classType.name, '.', member.name),
      ),
      member.staticType,
      thisBucket,
    );
  }

  //#override
  Null debugCheckInvariants() {
    super.debugCheckInvariants();
    assert(member.needsMethods, 'inconsistency');
  }
}

// Ambiguous as in could be a field or a method.
class AmbiguousMemberIdentifierEntity extends MemberIdentifierEntity {
  //#override
  Bucket forRead(CompiledScope scope) {
    scope.environment().coreSubroutineCodeAddressType.markConstructed();
    return scope.emitCodePointerCall(
      createOrFindSubroutineTypeWithSpecificParameters(scope.environment(), member.staticType, []:Type),
      DereferenceWithStaticTypeBucket(
        DereferenceWithOffsetsBucket(
          thisBucket,
          scope.environment().integer(_fieldVmt + 8),
          scope.environment().integer(_fieldVmt),
          ow.QWord,
          scope.environment().coreIntegerType,
          LazyComment(member.classType.name, '.', member.name),
        ),
        VmtMemberBucket(scope.environment(), member, MemberProperty.Getter), 
        ow.QWord,
        scope.environment().coreSubroutineCodeAddressType,
        LazyComment(member.classType.name, '.', member.name),
      ), 
      null, // closure pointer
      thisBucket,
      []:Bucket, 
      null,
      null,
    );
  }

  //#override
  Boolean writeable() { return true; }

  //#override
  Null write(CompiledScope scope, Bucket value) {
    scope.environment().coreSubroutineCodeAddressType.markConstructed();
    scope.emitCodePointerCall(
      createOrFindSubroutineTypeWithSpecificParameters(scope.environment(), scope.environment().coreNullType, []:Type),
      DereferenceWithStaticTypeBucket(
        DereferenceWithOffsetsBucket(
          thisBucket,
          scope.environment().integer(_fieldVmt + 8),
          scope.environment().integer(_fieldVmt), 
          ow.QWord, 
          scope.environment().coreIntegerType,
          LazyComment(member.classType.name, '.', member.name),
        ),
        VmtMemberBucket(scope.environment(), member, MemberProperty.Setter), 
        ow.QWord,
        scope.environment().coreSubroutineCodeAddressType,
        LazyComment(member.classType.name, '.', member.name),
      ),
      null,
      thisBucket,
      []:Bucket, 
      null,
      null,
    );
    scope.emit(HeapUpdateInstruction(FieldPointerBucket(thisBucket, member, scope.environment().coreIntegerType), value, member.staticType));
  }
}

class MemberDescription extends Object {
  SourceLocation sourceLocation;
  ClassType classType;
  String name;
  Type staticType;
  Boolean isInherited; // this is just a copy of the inherited version, we have not overridden it or introduced it
  Boolean hasSuperclassMember = false;
  Boolean isField; // whether this class specifically has a method or a field with this name
  Boolean needsField = false; // this member needs storage in this class OR a superclass
  Boolean needsMethods = false; // this member has methods in this class OR a superclass OR a subclass
  Boolean isAmbiguous = false; // this member is a field/method in this class, and the opposite in a subclass
  Boolean needsDynamicDispatch = false;

  IntegerNullable fieldIndex = null;
  IntegerNullable methodsIndex = null;
  CompiledSubroutineNullable getter = null; // generated method used when a method is used as a field, or in general for getting the member when it is both a field and a method
  CompiledSubroutineNullable setter = null; // generated method called immediately prior to setting the field, if it is both a field and a method
  CompiledSubroutineNullable methodImplementation = null; // actual method implementation when we have one

  Boolean setNeedsField() {
    if (needsField) {
      return false;
    }
    needsField = true;
    return true;
  }

  Boolean setNeedsMethods() {
    if (needsMethods) {
      return false;
    }
    needsMethods = true;
    return true;
  }

  Null setIsField() {
    assert(needsField, 'cannot be a field if it does not need a field');
    isField = true;
  }

  Null setIsMethod() {
    assert(needsMethods, 'cannot be a method if it does not need methods');
    isField = false;
  }

  Null setIsAmbiguous() {
    isAmbiguous = true;
  }

  Null prepareForAssignIndicies(CompilationEnvironment environment) {
    needsDynamicDispatch = environment.neededForDynamicDispatch(name);
    if (needsDynamicDispatch) {
      setNeedsMethods();
    }
  }

  Null assignIndicies(CompilationEnvironment environment, Integer fieldIndexArg, Integer methodsIndexArg) {
    assert(fieldIndex == null && methodsIndex == null, 'assignIndicies called redundantly');
    assert(needsField || needsMethods, 'assignIndicies called before setNeedsField/setNeedsMethods');
    if (needsField) {
      fieldIndex = fieldIndexArg;
    }
    if (needsMethods) {
      methodsIndex = methodsIndexArg;
    }
  }

  Null setSetter(CompiledSubroutine subroutineArg) {
    setter = subroutineArg;
  }

  Null setGetter(CompiledSubroutine subroutineArg) {
    getter = subroutineArg;
  }

  Null setMethodImplementation(CompiledSubroutine subroutineArg) {
    methodImplementation = subroutineArg;
  }
   
  Boolean _isDeclared = false; 

  Boolean isDeclared() {
    return isInherited || hasSuperclassMember || _isDeclared;
  }

  Null markDeclared() {
    assert(!isInherited, concat('use override() before declare() for reintroduced inherited members'));
    // isDeclared could be true if this is a forward-declared member
    _isDeclared = true;
  }

  Boolean _isDefined = false;

  Boolean isDefined() {
    return  _isDefined;
  }

  Null markDefined() {
    assert(!isInherited, concat('use override() before markDefined() for reintroduced inherited members'));
    // _isDefined could be true if this is an inherited method
    _isDefined = true;
  }

  // indicate that this is a new implementation of an inherited member
  Null override(Type staticTypeArg, SourceLocation sourceLocationArg) {
    assert(name == kConstructor || staticTypeArg.isSubtypeOf(staticType), 'type mismatch');
    staticType = staticTypeArg;
    isInherited = false;
    hasSuperclassMember = true;
    getter = null;
    setter = null;
    methodImplementation = null;
    sourceLocation = sourceLocationArg;
  }

  // indicate that this is a brand new member, not inherited
  Null introduce(Type typeArg, SourceLocation sourceLocationArg) {
    assert(!isInherited, 'cannot call introduce on inherited members');
    sourceLocation = sourceLocationArg;
    staticType = typeArg;
  }

  // used when creating the actual inherited copy of the member description.
  // if this is an override, call override() afterwards.
  Null adoptFrom(MemberDescription source) {
    if (source.needsField) {
      setNeedsField();
    }
    if (source.needsMethods) {
      setNeedsMethods();
    }
    if (source.isField) {
      setIsField();
    } else {
      setIsMethod();
    }
    if (source.getter != null) {
      setGetter(source.getter!);
    }
    if (source.setter != null) {
      setSetter(source.setter!);
    }
    if (source.methodImplementation != null) {
      setMethodImplementation(source.methodImplementation!);
    }
    assert(staticType.isSubtypeOf(source.staticType), 'invariant violation');
    staticType = source.staticType;
    isInherited = true;
    _isDefined = true;
  }

  // create a copy of this member that has the isInherited flag set.
  MemberDescription inherit(ClassType subclass) {
    MemberDescription result = MemberDescription(subclass, name, staticType, true, sourceLocation);
    result.adoptFrom(this);
    return result;
  }

  //#override
  String toString() {
    return concat('MemberDescription: ', staticType, ' ', name, ' (methodsIndex=', methodsIndex, '; fieldIndex=', fieldIndex, ')');
  }

  Null constructor(ClassType classTypeArg, String nameArg, Type staticTypeArg, Boolean isInheritedArg, SourceLocation sourceLocationArg) {
    super.constructor();
    classType = classTypeArg;
    name = nameArg;
    staticType = staticTypeArg;
    isInherited = isInheritedArg;
    sourceLocation = sourceLocationArg;
  }
}

class ClassType extends Type {
  ClassType supertype;

  Boolean isDefined = false;

  Null markAsDefined() {
    assert(!isDefined, 'cannot mark a class as defined twice');
    isDefined = true;
    markConstructed(); // TODO: be more judicious
  }

  Set subtypes = Set();

  Map forwardDeclaredMembers = Map(); // name to MemberDescription
  Map members = Map(); // name to MemberDescription
  Boolean isConstructedOrSubclassIsConstructed = false;

  //#override
  Null markConstructed() {
    super.markConstructed();
    if (!isConstructedOrSubclassIsConstructed && supertype != this) {
      supertype.markConstructed();
    }
    isConstructedOrSubclassIsConstructed = true;
  }

  // This is the generated constructor (the one with the name of the class),
  // not the method called constructor (which this one calls).
  SubroutinePointerBucket constructorSubroutine;

  Null setConstructorSubroutine(SubroutinePointerBucket constructorSubroutineArg) {
    constructorSubroutine = constructorSubroutineArg;
  }

  Null registerForwardMember(String name, Type type, SourceLocation sourceLocation) {
    assert(!isDefined, 'registerForwardMember must be called before markAsDefined');
    MemberDescriptionNullable existingDeclaration = forwardDeclaredMembers.get(name) as MemberDescriptionNullable;
    if (existingDeclaration != null) {
      assert(sourceLocation != existingDeclaration!.sourceLocation, 'tried to call registerForwardMember twice for the same code');
      throw(concat('member "', this.name, '.', name, '" already declared at ', existingDeclaration!.sourceLocation, ', cannot redeclare at ', sourceLocation, '.'));
    }
    MemberDescription member = MemberDescription(this, name, type, false /* isInherited -- forward declarations get fixed up later */, sourceLocation);
    member.setIsAmbiguous(); // we don't know yet whether this is a field or a method
    member.markDeclared();
    forwardDeclaredMembers.set(name, member);
  }

  Null inheritMembersFromSupertype() {
    assert(!isDefined, 'inheritMembersFromSupertype must be called before markAsDefined');
    assert(members.length == 0, 'cannot inherit members twice');
    for (member in supertype.members.values() as MemberDescriptionList) {
      MemberDescriptionNullable forwardDeclaredMember = forwardDeclaredMembers.get(member.name) as MemberDescriptionNullable;
      if (forwardDeclaredMember != null) {
        if (!forwardDeclaredMember!.staticType.isSubtypeOf(member.staticType)) {
          throw(concat(
            'Forward declared property ', member.name, 
            ' has type ', forwardDeclaredMember!.staticType, 
            ' at ', forwardDeclaredMember!.sourceLocation, 
            ' which is not a subtype of inherited type ', member.staticType,
            ' as defined at ', member.sourceLocation,
            '.'
          ));
        }
        forwardDeclaredMember!.adoptFrom(member);
        members.set(member.name, forwardDeclaredMember!);
      } else {
        members.set(member.name, member.inherit(this));
      }
    }
  }

  Null checkForMissingForwardDeclaredMembers(SourceLocation classSourceLocation) {
    for (forwardDeclaredMember in forwardDeclaredMembers.values() as MemberDescriptionList) {
      if (members.get(forwardDeclaredMember.name) != forwardDeclaredMember) {
        throw(concat(
          'Forward declared property ', forwardDeclaredMember.name, 
          ' has type ', forwardDeclaredMember.staticType, 
          ' at ', forwardDeclaredMember.sourceLocation, 
          ' but is not defined in ', name,
          ' at ', classSourceLocation,
          '.'
        ));
      }
      assert(members.get(forwardDeclaredMember.name) == forwardDeclaredMember, 'inconsistent forward declaration status');
    }
  }

  Null propagateNeedsMethodsFor(String name) {
    assert(members.get(name) != null, 'propagateNeedsMethodsFor called with name that did not exist');
    if ((members.get(name) as MemberDescription).setNeedsMethods()) {
      for (subclass in subtypes.values()) {
        (subclass as ClassType).propagateNeedsMethodsFor(name);
      }
    }
  }

  // when we create the generated constructor, we inline all of these
  NullFunctionList initializers = []:NullFunction;

  // called when defining the member (not forward declaring it)
  // this is called during the class setup, before we actually compile the members. because
  // we don't want methods and initializers to be able to refer to members defined after them
  // (unless forward declared), we do not mark them as declared here, we only mark them as
  // declared when we actually compile them.
  Null registerMember(String name, Type type, Boolean isField, NullFunctionNullable initializer, SourceLocation sourceLocation) {
    assert(isDefined, 'registerMember must be called after markAsDefined');
    assert(name == kConstructor || supertype.members.get(name) == null || type.isSubtypeOf((supertype.members.get(name) as MemberDescription).staticType),
           'tried to register overriding member with broader type than inherited type');
    MemberDescriptionNullable inheritedMember = members.get(name) as MemberDescriptionNullable;
    MemberDescription member;
    MemberDescriptionNullable forwardDeclaredMember = forwardDeclaredMembers.get(name) as MemberDescriptionNullable;
    assert(inheritedMember == null || inheritedMember!.isInherited, 'inconsistent inheritance status');
    assert(inheritedMember == null || forwardDeclaredMember == null || inheritedMember == forwardDeclaredMember, 'inconsistent forward declaration status');
    Boolean isInherited = inheritedMember != null;
    if (isInherited) {
      member = inheritedMember!;
      member.override(type, sourceLocation);
    } else {
      if (forwardDeclaredMember == null) {
        member = MemberDescription(this, name, type, false, sourceLocation);
      } else {
        member = forwardDeclaredMember!;
        member.introduce(type, sourceLocation);
      }
      members.set(name, member);
    }
    if (isField) {
      if (member.setNeedsField() && isInherited) {
        ClassType node = this;
        while (node != node.supertype && node.supertype.members.get(name) != null) {
          node = node.supertype;
          (node.members.get(name) as MemberDescription).setIsAmbiguous();
        }
      }
      member.setIsField();
      append(initializers, initializer);
    } else {
      assert(initializer == null, 'Initializers can only be used with fields.');
      if (member.setNeedsMethods()) {
        if (isInherited) {  
          // also require methods for it in the rest of the class hierarchy
          // TODO: this propagation logic should wait until we've computed which classes are used
          ClassType node = this;
          while (node != node.supertype && node.supertype.members.get(name) != null) {
            node = node.supertype;
            (node.members.get(name) as MemberDescription).setIsAmbiguous();
          }
          node.propagateNeedsMethodsFor(name);
        }
      }
      member.setIsMethod();
    }
  }

  MemberDescriptionNullable getMember(String name) {
    MemberDescriptionNullable forwardDeclaredMember = forwardDeclaredMembers.get(name) as MemberDescriptionNullable;
    if (forwardDeclaredMember != null) {
      return forwardDeclaredMember;
    }
    return members.get(name) as MemberDescriptionNullable;
  }

  MemberDescriptionNullable getRealMember(String name) {
    return members.get(name) as MemberDescriptionNullable;
  }

  Integer fieldCount;
  Integer methodCount;

  Null assignIndicies(CompilationEnvironment environment, Integer nextFieldArg, Integer nextMethodsArg) {
    Integer nextField = nextFieldArg; // for the purposes of this algorithm, we need to change these
    Integer nextMethods = nextMethodsArg;
    fieldCount = 0;
    methodCount = 0;
    for (member in members.values()) {
      MemberDescriptionNullable inheritedMember = supertype.members.get((member as MemberDescription).name) as MemberDescriptionNullable;
      (member as MemberDescription).prepareForAssignIndicies(environment);
      Integer fieldIndex = -1;
      Integer methodsIndex = -1;
      if (inheritedMember != null && supertype != this && inheritedMember!.needsField) {
        assert((member as MemberDescription).needsField, 'inconsistency in needsField');
        fieldIndex = inheritedMember!.fieldIndex!;
      } else if ((member as MemberDescription).needsField) {
        fieldIndex = nextField;
        nextField += 1;
      }
      if (inheritedMember != null && supertype != this && inheritedMember!.needsMethods) {
        assert((member as MemberDescription).needsMethods, 'inconsistency in needsMethods');
        methodsIndex = inheritedMember!.methodsIndex!;
      } else if ((member as MemberDescription).needsMethods) {
        methodsIndex = nextMethods;
        nextMethods += 1;
      }
      (member as MemberDescription).assignIndicies(environment, fieldIndex, methodsIndex);
      if ((member as MemberDescription).needsField) {
        fieldCount += 1;
      }
      if ((member as MemberDescription).needsMethods) {
        methodCount += 1;
      }
    }
    assert(methodCount == nextMethods, concat('inconsistent method count: ', methodCount, ' vs ', nextMethods));
    for (subtype in subtypes.values()) {
      (subtype as ClassType).assignIndicies(environment, nextField, nextMethods);
    }
  }

  Null populateMembers(CompilationEnvironment environment) {
    if (!isConstructedOrSubclassIsConstructed) {
      return;
    }
    for (member in members.values() as MemberDescriptionList) {
      if (member.needsMethods) {
        assert(member.getter == null, 'where did you come from');
        if (member.getter == null) {
          // TODO: it's kind of weird that we sort of put this in the intrinsics library, which should be done compiling by now
          member.setGetter(BuiltInGetterMethod(environment.intrinsicsLibrary, this, member));
          environment.addSubroutine(member.getter!);
        }
        assert(member.setter == null, 'where did you come from');
        if (member.setter == null) {
          // TODO: it's kind of weird that we sort of put this in the intrinsics library, which should be done compiling by now
          member.setSetter(BuiltInSetterMethod(environment.intrinsicsLibrary, this, member));
          environment.addSubroutine(member.setter!);
        }
      }
    }
    for (subtype in subtypes.values()) {
      (subtype as ClassType).populateMembers(environment);
    }
  }

  IdentifierEntity createIdentifierEntity(CompiledScope scope, Bucket thisPointer, String name) {
    MemberDescription member = getMember(name)!;
    if (member.isAmbiguous) {
      // TODO: if this was just a forward declaration, this is inefficient
      return AmbiguousMemberIdentifierEntity(thisPointer, member, concat(this.name, '.', name));
    }
    if (member.isField) {
      return FieldIdentifierEntity(thisPointer, member, concat(this.name, '.', name));
    }
    return MethodIdentifierEntity(thisPointer, member, concat(this.name, '.', name));
  }

  AssemblerLabel label;
  AssemblerLabel vmtLabel;
  AssemblerLabel ddtLabel;

  Null generateVmt(CompilationEnvironment environment, Assembler assembler) {
    if (isConstructedOrSubclassIsConstructed) {
      // VMT
      ConstantPartList vmtLines = []:ConstantPart;
  
      if (code != null) {
        append(vmtLines, ConstantPart(ow.QWord, [TypeCodeDatum(this)]:ImmediateDatum, 'type code'));
      } else {
        // this class is never constructed or type checked, so has no type code
        append(vmtLines, ConstantPart(ow.QWord, [IntegerDatum(-1, 'missing type code specifier')]:ImmediateDatum, 'type code'));
      }
  
      append(vmtLines, ConstantPart(ow.QWord, [IntegerDatum(fieldCount, concat('field count of ', name))]:ImmediateDatum, 'number of fields to allocate during construction'));
  
      StringBucket classNameBucket = environment.registerStringConstant(label.deriveWith('className'), name, environment.coreStringType, 'class name', name);
      append(vmtLines, ConstantPart(ow.QWord, [ConstantDatum(classNameBucket.value, concat('"', name, '"'))]:ImmediateDatum, 'pointer to class name'));

      // Pointer to parent VMT
      // TODO: we should remove the parent vmt pointer entirely, we don't use it
      append(vmtLines, ConstantPart(ow.QWord, [IntegerDatum(0, 'unnecessary zero')]:ImmediateDatum, 'reserved (previously pointer to parent VMT)'));
  
      append(vmtLines, ConstantPart(ow.QWord, [DataLabelDatum(ddtLabel, concat('ddt of ', name))]:ImmediateDatum, 'pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)'));
  
      // there must be exactly vmtHeaderFieldCount * 8 bytes from the label to here.
  
      MemberDescriptionList sortedMethods = []:MemberDescription;
      for (member in members.values()) {
        if ((member as MemberDescription).needsMethods) {
          append(sortedMethods, member);
        }
      }
      Integer indexComparator(MemberDescription a, MemberDescription b) {
        return a.methodsIndex! - b.methodsIndex;
      }
      sortWithComparator(sortedMethods, indexComparator);
      Integer debugIndex = 0;
      for (member in sortedMethods) {
        if ((member as MemberDescription).needsMethods) {
          assert((member as MemberDescription).methodsIndex == debugIndex, concat('methods out of sync: method ', name, '.', (member as MemberDescription).name, ' has index ', (member as MemberDescription).methodsIndex, ' but we have seen ', debugIndex, ' method(s) so far'));
          String comment = concat(name, '.', (member as MemberDescription).name);
          ImmediateDatum methodValue;
          if ((member as MemberDescription).methodImplementation == null) {
            methodValue = IntegerDatum(0, 'null');
          } else {
            methodValue = CodeLabelDatum((member as MemberDescription).methodImplementation!.label, (member as MemberDescription).methodImplementation!.label.name);
          }
          ImmediateDatum typeCode;
          if ((member as MemberDescription).isField) {
            typeCode = IntegerDatum(-1, 'missing method specifier');
          } else {
            typeCode = TypeCodeDatum((member as MemberDescription).staticType);
          }
          append(vmtLines, ConstantPart(ow.QWord, [
            typeCode,
            CodeLabelDatum((member as MemberDescription).setter!.label, concat('setter of ', name, '.', (member as MemberDescription).name)),
            CodeLabelDatum((member as MemberDescription).getter!.label, concat('getter of ', name, '.', (member as MemberDescription).name)),
            methodValue,
          ]:ImmediateDatum, comment));
          debugIndex += 1;
        }
      }
  
      assembler.addConst(Constant(vmtLabel, vmtLines, null, concat('VMT for ', name)));
  
      // DDT
      ConstantPartList ddtLines = []:ConstantPart;
      MemberDescriptionList sortedMembers = []:MemberDescription;
      for (member in members.values()) {
        if ((member as MemberDescription).needsDynamicDispatch) {
          append(sortedMembers, member);
        }
      }
      Integer atomComparator(MemberDescription a, MemberDescription b) {
        return environment.atomizeForDynamicDispatch(a.name) - environment.atomizeForDynamicDispatch(b.name);
      }
      sortWithComparator(sortedMembers, atomComparator);
      append(ddtLines, ConstantPart(ow.QWord, [IntegerDatum(len(sortedMembers), concat('number of members in ', name))]:ImmediateDatum, 'number of members used in dynamic dispatch'));
      for (member in sortedMembers) {
        append(ddtLines, ConstantPart(ow.DWord, [
          IntegerDatum(environment.atomizeForDynamicDispatch(member.name), concat('atom for ', member.name)), // low bits, member identifier
          IntegerDatum(vmtHeaderFieldCount * 8 + member.methodsIndex * 4 * 8 + 16, concat('offset into ', name, ', VMT for ', member.name, ' getter')), // high bits, offset into vmt to getter function, from vmt pointer
        ]:ImmediateDatum, concat('dynamic dispatch data for ', name, '.', member.name)));
      } 
      assembler.addConst(Constant(ddtLabel, ddtLines, null, concat('DDT for ', name)));
    }

    for (subtype in subtypes.values()) {
      (subtype as ClassType).generateVmt(environment, assembler);
    }
  }

  //#override
  Boolean isSubtypeOf(Type other) {
    return other == this
        || other is AnythingType
        || other is WhateverType
        || other is GarbageCollectableType
        || other is ReferenceCountedType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype))
        || (supertype != this && supertype.isSubtypeOf(other));
  }
  
  //#override
  Boolean neverReferenceCounted() {
    return false;
  }

  AssemblerLabel methodsLabel;
  AssemblerLabel gettersLabel;
  AssemblerLabel settersLabel;

  Null constructor(CompiledScope parentScope, String nameArg, TypeNullable supertypeArg) {
    super.constructor(parentScope.environment(), nameArg);
    assert(supertypeArg is ClassTypeNullable, 'passed in non-class type to classtype constructor');
    if (supertypeArg == null) {
      supertype = this;
    } else {
      supertype = supertypeArg as ClassType;
      supertype.subtypes.add(this);
    }
    label = parentScope.classesLabel.deriveWith(name);
    vmtLabel = label.deriveWith('vmt'); // virtual method table
    ddtLabel = label.deriveWith('ddt'); // dynamic dispatch table
    methodsLabel = label.deriveWith('method');
    gettersLabel = label.deriveWith('getter');
    settersLabel = label.deriveWith('setter');
  }
}

// ============================================================================
// ENUMS
// ============================================================================

// internal type for RTL to recognize enum values
// all enum values are of this type
class RootEnumPropertyType extends NumericType {
  //#override
  Boolean isSubtypeOf(Type other) {
    return other is RootEnumPropertyType
        || other is AnythingType
        || other is WhateverType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype));
  }
}

// the specific type of an enum value
class EnumPropertyType extends NumericType {
  //#override
  Boolean isSubtypeOf(Type other) {
    return other == this
        || other is RootEnumPropertyType
        || other is AnythingType
        || other is WhateverType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype));
  }
}

// internal type for RTL to recognize reified enum types
// all reified enums are of this type
class RootReifiedEnumType extends NumericType {
  //#override
  Boolean isSubtypeOf(Type other) {
    return other is RootReifiedEnumType
        || other is AnythingType
        || other is WhateverType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype));
  }
}

// the type of the enum namespace
class ReifiedEnumType extends NumericType {
  StringBucket nameBucket;
  AssemblerLabel label;
  Map values; // String -> StringBucket
  EnumPropertyType propertyType;

  //#override
  Boolean isSubtypeOf(Type other) {
    return other == this
        || other is RootReifiedEnumType
        || other is AnythingType
        || other is WhateverType
        || (other is NullableType && isSubtypeOf((other as NullableType).subtype));
  }

  Null constructor(TypeRegistry typeRegistryArg, AssemblerLabel labelArg, StringBucket nameBucketArg, EnumPropertyType propertyTypeArg, Map valuesArg) {
    super.constructor(typeRegistryArg, concat(nameBucketArg.value.value, 'Enum'));
    nameBucket = nameBucketArg;
    label = labelArg;
    propertyType = propertyTypeArg;
    values = valuesArg;
  }
}

class ReifiedEnumBucket extends DataLabelBucket {
  Null constructor(ReifiedEnumType staticTypeArg) {
    super.constructor(staticTypeArg.label, staticTypeArg);
  }
}

// ============================================================================
// SPECIALIZED INSTRUCTIONS
// ============================================================================

// runs block1 if condition != false, otherwise runs block2
class IfScopeInstruction extends BoundInstruction {
  Bucket condition;
  CompiledScope block1;
  CompiledScopeNullable block2;

  //#override
  BoundInstruction extract() {
    BoundInstructionList block1Instructions = []:BoundInstruction;
    block1.extractInstructionsInto(block1Instructions);
    BoundInstructionList block2Instructions = []:BoundInstruction;
    if (block2 != null) {
      block2!.extractInstructionsInto(block2Instructions);
    }
    BoundInstruction result = IfBlockInstruction(condition, block1Instructions, block2Instructions);
    result.bind(scopeLabel);
    return result;
  }

  Null constructor(Bucket conditionArg, CompiledScope block1Arg, CompiledScopeNullable block2Arg) {
    super.constructor();
    condition = conditionArg;
    block1 = block1Arg;
    block2 = block2Arg;
  }
}

class LoopScopeInstruction extends BoundInstruction {
  CompiledScope block;

  //#override
  BoundInstruction extract() {
    BoundInstructionList blockInstructions = []:BoundInstruction;
    block.extractInstructionsInto(blockInstructions);
    BoundInstruction result = LoopBlockInstruction(blockInstructions);
    result.bind(scopeLabel);
    return result;
  }

  Null constructor(CompiledScope blockArg) {
    super.constructor();
    block = blockArg;
  }
}

// ============================================================================
// SCOPES
// ============================================================================

class CompiledScope extends Object {
  CompiledScopeNullable parent;
  String name;

  AssemblerLabel label;
  AssemblerLabel classesLabel;
  AssemblerLabel subroutinesLabel;

  CompiledLibrary globalScope() { 
    assert(parent != null, 'compiled scope chain failure');
    return parent!.globalScope();
  }

  CompiledStackFrameScope stackFrame() { 
    assert(parent != null, 'compiled scope chain failure');
    CompiledScope result = parent!.stackFrame() as CompiledScope;
    return result;
  }

  CompilationEnvironment environment() {
    assert(parent != null, 'compiled scope chain failure');
    return parent!.environment();
  }

  // REGISTRIES

  // variables namespace
  Map identifiers = Map(); // String -> IdentifierEntity (includes functions)
  Boolean isIdentifierDeclaredInLocalScope(String name) {
    return identifiers.get(name) != null;
  }

  IdentifierEntityNullable lookupIdentifier(String name) {
    return internalLookupIdentifier(name);
  }

  IdentifierEntityNullable localLookupIdentifier(String name) {
    return identifiers.get(name) as IdentifierEntityNullable;
  }

  IdentifierEntityNullable internalLookupIdentifier(String name) {
    IdentifierEntityNullable value = localLookupIdentifier(name);
    if (value == null && parent != null) {
      value = parent!.internalLookupIdentifier(name);
    }
    return value;
  }

  Set subscopes = Set(); // CompiledScope

  Null registerNestedScope(CompiledScope nestedScope) {
    subscopes.add(nestedScope);
  }

  // Caller must incref variable if appropriate.
  // Libraries override this to register global variables.
  IdentifierEntity registerVariable(String name, Type type) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    LocalVariable variable = LocalVariable(type, environment().coreSentinel, name,);
    IdentifierEntity result = LocalVariableIdentifierEntity(variable);
    identifiers.set(name, result);
    emit(VariableDeclarationInstruction(variable));
    return result;
  }

  // Caller must incref variable if appropriate.
  Null registerImmutableValue(String name, Bucket value) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    assert(!(value is LocalVariable), concat('registerImmutableValue used to register variable "', name, '"'));
    identifiers.set(name, ImmutableVariableIdentifierEntity(value));
  }

  Null registerConstant(String name, ConstantBucket value) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    assert(!(value is LocalVariable), concat('registerConstant used to register variable "', name, '"'));
    identifiers.set(name, ConstantIdentifierEntity(value));
    value.staticType.markConstructed();
  }

  SubroutinePointerBucket registerSubroutine(CompiledSubroutine subroutine, Boolean isConstructor) { 
    assert(!isIdentifierDeclaredInLocalScope(subroutine.name), concat('tried to redeclare an identifier (', subroutine.name, ') within a scope'));
    SubroutinePointerBucket bucket = SubroutinePointerBucket(subroutine, isConstructor);
    identifiers.set(subroutine.name, SubroutineIdentifierEntity(bucket));
    subroutine.adoptBucket(bucket);
    environment().addSubroutine(subroutine);
    return bucket;
  }


  // INSTRUCTION GENERATION

  // only emit() should modify this
  BoundInstructionList instructions = []:BoundInstruction;

  Null emit(BoundInstruction instruction) {
    instruction.bind(label); // so that the instruction can generate labels
    append(instructions, instruction);
  }

  Bucket compute(ComputationBoundInstruction instruction) {
    instruction.bind(label); // so that the instruction can generate labels
    append(instructions, instruction);
    return instruction.target;
  }
  
  Null subemit(BoundInstructionList instructions, BoundInstruction instruction) {
    instruction.bind(label); // so that the instruction can generate labels
    append(instructions, instruction);
  }

  Bucket subcompute(BoundInstructionList instructions, ComputationBoundInstruction instruction) {
    subemit(instructions, instruction);
    return instruction.target;
  }
  
  Null markSourceLocation(AstNode statement) {
    emit(AstNodeReferenceInstruction(statement));
  }
    
  // Caller should emit static and dynamic type checks on target.
  // Target should be a pointer to a structure that contains a pointer to code, and a this pointer and a closure as appropriate (i.e. target is a function pointer).
  Bucket emitSubroutinePointerCall(Bucket target, BucketList arguments, SourceLocationNullable callLocation, SourceLocationListNullable sourceLocations) {
    assert((callLocation != null) == (sourceLocations != null), 'callLocation and sourceLocations must both be null or both be non-null');
    Type subroutineType = target.staticType;
    assert(subroutineType.isSubtypeOf(environment().coreSubroutineType), 'cannot call a non-function (to call code pointer, use emitCodePointerCall)');
    Type returnType;
    if (subroutineType is AbstractSubroutineType) {
      returnType = (subroutineType as AbstractSubroutineType).returnType;
    } else {
      returnType = environment().coreAnythingType;
    }
    CompilationEnvironment environment = environment();
    if (sourceLocations != null && subroutineType is AbstractSubroutineTypeWithSpecificParameters) {
      TypeList argumentTypes = []:Type;
      for (argument in arguments) {
        append(argumentTypes, argument.staticType);
      }
      (subroutineType as AbstractSubroutineTypeWithSpecificParameters).verifyArguments(argumentTypes, callLocation!, sourceLocations!);
    }
    environment.coreSubroutineCodeAddressType.markConstructed();
    Bucket label = DereferenceWithOffsetsBucket(
      target,
      environment.integer(_subroutineCodePointer),
      environment.integer(_subroutineCodeType),
      ow.QWord,
      environment.coreSubroutineCodeAddressType,
      LazyComment('callee'),
    );
    // Extract closure and this from function pointer structure
    environment.coreClosureType.markConstructed();
    Bucket closure = emitCopy(DereferenceWithStaticTypeBucket(
      target,
      environment.integer(_subroutineClosurePointer),
      ow.QWord,
      environment.coreClosureType,
      LazyComment('closure'),
    ));
    Bucket thisPointer = DereferenceWithOffsetsBucket(
      target,
      environment.integer(_subroutineReceiverPointer),
      environment.integer(_subroutineReceiverType),
      ow.QWord,
      environment.lookupIntrinsicClass(environment.coreClassTypeIntrinsicName),
      LazyComment('this pointer'),
    );
    // Call label
    return compute(CallInstruction(returnType, label, closure, thisPointer, arguments));
  }

  // Caller should emit static and dynamic type checks on target.
  // Target should be a pointer to code (i.e. target is an actual code label).
  // This basically just calls CallInstruction directly, but first calls verifyArguments.
  Bucket emitCodePointerCall(AbstractSubroutineTypeWithSpecificParameters subroutineType, Bucket target, BucketNullable closure, BucketNullable thisPointer, BucketList arguments, SourceLocationNullable callLocation, SourceLocationListNullable sourceLocations) {
    assert((callLocation != null) == (sourceLocations != null), 'callLocation and sourceLocations must both be null or both be non-null');
    assert(subroutineType.isSubtypeOf(environment().coreSubroutineType), 'cannot call a non-function');
    assert(closure == null || closure!.staticType.isSubtypeOf(environment().coreClosureType), 'internal error');
    CompilationEnvironment environment = environment();
    if (sourceLocations != null) {
      TypeList argumentTypes = []:Type;
      for (argument in arguments) {
        append(argumentTypes, argument.staticType);
      }
      (subroutineType as AbstractSubroutineTypeWithSpecificParameters).verifyArguments(argumentTypes, callLocation!, sourceLocations!);
    }
    return compute(CallInstruction(subroutineType.returnType, target, closure, thisPointer, arguments));
  }
  
  Bucket emitIntrinsicCall(String name, BucketList arguments) {
    CompiledSubroutine subroutine = environment().lookupIntrinsicSubroutine(name);
    return emitCodePointerCall(
      subroutine.type,
      subroutine.codePointer,
      null, // closure
      null, // this
      arguments,
      null, // source locations
      null,
    );
  }
  
  // Computes the pointer for subscripting a list.
  // Returned bucket is a pointer to the type/value pair (type quad immediately followed by value quad), not the actual value.
  Bucket emitSubscriptEvaluation(Bucket list, Bucket index) {
    Type elementType;
    if (list.staticType is AbstractListType) {
      AbstractListType listType = list.staticType as AbstractListType;
      elementType = listType.elementType;
    } else {
      elementType = environment().coreAnythingType;
    }
    return compute(SubscriptEvaluationInstruction(list, index, elementType, LazyComment('@', list, '[', index, ']')));
  }

  Bucket emitCopy(Bucket source) {
    CopyBucketInstruction instruction = CopyBucketInstruction(source);
    emit(instruction);
    return instruction.target;
  }


  // COMPILER PHASES

  Null appendHeader(BoundInstructionList result) { }
  Null appendBody(BoundInstructionList result) {
    for (instruction in instructions) {
      append(result, instruction.extract());
    }
  }
  Null appendCleanup(BoundInstructionList result) { }
  Null appendEpilog(BoundInstructionList result) { }
  Null appendReturn(BoundInstructionList result) { }

  Null extractInstructionsInto(BoundInstructionList result) {
    appendHeader(result);
    appendBody(result);
    appendCleanup(result);
    appendEpilog(result);
    appendReturn(result);
  }

  Null finalizeInstructions(Assembler assembler) {}

  AssemblerLabel createLabel() {
    if (parent != null) {
      return parent!.label.deriveWith(name);
    }
    return environment().rootLabel.deriveWith(name);
  }

  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor();
    name = nameArg;
    parent = parentArg as CompiledScopeNullable;
    label = createLabel();
    classesLabel = label.deriveWith('class');
    subroutinesLabel = label.deriveWith('func');
  }

  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, concat(stringTimes(' ', indent), 'identifiers: ', identifiers));
    if (len(instructions) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'instructions:'));
      for (instruction in instructions) {
        append(buffer, concat(instruction));
      }
    } else {
      append(buffer, concat(stringTimes(' ', indent), 'no instructions'));
    }
    return join(buffer, '\n');
  }

  //#override
  String toString() {
    return concat('<', label, ':', className, '@', internalObjectId, '>');
  }
}

class CompiledLoopScope extends CompiledScope { }

class CompiledStackFrameScope extends CompiledScope {
  Null constructor(CompiledScopeNullable parentArg, String nameArg) {
    super.constructor(parentArg, nameArg);
  }

  //#override
  CompiledStackFrameScope stackFrame() { 
    return this;
  }

  BucketList locallyCreatedBuckets() {
    return []:Bucket;
  }

  PrologType prologType() {
    abstract();
  }

  //#override
  Null appendHeader(BoundInstructionList result) {
    super.appendHeader(result);
    subemit(result, PrologInstruction(locallyCreatedBuckets(), prologType()).extract());
  }
  
  //#override
  Null appendEpilog(BoundInstructionList result) {
    subemit(result, EpilogInstruction().extract());
    super.appendEpilog(result);
  }
}

class CompiledSubroutine extends CompiledStackFrameScope {
  AbstractSubroutineTypeWithSpecificParameters type; // subroutine signature
  ClassTypeNullable parentClass;

  ParameterCountBucket parameterCount;
  ReturnValuePointerParameterBucket returnValuePointer;
  ReturnTypePointerParameterBucket returnTypePointer;
  //#ignore_unused
  ClosurePointerParameterBucket closurePointer;
  Bucket thisPointer;

  SubroutinePointerBucketNullable functionPointerBucket = null;
  AssemblerLabel functionPointerLabel;

  Bucket codePointer; // set in constructor

  //#override
  AssemblerLabel createLabel() {
    if (parentClass != null) {
      return parentClass!.methodsLabel.deriveWith(name);
    }
    return parent!.subroutinesLabel.deriveWith(name);
  }

  Null adoptBucket(SubroutinePointerBucket functionPointerBucketArg) {
    functionPointerBucket = functionPointerBucketArg;
  }

  BucketNullable inline(CompiledScope scope, BucketList arguments) {
    return null;
  }

  // This is called from other scopes (where we need to emit the instructions),
  // hence the scope argument.
  // Caller is expected to do any needed static type checks.
  Null emitReturnFrom(CompiledScope scope, Bucket value, Boolean isFallbackReturn) {
    scope.emit(SetReturnValueInstruction(
      value,
      returnValuePointer,
      returnTypePointer,
      type.returnType,
      isFallbackReturn,
    ));
    scope.emit(ReturnInstruction());
  }

  StringBucket nameConstant;

  Boolean isMethod() {
    return parentClass != null;
  }

  //#override
  IdentifierEntityNullable localLookupIdentifier(String name) {
    IdentifierEntityNullable value = super.localLookupIdentifier(name);
    if (value == null && parentClass != null) { // explicitly _not_ using isMethod(), we don't know the runtime type!
      MemberDescriptionNullable member = parentClass!.getMember(name);
      if (member != null && member!.isDeclared()) {
        // We are in a method calling another method on the same object
        // so the thisPointer of the call is the same as ours.
        return parentClass!.createIdentifierEntity(this, thisPointer, name);
      }
    }
    return value;
  }

  //#override
  Null finalizeInstructions(Assembler assembler) {
    emit(CommentInstruction(LazyComment('Implicit return from ', name)));
    emitReturnFrom(this, environment().coreNull, true);
    if (functionPointerBucket != null) {
      functionPointerLabel = label.deriveWith('functionPointer');
      // TODO: this should be in .const; not in .data
      assembler.addData(Constant(
        functionPointerLabel,
        [
          ConstantPart(ow.QWord, [IntegerDatum(1, 'initial reference count')]:ImmediateDatum, 'initial reference count'),
          ConstantPart(ow.QWord, [IntegerDatum(3, 'number of fields in function pointer block')]:ImmediateDatum, 'number of fields in function pointer block'),
          ConstantPart(ow.QWord, [IntegerDatum(0, 'scratch space for garbage collector')]:ImmediateDatum, 'scratch space for garbage collector'),
          ConstantPart(ow.QWord, [IntegerDatum(-1, 'missing block list entry pointer specifier')]:ImmediateDatum, 'block list entry pointer (invalid for function pointers as they are not in the block list)'),
          ConstantPart(ow.QWord, [TypeCodeDatum(environment().coreNullType)]:ImmediateDatum, 'receiver (Null)'),
          ConstantPart(ow.QWord, [IntegerDatum(0, 'pointer to receiver (null)')]:ImmediateDatum, 'pointer to receiver (null)'),
          ConstantPart(ow.QWord, [TypeCodeDatum(environment().coreNullType)]:ImmediateDatum, 'closure (Null)'),
          ConstantPart(ow.QWord, [IntegerDatum(0, 'pointer to closure (null)')]:ImmediateDatum, 'pointer to closure (null)'),
          ConstantPart(ow.QWord, [TypeCodeDatum(environment().coreSubroutineCodeAddressType)]:ImmediateDatum, 'code pointer (CodeAddress)'),
          ConstantPart(ow.QWord, [DataLabelDatum(label, concat('code pointer of ', name))]:ImmediateDatum, 'code pointer'),
        ]:ConstantPart,
        null,
        concat('function pointer for ', name)
      ));
    }
    super.finalizeInstructions(assembler);
  }

  //#override
  Null appendHeader(BoundInstructionList result) {
    subemit(result, SeparatorInstruction());
    subemit(result, CommentInstruction(LazyComment(name, ' (', type.name, ')')).extract());
    subemit(result, AnnotationInstruction(nameConstant.value.label));
    subemit(result, LabelInstruction(label, name).extract());
    super.appendHeader(result);
  }

  //#override
  Null appendBody(BoundInstructionList result) {
    BoundInstructionList body = []:BoundInstruction;
    super.appendBody(body);
    BoundInstruction block = SubroutineBlockInstruction(body, name).extract();
    subemit(result, block);
  }

  //#override
  Null appendReturn(BoundInstructionList result) {
    super.appendReturn(result);
    subemit(result, FinalReturnInstruction().extract());
  }

  //#override
  BucketList locallyCreatedBuckets() {
    BucketList result = []:Bucket;
    append(result, parameterCount);
    append(result, returnValuePointer);
    append(result, returnTypePointer);
    append(result, closurePointer);
    append(result, codePointer);
    if (isMethod()) {
      append(result, thisPointer);
    }
    return result;
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg, ClassTypeNullable parentClassArg) {
    parentClass = parentClassArg as ClassTypeNullable;
    super.constructor(parentArg, nameArg);
    type = typeArg;
    parameterCount = ParameterCountBucket(environment().coreIntegerType);
    returnValuePointer = ReturnValuePointerParameterBucket(environment().coreIntegerType);
    returnTypePointer = ReturnTypePointerParameterBucket(environment().coreIntegerType);
    closurePointer = ClosurePointerParameterBucket(environment().coreClosureType);
    environment().coreSubroutineCodeAddressType.markConstructed();
    codePointer = DatumBucket(
      CodeLabelDatum(label, name), 
      TypeCodeDatum(environment().coreSubroutineCodeAddressType),
      environment().coreSubroutineCodeAddressType,
      false /* isGCRoot */,
    );
    if (isMethod()) {
      thisPointer = ThisPointerParameterBucket(parentClass!);
      identifiers.set('this', ImmutableVariableIdentifierEntity(thisPointer));
    }
    nameConstant = environment().registerStringConstant(
      label.deriveWith('annotation'),
      name,
      environment().coreStringType, 
      concat('annotation for ', name, '(line ', __LINE__, ' col ', __COL__, ' in ', __FILE__, ')'),
      concat('"', name, '"'),
    );
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'type: ', type));
    return join(buffer, '\n');
  }
}

class CompiledSubroutineWithSpecificParameters extends CompiledSubroutine {
  ParameterBucketList parameters = []:ParameterBucket;

  ParameterBucket registerParameter(String name, Type type, Integer position) {
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter names');
    Bucket result = ParameterBucket(type, position, name);
    append(parameters, result);
    identifiers.set(name, ImmutableVariableIdentifierEntity(result));
    return result;
  }

  //#override
  BucketList locallyCreatedBuckets() {
    BucketList result = super.locallyCreatedBuckets();
    for (parameter in parameters) {
      append(result, parameter);
    }
    return result;
  }

  //#override
  PrologType prologType() {
    return PrologType.subroutine;
  }

  Null emitParameterChecks(ParameterBucketList parameters) {
    // check for parameter count
    emit(CommentInstruction(LazyComment('check parameters (starting with parameter count)')));
    environment().coreIntegerType.markConstructed();
    Bucket expectedParamCountValue = environment().integer(len(parameters));
    // TODO: add more arguments to createErrorHandlerBlock call
    BoundInstruction error = ErrorInstruction('incorrect number of parameters'); // TODO: be more detailed
    error.bind(label);
    emit(IfBlockInstruction(
      compute(EqualityInstruction(parameterCount, expectedParamCountValue, environment().coreBooleanType, false, LazyComment('check parameter count (expecting ', parameterCount, ')'))),
      []:BoundInstruction,
      [ error ]:BoundInstruction,
    ));
    Integer index = 0;
    for (parameter in parameters) {
      emit(TypeCheckInstruction(
        parameter, 
        parameter.staticType, 
        'parameter of wrong type', 
        false, 
        LazyComment('check type of parameter ', index, ' (expecting ', parameter.staticType, ')'),
      ));
      index += 1;
    }
    emit(CommentInstruction(LazyComment('end of parameter checks')));
  }
}

class CompiledVarArgsSubroutine extends CompiledSubroutine {
  VarArgsParameterBucketNullable parameters = null;

  VarArgsParameterBucket registerVarArgsParameter(String name, Type type) {
    assert(parameters == null, 'varargs subroutine expects to have only one parameter');
    ReadOnlyListType listType = createOrFindReadOnlyListType(environment(), type);
    listType.markConstructed();
    assert(!isIdentifierDeclaredInLocalScope(name), 'duplicate parameter name');
    parameters = VarArgsParameterBucket(listType, parameterCount);
    identifiers.set(name, VarArgsIdentifierEntity(parameters!));
    return parameters;
  }

  //#override
  BucketList locallyCreatedBuckets() {
    assert(parameters != null, 'parameters should be set by now');
    BucketList result = super.locallyCreatedBuckets();
    append(result, parameters!);
    return result;
  }

  //#override
  PrologType prologType() {
    return PrologType.varArgsSubroutine;
  }

  Null emitVarArgsParameterChecks(Type staticType, VarArgsParameterBucket varArgs) {
    // for each argument:
    //   check that it is a subtype of staticType
    //   if not, complain
    //
    // == in simpler terms: ==
    //
    // variable "a" set to base of varargs
    // "b" = base of varargs + parameter count * 16
    // loop:
    //   if a >= b:
    //     break
    //   emit type check for dereferenced a and staticType
    //   a = a + 16
    emit(CommentInstruction(LazyComment('varargs parameter type check; expecting parameters to be ', staticType.name)));
    CompilationEnvironment environment = environment();
    LocalVariable pointerToIndexthArg = LocalVariable(environment.coreIntegerType, environment.coreSentinel, '$pointerToIndexthArg$');
    emit(VariableDeclarationInstruction(pointerToIndexthArg));
    emit(UpdateVariableInstruction(pointerToIndexthArg, DatumBucket(varArgs.baseAddress, TypeCodeDatum(environment.coreIntegerType), environment.coreIntegerType, false /*isGCRoot*/)));
    Bucket paramCountTimes16 = compute(UnsignedMultiplyInstruction(environment.integer(0x10), varArgs.parameterCount, environment.coreIntegerType, LazyComment('parameter count times 16')));
    Bucket pointerToLastArg = compute(UnsignedAddInstruction(pointerToIndexthArg /* this is another way to say base address */, paramCountTimes16, environment.coreIntegerType, LazyComment('pointer to last argument')));
    BoundInstructionList loopBlock = []:BoundInstruction;
    Bucket whileCondition = subcompute(loopBlock, InequalityInstruction(Comparison.LessThan, pointerToIndexthArg, pointerToLastArg, environment.coreBooleanType, LazyComment('condition for "while"')));
    BoundInstruction breakInstruction = BreakInstruction();
    breakInstruction.bind(label);
    subemit(loopBlock, IfBlockInstruction(whileCondition, []:BoundInstruction, [breakInstruction]:BoundInstruction));
    environment.coreStringType.markConstructed();
    subemit(loopBlock, TypeCheckInstruction(
      DereferenceWithOffsetsBucket(
        pointerToIndexthArg, 
        environment.integer(0x08), 
        environment.integer(0x00), 
        ow.QWord, 
        staticType,
        LazyComment('indexth argument'),
      ), 
      staticType, 
      'argument %d of %s had type %s which is not a %s' /* TODO: fill in variables at runtime */, 
      false, 
      LazyComment('verify varargs parameter type'),
    ));
    subemit(loopBlock, UpdateVariableInstruction(pointerToIndexthArg, subcompute(loopBlock, UnsignedAddInstruction(pointerToIndexthArg, environment.integer(0x10), environment.coreIntegerType, LazyComment('new value of ', pointerToIndexthArg)))));
    emit(LoopBlockInstruction(loopBlock));
  }
}

// This is the autogenerated code that allocates memory for an object
// when the constructor is invoked.
//
// It should allocate memory, configure that memory with the appropriate
// bits, then call the user-defined constructor, if any. (There will always
// be one, because the RTL defines a base class constructor for __Object.)
class CompiledGeneratedConstructorSubroutine extends CompiledSubroutine {
  // actualConstructor (setActualConstructor)
  // thisPointer (setThisPointer)
  // superclass constructor:
  //   parent
  //   type
  //   name
  //   parentClass
  // ->
  // fancy final return

  // user-defined constructor
  CompiledSubroutine actualConstructor;

  Null setActualConstructor(CompiledSubroutine value) {
    actualConstructor = value;
  }

  //#override
  Boolean isMethod() {
    return false;
  }

  Null setThisPointer(Bucket thisPointerArg) {
    thisPointer = thisPointerArg;
  }

  LocalBucket thisPointerPin;
  LocalBucket closurePin;
  LocalBucket parameterCountPin;

  //#override
  PrologType prologType() {
    return PrologType.generatedConstructor;
  }

  //#override
  Null appendCleanup(BoundInstructionList result) {
    subemit(result, PrepareConstructorTrampolineInstruction(thisPointer, thisPointerPin, closurePin, parameterCount, parameterCountPin).extract());
    subemit(result, ReplaceParameterInstruction(returnValuePointer, ScratchBucket(ScratchIdentifier.FakeReturnValue, environment().coreIntegerType, 'return value pointer')).extract());
    subemit(result, ReplaceParameterInstruction(returnTypePointer, ScratchBucket(ScratchIdentifier.FakeReturnType, environment().coreIntegerType, 'return type pointer')).extract());
    super.appendCleanup(result);
  }

  //#override
  Null appendReturn(BoundInstructionList result) {
    // do not call super (which emits "ret")
    subemit(result, ConstructorTrampolineInstruction(actualConstructor.label, thisPointerPin, closurePin, parameterCountPin).extract());
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg, ClassType parentClassArg) {
    super.constructor(parentArg, typeArg, nameArg, parentClassArg);
    thisPointerPin = LocalBucket(parentClass!, 'this pointer for user constructor');
    closurePin = LocalBucket(environment().coreSentinelType, 'closure for user constructor');
    parameterCountPin = LocalBucket(environment().coreIntegerType, 'parameter count for user constructor');
  }
}

class BuiltInSubroutine extends CompiledSubroutineWithSpecificParameters {
  // names of the parameters
  StringList parameterNames() {
    return []:String;
  }

  // used to generate the instructions for the subroutine
  Null generateInstructions() { }

  //#override
  Null finalizeInstructions(Assembler assembler) {
    emitParameterChecks(parameters);
    generateInstructions();
    super.finalizeInstructions(assembler);
  }

  Null constructor(CompiledScopeNullable parentArg, AbstractSubroutineTypeWithSpecificParameters typeArg, String nameArg, ClassTypeNullable parentClassArg) {
    super.constructor(parentArg, typeArg, nameArg, parentClassArg);
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterBucket(signature.parameterTypes[index], index, parameterNames()[index]));
      index += 1;
    }
  }
}

class BuiltInGetterMethod extends BuiltInSubroutine {
  MemberDescription member;

  //#override
  Null generateInstructions() {
    assert(isMethod(), 'BuiltInGetterMethod is not a method');
    if (member.isField) {
      assert(member.needsField, 'isField but !needsField ?!');
      assert(member.fieldIndex! >= 0, concat('invalid field index for ', parentClass!.name, '.', member.name, ': ', member.fieldIndex));
      assert(_gcBlockData > 0, concat('invalid _gcBlockData: ', _gcBlockData));
      emitReturnFrom(
        this, 
        DereferenceWithOffsetsBucket(
          thisPointer, 
          environment().integer(_gcBlockData + member.fieldIndex * 16 + 8), 
          environment().integer(_gcBlockData + member.fieldIndex * 16),  
          ow.QWord,
          member.staticType,
          LazyComment(member.classType.name, '.', member.name),
        ),
        false,
      );
    } else {
      assert(member.methodImplementation != null, 'not field but has no method?');
      member.staticType.markConstructed();
      emitReturnFrom(this, 
        emitIntrinsicCall(
          environment().createMethodPointerIntrinsicName,
          [
            thisPointer,
            member.methodImplementation!.codePointer,
            TypeCodeBucket(member.staticType, environment().coreIntegerType),
          ]:Bucket,
        ),
        false,
      );
    }
    super.generateInstructions();
  }

  //#override
  AssemblerLabel createLabel() {
    return parentClass!.gettersLabel.deriveWith(name);
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, ClassType classArg, MemberDescription memberArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), memberArg.staticType, []:Type),
      memberArg.name,
      classArg,
    );
    member = memberArg;
  }
}

class BuiltInSetterMethod extends BuiltInSubroutine {
  MemberDescription member;

  //#override
  StringList parameterNames() {
    return []:String;
  }

  //#override
  Null generateInstructions() {
    if (!member.isField) {
      // TODO: provide more details in error message
      emit(ErrorInstruction('Tried to assign to a method'));
    }
    super.generateInstructions();
  }

  //#override
  AssemblerLabel createLabel() {
    return parentClass!.settersLabel.deriveWith(name);
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg, ClassType classArg, MemberDescription memberArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), parentArg.environment().coreNullType, []:Type),
      memberArg.name,
      classArg,
    );
    member = memberArg;
  }
}

class BuiltInLenSubroutine extends BuiltInSubroutine {
  //#override
  StringList parameterNames() {
    return ['list'];
  }

  //#override
  BucketNullable inline(CompiledScope scope, BucketList arguments) {
    if (len(arguments) == 1) {
      VarArgsParameterBucketNullable varArgs = arguments[0].asVarArgs();
      if (varArgs != null) {
        return varArgs!.parameterCount;
      }
    }
    return null;
  }

  //#override
  Null generateInstructions() {
    super.generateInstructions();
    emitReturnFrom(
      this, 
      DereferenceWithStaticTypeBucket(
        DereferenceWithStaticTypeBucket(
          parameters[0], 
          environment().integer(_listBlockData),  
          ow.QWord,
          environment().coreIntegerType,
          LazyComment('list block data of ', parameters[0].commentName()),
        ), 
        environment().integer(_gcBlockHeaderLength),  
        ow.QWord,
        environment().coreIntegerType,
        LazyComment('length of ', parameters[0].commentName()),
      ),
      false,
    );
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.environment().coreIntegerType,
        [ createOrFindReadOnlyListType(parentArg.environment(), parentArg.environment().coreWhateverType) ]:Type,
      ),
      'len',
      null /* parentClass */,
    );
  }
}

class BuiltInDebuggerSubroutine extends BuiltInSubroutine {
  //#override
  BucketNullable inline(CompiledScope scope, BucketList arguments) {
    if (len(arguments) == 0) {
      scope.emit(DebuggerInstruction());
      return environment().coreNull;
    }
    assert(false, concat('inline __debugger() takes 0 arguments, got ', len(arguments)));
    return null;
  }

  //#override
  Null generateInstructions() {
    super.generateInstructions();
    emit(DebuggerInstruction());
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.environment().coreNullType,
        []:Type,
      ),
      '__debugger',
      null /* parentClass */,
    );
  }
}

class CompilerIntrinsic extends BuiltInSubroutine {
  //#override
  StringList parameterNames() {
    abstract();
  }
  
  Bucket inlineBody(CompiledScope scope, BucketList arguments) {
    abstract();
  }

  Boolean verifyArguments(BucketList arguments, TypeList parameters) {
    assert(len(parameters) == len(arguments), 'unexpected number of arguments');
    Integer index = 0;
    while (index < len(arguments)) {
      assert(
        arguments[index].staticType.isSubtypeOf(parameters[index]),
        concat('argument ', index+1, ' of ', name, '() has unexpected type (wanted ', parameters[index], ' but got ', arguments[index].staticType, ')'),
      );
      index += 1;
    }
    return true;
  }

  //#override
  BucketNullable inline(CompiledScope scope, BucketList arguments) {
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    assert(verifyArguments(arguments, signature.parameterTypes), 'unexpected arguments');
    Bucket result = inlineBody(scope, arguments);
    assert(result.staticType == signature.returnType, concat(this, ' returned bucket of wrong type (expected ', signature.returnType, ' but got ', result.staticType, ')'));
    return result;
  }
}

class BuiltInReadFromAddressIntrinsic extends CompilerIntrinsic {
  //#override
  StringList parameterNames() {
    return ['address'];
  }

  //#override
  Bucket inlineBody(CompiledScope scope, BucketList arguments) {
    return scope.emitCopy(DereferenceWithStaticTypeBucket(
      arguments[0],
      environment().integer(0), 
      ow.QWord, 
      environment().coreIntegerType,
      LazyComment(arguments[0]),
    ));
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.environment().coreIntegerType,
        [ parentArg.environment().coreIntegerType ]:Type,
      ),
      '__readFromAddress',
      null /* parentClass */,
    );
  }
}

class BuiltInWriteToAddressIntrinsic extends CompilerIntrinsic {
  //#override
  StringList parameterNames() {
    return ['address', 'value'];
  }

  //#override
  Bucket inlineBody(CompiledScope scope, BucketList arguments) {
    scope.emit(WriteToAddressInstruction(arguments[0], arguments[1], 0));
    return scope.environment().coreNull;
  }

  Null constructor(CompiledIntrinsicsLibrary parentArg) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(
        parentArg.environment(),
        parentArg.environment().coreNullType,
        [ parentArg.environment().coreIntegerType, parentArg.environment().coreIntegerType ]:Type,
      ),
      '__writeToAddress',
      null /* parentClass */,
    );
  }
}

class GenericSystemCallSubroutine extends CompiledSubroutineWithSpecificParameters {
  String externalName;
  String library;

  //#override
  Null finalizeInstructions(Assembler assembler) {
    emitParameterChecks(parameters);
    emit(CommentInstruction(LazyComment('Calling ', externalName)));
    emitReturnFrom(this, compute(CallSystemInstruction(type.returnType, library, externalName, parameters as BucketList)), false);
    super.finalizeInstructions(assembler);
  }

  Null constructor(CompiledScope parentArg, Type returnTypeArg, TypeList argumentTypesArg, String libraryArg, String externalNameArg, String internalNameArg, StringList parameterNames) { 
    super.constructor(
      parentArg,
      createOrFindSubroutineTypeWithSpecificParameters(parentArg.environment(), returnTypeArg, argumentTypesArg),
      internalNameArg,
      null /* parentClass */,
    );
    library = libraryArg;
    externalName = externalNameArg;
    SubroutineTypeWithSpecificParameters signature = type as SubroutineTypeWithSpecificParameters;
    Integer index = 0;
    while (index < len(signature.parameterTypes)) {
      append(parameters, ParameterBucket(signature.parameterTypes[index], index, parameterNames[index]));
      index += 1;
    }
  }
}

class CompiledLibrary extends CompiledStackFrameScope {
  CompilationEnvironment compilationEnvironment;
  AssemblerLabel globalVariablesLabel;

  //#override
  CompiledLibrary globalScope() {
    assert(parent == null, 'CompiledLibrary had a parent scope');
    return this;
  }

  //#override
  CompilationEnvironment environment() {
    assert(compilationEnvironment != null, 'compilation environment was not set');
    return compilationEnvironment;
  }

  CompiledLibraryList libraries = []:CompiledLibrary;

  Null importLibrary(CompiledLibrary library) {
    assert(!contains(libraries, library), 'tried to import library twice');
    append(libraries, library);
  }

  GlobalVariableList globalVariables = []:GlobalVariable;

  //#override
  IdentifierEntity registerVariable(String name, Type type) {
    assert(!isIdentifierDeclaredInLocalScope(name), concat('tried to redeclare an identifier (', name, ') within a scope'));
    GlobalVariable variable = GlobalVariable(type, globalVariablesLabel, name);
    IdentifierEntity result = GlobalVariableIdentifierEntity(variable);
    identifiers.set(name, result);
    append(globalVariables, variable);
    return result;
  }

  //#override
  IdentifierEntityNullable internalLookupIdentifier(String name) {
    IdentifierEntityNullable result = super.internalLookupIdentifier(name);
    if (result == null) {
      for (library in libraries) {
        result = library.internalLookupIdentifier(name);
        if (result != null) {
          break;
        }
      }
    }
    return result;
  }

  // types namespace
  Map types = Map(); // String -> Type

  Null declareType(Type type) {
    assert(!environment().isCompoundType(type.name), 'tried to declare a type that ends with a generic suffix');
    assert(types.get(type.name) == null, 'tried to redefine a type name'); // TODO: hoist this into real error messages in the AST
    types.set(type.name, type);
  }

  TypeNullable lookupType(String name) {
    TypeNullable result = types.get(name) as TypeNullable;
    if (result != null) {
      return result;
    }
    for (library in libraries) {
      result = library.lookupType(name);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  Boolean isProgram = false;
  Null setAsProgram() {
    isProgram = true;
  }

  //#override
  Null appendReturn(BoundInstructionList result) {
    if (isProgram) {
      subemit(result, FinalReturnInstruction().extract());
    }
    super.appendReturn(result);
  }

  //#override
  PrologType prologType() {
    return PrologType.library;
  }

  //#override
  Null appendHeader(BoundInstructionList result) {
    subemit(result, CommentInstruction(LazyComment(name)).extract());
    subemit(result, CommentInstruction(LazyComment(stringTimes('=', len(scalarValues(name))))).extract());
    super.appendHeader(result);
  }

  //#override
  AssemblerLabel createLabel() {
    return environment().rootLabel.deriveWith(name);
  }

  //#override
  Null finalizeInstructions(Assembler assembler) {
    super.finalizeInstructions(assembler);
    for (global in globalVariables) {
      assembler.addUninitializedGlobal(UninitializedGlobal(global.currentValueDatum().label, 0x08, concat(global.name, ' value')));
      assembler.addUninitializedGlobal(UninitializedGlobal(global.currentTypeDatum().label, 0x08, concat(global.name, ' type')));
    }
  }

  Null constructor(CompilationEnvironment compilationEnvironmentArg, String nameArg) {
    compilationEnvironment = compilationEnvironmentArg;
    super.constructor(null, nameArg);
    globalVariablesLabel = label.deriveWith('global');
    if (!(this is CompiledIntrinsicsLibrary)) {
      importLibrary(compilationEnvironment.intrinsicsLibrary);
    }
    CompiledLibraryNullable runtimeLibrary = compilationEnvironment.runtimeLibrary;
    if (runtimeLibrary != null) {
      importLibrary(runtimeLibrary!);
    }
    CompiledLibraryNullable standardLibrary = compilationEnvironment.standardLibrary;
    if (standardLibrary != null) {
      importLibrary(standardLibrary!);
    }
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    append(buffer, super.toStringIndent(indent));
    append(buffer, concat(stringTimes(' ', indent), 'types: ', types));
    if (len(libraries) > 0) {
      append(buffer, concat(stringTimes(' ', indent), 'imports:'));
      for (library in libraries) {
        append(buffer, concat(library.toStringIndent(indent + 2)));
      }
    }
    return join(buffer, '\n');
  }
}

class CompiledIntrinsicsLibrary extends CompiledLibrary {
  Null generateScopes() {
    CompilationEnvironment environment = environment();
    registerConstant('null', environment.coreNull);
    registerConstant('false', environment.coreFalse);
    registerConstant('true', environment.coreTrue);
    declareType(environment.coreAnythingType);
    declareType(environment.coreWhateverType);
    declareType(environment.coreNullType);
    declareType(environment.coreBooleanType);
    declareType(environment.coreIntegerType);
    declareType(environment.coreStringType);
    declareType(environment.coreGarbageCollectableType);
    declareType(environment.coreReferenceCountedType);
    declareType(environment.coreSubroutineCodeAddressType);
    declareType(environment.coreListDataType);
    declareType(environment.coreRootEnumPropertyType);
    declareType(environment.coreRootReifiedEnumType);

    // built-in functions not used from compiler
    registerSubroutine(BuiltInDebuggerSubroutine(this), false);
    registerSubroutine(BuiltInLenSubroutine(this), false);

    // intrinsic functions (functions that only work when inlined)
    registerSubroutine(BuiltInReadFromAddressIntrinsic(this), false);
    registerSubroutine(BuiltInWriteToAddressIntrinsic(this), false);
  }
}
