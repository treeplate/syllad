import 'core.syd';
import 'syd-compiler.syd';

class AstNode extends Object {
  String toStringIndent(Integer indent) {
    abstract();
  }

  String toString() {
    return toStringIndent(0);
  }

  Null walk(NullFunction callback, Anything context) {
    // no children
  }

  Null constructor() {
    super.constructor();
  }
}

class Statement extends AstNode {
  Null constructor() {
    super.constructor();
  }

  Null compile(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  String toStringIndent(Integer indent) {
    StringList buffer = [];
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in children) {
      callback(child, context);
    }
  }

  Null compile(CompiledScope scope) {
    Null compileChild(AstNode child, CompiledScope scope) {
      cast(cast(child).compile)(scope); // workaround because self-reference doesn't work in closures
    }
    walk(compileChild, scope);
  }

  Null constructor(StatementList statementsArg) {
    super.constructor();
    children = statementsArg;
  }
}

class Expression extends AstNode {
  Boolean isLValue() {
    return false;
  }

  // Expressions are expected to declare a Slot then return a ValueHandle read from that Slot
  ValueHandle compile(CompiledScope scope) {
    abstract();
  }

  Null constructor() {
    super.constructor();
  }
}

class StringLiteralExpression extends Expression {
  String value;
  String label;

  ValueHandle compile(CompiledScope scope) {
    label = scope.environment().generateLabel('string');
    scope.emitInstruction(DataInstruction(
      label,
      [
        // ref count (-1 means permanently allocated, ignore ref count)
        'dq -01h',
        // length
        // XXX this is wrong, we should be giving the byte length in whatever encoding we use (probably UTF-8? though windows, so maybe UTF-16?)
        concat('dq ', len(scalarValues(value))),
        concat('db ', stringLiteral(value)),
      ],
      Object(), // xxxxxx source arg
    ));
    Slot slot = scope.registerStaticValue(LabelValue((scope.environment().runtimeLibrary! as CompiledRuntimeLibrary).coreStringType, label), concat(this));
    ValueHandle result = slot.read(scope);
    scope.emitInstruction(SlotReadInstruction(slot, result));
    return result;
  }

  String toStringIndent(Integer indent) {
    // XXX TODO escape quotes and backslashes (and newlines)
    return concat('\'', value, '\'');
  }

  Null constructor(String valueArg) {
    super.constructor();
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;
  
  String toStringIndent(Integer indent) {
    return concat(intToStr(value), ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg) {
    super.constructor();
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;

  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent);
    }
    return concat('[', join(cast(map(values, indenter)), ','), ']');
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in values) {
      callback(child, context);
    }
  }

  Null constructor(ExpressionList valuesArg) {
    super.constructor();
    values = valuesArg;
  }
}

class Subroutine extends Expression {
  String returnType;
  String identifier;
  StringListList parameters; // pairs of type and identifier
  StatementBlock body;
  
  String toStringIndent(Integer indent) {
    StringList parametersList = [];
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, parameter[0]);
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType, ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(body, context);
  }

  ValueHandle compile(CompiledScope scope) {
    body.compile(CompiledScope(scope, identifier));
    abstract();
  }

  Null constructor(String returnTypeArg, String identifierArg, StringListList parametersArg, StatementBlock bodyArg) {
    super.constructor();
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    body = bodyArg;
  }
}

class VariableExpression extends Expression {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Boolean isLValue() {
    return true;
  }

  ValueHandle compile(CompiledScope scope) {
    NamedSlotNullable slot = scope.lookupIdentifier(name);
    if (slot == null) {
      throw('xxxx');
    }
    ValueHandle result = slot!.read(scope);
    scope.emitInstruction(SlotReadInstruction(slot!, result));
    return result;
  }

  Null constructor(String nameArg) {
    super.constructor();
    name = nameArg;
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = [];
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(subroutineReference, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  ValueHandle compile(CompiledScope scope) {
    ValueHandle subroutine = subroutineReference.compile(scope);
    ValueHandleList argumentValues = [];
    if ((subroutine.slot as Slot).staticType is AbstractSubroutineType) {
      for (argument in arguments) {
        append(argumentValues, argument.compile(scope));
      }
    } else {
      throw('xxxx');
    }
    return scope.emitSubroutineCall(subroutine, argumentValues);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg) {
    super.constructor();
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class SubscriptExpression extends Expression {
  Expression list;
  Expression argument;
  
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(list, context);
    callback(argument, context);
  }

  Null constructor(Expression listArg, Expression argumentArg) {
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends Expression {
  Expression object;
  String member;
  
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
  }

  Null constructor(Expression objectArg, String memberArg) {
    object = objectArg;
    member = memberArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  String typeName;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', typeName);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null constructor(Expression expressionArg, String typeNameArg) {
    expression = expressionArg;
    typeName = typeNameArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }

  Null constructor(Expression rhsArg) {
    super.constructor();
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  String describeOperator() {
    return '-';
  }
}

class PlusExpression extends UnaryExpression {
  String describeOperator() {
    return '+';
  }
}

class BooleanNotExpression extends UnaryExpression {
  String describeOperator() {
    return '!';
  }
}

class BitwiseNotExpression extends UnaryExpression {
  String describeOperator() {
    return '~';
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() { abstract(); }
  
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
    callback(rhs, context);
  }

  Null constructor(Expression lhsArg, Expression rhsArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class OperatorAdditionExpression extends OperatorExpression {
  String describeOperator() {
    return '+';
  }
}

class OperatorSubtractionExpression extends OperatorExpression {
  String describeOperator() {
    return '-';
  }
}

class OperatorMultiplicationExpression extends OperatorExpression {
  String describeOperator() {
    return '*';
  }
}

class OperatorDivisionExpression extends OperatorExpression {
  String describeOperator() {
    return '/';
  }
}

class OperatorModulusExpression extends OperatorExpression {
  String describeOperator() {
    return '%';
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '==';
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '!=';
  }
}

class OperatorLessThanExpression extends OperatorExpression {
  String describeOperator() {
    return '<';
  }
}

class OperatorLeftShiftExpression extends OperatorExpression {
  String describeOperator() {
    return '<<';
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '<=';
  }
}

class OperatorGreaterThanExpression extends OperatorExpression {
  String describeOperator() {
    return '>';
  }
}

class OperatorRightShiftExpression extends OperatorExpression {
  String describeOperator() {
    return '>>';
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '>=';
  }
}

class OperatorBitwiseAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&';
  }
}

class OperatorLogicalAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&&';
  }
}

class OperatorBitwiseOrExpression extends OperatorExpression {
  String describeOperator() {
    return '|';
  }
}

class OperatorLogicalOrExpression extends OperatorExpression {
  String describeOperator() {
    return '||';
  }
}

class OperatorBitwiseXorExpression extends OperatorExpression {
  String describeOperator() {
    return '^';
  }
}

class DeclarationStatement extends Statement {
  String identifier;
  ExpressionNullable rValue;
  
  Null walk(NullFunction callback, Anything context) {
    if (rValue != null) {
      callback(rValue, context);
    }
  }

  Null constructor(String identifierArg, ExpressionNullable rValueArg) {
    super.constructor();
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  String type;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type, ' ', identifier, ';\n');
    }
    return concat(type, ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }

  Null constructor(String typeArg, String identifierArg, ExpressionNullable rValueArg) {
    super.constructor(identifierArg, rValueArg);
    type = typeArg;
  }
}

class SubroutineDeclarationStatement extends DeclarationStatement {
  String toStringIndent(Integer indent) {
    assert(rValue != null, 'Internal error: SubroutineDeclarationStatement has null subroutine');
    return rValue!.toStringIndent(indent);
  }

  Null constructor(Subroutine subroutine) {
    super.constructor(subroutine.identifier, subroutine);
  }
}  

class EnumDeclaration extends Statement {
  String name;
  StringList values;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', name, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  Null compile(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    globalScope.declareType(EnumType(scope.environment(), name, values));
  }

  Null constructor(String nameArg, StringList valuesArg) {
    super.constructor();
    name = nameArg;
    values = valuesArg;
  }
}

class ClassDeclaration extends Statement {
  String className;
  StringNullable superclassName;
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', className, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName);
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  Null constructor(String classNameArg, StringNullable superclassNameArg, DeclarationStatementList membersArg) {
    super.constructor();
    className = classNameArg;
    superclassName = superclassNameArg;
    members = membersArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null compile(CompiledScope scope) {
    expression.compile(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg) {
    super.constructor();
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null constructor(ExpressionNullable expressionArg) {
    super.constructor();
    expression = expressionArg;
  }
}

class ImportStatement extends Statement {
  String path;
  
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  Null compile(CompiledScope scope) {
    assert(scope.environment().getLibraryState(path) == lsDefined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(path) as CompiledLibrary);
  }

  Null constructor(String pathArg) {
    super.constructor();
    path = pathArg;
  }
}

class AssignmentStatement extends Statement {
  Expression lValue; // with isLValue true
  Expression rValue;

  String describeOperator() { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(Expression lValueArg, Expression rValueArg) {
    super.constructor();
    assert(lValueArg.isLValue(), 'lvalue is not assignable');
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class StraightAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '=';
  }
}

class PlusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '+=';
  }
}

class MinusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '-=';
  }
}

class AsteriskAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '*=';
  }
}

class SlashAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '/=';
  }
}

class ModulusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '%=';
  }
}

class BitwiseAndAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '&=';
  }
}

class BitwiseXorAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '^=';
  }
}

class BitwiseOrAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '|=';
  }
}

class ElseClause extends AstNode { }

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
    if (elseClause != null) {
      callback(elseClause, context);
    }
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg) {
    super.constructor();
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(block, context);
  }

  Null constructor(StatementBlock blockArg) {
    super.constructor();
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(ifClause, context);
  }

  Null constructor(IfStatement clauseArg) {
    super.constructor();
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg) {
    super.constructor();
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variable;
  Expression iterable;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variable,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(iterable, context);
    callback(block, context);
  }

  Null constructor(String variableArg, Expression iterableArg, StatementBlock blockArg) {
    super.constructor();
    variable = variableArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg) {
    super.constructor(childrenArg);
    name = nameArg;
  }

  CompiledLibrary compileLibrary(CompilationEnvironment compilationEnvironmentArg, Assembler assembler) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    compile(result);
    result.populateValueHandles();
    result.generateAssembler(assembler, assembler.mainBlockId);
    return result;
  }
}