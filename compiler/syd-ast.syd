import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';

fwdclass Statement(SourceLocation) extends AstNode;
fwdclass StatementBlock(StatementList, SourceLocation) extends AstNode;
fwdclass Library(StatementList, String, SourceLocation) extends StatementBlock;
fwdclassmethod LibraryList Library.generateLibraryScope(CompilationEnvironment);

class TypeIdentifier extends AstNode {
  String name;
  
  //#override
  String toStringIndent(Integer indent) {
    return name;
  }

  Type lookup(CompiledLibrary scope, Boolean requireDeclared) {
    TypeNullable result = scope.environment().parseType(name, requireDeclared, scope.lookupType);
    if (result == null) {
      throw(concat('Type "', name, '" not known in ', scope.name, ' scope at ', sourceLocation));
    }
    return result!;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null declareTypes(CompiledScope scope) { }

  Null prepareIdentifiers(CompiledScope scope) {
    abstract();
  }

  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null declareTypes(CompiledScope scope) {
    for (child in children) {
      child.declareTypes(scope);
    }
  }

  Null prepareIdentifiers(CompiledScope scope) {
    for (child in children) {
      child.prepareIdentifiers(scope);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    for (child in children) {
      scope.markSourceLocation(child);
      child.generateInstructions(scope);
    }
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class StringLiteralExpression extends Expression {
  String value;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return scope.environment().registerStringConstant(
      scope.label.deriveWith('string'),
      value,
      scope.environment().coreStringType,
      concat(sourceLocation),
      commentNameForString(value),
    );
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class SourceLocationFileStringLiteralExpression extends Expression {
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return scope.environment().registerStringConstant(
      scope.label.deriveWith('file'),
      sourceLocation.filename,
      scope.environment().coreStringType,
      concat(sourceLocation),
      commentNameForString('FILE'),
    );
  }

  //#override
  String toStringIndent(Integer indent) {
    return 'FILE';
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    scope.environment().coreIntegerType.markConstructed();
    return scope.environment().integer(value);
  }
  
  //#override
  String toStringIndent(Integer indent) {
    if (value > -10 && value < 10) {
      return concat(value);
    }
    if (value == -0x8000000000000000) {
      return concat(value, ' /* -0x8000000000000000 */');
    }
    if (value < 0) {
      return concat(value, ' /* -0x', hex(-value), ' */');
    }
    return concat(value, ' /* 0x', hex(value), ' */');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class SourceLocationLineIntegerLiteralExpression extends Expression {
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    scope.environment().coreIntegerType.markConstructed();
    return scope.environment().integer(sourceLocation.startLineNo);
  }

  //#override
  String toStringIndent(Integer indent) {
    return 'LINE';
  }
}

class SourceLocationColumnIntegerLiteralExpression extends Expression {
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    scope.environment().coreIntegerType.markConstructed();
    return scope.environment().integer(sourceLocation.startColNo);
  }

  //#override
  String toStringIndent(Integer indent) {
    return 'COL';
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;
  TypeIdentifierNullable elementType;

  //#override
  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent + 2);
    }
    String elementTypeString = '';
    if (elementType != null) {
      elementTypeString = concat(':', elementType!.toStringIndent(indent));
    }
    return concat('[', join(map(values, indenter) as StringList, ','), ']', elementTypeString);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    for (value in values) {
      value.prepareIdentifiers(scope);
    }
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();

    // Determine the elements of the list.
    BucketList elements = []:Bucket;
    for (value in values) {
      append(elements, value.generateInstructions(scope));
    }
    Integer initialLength = 1;
    if (len(elements) > initialLength) {
      initialLength = len(elements);
    }

    // Determine type of list.
    Type evaluatedElementType;
    if (elementType != null) {
      evaluatedElementType = elementType!.lookup(scope.globalScope(), true);
    } else {
      // infer the type based on the elements of the list
      TypeNullable currentType = null;
      for (element in elements) {
        if (!(element.staticType is WhateverType)) {
          if (currentType == null) {
            currentType = element.staticType;
          } else {
            if (currentType != element.staticType) {
              currentType = environment.coreAnythingType;
              break;
            }
          }
        }
      }
      if (currentType == null) {
        currentType = environment.coreAnythingType;
      }
      evaluatedElementType = currentType!;
    }
      
    Integer index = 0;
    for (element in elements) {
      if (!element.staticType.isSubtypeOf(evaluatedElementType)) {
        throw(concat('List of type ', evaluatedElementType.name, ' cannot contain element of type ', element.staticType.name, ' at ', values[index].sourceLocation));
      }
      index += 1;
    }

    Type type = createOrFindListType(environment, evaluatedElementType);
    type.markConstructed();
    createOrFindIteratorType(environment, evaluatedElementType).markConstructed();
    assert(initialLength > 0, 'List must not be constructed with zero elements.');
    Bucket list = scope.emitIntrinsicCall(environment.listConstructorIntrinsicName, [ TypeCodeBucket(type, scope.environment().coreIntegerType), environment.integer(initialLength) ]:Bucket).asType(type);
    for (element in elements) {
      scope.emitIntrinsicCall(environment.appendIntrinsicName, [ list, element ]:Bucket);
    }
    return list;
  }

  Null constructor(ExpressionList valuesArg, TypeIdentifierNullable elementTypeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
    elementType = elementTypeArg;
  }
}

class LValue extends Object {
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    abstract();
  }
}

class LValueExpression extends Expression {
  LValue generateLValue(CompiledScope scope) {
    abstract();
  }
}

class VariableLValue extends LValue {
  IdentifierEntity variable;

  //#override
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    if (!variable.writeable()) {
      throw(concat('Cannot assign to immutable value at ', sourceLocation));
    }
    if (!rValue.staticType.isSubtypeOf(variable.staticType())) {
      throw(concat('Cannot assign ', rValue.staticType.name, ' to variable of type ', variable.staticType().name, ' at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rValue, 
      variable.staticType(), 
      'tried to assign to variable of wrong type compared to rvalue', 
      true, 
      LazyComment('check assignment is type-safe'),
    ));
    variable.write(scope, rValue);
  }

  Null constructor(IdentifierEntity variableArg) {
    super.constructor();
    variable = variableArg;
  }
}

class VariableExpression extends LValueExpression {
  String name;
  
  //#override
  String toStringIndent(Integer indent) {
    return name;
  }

  IdentifierEntity lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable result = scope.lookupIdentifier(name);
    if (result == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    if (!result!.isDeclared()) {
      // for compatibility with the interpreter
      throw(concat('Identifier "', name, '" has not yet been defined at ', sourceLocation));
    }
    return result!;
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    scope.prepareIdentifierReferenceFor(name);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return lookupCurrentIdentifier(scope).forRead(scope);
  }

  //#override
  LValue generateLValue(CompiledScope scope) {
    return VariableLValue(lookupCurrentIdentifier(scope));
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubscriptLValue extends LValue {
  Type elementType;
  Bucket pointer;

  //#override
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    if (!rValue.staticType.isSubtypeOf(elementType)) {
      throw(concat('Cannot assign ', rValue.staticType.name, ', to list element of type ', elementType.name, ' at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rValue, 
      elementType, 
      'tried to assign to subscript lvalue of type that does not match rvalue', 
      true, 
      LazyComment('check subscript assignment is type-safe'),
    ));
    scope.emit(HeapUpdateInstruction(pointer, rValue, 0, elementType));
  }

  Null constructor(Type elementTypeArg, Bucket pointerArg) {
    super.constructor();
    elementType = elementTypeArg;
    pointer = pointerArg;
  }
}

class SubscriptExpression extends LValueExpression {
  Expression list;
  Expression argument;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Boolean _prepared = false;
  Bucket _evaluatedList;
  Bucket _evaluatedArgument;
  Type _evaluatedElementType;

  Null _prepare(CompiledScope scope) {
    if (_prepared) {
      return;
    }
    _evaluatedList = list.generateInstructions(scope);
    if (_evaluatedList.staticType is AbstractListType) {
      _evaluatedElementType = (_evaluatedList.staticType as AbstractListType).elementType;
    } else if (_evaluatedList.staticType.isSubtypeOf(scope.environment().coreSubscriptableType)) {
      _evaluatedElementType = scope.environment().coreAnythingType;
    } else {
      throw(concat('"', list, '", a ', _evaluatedList.staticType.name, ', is not a list (and therefore cannot be subscripted) at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      _evaluatedList,
      scope.environment().coreSubscriptableType, 
      'tried to subscript non-list', 
      true, 
      LazyComment('check subscript receiver is a list'),
    ));
    _evaluatedArgument = argument.generateInstructions(scope);
    if (!_evaluatedArgument.staticType.isSubtypeOf(scope.environment().coreIntegerType)) {
      throw(concat('Subscript index is not an Integer at ', sourceLocation, ' (is ', _evaluatedArgument.staticType.name, ')'));
    }
    scope.emit(TypeCheckInstruction(
      _evaluatedArgument,
      scope.environment().coreIntegerType,
      'tried to subscript with non-integer index',
      true,
      LazyComment('check subscript index is an integer'),
    ));
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    list.prepareIdentifiers(scope);
    argument.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    _prepare(scope);
    return DereferenceWithOffsetsBucket(
      scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument), 
      scope.environment().integer(0x08), 
      scope.environment().integer(0x00), 
      ow.QWord, 
      _evaluatedElementType,
      LazyComment('subscript result'),
    );
  }

  //#override
  LValue generateLValue(CompiledScope scope) {
    _prepare(scope);
    return SubscriptLValue(_evaluatedElementType, scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument));
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends LValueExpression {
  Expression object;
  String member;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    object.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lBucket = object.generateInstructions(scope);
    CompilationEnvironment environment = scope.environment();
    if (lBucket.staticType is ClassType) {
      ClassType class = lBucket.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDeclared()) {
        return class.createIdentifierEntity(scope, lBucket, member).forRead(scope);
      }
      throw(concat('Class "', class.name, '" does not have a member "', member, '", as used at ', sourceLocation));
    }
    if (lBucket.staticType is ReifiedEnumType) {
      ReifiedEnumType enum = lBucket.staticType as ReifiedEnumType;
      BucketNullable result = enum.values.get(member) as BucketNullable;
      if (result != null) {
        return result!;
      }
      throw(concat('Enum "', enum.name, '" does not have a value "', member, '", as used at ', sourceLocation));
    }
    if (lBucket.staticType.isSubtypeOf(environment.lookupIntrinsicClass(environment.coreClassTypeIntrinsicName, sourceLocation)) || 
        lBucket.staticType.isSubtypeOf(environment.coreRootReifiedEnumType)) {
      Integer memberId = scope.environment().atomizeForDynamicDispatch(member);
      return scope.emitIntrinsicCall(scope.environment().dynamicLookupIntrinsicName, [ lBucket, scope.environment().integer(memberId) ]:Bucket);
    }
    throw(concat('Type ', lBucket.staticType.name, ' does not support member access as used at ', sourceLocation));
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

CompiledSubroutine evaluateSuper(CompiledScope scope, String method, SourceLocation sourceLocation) {
  CompiledStackFrameScope stackFrame = scope.stackFrame();
  if (!stackFrame is CompiledSubroutine) {
    throw(concat('Super expression used outside method at ', sourceLocation));
  }
  ClassTypeNullable hostClass = (stackFrame as CompiledSubroutine).parentClass;
  if (hostClass == null) {
    throw(concat('Super expression used in function instead of method at ', sourceLocation));
  }
  if (hostClass!.supertype == hostClass) {
    assert(hostClass!.supertype == scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName, sourceLocation), 'unexpected other root class');
    throw(concat('Super expression used in internal base class at ', sourceLocation));
  }
  if (hostClass!.supertype == scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName, sourceLocation)) {
    throw(concat('Super expression used in base class at ', sourceLocation));
  }
  ClassType superclass = hostClass!.supertype;
  MemberDescriptionNullable memberDescription = superclass.getMember(method);
  if (memberDescription == null) {
    throw(concat('Superclass does not have a method "', method, '" as referenced at ', sourceLocation));
  }
  assert(memberDescription!.isDefined(), concat('superclass method ', method, ' not defined'));
  while (memberDescription!.isField) {
    if (superclass.supertype == superclass) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
    superclass = superclass.supertype;
    memberDescription = superclass.getMember(method);
    if (memberDescription == null) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
  }
  return memberDescription!.methodImplementation!;
}

// super only ever applies to methods (not fields)
// this AST node is used when super.foo is not being directly called
// super.foo() is handled by SuperSubroutineCallExpression
class SuperExpression extends Expression {
  String method;

  //#override
  String toStringIndent(Integer indent) {
    return concat('super.', method);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    targetMethod.type.markConstructed();
    return scope.emitIntrinsicCall(
      scope.environment().createFunctionPointerIntrinsicName,
      [
        thisMethod.thisPointer,
        targetMethod.codePointer,
        scope.environment().coreNull,
        TypeCodeBucket(targetMethod.type, scope.environment().coreIntegerType),
      ]:Bucket,
    );
  }

  Null constructor(String methodArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
  }
}

Null generateInstructionsForArguments(CompilationEnvironment environment, CompiledScope scope, Expression subroutineReference, SourceLocation sourceLocation, Type subroutineType, ExpressionList arguments, BucketList argumentValues, SourceLocationList sourceLocations) {
  if (subroutineType.isSubtypeOf(environment.coreSubroutineType)) {
    for (argument in arguments) {
      append(sourceLocations, argument.sourceLocation);
      append(argumentValues, argument.generateInstructions(scope));
    }
  } else {
    throw(concat('"', subroutineReference.toStringIndent(0), '" is not a function pointer at ', sourceLocation, ' (is ', subroutineType.name, ')'));
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    subroutineReference.prepareIdentifiers(scope);
    for (argument in arguments) {
      argument.prepareIdentifiers(scope);
    }
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return generateInstructionsForSubroutinePointerCallExpression(scope, subroutineReference.generateInstructions(scope), arguments, subroutineReference, sourceLocation);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class IdentifierSubroutineCallExpression extends Expression {
  String name;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(name, '(', joinList(argumentsList), ')');
  }
  
  IdentifierEntity lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable entity = scope.lookupIdentifier(name);
    if (entity == null)  {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    if (!entity!.isDeclared()) {
      // for compatibility with the interpreter
      throw(concat('Identifier "', name, '" is known but has not yet been declared at ', sourceLocation));
    }
    return entity!;
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    scope.prepareIdentifierReferenceFor(name);
    for (argument in arguments) {
      argument.prepareIdentifiers(scope);
    }
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return lookupCurrentIdentifier(scope).emitCall(scope, arguments, this, sourceLocation);
  }

  Null constructor(String nameArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
    arguments = argumentsArg;
  }
}

class MemberAccessSubroutineCallExpression extends Expression {
  Expression object;
  String member;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(object.toStringIndent(indent), '.', member, '(', joinList(argumentsList), ')');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    object.prepareIdentifiers(scope);
    for (argument in arguments) {
      argument.prepareIdentifiers(scope);
    }
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lBucket = object.generateInstructions(scope);
    if (lBucket.staticType is ClassType) {
      ClassType class = lBucket.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDeclared()) {
        return class.createIdentifierEntity(scope, lBucket, member).emitCall(scope, arguments, this, sourceLocation);
      }
      throw(concat('Nonexistent member ', member, ' at ', sourceLocation));
    } else {
      throw(concat('Cannot call member on non-class type ', lBucket.staticType.name, ' at ', sourceLocation));
    }
  }

  Null constructor(Expression objectArg, String memberArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
    arguments = argumentsArg;
  }
}

class SuperSubroutineCallExpression extends Expression {
  String method;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat('super.', method, '(', joinList(argumentsList), ')');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    for (argument in arguments) {
      argument.prepareIdentifiers(scope);
    }
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    return generateInstructionsForSubroutineCallExpression(
      scope,
      ForCallResult(targetMethod.codePointer, targetMethod.type, thisMethod.thisPointer),
      null,
      arguments,
      this,
      sourceLocation,
    );
  }

  Null constructor(String methodArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
    arguments = argumentsArg;
  }
}

class UnwrapExpression extends Expression {
  Expression lhs;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(lhs.toStringIndent(indent), '!');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    lhs.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // check that it's not nullable
    // return a static cast
    Bucket value = lhs.generateInstructions(scope);
    if (value.staticType is NullableType) {
      Type unwrappedType = (value.staticType as NullableType).subtype;
      assert(value.staticType.needRuntimeTypeCheckFor(unwrappedType), 'internal error');
      assert(unwrappedType.isSubtypeOf(value.staticType), 'internal error');
      scope.emit(TypeCheckInstruction(value, unwrappedType, 'value is null', true, LazyComment('check type of ', value, ' is ', unwrappedType, ' and not null')));
      return StaticCastBucket(value, unwrappedType);
    } else if (value.staticType is WhateverType) {
      BoundInstruction error = ErrorInstruction('unexpected null value');
      error.bind(scope.label);
      scope.emit(IfBlockInstruction(
        scope.compute(EqualityInstruction(value, scope.environment().coreNull, scope.environment().coreBooleanType, false, LazyComment('check ', value, ' is not null'))),
        [ error ]:BoundInstruction,
        []:BoundInstruction,
      ));
      return value;
    } else {
      throw(concat('Type of expression (', value.staticType.name, ') is not a nullable type at ', sourceLocation));
    }
  }

  Null constructor(Expression lhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', type);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Type rhs = type.lookup(scope.globalScope(), true);
    if (!lhs.staticType.needRuntimeTypeCheckFor(rhs)) {
      // always true
      return scope.environment().coreTrue;
    }
    if (!rhs.isSubtypeOf(lhs.staticType)) {
      // always false
      return scope.environment().coreFalse;
    }
    return scope.compute(StoreTypeCheckInstruction(rhs, lhs, scope.environment().coreBooleanType, 'evaluate is operator', LazyComment('result of "is" operator')));
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

// AST node for "(expression) as type_literal"
//
// The expression is "lhs" and the type literal is "rhs".
// 
// language semantics for this operator are a little special:
//
//  0. if:
//       - rhs is not a subtype of lhs' static type, and
//       - lhs' static type is not a subtype of rhs, and
//       - (rhs is not list type, or 
//         - lhs' static type is not list type, or 
//         - (rhs' element type is not a subtype of lhs' static type's element type, and
//           - lhs' static type's element type is not a subtype of rhs' element type)):
//     compile time error.
//  1. if lhs' dynamic type is a subtype of rhs:
//     return lhs unchanged.
//  2. if rhs is WhateverList and lhs' dynamic type is a list type:
//     return lhs unchanged.
//  3. if rhs is a list type, and lhs' dynamic type is a list type:
//     return listCast(lhs, rhs).
//  4. otherwise, throw at runtime.
class AsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' as ', type);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Type rhs = type.lookup(scope.globalScope(), true);
    CompilationEnvironment environment = scope.environment();
    if (!rhs.isSubtypeOf(lhs.staticType) && !lhs.staticType.isSubtypeOf(rhs)) {
      if (!rhs is AbstractListType || !lhs.staticType is AbstractListType) {
        throw(concat('Cannot cast ', lhs.staticType.name, ' to ', rhs.name, ' at ', sourceLocation));
      }
      // both are list types but they're not a simple static cast away from compatibility
      AbstractListType lhsListType = lhs.staticType as AbstractListType;
      AbstractListType rhsListType = rhs as AbstractListType;
      if ((!rhsListType.elementType.isSubtypeOf(lhsListType.elementType)) &&
          (!lhsListType.elementType.isSubtypeOf(rhsListType.elementType))) {
        throw(concat('Cannot cast list of type ', lhs.staticType.name, ' to list of type ', rhs.name, ' at ', sourceLocation));
      }
      return scope.emitIntrinsicCall(
        environment.listCastIntrinsicName,
        [
          lhs,
          TypeCodeBucket(rhs, environment.coreIntegerType),
        ]:Bucket,
      ).asType(rhs);
    }
    // TODO: whatever as whatever should not need runtime check
    if (!lhs.staticType.needRuntimeTypeCheckFor(rhs)) {
      return lhs.asType(rhs);
    }
    // either we think there's a chance the types are compatible
    // or we know we need a dynamic check for it
    LocalVariable result = LocalVariable(rhs, environment.coreSentinel, '$result$');
    scope.emit(VariableDeclarationInstruction(result));
    CompiledScope castScope = CompiledScope(scope, 'as operator runtime cast case');
    CompiledScope listCheckScope = CompiledScope(scope, 'as operator list cast case');
    scope.emit(IfScopeInstruction(
      scope.compute(
        StoreTypeCheckInstruction(
          rhs,
          lhs,
          environment.coreBooleanType,
          'dynamic type check for as operator',
          LazyComment('result of type check for "as" operator'),
        ),
      ),
      castScope,
      listCheckScope,
    ));
    // castScope: (step 1 above)
    castScope.emit(UpdateVariableInstruction(result, lhs.asType(rhs)));
    // listCheckScope: (steps 2, 3, and 4 above)
    if (rhs is AbstractListType) {
      if ((rhs as AbstractListType).elementType is WhateverType) {
        // WhateverList is magical in the language spec.
        listCheckScope.emit(UpdateVariableInstruction(result, lhs.asType(rhs)));
      } else {
        listCheckScope.emit(
          UpdateVariableInstruction(
            result,
            listCheckScope.emitIntrinsicCall( // (includes dynamic check for step 3)
              environment.listCastIntrinsicName,
              [
                lhs,
                TypeCodeBucket(rhs, environment.coreIntegerType),
              ]:Bucket,
            ).asType(rhs),
          ),
        );
      }
    } else {
      listCheckScope.emit(ErrorInstruction('type error in "as" operator')); // TODO: more useful message
    }
    return result;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretAsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __as__ ', type);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket exprBucket = expression.generateInstructions(scope);
    Type rhs = type.lookup(scope.globalScope(), true);
    rhs.markConstructed();
    return StaticReinterpretCastBucket(exprBucket, rhs);
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class DynamicIsOperatorExpression extends Expression {
  Expression expression;
  Expression type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __dynamic_is__ ', type.toStringIndent(indent));
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
    type.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Bucket rhs = type.generateInstructions(scope);
    return scope.compute(
      StoreDynamicTypeCheckInstruction(
        rhs,
        lhs,
        scope.environment().coreBooleanType,
        'evaluate __dynamic_is_ operator',
        LazyComment('result of "__dynamic_is__" operator'),
      ),
    );
  }

  Null constructor(Expression expressionArg, Expression typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretDynamicAsOperatorExpression extends Expression {
  Expression expression;
  Expression type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __dynamic_as__ ', type);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
    type.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Bucket rhs = type.generateInstructions(scope);
    return DynamicCastBucket(lhs, rhs, scope.environment().coreAnythingType);
  }

  Null constructor(Expression expressionArg, Expression typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  Type rhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type returnType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // return scope.compute(AdditionInstruction(rhsValue, concat(describeOperator(), ' operator')));
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    rhs.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket rhsValue = rhs.generateInstructions(scope);
    Type rhsType = rhsType(scope.environment());
    if (!rhsValue.staticType.isSubtypeOf(rhsType)) {
      throw(concat('Expected ', rhsType.name, ', but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      rhsType, 
      'expected %s but got %s (in unary %s expression)', 
      true, 
      LazyComment('check ', describeOperator(), ' operator\'s operand is valid type'),
    ));
    assert(returnType(scope.environment()).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    return generateExpressionInstructions(rhsValue, scope);
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '-';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(NegateInstruction(rhsValue, scope.environment().coreIntegerType, LazyComment('result of unary -')));
  }
}

class PlusExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '+';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return rhsValue;
  }
}

class BooleanNotExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '!';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(BooleanNotInstruction(rhsValue, scope.environment().coreBooleanType, LazyComment('result of unary ! operator')));
  }
}

class BitwiseNotExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '~';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(BitwiseNotInstruction(rhsValue, scope.environment().coreIntegerType, LazyComment('result of unary ~ operator')));
  }
}

class TypeOfExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__typeOf';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return TypeOfBucket(rhsValue, scope.environment().coreIntegerType);
  }
}

class ElementTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__elementTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    // input: type code of iterable
    // output: type code of elements in iterable
    // the elementTypeTableLabel is a table of 32 bit wide codes (4 bytes wide)
    // first, multiply the type code by 4 to get the offset into the table in bytes
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into element type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().elementTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('element type of ', rhsValue),
    );
  }
}

class IteratorTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__iteratorTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    // input: type code of iterable
    // output: type code of iterator version of input
    // the iteratorTypeTableLabel is a table of 32 bit wide codes (4 bytes wide)
    // first, multiply the type code by 4 to get the offset into the table in bytes
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into iterator type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().iteratorTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('iterator type version of ', rhsValue),
    );
  }
}

class ListTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__listTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into list type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().listTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('list type version of ', rhsValue),
    );
  }
}

// This marks the type as constructed, but not as type checked.
class TypeToCodeExpression extends Expression {
  TypeIdentifier rhs;

  String describeOperator() {
    return '__typeCodeOf';
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Type rhsValue = rhs.lookup(scope.globalScope(), true);
    rhsValue.markConstructed();
    return TypeCodeBucket(rhsValue, scope.environment().coreIntegerType);
  }

  Null constructor(TypeIdentifier rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    abstract();
    // e.g.:
    // return '+';
  }

  Type lhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type rhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type returnType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // return scope.compute(AdditionInstruction(rhsValue, concat(describeOperator(), ' operator')));
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    Type lhsType = lhsType(scope.environment());
    if (!lhsValue.staticType.isSubtypeOf(lhsType)) {
      throw(concat('Expected ', lhsType.name, ', but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      lhsType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    Type rhsType = rhsType(scope.environment());
    if (!rhsValue.staticType.isSubtypeOf(rhsType)) {
      throw(concat('Expected ', rhsType.name, ', but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      rhsType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    lhs.prepareIdentifiers(scope);
    rhs.prepareIdentifiers(scope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhsValue = lhs.generateInstructions(scope);
    Bucket rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(lhsValue, rhsValue, scope);
    assert(returnType(scope.environment()).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    Bucket result = generateExpressionInstructions(lhsValue, rhsValue, scope);
    assert(result.staticType == returnType(scope.environment()), concat(className, '\'s returnType is not respected by its generateExpressionInstructions method'));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class NumericOperatorExpression extends OperatorExpression {
  //#override
  Type lhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }
}

class OperatorAdditionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '+';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedAddInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary + operator')));
  }
}

class OperatorSubtractionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '-';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedSubtractInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary - operator')));
  }
}

class OperatorExponentiationExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '**';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedExponentiationInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary ** operator')));
  }
}

class OperatorMultiplicationExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '*';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedMultiplyInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary * operator')));
  }
}

class OperatorDivisionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '/';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedDivideInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary / operator')));
  }
}

class OperatorModulusExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '%';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedModulusInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary % operator')));
  }
}

class OperatorBitwiseAndExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '&';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary & operator')));
  }
}

class OperatorBitwiseOrExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '|';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary | operator')));
  }
}

class OperatorBitwiseXorExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '^';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(XOrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary ^ operator')));
  }
}

class OperatorLeftShiftExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '<<';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(ShiftLeftInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary << operator')));
  }
}

class OperatorRightShiftExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '>>';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(ShiftRightInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary >> operator')));
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  //#override
  String describeOperator() {
    return '==';
  }

  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType.name, ' and ', rhsValue.staticType.name));
    }
  }

  //#override
  Type lhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(EqualityInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, false, LazyComment('result of binary == operator')));
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  //#override
  String describeOperator() {
    return '!=';
  }

  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType, ' and ', rhsValue.staticType));
    }
  }

  //#override
  Type lhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(EqualityInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, true, LazyComment('result of binary != operator')));
  }
}

class OperatorNumericCmpExpression extends OperatorExpression {
  Comparison flag() {
    abstract();
  }
  
  //#override
  Type lhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(InequalityInstruction(flag(), lhsValue, rhsValue, scope.environment().coreBooleanType, LazyComment('result of binary ', describeOperator(), ' operator')));
  }
}

class OperatorLessThanExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '<';
  }

  //#override
  Comparison flag() {
    return Comparison.LessThan;
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '<=';
  }

  //#override
  Comparison flag() {
    return Comparison.LessThanOrEqual;
  }
}

class OperatorGreaterThanExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '>';
  }

  //#override
  Comparison flag() {
    return Comparison.GreaterThan;
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '>=';
  }

  //#override
  Comparison flag() {
    return Comparison.GreaterThanOrEqual;
  }
}

class OperatorLogicalAndExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    return '&&';
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  CompiledScope rhsScope;
  CompiledScope falseScope;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    rhsScope = CompiledScope(scope, '&&');
    falseScope = CompiledScope(scope, 'short-circuited &&');
    lhs.prepareIdentifiers(scope);
    rhs.prepareIdentifiers(rhsScope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // evaluate lhs
    LocalVariable result = LocalVariable(scope.environment().coreBooleanType, scope.environment().coreSentinel, '$result$');
    scope.emit(VariableDeclarationInstruction(result));
    Bucket lhsValue = lhs.generateInstructions(scope);
    if (!lhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    // create a scope for when lhs is not false, that returns rhs
    Bucket rhsValue = rhs.generateInstructions(rhsScope);
    if (!rhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    rhsScope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    rhsScope.emit(UpdateVariableInstruction(result, rhsValue));
    // create a scope for when lhs is false, that returns false
    falseScope.emit(UpdateVariableInstruction(result, scope.environment().coreFalse)); // 'short-circuited &&'
    // put it all together
    scope.emit(IfScopeInstruction(lhsValue, rhsScope, falseScope));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class OperatorLogicalOrExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    return '||';
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  CompiledScope trueScope;
  CompiledScope rhsScope;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    trueScope = CompiledScope(scope, 'short-circuited ||');
    rhsScope = CompiledScope(scope, '||');
    lhs.prepareIdentifiers(scope);
    rhs.prepareIdentifiers(rhsScope);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // evaluate lhs
    LocalVariable result = LocalVariable(scope.environment().coreBooleanType, scope.environment().coreSentinel, '$result$');
    scope.emit(VariableDeclarationInstruction(result));
    Bucket lhsValue = lhs.generateInstructions(scope);
    if (!lhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    // create scope for when lhs is not false, that returns true
    trueScope.emit(UpdateVariableInstruction(result, scope.environment().coreTrue)); // 'short-circuited ||'
    // create scope for when lhs is false, that returns rhs
    Bucket rhsValue = rhs.generateInstructions(rhsScope);
    if (!rhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    rhsScope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    rhsScope.emit(UpdateVariableInstruction(result, rhsValue));
    // put it all together
    scope.emit(IfScopeInstruction(lhsValue, trueScope, rhsScope));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class FieldDeclarationStatement extends Statement {
  String identifier;
  TypeIdentifier type;
  ExpressionNullable rValue;
  ClassType parentClass;

  //#override
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }

  Type staticType; // set in registerMember, used when generating instructions

  Null registerMember(CompiledScope scope, ClassType parentClassArg) {
    parentClass = parentClassArg;
    staticType = type.lookup(scope.globalScope(), false);
    if (identifier == kConstructor && !staticType.isSubtypeOf(createOrFindSubroutineTypeWithAnyArgs(scope.environment(), scope.environment().coreNullType))) {
      throw(concat('Constructor must be a NullFunction, but is declared as a ', staticType.name, ' at ', sourceLocation));
    }
    MemberDescriptionNullable inheritedMember = parentClass.getMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (!staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    parentClass.registerMember(identifier, staticType, true);
  }
  
  Null generateInitializerInstructions(CompiledScope constructor) {
    if (rValue != null) {
      Bucket rBucket = rValue!.generateInstructions(constructor);
      if (!rBucket.staticType.isSubtypeOf(staticType)) {
        throw(concat('Cannot assign ', rBucket.staticType.name, ' to field of type ', staticType.name, ' at ', sourceLocation));
      }
      constructor.emit(TypeCheckInstruction(
        rBucket, 
        staticType, 
        'tried to assign %s to field of type %s at %s', 
        true, 
        LazyComment('check type of field initializer is valid'), // TODO: better error message
      ));
      IdentifierEntity entity = (constructor as CompiledSubroutine).parentClass!.createIdentifierEntity(
        constructor as CompiledSubroutine,
        (constructor as CompiledSubroutine).thisPointer,
        identifier,
      );
      if (entity.writeable()) {
        entity.write(constructor, rBucket);
      }
    }
  }
  
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    if (rValue != null) {
      rValue!.prepareIdentifiers(scope);
    }
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (identifier == kConstructor) {
      // TODO: this violates the language spec
      throw(concat('Identifier "', identifier, '" is an invalid name for a field at ', sourceLocation));
    }
    generateInitializerInstructions(scope);
    parentClass.getMember(identifier)!.markDeclared();
    parentClass.getMember(identifier)!.markDefined();
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    type = typeArg;
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class ConstantDeclarationStatement extends Statement {
  String identifier;
  TypeIdentifier type;
  Expression rValue;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('const ', type.toStringIndent(indent), ' ', identifier, ' = ', rValue.toStringIndent(indent), ';\n');
  }
  
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    rValue.prepareIdentifiers(scope);
    scope.prepareIdentifier(identifier);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Type staticType = type.lookup(scope.globalScope(), true);
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Bucket rhs = rValue.generateInstructions(scope);
    if (!rhs.staticType.isSubtypeOf(staticType)) {
      throw(concat('Cannot assign ', rhs.staticType.name, ' to variable of type ', staticType.name, ' at ', sourceLocation));
    }
    ConstantBucketNullable rhsConstant = rhs.asConstant();
    if (rhsConstant != null) {
      scope.registerConstant(identifier, rhsConstant!);
    } else {
      scope.emit(TypeCheckInstruction(
        rhs, 
        staticType, 
        'type mismatch in assignment.', 
        true, 
        LazyComment('check type of variable initializer (', rhs, ')'), // TODO: more detailed error message
      ));
      scope.registerImmutableValue(identifier, rhs);
    }
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    type = typeArg;
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends Statement {
  String identifier;
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  //#override
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }
  
  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    if (rValue != null) {
      rValue!.prepareIdentifiers(scope);
    }
    scope.prepareIdentifier(identifier);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Type staticType = type.lookup(scope.globalScope(), true);
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Bucket rhs;
    if (rValue != null) {
      // TODO: for literals assigned to globals, instead of doing it this way, we should put the initialized value in the .data section
      rhs = rValue!.generateInstructions(scope);
    }
    IdentifierEntity lhs = scope.registerVariable(identifier, staticType);
    assert(lhs.writeable(), 'variable is not writeable');
    if (rValue != null) {
      if (!rhs.staticType.isSubtypeOf(lhs.staticType())) {
        throw(concat('Cannot assign ', rhs.staticType.name, ' to variable of type ', lhs.staticType().name, ' at ', sourceLocation));
      }
      scope.emit(TypeCheckInstruction(
        rhs, 
        staticType, 
        'type mismatch in assignment.', 
        true, 
        LazyComment('check type of variable initializer (', rhs, ')'), // TODO: more detailed error message
      ));
      lhs.write(scope, rhs);
    }
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    type = typeArg;
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class AbstractSubroutineDeclarationStatement extends Statement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // tuples of type (TypeIdentifier), identifier (String), and SourceLocation
  Boolean isVarArgs;
  StatementBlock body;

  ClassTypeNullable receiverType() {
    abstract();
  }

  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    abstract();
  }

  CompiledSubroutine subroutine;
  Type staticType;

  Null generateStaticType(CompiledScope scope, Boolean requireDeclared) {
    Type compiledReturnType = returnType.lookup(scope.globalScope(), requireDeclared);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      if (entry[1] == identifier) {
        throw(concat('Parameter has the same name as its function at ', entry[2]));
      }
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).lookup(scope.globalScope(), requireDeclared));
    }
    if (isVarArgs) {
      assert(len(compiledParameterTypes) == 1, 'unexpected number of parameters to varargs function');
      staticType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
      createOrFindIteratorType(scope.environment(), compiledParameterTypes[0]).markConstructed();
      createOrFindListType(scope.environment(), compiledParameterTypes[0]).markConstructed();
    } else {
      staticType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
    }
    staticType.markConstructed();
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    if (isVarArgs) {
      subroutine = CompiledVarArgsSubroutine(scope, identifier, receiverType());
    } else {
      subroutine = CompiledSubroutineWithSpecificParameters(scope, identifier, receiverType());
    }
    scope.prepareIdentifier(identifier);
    for (parameter in parameters) {
      String name = parameter[1] as String;
      subroutine.prepareIdentifier(name);
    }
    body.prepareIdentifiers(subroutine);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (isVarArgs) {
      subroutine.setType(staticType as SubroutineTypeWithVarArgs);
      String name = parameters[0][1] as String;
      Type type = (staticType as SubroutineTypeWithVarArgs).parameterType;
      (subroutine as CompiledVarArgsSubroutine).emitVarArgsParameterChecks(type, (subroutine as CompiledVarArgsSubroutine).registerVarArgsParameter(name, type) as VarArgsParameterBucket);
    } else {
      subroutine.setType(staticType as SubroutineTypeWithSpecificParameters);
      ParameterBucketList parameterBuckets = []:ParameterBucket;
      Integer index = 0;
      for (parameter in parameters) {
        String name = parameter[1] as String;
        Type type = (staticType as SubroutineTypeWithSpecificParameters).parameterTypes[index];
        append(parameterBuckets, (subroutine as CompiledSubroutineWithSpecificParameters).registerParameter(name, type, index));
        index += 1;
      }
      (subroutine as CompiledSubroutineWithSpecificParameters).emitParameterChecks(parameterBuckets);
    }
    registerSubroutine(scope, subroutine);
    body.generateInstructions(subroutine);
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg) {
    assert(!isVarArgsArg || (len(parametersArg) == 1), 'varargs is only valid with a single parameter');
    super.constructor(sourceLocationArg);
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    isVarArgs = isVarArgsArg;
    body = bodyArg;
  }
}

class MethodDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  ClassType parentClass;

  Null registerMember(CompiledScope scope, ClassType parentClassArg) {
    parentClass = parentClassArg;
    generateStaticType(scope, false);
    if (identifier == kConstructor && !staticType.isSubtypeOf(createOrFindSubroutineTypeWithAnyArgs(scope.environment(), scope.environment().coreNullType))) {
      throw(concat('Constructor must be a NullFunction, but is declared as a ', staticType.name, ' at ', sourceLocation));
    }
    MemberDescriptionNullable inheritedMember = parentClass.getMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (inheritedMember!.name != kConstructor && !staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    parentClass.registerMember(identifier, staticType, false);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    super.generateInstructions(scope);
  }

  //#override
  ClassTypeNullable receiverType() {
    return parentClass;
  }

  //#override
  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    MemberDescription member = parentClass.getMember(identifier)!;
    member.markDeclared();
    member.markDefined();
    member.setMethodImplementation(subroutine);
    scope.environment().addSubroutine(subroutine);
  }
}

class SubroutineDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  Boolean isIntrinsic;

  //#override
  ClassTypeNullable receiverType() {
    return null;
  }

  //#override
  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    if (subroutine.isClosure()) {
      scope.registerClosure(subroutine, false);
    } else {
      scope.registerSubroutine(subroutine, false);
    }
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(subroutine);
    }
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    generateStaticType(scope, true);
    super.generateInstructions(scope);
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(returnTypeArg, identifierArg, parametersArg, isVarArgsArg, bodyArg, sourceLocationArg);
    isIntrinsic = isIntrinsicArg;
  }
}  

class GenericSystemSubroutineDeclarationStatement extends Statement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  String library;
  String externalName;
  Boolean isIntrinsic;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    scope.prepareIdentifier(identifier);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Type compiledReturnType = returnType.lookup(scope.globalScope(), true);
    TypeList compiledParameterTypes = []:Type;
    StringList compiledParameterNames = []:String;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).lookup(scope.globalScope(), true));
      append(compiledParameterNames, entry[1] as String);
    }
    CompiledSubroutine subroutine = GenericSystemCallSubroutine(
      scope,
      compiledReturnType,
      compiledParameterTypes,
      library,
      externalName,
      identifier,
      compiledParameterNames,
    );
    scope.registerSubroutine(subroutine, false);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(subroutine);
    }
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') __extern \'', escapeString(library), '\' \'', escapeString(externalName), '\'\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, String libraryArg, String externalNameArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(sourceLocationArg);
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    library = libraryArg;
    externalName = externalNameArg;
    isIntrinsic = isIntrinsicArg;
  }
}

class EnumDeclaration extends Statement {
  String identifier;
  StringList values;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', identifier, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  EnumPropertyType enumPropertyType;
  ReifiedEnumType reifiedEnumType;

  //#override
  Null declareTypes(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompilationEnvironment environment = scope.environment();
    if ((scope as CompiledLibrary).isTypeDeclaredInGlobalScope(identifier)) {
      throw(concat('"', identifier, '" redeclared at ', sourceLocation));
    }
    enumPropertyType = EnumPropertyType(environment, identifier);
    AssemblerLabel enumLabel = scope.label.deriveWith(identifier);
    Map enumValues = Map(); // String -> StringBucket
    for (value in values) {
      enumValues.set(value, environment.registerStringConstant(
        enumLabel.deriveWith(value),
        concat(identifier, '.', value),
        enumPropertyType,
        concat(identifier, '.', value, ' stringification'),
        concat(identifier, '.', value),
      ));
    }
    reifiedEnumType = ReifiedEnumType(
      environment,
      enumLabel, 
      environment.registerStringConstant(enumLabel.deriveWith('name'), identifier, environment.coreStringType, identifier, identifier),
      enumPropertyType,
      enumValues,
    );
    (scope as CompiledLibrary).registerType(enumPropertyType);
    (scope as CompiledLibrary).registerType(reifiedEnumType);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    enumPropertyType.markDeclared();
    reifiedEnumType.markDeclared();
    scope.registerConstant(identifier, scope.environment().registerEnumType(reifiedEnumType));
  }

  Null constructor(String identifierArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
    values = valuesArg;
  }
}

class AbstractClassDeclaration extends Statement {
  ClassType declareType(CompiledScope scope, String identifier, TypeIdentifierNullable superclassName, Boolean isIntrinsic) {
    if (scope.globalScope().isTypeDeclaredInGlobalScope(identifier)) {
      throw(concat('Type ', identifier, ' redeclared at ', sourceLocation));
    }
    TypeNullable superclass;
    if (isIntrinsic) {
      if (identifier != scope.environment().coreClassTypeIntrinsicName) {
        throw(concat('Class "', identifier, '" is not a valid intrinsic class (only "', scope.environment().coreClassTypeIntrinsicName, '" can be intrinsic).'));
      }
      if (superclassName != null) {
        throw(concat('Intrinsic class cannot have a superclass as ', sourceLocation));
      }
      superclass = null;
    } else if (superclassName == null) {
      superclass = scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName, sourceLocation);
    } else {
      superclass = superclassName!.lookup(scope.globalScope(), false);
    }
    ClassType classType = ClassType(scope, identifier, superclass);
    scope.globalScope().registerType(classType);
    if (isIntrinsic) {
      scope.environment().registerClassIntrinsic(classType);
    }
    return classType;
  }

  AbstractSubroutineTypeWithSpecificParameters createConstructorType(CompiledScope scope, ClassType classType, TypeList constructorParameters, Boolean constructorIsVarArgs) {
    if (constructorIsVarArgs) {
      return createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        classType,
        constructorParameters,
      );
    }
    return createOrFindSubroutineTypeWithSpecificParameters(
      scope.environment(),
      classType,
      constructorParameters,
    );
  }
}

class ForwardClassDeclaration extends AbstractClassDeclaration {
  String identifier;
  TypeIdentifierNullable superclassName;
  Boolean isIntrinsic;
  TypeIdentifierList constructorParameterTypes;
  Boolean isVarArgs;

  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['fwdclass ', identifier];
    append(buffer, '(');
    Integer index = 0;
    while (index < len(constructorParameterTypes)) {
      if (index > 0) {
        append(buffer, ', ');
      }
      append(buffer, constructorParameterTypes[index].toStringIndent(indent));
      index += 1;
    }
    append(buffer, ')');
    if (superclassName != null) {
      append(buffer, ' extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    if (isIntrinsic) {
      append(buffer, ' intrinsic#');
    }
    append(buffer, ';\n');
    return joinList(buffer);
  }

  //#override
  Null declareTypes(CompiledScope scope) {
    ClassType classType = declareType(scope, identifier, superclassName, isIntrinsic);
    classType.markAsForwardDeclared();
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    ClassTypeNullable classType = scope.globalScope().lookupType(identifier, false) as ClassTypeNullable;
    assert(classType != null, 'but... we just registered it');
    if (classType!.isForwardDeclared) {
      throw(concat('Class ', identifier, ' is never defined after being forward-declared at ', sourceLocation));
    }
    classType!.markDeclared();
    TypeList parameterTypes = []:Type;
    for (parameterType in constructorParameterTypes) {
      append(parameterTypes, parameterType.lookup(scope.globalScope(), true));
    }
    assert(!isVarArgs || len(parameterTypes) == 1, 'varargs must have one parameter in their list');
    AbstractSubroutineTypeWithSpecificParameters constructorSubroutineType = createConstructorType(scope, classType!, parameterTypes, isVarArgs);
    if (constructorSubroutineType != classType!.constructorSubroutine.staticType) {
      throw(concat('Constructor for class ', identifier, ' is defined as ', classType!.constructorSubroutine.staticType.name, ' but was forward declared as ', constructorSubroutineType.name, ' at ', sourceLocation));
    }
    ClassType supertype;
    if (superclassName != null) {
      supertype = superclassName!.lookup(scope.globalScope(), true) as ClassType;
    } else {
      supertype = scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName, sourceLocation);
    }
    if (classType!.supertype != supertype) {
      if (supertype == classType) {
        // we (the forward declaration) expected the supertype to be the same as our declared type, i.e., that this is Object#
        // but when it was actually defined, this did not turn out to be the case, so it must have had some other supertype declared
        throw(concat('Class ', classType!.name, ' has supertype (', classType!.supertype.name, ') but forward-declaration had no supertype at ', sourceLocation));
      } else if (classType!.supertype == classType) {
        // the actual defined type did not have an "extends" clause (implied or otherwise), i.e., it was Object#.
        // however, this forward declaration did have a declared supertype.
        throw(concat('Class ', classType!.name, ' has no supertype, but forward-declaration has a supertype (', supertype.name, ') at ', sourceLocation));
      } else {
        throw(concat('Class ', classType!.name, ' supertype (', classType!.supertype.name, ') does not match forward-declared supertype (', supertype.name, ') at ', sourceLocation));
      }
    }
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    classType!.constructorSubroutine.markConstructorAsDeclared();
  }

  Null constructor(String classNameArg, TypeIdentifierList constructorParameterTypesArg, Boolean isVarArgsArg, TypeIdentifierNullable superclassNameArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = classNameArg;
    superclassName = superclassNameArg;
    isIntrinsic = isIntrinsicArg;
    constructorParameterTypes = constructorParameterTypesArg;
    isVarArgs = isVarArgsArg;
  }
}

class ClassDeclaration extends AbstractClassDeclaration {
  String identifier;
  TypeIdentifierNullable superclassName;
  Boolean isIntrinsic;
  StatementList members;
 
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', identifier];
    if (superclassName != null) {
      append(buffer, ' extends');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    if (isIntrinsic) {
      append(buffer, ' intrinsic#');
    }
    append(buffer, ' {\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  ClassType classType;

  //#override
  Null declareTypes(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'invariant violation');
    TypeNullable candidate = scope.globalScope().lookupType(identifier, false);
    if ((candidate is ClassType) && (candidate as ClassType).isForwardDeclared) {
      classType = candidate as ClassType;
      classType.markAsNoLongerMerelyForwardDeclared();
    } else {
      classType = declareType(scope, identifier, superclassName, isIntrinsic);
    }
    classType.inheritMemberSignaturesFromSupertype();
    for (member in members) {
      if (member is FieldDeclarationStatement) {
        (member as FieldDeclarationStatement).registerMember(scope, classType);
      } else if (member is MethodDeclarationStatement) {
        (member as MethodDeclarationStatement).registerMember(scope, classType);
      } else {
        assert(false, concat('unexpected declaration statement (', member.className, ') in class at ', member.sourceLocation));
      }
    }

    MemberDescriptionNullable constructorMember = classType.getMember(kConstructor);
    TypeList constructorParameters;
    Boolean constructorIsVarArgs;
    if (constructorMember != null) {
      // we have an explicit constructor
      assert(constructorMember!.staticType.isSubtypeOf(createOrFindSubroutineTypeWithAnyArgs(scope.environment(), scope.environment().coreNullType)), 'invariant violation');
      if (constructorMember!.isField) {
        // constructor was probably declared as a property (grr!)
        assert(constructorMember!.staticType is SubroutineTypeWithAnyArguments, concat('unexpected subroutine type ', constructorMember!.staticType, ' for constructor ', constructorMember));
        constructorParameters = [scope.environment().coreAnythingType]:Type;
        constructorIsVarArgs = true;
      } else {
        // constructor was declared as a method
        if (constructorMember!.staticType is SubroutineTypeWithVarArgs) {
          constructorParameters = [(constructorMember!.staticType as SubroutineTypeWithVarArgs).parameterType]:Type;
          constructorIsVarArgs = true;
        } else {
          assert(constructorMember!.staticType is SubroutineTypeWithSpecificParameters, 'unexpected subroutine type');
          constructorParameters = (constructorMember!.staticType as SubroutineTypeWithSpecificParameters).parameterTypes;
          constructorIsVarArgs = false;
        }
      }
    } else {
      if (classType.supertype == classType) {
        // this must be the Object# definition
        throw(concat('Base class must have an explicit constructor but has none at ', sourceLocation));
      }
      throw(concat('Class attempts to extend a forward-declared (but not yet defined) class at ', sourceLocation));
    }
    AbstractSubroutineTypeWithSpecificParameters subroutineType = createConstructorType(scope, classType, constructorParameters, constructorIsVarArgs);
    subroutineType.markConstructed();
    CompiledGeneratedConstructorSubroutine generatedConstructor = CompiledGeneratedConstructorSubroutine(scope, identifier, classType);
    generatedConstructor.setType(subroutineType);
    classType.setConstructorSubroutine(scope.registerSubroutine(generatedConstructor, true));
  }

  CompiledSubroutineNullable initializer = null;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    scope.prepareIdentifier(identifier);
    for (member in members) {
      if (member is FieldDeclarationStatement) {
        if (initializer == null) {
          CompilationEnvironment environment = scope.environment();
          initializer = CompiledSubroutineWithSpecificParameters(
            scope,
            concat(classType.name, '.initializer#'),
            classType,
          );
          initializer!.setType(createOrFindSubroutineTypeWithSpecificParameters(environment, environment.coreNullType, []:Type));
          classType.setInitializerSubroutine(initializer!);
          scope.registerSubroutine(initializer!, false);
        }
        member.prepareIdentifiers(initializer!);
      } else {
        member.prepareIdentifiers(scope);
      }
    }
  }
  
  //#override
  Null generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();
    classType.inheritMemberImplementationsFromSupertype();
    classType.markDeclared();
    classType.markAsDefined();
    if (!classType.supertype.isDefined) {
      if (superclassName == null) {
        throw(concat('Class defined before Object# is defined at ', sourceLocation));
      }
      assert(superclassName != null, 'we were not defined');
      throw(concat('Cannot extend a class that has not yet been defined at ', superclassName!.sourceLocation));
    }
    // register members on the class type
    for (member in members) {
      if (member is FieldDeclarationStatement) {
        member.generateInstructions(initializer!);
      } else if (member is MethodDeclarationStatement) {
        member.generateInstructions(scope);
      } else {
        assert(false, concat('unexpected declaration statement (', member.className, ') in class at ', member.sourceLocation));
      }
    }
    SubroutinePointerBucket generatedConstructorBucket = classType.constructorSubroutine;
    if (!classType.constructorSubroutine.isDeclared()) {
      if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
        throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
      }
      generatedConstructorBucket.markConstructorAsDeclared();
    }
    CompiledGeneratedConstructorSubroutine generatedConstructorScope = generatedConstructorBucket.subroutine as CompiledGeneratedConstructorSubroutine;
    Bucket thisPointer = generatedConstructorScope.emitIntrinsicCall(environment.classAllocatorIntrinsicName, [ VmtPointerBucket(environment, classType) ]:Bucket).asType(classType);
    generatedConstructorScope.setThisPointer(thisPointer);
    // call initializers
    ClassType ancestorClassType = classType;
    ClassTypeList classHierarchy = [classType]:ClassType;
    while (ancestorClassType.supertype != ancestorClassType) {
      ancestorClassType = ancestorClassType.supertype;
      append(classHierarchy, ancestorClassType);
    }
    Integer index = len(classHierarchy) - 1;
    while (index >= 0) {
      CompiledSubroutineNullable initializer = classHierarchy[index].initializerSubroutine;
      if (initializer != null) {
        generatedConstructorScope.emitCodePointerCall(
          initializer!.type as AbstractSubroutineTypeWithSpecificParameters,
          initializer!.codePointer,
          null,
          thisPointer,
          []:Bucket,
          null, null, // source locations
        );
      }
      index -= 1;
    }
    // userConstructor should never be null, because the base class must have a constructor
    // TODO: handle the case of userConstructor being a field (see tests/class_constructors_4.syd)
    CompiledSubroutine userConstructor = classType.getMember(kConstructor)!.methodImplementation!;
    generatedConstructorScope.setActualConstructor(userConstructor);
    // Finally, we set the generated constructor's return type and value to the
    // newly allocated thisPointer. The CompiledGeneratedConstructorSubroutine logic
    // will invoke the actualConstructor (the user's "constructor" method) using a
    // "jmp" and will ensure that the return value is not overridden by the
    // actualConstructor; that constructor will do the final "ret".
    generatedConstructorScope.emitReturnFrom(generatedConstructorScope, thisPointer, false);
  }

  Null constructor(String classNameArg, TypeIdentifierNullable superclassNameArg, StatementList membersArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = classNameArg;
    superclassName = superclassNameArg;
    isIntrinsic = isIntrinsicArg;
    members = membersArg;
  }
}

class ForwardClassFieldDeclaration extends Statement {
  TypeIdentifier fieldType;
  TypeIdentifier hostClass;
  String identifier;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('fwdclassfield ', fieldType.toStringIndent(indent), ' ', hostClass.toStringIndent(indent), '.', identifier, ';\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Type candidateClassType = hostClass.lookup(scope.globalScope(), true);
    if (!(candidateClassType is ClassType)) {
      throw(concat('Type ', hostClass.name, ' is not a class at ', sourceLocation));
    }
    ClassType classType = candidateClassType as ClassType;
    if (classType.isDefined) {
      throw(concat('Type ', hostClass.name, ' is already defined and cannot have a forward-declared property at ', sourceLocation));
    }
    MemberDescriptionNullable member = classType.getMember(identifier);
    if (member == null) {
      throw(concat('Field ', hostClass.name, '.', identifier, ' never defined after being forward declared at ', sourceLocation));
    }
    if (!member!.isField) {
      throw(concat('Field ', hostClass.name, '.', identifier, ' not defined as a field after being forward declared at ', sourceLocation));
    }
    TypeNullable candidateFieldType = fieldType.lookup(scope.globalScope(), true);
    if (candidateFieldType == null) {
      throw(concat('Field ', hostClass.name, '.', identifier, ' forward declared with type ', fieldType.toStringIndent(0), ' which is not yet known at ', sourceLocation));
    }
    if (member!.staticType != candidateFieldType) {
      throw(concat('Field ', hostClass.name, '.', identifier, ' has type ', member!.staticType.name, ' which does not match the type used in the forward declaration at ', sourceLocation));
    }
    member!.markDeclared();
    if (member!.forwardDeclare()) {
      throw(concat('Field ', hostClass.name, '.', identifier, ' forward declared twice at ', sourceLocation));
    }
  }

  Null constructor(TypeIdentifier hostClassArg, TypeIdentifier fieldTypeArg, String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    hostClass = hostClassArg;
    fieldType = fieldTypeArg;
    identifier = identifierArg;
  }
}

class ForwardClassMethodDeclaration extends Statement {
  TypeIdentifier returnType;
  TypeIdentifier hostClass;
  String identifier;
  AnythingListList parameters; // list of one-element lists of TypeIdentifiers (example: [[String], [Integer]])
  Boolean isVarArgs;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
    }
    return concat('fwdclassmethod ', returnType.toStringIndent(indent), ' ', hostClass.toStringIndent(indent), '.', identifier, '(', joinList(parametersList), ');\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Type candidateClassType = hostClass.lookup(scope.globalScope(), true);
    if (!(candidateClassType is ClassType)) {
      throw(concat('Type ', hostClass.name, ' is not a class at ', sourceLocation));
    }
    ClassType classType = candidateClassType as ClassType;
    if (classType.isDefined) {
      throw(concat('Type ', hostClass.name, ' is already defined and cannot have a forward-declared property at ', sourceLocation));
    }
    MemberDescriptionNullable member = classType.getMember(identifier);
    if (member == null) {
      throw(concat('Method ', hostClass.name, '.', identifier, ' never defined after being forward declared at ', sourceLocation));
    }
    if (member!.isField) {
      throw(concat('Method ', hostClass.name, '.', identifier, ' not defined as a method after being forward declared at ', sourceLocation));
    }
    TypeNullable forwardDeclaredReturnType = returnType.lookup(scope.globalScope(), true);
    if (forwardDeclaredReturnType == null) {
      throw(concat('Method ', hostClass.name, '.', identifier, ' forward declared with return type ', returnType.toStringIndent(0), ' which is not yet known at ', sourceLocation));
    }
    assert(member!.staticType is AbstractSubroutineTypeWithSpecificParameters, 'invariant violation');
    if ((member!.staticType as AbstractSubroutineTypeWithSpecificParameters).returnType != forwardDeclaredReturnType) {
      throw(concat('Method ', hostClass.name, '.', identifier, ' has return type ', (member!.staticType as AbstractSubroutineTypeWithSpecificParameters).returnType.name, ' which does not match the return type used in the forward declaration at ', sourceLocation));
    }
    TypeList forwardDeclaredParameters = []:Type;
    for (parameter in parameters) {
      append(forwardDeclaredParameters, (parameter[0] as TypeIdentifier).lookup(scope.globalScope(), true));
    }
    Type forwardDeclaredType;
    if (isVarArgs) {
      assert(len(forwardDeclaredParameters) == 1, 'unexpected number of parameters to varargs function');
      forwardDeclaredType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        forwardDeclaredReturnType!,
        forwardDeclaredParameters,
      );
    } else {
      forwardDeclaredType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        forwardDeclaredReturnType!,
        forwardDeclaredParameters,
      );
    }
    if (forwardDeclaredType != member!.staticType) {
      throw(concat('Method ', hostClass.name, '.', identifier, ' defined with signature ', member!.staticType.name, ' but forward declared with signature ', forwardDeclaredType.name, ' at ', sourceLocation));
    }
    member!.markDeclared();
  }

  Null constructor(TypeIdentifier hostClassArg, TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarargsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    hostClass = hostClassArg;
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    isVarArgs = isVarargsArg;
  }
}

class TypeIntrinsicDeclaration extends Statement {
  String identifier;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('typedef# ', identifier, ' is GarbageCollectable;\n');
  }

  IntrinsicType staticType;

  //#override
  Null declareTypes(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found typedef# in non-global scope');
    if (scope.globalScope().isTypeDeclaredInGlobalScope(identifier)) {
      throw(concat('"', identifier, '" redeclared at ', sourceLocation));
    }
    staticType = IntrinsicType(scope.environment(), identifier);
    (scope as CompiledLibrary).registerType(staticType);
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    staticType.markDeclared();
  }

  Null constructor(String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  //#override
  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    if (expression != null) {
      expression!.prepareIdentifiers(scope);
    }
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (!(scope.stackFrame() is CompiledSubroutine)) {
      throw(concat('Invalid return; not in a function at ', sourceLocation));
    }
    CompiledSubroutine subroutine = scope.stackFrame() as CompiledSubroutine;
    if (expression != null) {
      Bucket returnValue = expression!.generateInstructions(scope);
      if (!returnValue.staticType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Type of return statement (', returnValue.staticType.name, ') does not match expected return type (', subroutine.type.returnType.name, ') at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, returnValue, false);
    } else {
      if (!scope.environment().coreNullType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Tried to return null from a function whose expected return type is ', subroutine.type.returnType.name, ' at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, scope.environment().coreNull, false);
    }
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class BreakStatement extends Statement {
  //#override
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'break;\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid break; not in a loop at ', this));
    }
    scope.emit(BreakInstruction());
  }
}

class ContinueStatement extends Statement {
  //#override
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'continue;\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid continue; not in a loop at ', this));
    }
    scope.emit(ContinueInstruction());
  }
}

class ImportStatement extends Statement {
  String path;

  String resolvedPath;
  Library resolvedLibrary;

  Null setResolvedPath(String resolvedPathArg) {
    resolvedPath = resolvedPathArg;
  }

  Null setResolvedLibrary(Library library) {
    resolvedLibrary = library;
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    // no identifiers to prepare
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found import outside global scope');
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class StraightAssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' = ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    lValue.prepareIdentifiers(scope);
    rValue.prepareIdentifiers(scope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket rBucket = rValue.generateInstructions(scope);
    lValue.generateLValue(scope).assign(scope, rBucket, sourceLocation);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class AssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  String describeOperator() { abstract(); }
  Bucket computeResult(CompiledScope scope, Bucket lBucket, Bucket rBucket) { abstract(); }

  LazyComment comment() {
    return LazyComment('result of ', describeOperator(), ' operator');
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    lValue.prepareIdentifiers(scope);
    rValue.prepareIdentifiers(scope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket lBucket = lValue.generateInstructions(scope);
    // TODO: verify that lBucket is assignable
    // In particular, parameters (including dereferenced varargs) and constants are not assignable.
    Bucket rBucket = rValue.generateInstructions(scope);
    Bucket result = computeResult(scope, lBucket, rBucket);
    lValue.generateLValue(scope).assign(scope, result, sourceLocation);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class OperatorAssignmentStatement extends AssignmentStatement {
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
  }

  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }

  //#override
  Bucket computeResult(CompiledScope scope, Bucket lBucket, Bucket rBucket) {
    Bucket lhsValue = lBucket;
    Bucket rhsValue = rBucket;
    generateTypeCheckInstructions(lhsValue, rhsValue, scope);
    return generateExpressionInstructions(lhsValue, rhsValue, scope);
  }
}

class NumericOperatorAssignmentStatement extends OperatorAssignmentStatement {
  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreIntegerType, 
      'type error', 
      true, 
      LazyComment('verify type of left hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreIntegerType, 
      'type error', 
      true, 
      LazyComment('verify type of right hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
  }
}

class PlusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '+=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedAddInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class MinusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '-=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedSubtractInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class AsteriskAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '*=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedMultiplyInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class AsteriskAsteriskAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '**=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedExponentiationInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class SlashAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '/=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedDivideInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class ModulusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '%=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedModulusInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseAndAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '&=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseXorAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '^=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(XOrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseOrAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '|=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BooleanOperatorAssignmentStatement extends OperatorAssignmentStatement {
  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'type error', 
      true, 
      LazyComment('verify type of left hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'type error', 
      true, 
      LazyComment('verify type of right hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
  }
}

class LogicalAndAssignmentStatement extends BooleanOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '&&=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, comment()));
  }
}

class LogicalOrAssignmentStatement extends BooleanOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '||=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, comment()));
  }
}

class ElseClause extends AstNode {
  Null prepareIdentifiers(CompiledScope scope) {
    abstract();
  }

  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  //#override
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  CompiledScope blockScope;
  CompiledScopeNullable elseBlockScope;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    expression.prepareIdentifiers(scope);
    blockScope = CompiledScope(scope, 'if');
    block.prepareIdentifiers(blockScope);
    if (elseClause != null) {
      elseBlockScope = CompiledScope(scope, 'else');
      elseClause!.prepareIdentifiers(elseBlockScope!);
    } else {
      elseBlockScope = null;
    }
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket expressionHandle = expression.generateInstructions(scope);
    if (!expressionHandle.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('If expression must be a boolean, not a ', expressionHandle.staticType.name, ', at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      expressionHandle, 
      scope.environment().coreBooleanType, 
      'if expression must be boolean', 
      true, 
      LazyComment('verify type of if condition'), // TODO: better error messages
    ));
    block.generateInstructions(blockScope);
    if (elseClause != null) {
      elseClause!.generateInstructions(elseBlockScope!);
    }
    scope.emit(IfScopeInstruction(expressionHandle, blockScope, elseBlockScope));
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    block.prepareIdentifiers(scope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    block.generateInstructions(scope);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    ifClause.prepareIdentifiers(scope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    ifClause.generateInstructions(scope);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  CompiledLoopScope loopScope;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    loopScope = CompiledLoopScope(scope, 'while');
    expression.prepareIdentifiers(loopScope);
    block.prepareIdentifiers(loopScope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledScope emptyScope = CompiledScope(loopScope, 'while condition is true');
    CompiledScope breakScope = CompiledScope(loopScope, 'while condition is false');
    breakScope.emit(BreakInstruction());
    Bucket expressionHandle = expression.generateInstructions(loopScope);
    if (!expressionHandle.staticType.isSubtypeOf(loopScope.environment().coreBooleanType)) {
      throw(concat('While expression must be a boolean, not a ', expressionHandle.staticType.name, ', at ', sourceLocation));
    }
    loopScope.emit(TypeCheckInstruction(
      expressionHandle, 
      loopScope.environment().coreBooleanType, 
      'while expression must be boolean', 
      true, 
      LazyComment('verify type of while condition'), // TODO: better error messages
    ));
    loopScope.emit(IfScopeInstruction(expressionHandle, emptyScope, breakScope));
    block.generateInstructions(loopScope);
    scope.emit(LoopScopeInstruction(loopScope));
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variableName;
  Expression iterable;
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variableName,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  CompiledLoopScope loopScope;

  //#override
  Null prepareIdentifiers(CompiledScope scope) {
    iterable.prepareIdentifiers(scope);
    loopScope = CompiledLoopScope(scope, 'for loop');
    loopScope.prepareIdentifier(variableName);
    block.prepareIdentifiers(loopScope);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();
    Bucket iterableBucket = iterable.generateInstructions(scope);
    if (!iterableBucket.staticType.isSubtypeOf(environment.coreIterableType)) {
      throw(concat('Expected an iterable type in "for" statement, but ', iterable.toStringIndent(0), ' is of type ', iterableBucket.staticType.name, ' at ', iterable.sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      iterableBucket, 
      environment.coreIterableType, 
      'non-iterable in for', 
      true, 
      LazyComment('verify type of for loop iterable'), // TODO: better error messages
    ));
    assert(!(iterableBucket is VarArgsParameterBucket), 'iteration on varargs list not yet supported');
    // TODO: for varargs, instead of calling iteratorIntrinsicName, we call varargsIteratorIntrinsicName
    // and pass it the number of arguments and a pointer to the first entry on the stack
    Bucket iteratorBucket = scope.emitIntrinsicCall(
      environment.iteratorIntrinsicName,
      [ iterableBucket ]:Bucket,
    );
    CompiledScope emptyScope = CompiledScope(loopScope, 'iterator continues');
    CompiledScope breakScope = CompiledScope(loopScope, 'iterator finished');
    breakScope.emit(BreakInstruction());
    loopScope.emit(
      IfScopeInstruction(
        loopScope.emitIntrinsicCall(
          environment.nextIntrinsicName,
          [ iteratorBucket ]:Bucket,
        ),
        emptyScope,
        breakScope,
      ),
    );
    Type variableType;
    if (iterableBucket.staticType is IterableType) {
      variableType = (iterableBucket.staticType as IterableType).elementType;
    } else if (iterableBucket.staticType is AbstractListType) {
      variableType = (iterableBucket.staticType as AbstractListType).elementType;
    } else {
      variableType = environment.coreWhateverType;
    }
    assert(loopScope.identifiers.length == 0, 'newly created scope has identifiers in scope');
    Bucket currentValue = loopScope.emitIntrinsicCall(
      environment.currentIntrinsicName,
      [ iteratorBucket ]:Bucket,
    ).asType(variableType);
    loopScope.registerImmutableValue(variableName, currentValue);
    block.generateInstructions(loopScope);
    scope.emit(LoopScopeInstruction(loopScope));
  }

  Null constructor(String variableNameArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variableName = variableNameArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  CompiledLibraryNullable library = null;

  LibraryList generateLibraryScope(CompilationEnvironment environment) { 
    LibraryList result = []:Library;
    if (library != null) {
      // we already generated our library scope
      return result; // (return empty list)
    }
    library = CompiledLibrary(environment, name);
    for (child in children) {
      if (child is ImportStatement) {
        appendAll(result, (child as ImportStatement).resolvedLibrary.generateLibraryScope(environment));
        library!.importLibrary((child as ImportStatement).resolvedLibrary.library!);
      }
    }
    environment.registerLibrary(library!);
    append(result, this);
    return result;
  }

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }
}

class Program extends Library {
  //#override
  Null generateInstructions(CompiledScope scope) {
    (scope as CompiledLibrary).setAsProgram();
    super.generateInstructions(scope);
    scope.emit(CommentInstruction(LazyComment('Terminate application - call exit(0)')));
    Bucket exitCode = scope.environment().integer(0);
    scope.emitIntrinsicCall(scope.environment().exitIntrinsicName, [exitCode]:Bucket);
  }
}