import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';
import 'syd-loop-scopes.syd';

class AstNode extends SourceCode {
  String toStringIndent(Integer indent) {
    abstract();
  }

  String toString() {
    return toStringIndent(0);
  }

  Null walk(NullFunction callback, Anything context) {
    // no children
  }
}

class TypeIdentifier extends AstNode {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Type generateInstructions(CompiledScope scope) {
    TypeNullable result = (scope.globalScope() as CompiledLibrary).lookupType(name);
    if (result == null) {
      throw(concat('Type "', name, '" not known at ', sourceLocation));
    }
    return result;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in children) {
      callback(child, context);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    Null compileChild(Statement child, CompiledScope scope) {
      scope.emitInstruction(SourceLocationInstruction(scope, child)); // TODO: only emit this for lines that actually generate assembler...
      child.generateInstructions(scope); // workaround because self-reference doesn't work in closures
    }
    walk(compileChild, scope);
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class Expression extends AstNode {
  Boolean isLValue() {
    return false;
  }

  // Expressions are expected to declare (or identify) a Slot, and return it.
  // For lvalues, this Slot might be written to.
  Slot generateInstructions(CompiledScope scope) {
    abstract();
  }
}

Map stringAtomTable = Map(); // value -> label

class StringLiteralExpression extends Expression {
  String value;
  String label;

  Slot generateInstructions(CompiledScope scope) {
    StringNullable maybeLabel = stringAtomTable.get(value) as StringNullable;
    if (maybeLabel == null) {
      label = scope.environment().generateLabel('string');
      scope.emitInstruction(StringConstantInstruction(
        scope,
        label,
        value,
        sourceLocation,
      ));
      stringAtomTable.set(value, label);
    } else {
      label = maybeLabel!;
    }
    Type type = (scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreStringType;
    type.markConstructed();
    return scope.registerStaticValue(ImmediateAddressVot(type, label), concat(this));
  }

  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  Slot generateInstructions(CompiledScope scope) {
    return scope.registerStaticValue(LiteralIntegerVot((scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreIntegerType, value), concat(this));
  }
  
  String toStringIndent(Integer indent) {
    if (value > -10 && value < 10) {
      return intToStr(value);
    }
    if (value < 0) {
      return concat(intToStr(value), ' /* -0x', hex(-value), ' *\/');
    }
    return concat(intToStr(value), ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;

  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent);
    }
    return concat('[', join(map(values, indenter) as StringList, ','), ']');
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in values) {
      callback(child, context);
    }
  }

  Null constructor(ExpressionList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
  }
}

class VariableExpression extends Expression {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Boolean isLValue() {
    return true;
  }

  Slot generateInstructions(CompiledScope scope) {
    SlotNullable slot = scope.lookupIdentifier(name);
    if (slot == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    return slot;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(subroutineReference, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    ValueHandle subroutine = subroutineReference.generateInstructions(scope).read(scope);
    ValueHandleList argumentValues = []:ValueHandle;
    if (subroutine.source.staticType is AbstractSubroutineType) {
      for (argument in arguments) {
        append(argumentValues, argument.generateInstructions(scope).read(scope));
      }
    } else {
      throw(concat('"', subroutineReference, '" is not a subroutine at ', sourceLocation));
    }
    return scope.emitSubroutineCall(subroutine, argumentValues);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class SubscriptExpression extends Expression {
  Expression list;
  Expression argument;
  
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type checks
    ValueHandle evaluatedList = list.generateInstructions(scope).read(scope);
    // TODO: static type check for evaluatedList to check it's a List or ReadOnlyList
    // TODO: dynamic type check to verify that evaluatedList is a List or ReadOnlyList at runtime
    ValueHandle evaluatedArgument = argument.generateInstructions(scope).read(scope);
    // TODO: static type check for evaluatedList to check it's a list
    // TODO: dynamic type check to verify that evaluatedList is a list at runtime
    Type elementType = (evaluatedList.source.staticType as AbstractListType).elementType;
    Slot result = scope.registerDynamicValue(elementType, concat('element ', argument, ' of ', list));
    CompiledScope boundsErrorBlock = scope.createErrorHandlerBlock(scope.environment().intrinsicsLibrary!.boundsFailureMessage, 'subscript bounds error');
    scope.emitInstruction(SubscriptInstruction(scope, evaluatedList, evaluatedArgument, result.prepareWrite(scope), boundsErrorBlock, concat(scope.labelPrefix(), '$subscript')));
    return result;
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(list, context);
    callback(argument, context);
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends Expression {
  Expression object;
  String member;
  
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    TypeHandle lhs = expression.generateInstructions(scope).read(scope).type;
    Type rhs = type.generateInstructions(scope);
    Slot slot = scope.registerDynamicValue((scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreBooleanType, 'is expression result');
    scope.emitInstruction(StoreTypeCheckInstruction(scope, rhs, lhs, slot.prepareWrite(scope), concat(expression)));
    return slot;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class AsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' as ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type check
    Slot exprSlot = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    scope.emitTypeCheck(exprSlot.read(scope), rhs, (scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).asOperatorFailureMessage, concat(this));
    return exprSlot;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  String describeOperator() {
    return '-';
  }
}

class PlusExpression extends UnaryExpression {
  String describeOperator() {
    return '+';
  }
}

class BooleanNotExpression extends UnaryExpression {
  String describeOperator() {
    return '!';
  }
}

class BitwiseNotExpression extends UnaryExpression {
  String describeOperator() {
    return '~';
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    abstract();
    // e.g.:
    // return '+';
  }

  Null generateTypeCheckInstructions(ValueHandle lhsValue, ValueHandle rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs));
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs));
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
    callback(rhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type checks
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary;
    ValueHandle lhsValue = lhs.generateInstructions(scope).read(scope);
    ValueHandle rhsValue = rhs.generateInstructions(scope).read(scope);
    generateTypeCheckInstructions(lhsValue, rhsValue, scope, intrinsics);
    Slot result = scope.registerDynamicValue(returnType(intrinsics), concat(describeOperator(), ' operator result'));
    generateExpressionInstructions(lhsValue, rhsValue, result.prepareWrite(scope), scope, intrinsics);
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class NumericOperatorExpression extends OperatorExpression {
  Null generateTypeCheckInstructions(ValueHandle lhsValue, ValueHandle rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs));
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs));
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }
}

class OperatorAdditionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '+';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'add', lhsValue, rhsValue, result, intrinsics.coreIntegerType, concat(describeOperator(), ' operator')));
  }
}

class OperatorSubtractionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '-';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'sub', lhsValue, rhsValue, result, intrinsics.coreIntegerType,  concat(describeOperator(), ' operator')));
  }
}

class OperatorMultiplicationExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '*';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'imul', lhsValue, rhsValue, result, intrinsics.coreIntegerType,  concat(describeOperator(), ' operator')));
  }
}

class OperatorDivisionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '/';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(DivisonInstruction(scope, lhsValue, rhsValue, result, rax, intrinsics.coreIntegerType, len((scope.stackFrame() as CompiledStackFrameScope).nonvolatileRegistersUsed()), concat(describeOperator(), ' operator')));
  }
}

class OperatorModulusExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '%';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(DivisonInstruction(scope, lhsValue, rhsValue, result, rdx, intrinsics.coreIntegerType, len((scope.stackFrame() as CompiledStackFrameScope).nonvolatileRegistersUsed()), concat(describeOperator(), ' operator')));
  }
}

class OperatorBitwiseAndExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '&';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'and', lhsValue, rhsValue, result, intrinsics.coreIntegerType,  concat(describeOperator(), ' operator')));
  }
}

class OperatorBitwiseOrExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '|';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'or', lhsValue, rhsValue, result, intrinsics.coreIntegerType,  concat(describeOperator(), ' operator')));
  }
}

class OperatorBitwiseXorExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '^';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'xor', lhsValue, rhsValue, result, intrinsics.coreIntegerType, concat(describeOperator(), ' operator')));
  }
}

class OperatorLeftShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '<<';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'shl', lhsValue, rhsValue, result, intrinsics.coreIntegerType, concat(describeOperator(), ' operator')));
  }
}

class OperatorRightShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '>>';
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction(scope, 'shr', lhsValue, rhsValue, result, intrinsics.coreIntegerType, concat(describeOperator(), ' operator')));
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '==';
  }

  Null generateTypeCheckInstructions(ValueHandle lhsValue, ValueHandle rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type
    // xxxx statically check the types are compatible
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: StoreEqualityInstruction needs to implement string comparisons
    scope.emitInstruction(StoreEqualityInstruction(scope, lhsValue, rhsValue, result, false));
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '!=';
  }

  Null generateTypeCheckInstructions(ValueHandle lhsValue, ValueHandle rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type
    // xxxx statically check the types are compatible
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: StoreEqualityInstruction needs to implement string comparisons
    scope.emitInstruction(StoreEqualityInstruction(scope, lhsValue, rhsValue, result, true));
  }
}

class OperatorNumericCmpExpression extends OperatorExpression {
  cc flag() {
    abstract();
  }

  Null generateTypeCheckInstructions(ValueHandle lhsValue, ValueHandle rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs));
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs));
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(ValueHandle lhsValue, ValueHandle rhsValue, ValueHandle result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(StoreCmpInstruction(scope, lhsValue, rhsValue, result, flag()));
  }
}

class OperatorLessThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<';
  }

  cc flag() {
    return ccLessThan;
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<=';
  }

  cc flag() {
    return ccLessThanOrEqual;
  }
}

class OperatorGreaterThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>';
  }

  cc flag() {
    return ccGreaterThan;
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>=';
  }

  cc flag() {
    return ccGreaterThanOrEqual;
  }
}

class OperatorLogicalAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&&';
  }
}

class OperatorLogicalOrExpression extends OperatorExpression {
  String describeOperator() {
    return '||';
  }
}


class DeclarationStatement extends Statement {
  String identifier;
  ExpressionNullable rValue;
  
  Null walk(NullFunction callback, Anything context) {
    if (rValue != null) {
      callback(rValue, context);
    }
  }

  Null constructor(String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }
  
  Null generateInstructions(CompiledScope scope) {
    ValueHandle rValueHandle;
    if (rValue == null) {
      rValueHandle = ValueHandle(
        scope.environment().intrinsicsLibrary!.integers, // TODO: dubious source (maybe rename it?)
        (scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreSentinel,
      );
    } else {
      rValueHandle = rValue!.generateInstructions(scope).read(scope);
    }
    scope.registerVariable(identifier, type.generateInstructions(scope), rValueHandle);
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, rValueArg, sourceLocationArg);
    type = typeArg;
  }
}

class SubroutineDeclarationStatement extends Statement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  Boolean isVarArgs;
  StatementBlock body;

  Null walk(NullFunction callback, Anything context) {
    callback(body, context);
  }

  Null generateInstructions(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
    }
    AbstractSubroutineType subroutineType = createOrFindSubroutineType(
      scope.environment(),
      compiledReturnType,
      compiledParameterTypes,
      isVarArgs,
    );
    CompiledSubroutine subroutine;
    if (isVarArgs) {
      subroutine = CompiledVarArgsSubroutine(scope, subroutineType, identifier);
      assert(len(compiledParameterTypes) == 1, 'unexpected number of parameters to varargs function');
      String name = parameters[0][1] as String;
      Type type = compiledParameterTypes[0];
      (subroutine as CompiledVarArgsSubroutine).registerVarArgsParameter(name, type);
      (subroutine as CompiledVarArgsSubroutine).emitVarArgsParameterChecks(type);
    } else {
      subroutine = CompiledSubroutine(scope, subroutineType, identifier);
      SlotList parameterSlots = []:Slot;
      Integer index = 0;
      for (parameter in parameters) {
        String name = parameter[1] as String;
        Type type = compiledParameterTypes[index];
        append(parameterSlots, (subroutine as CompiledSubroutineWithSpecificParameters).registerParameter(name, type, index));
        index += 1;
      }
      (subroutine as CompiledSubroutineWithSpecificParameters).emitParameterChecks(parameterSlots);
    }
    scope.registerSubroutine(subroutine);
    // TODO: declare slot for "this" and "closure"
    body.generateInstructions(subroutine);
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg) {
    assert(!isVarArgsArg || (len(parametersArg) == 1), 'varargs is only valid with a single parameter');
    super.constructor(sourceLocationArg);
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    isVarArgs = isVarArgsArg;
    body = bodyArg;
  }
}  

class EnumDeclaration extends Statement {
  String name;
  StringList values;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', name, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    globalScope.declareType(EnumType(scope.environment(), name, values));
  }

  Null constructor(String nameArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
    values = valuesArg;
  }
}

class ClassDeclaration extends Statement {
  String className;
  StringNullable superclassName;
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', className, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName);
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  Null constructor(String classNameArg, StringNullable superclassNameArg, DeclarationStatementList membersArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    className = classNameArg;
    superclassName = superclassNameArg;
    members = membersArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    if (!(scope.stackFrame() is CompiledSubroutine)) {
      throw(concat('Invalid return; not in a function at ', sourceLocation));
    }
    CompiledSubroutine subroutine = scope.stackFrame() as CompiledSubroutine;
    if (expression != null) {
      subroutine.emitReturnFrom(scope, expression!.generateInstructions(scope).read(scope));
    } else {
      subroutine.emitReturnFrom(scope, (scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreNull.read(scope));
    }
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class BreakStatement extends Statement {
  String toStringIndent(Integer indent) {
    return 'break;\n';
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (scope == null) {
      throw(concat('Invalid break; not in a loop at ', this));
    }
    (scope as CompiledLoopScope).emitBreakInstructionFrom(scope);
  }
}

class ImportStatement extends Statement {
  String path;
  
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope.environment().getLibraryState(path) == lsDefined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(path) as CompiledLibrary);
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class AssignmentStatement extends Statement {
  Expression lValue; // with isLValue true
  Expression rValue;

  String describeOperator() { abstract(); }
  ValueHandle computeResult(CompiledScope scope) { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null generateInstructions(CompiledScope scope) {
    // xxxx static type check
    Slot slot = lValue.generateInstructions(scope);
    slot.write(scope, computeResult(scope));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(Expression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    assert(lValueArg.isLValue(), 'lvalue is not assignable');
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class StraightAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '=';
  }

  ValueHandle computeResult(CompiledScope scope) {
    return rValue.generateInstructions(scope).read(scope);
  }
}

class PlusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '+=';
  }
}

class MinusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '-=';
  }
}

class AsteriskAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '*=';
  }
}

class SlashAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '/=';
  }
}

class ModulusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '%=';
  }
}

class BitwiseAndAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '&=';
  }
}

class BitwiseXorAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '^=';
  }
}

class BitwiseOrAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '|=';
  }
}

class ElseClause extends AstNode { }

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  Null generateInstructions(CompiledScope scope) {
    ValueHandle expressionHandle = expression.generateInstructions(scope).read(scope);
    CompiledNestedScope blockScope = CompiledNestedScope(scope, scope.environment().generateLabel(concat(camelCase(scope.name), '$if$block')));
    block.generateInstructions(blockScope);
    assert(elseClause == null, 'TODO: else clauses');
    scope.emitConditionalBlock(blockScope, expressionHandle, (scope.environment().intrinsicsLibrary!.coreFalse as Slot).read(scope), 'if', concat(expression));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
    if (elseClause != null) {
      callback(elseClause, context);
    }
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(block, context);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(ifClause, context);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'while');
    ValueHandle expressionHandle = expression.generateInstructions(loopScope).read(loopScope);
    loopScope.emitConditionalJump(loopScope.loopBottomLabel, expressionHandle, (scope.environment().intrinsicsLibrary!.coreFalse as Slot).read(scope), 'while condition');
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variable;
  Expression iterable;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variable,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(iterable, context);
    callback(block, context);
  }

/*
  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'for');
    ValueHandle expressionHandle = expression.generateInstructions(loopScope).read(loopScope);
    // verify that expressionHandle is an *Iterable
    // if it is statically a *ReadOnlyList
    
    loopScope.emitConditionalJump(loopScope.loopBottomLabel, expressionHandle, (scope.environment().intrinsicsLibrary!.coreFalse as Slot).read(scope), 'while condition');
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }
*/

  Null constructor(String variableArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variable = variableArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }

  CompiledLibrary generateScopes(CompilationEnvironment compilationEnvironmentArg) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    generateInstructions(result);
    return result;
  }
}

class Program extends Library {
  Null generateInstructions(CompiledScope scope) {
    super.generateInstructions(scope);
    scope.emitInstruction(CommentInstruction(scope, 'Terminate application - call exit(0)'));
    ValueHandle exitCode = scope.environment().integer(0);
    ValueHandle exit = (scope.environment().intrinsicsLibrary! as CompiledIntrinsicsLibrary).coreExit.read(scope);
    scope.emitSubroutineCall(exit, [exitCode]);
  }
}