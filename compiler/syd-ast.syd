import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';
import 'syd-loop-scopes.syd';

class AstNode extends SourceCode {
  String toStringIndent(Integer indent) {
    abstract();
  }

  String toString() {
    return toStringIndent(0);
  }

  Null walk(NullFunction callback, Anything context) {
    // no children
  }
}

class TypeIdentifier extends AstNode {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Type generateInstructions(CompiledScope scope) {
    TypeNullable result = scope.environment().parseType(name, scope.globalScope().lookupType);
    if (result == null) {
      throw(concat('Type "', name, '" not known at ', sourceLocation));
    }
    return result;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in children) {
      callback(child, context);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    Null compileChild(Statement child, CompiledScope scope) {
      scope.markSourceLocation(child);
      child.generateInstructions(scope);
    }
    walk(compileChild, scope);
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class Expression extends AstNode {
  Boolean isLValue() {
    return false;
  }

  // Expressions are expected to declare (or identify) a Slot, and return it.
  // For lvalues, this Slot might be written to.
  Slot generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StringLiteralExpression extends Expression {
  String value;
  String label;

  Slot generateInstructions(CompiledScope scope) {
    return scope.environment().registerStringConstant('string', value, sourceLocation.lineNo, sourceLocation.colNo, sourceLocation.filename);
  }

  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  Slot generateInstructions(CompiledScope scope) {
    return ImmediateIntegerSlot(scope.environment().intrinsicsLibrary.coreIntegerType, value, concat(this));
  }
  
  String toStringIndent(Integer indent) {
    if (value > -10 && value < 10) {
      return intToStr(value);
    }
    if (value < 0) {
      return concat(intToStr(value), ' /* -0x', hex(-value), ' *\/');
    }
    return concat(intToStr(value), ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;
  TypeIdentifierNullable elementType;

  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent + 2);
    }
    String elementTypeString = '';
    if (elementType != null) {
      elementTypeString = concat(':', elementType!.toStringIndent(indent));
    }
    return concat('[', join(map(values, indenter) as StringList, ','), ']', elementTypeString);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in values) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    // TODO: implement list literals
    throw('list literals not implemented');
  }

  Null constructor(ExpressionList valuesArg, TypeIdentifierNullable elementTypeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
    elementType = elementTypeArg;
  }
}

class VariableExpression extends Expression {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Boolean isLValue() {
    return true;
  }

  Slot generateInstructions(CompiledScope scope) {
    SlotNullable slot = scope.lookupIdentifier(name);
    if (slot == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    return slot;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(subroutineReference, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot subroutine = subroutineReference.generateInstructions(scope);
    SlotList argumentValues = []:Slot;
    if (subroutine.staticType.isSubtypeOf(scope.environment().subroutineType)) {
      for (argument in arguments) {
        append(argumentValues, argument.generateInstructions(scope));
      }
    } else {
      throw(concat('"', subroutineReference, '" is not a subroutine at ', sourceLocation, ' (is ', subroutine.staticType, ')'));
    }
    // TODO: emit dynamic type check for subroutine (skip if we can guarantee it's a non-sentinel subroutine)
    return scope.emitSubroutineCall(subroutine, argumentValues);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class SubscriptExpression extends Expression {
  Expression list;
  Expression argument;
  
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot evaluatedList = list.generateInstructions(scope);
    Type elementType;
    Boolean trustStaticType;
    if (evaluatedList.staticType is AbstractListType) {
      elementType = (evaluatedList.staticType as AbstractListType).elementType;
    } else if (evaluatedList.staticType.isSubtypeOf(scope.environment().subscriptableType)) {
      elementType = scope.environment().intrinsicsLibrary.coreAnythingType;
    } else {
      throw(concat('"', list, '", a ', evaluatedList.staticType.name, ', is not a list (and therefore cannot be subscripted) at ', sourceLocation));
    }
    scope.emitTypeCheck(evaluatedList, scope.environment().subscriptableType, scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage, concat(list), true);
    Slot evaluatedArgument = argument.generateInstructions(scope);
    // TODO: static type check for evaluatedArgument to check it's an integer
    // TODO: dynamic type check to verify that evaluatedArgument is an integer at runtime
    Slot result = scope.registerDynamicValue(elementType, concat(list, '[', argument, ']'));
    scope.emitSubscriptEvaluation(evaluatedList, evaluatedArgument, result);
    return result;
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(list, context);
    callback(argument, context);
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends Expression {
  Expression object;
  String member;
  
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // TODO: implement member access
    throw('member access not implemented');
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

class UnwrapExpression extends Expression {
  Expression lhs;
  
  String toStringIndent(Integer indent) {
    return concat(lhs.toStringIndent(indent), '!');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // TODO: implement unwrap
    throw('unwrap not implemented');
  }

  Null constructor(Expression lhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot lhs = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    Slot slot = scope.registerDynamicValue(scope.environment().intrinsicsLibrary.coreBooleanType, 'is expression result');
    scope.emitStoreTypeCheck(rhs, lhs, slot, concat(expression));
    return slot;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class AsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' as ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type check
    Slot exprSlot = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    scope.emitTypeCheck(exprSlot, rhs, scope.environment().intrinsicsLibrary.asOperatorFailureMessage, concat(this), true);
    return exprSlot;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretAsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __as__ ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot exprSlot = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    Slot result = scope.registerDynamicValue(rhs, concat('force cast of ', exprSlot.debugName, ' to ', rhs.name));
    scope.emitInstruction(MoveInstruction(result, exprSlot, result.debugName));
    scope.emitInstruction(SetTypeInstruction(result, rhs));
    return result;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(rhsValue, result, concat(describeOperator(), ' operator')));
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type checks
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(rhsValue, scope, intrinsics);
    Slot result = scope.registerDynamicValue(returnType(intrinsics), concat(describeOperator(), ' unary operator result'));
    generateExpressionInstructions(rhsValue, result, scope, intrinsics);
    scope.emitInstruction(SetTypeInstruction(result, returnType(intrinsics)));
    return result;
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  String describeOperator() {
    return '-';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(MonoOperandInstruction('neg', rhsValue, result, concat(describeOperator(), ' unary operator')));
  }
}

class PlusExpression extends UnaryExpression {
  String describeOperator() {
    return '+';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: hmm
    abstract();
  }
}

class BooleanNotExpression extends UnaryExpression {
  String describeOperator() {
    return '!';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SetSlotIfEqualInstruction(rhsValue, scope.environment().integer(0), result, intrinsics.coreBooleanType, concat(describeOperator(), ' unary operator')));
  }
}

class BitwiseNotExpression extends UnaryExpression {
  String describeOperator() {
    return '~';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(MonoOperandInstruction('not', rhsValue, result, concat(describeOperator(), ' unary operator')));
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    abstract();
    // e.g.:
    // return '+';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
    callback(rhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // xxxx static type checks
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot lhsValue = lhs.generateInstructions(scope);
    Slot rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(lhsValue, rhsValue, scope, intrinsics);
    Slot result = scope.registerDynamicValue(returnType(intrinsics), concat(describeOperator(), ' operator result'));
    generateExpressionInstructions(lhsValue, rhsValue, result, scope, intrinsics);
    scope.emitInstruction(SetTypeInstruction(result, returnType(intrinsics)));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class NumericOperatorExpression extends OperatorExpression {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }
}

class OperatorAdditionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '+';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(AddInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorSubtractionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '-';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SubInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorMultiplicationExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '*';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SignedMultiplyInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorDivisionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '/';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(IntegerDivisionInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorModulusExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '%';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(IntegerRemainderInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseAndExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '&';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('and', lhsValue, rhsValue, result,   concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseOrExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '|';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('or', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseXorExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '^';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('xor', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorLeftShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '<<';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: this needs to check if the count operand is more than 6 bits
    scope.emitInstruction(ShiftInstruction('shl', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorRightShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '>>';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: this needs to check if the count operand is more than 6 bits
    scope.emitInstruction(ShiftInstruction('shr', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '==';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type
    // xxxx statically check the types are compatible
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: StoreEqualityInstruction needs to implement string comparisons
    scope.storeEquality(lhsValue, rhsValue, result, false);
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '!=';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type
    // xxxx statically check the types are compatible
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: StoreEqualityInstruction needs to implement string comparisons
    scope.storeEquality(lhsValue, rhsValue, result, true);
  }
}

class OperatorNumericCmpExpression extends OperatorExpression {
  cc flag() {
    abstract();
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(StoreCmpInstruction(lhsValue, rhsValue, result, flag()));
  }
}

class OperatorLessThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<';
  }

  cc flag() {
    return ccLessThan;
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<=';
  }

  cc flag() {
    return ccLessThanOrEqual;
  }
}

class OperatorGreaterThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>';
  }

  cc flag() {
    return ccGreaterThan;
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>=';
  }

  cc flag() {
    return ccGreaterThanOrEqual;
  }
}

class OperatorLogicalAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&&';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: implement logical and 
    throw('&& not implemented');
  }
}

class OperatorLogicalOrExpression extends OperatorExpression {
  String describeOperator() {
    return '||';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: implement logical or
    throw('|| not implemented');
  }
}


class DeclarationStatement extends Statement {
  String identifier;

  Null constructor(String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }
  
  Null generateInstructions(CompiledScope scope) {
    DynamicSlot lSlot = scope.registerVariable(identifier, type.generateInstructions(scope));
    if (rValue != null) {
      Slot rSlot = rValue!.generateInstructions(scope);
      scope.emitInstruction(MoveInstruction(lSlot, rSlot, concat('value initialization of variable declaration for ', lSlot.debugName, ' (', rSlot.debugName, ')')));
      scope.emitInstruction(MoveTypeToTypeInstruction(lSlot, rSlot, scope.environment(), concat('type initialization of variable declaration for ', lSlot.debugName)));
      scope.emitIncref(lSlot);
    }
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    type = typeArg;
    rValue = rValueArg;
  }
}

class SubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  Boolean isIntrinsic;
  Boolean isVarArgs;
  StatementBlock body;

  Null walk(NullFunction callback, Anything context) {
    callback(body, context);
  }

  Null generateInstructions(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
    }
    CompiledSubroutine subroutine;
    if (isVarArgs) {
      SubroutineTypeWithVarArgs subroutineType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
      subroutine = CompiledVarArgsSubroutine(scope, subroutineType, identifier);
      assert(len(compiledParameterTypes) == 1, 'unexpected number of parameters to varargs function');
      String name = parameters[0][1] as String;
      Type type = compiledParameterTypes[0];
      (subroutine as CompiledVarArgsSubroutine).emitVarArgsParameterChecks(type, (subroutine as CompiledVarArgsSubroutine).registerVarArgsParameter(name, type) as VarArgsParameterSlot);
    } else {
      SubroutineTypeWithSpecificParameters subroutineType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
      subroutine = CompiledSubroutineWithSpecificParameters(scope, subroutineType, identifier);
      SlotList parameterSlots = []:Slot;
      Integer index = 0;
      for (parameter in parameters) {
        String name = parameter[1] as String;
        Type type = compiledParameterTypes[index];
        append(parameterSlots, (subroutine as CompiledSubroutineWithSpecificParameters).registerParameter(name, type, index));
        index += 1;
      }
      (subroutine as CompiledSubroutineWithSpecificParameters).emitParameterChecks(parameterSlots);
    }
    scope.registerSubroutine(subroutine);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(subroutine);
    }
    // TODO: declare slot for "this" and "closure"
    body.generateInstructions(subroutine);
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    assert(!isVarArgsArg || (len(parametersArg) == 1), 'varargs is only valid with a single parameter');
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    isVarArgs = isVarArgsArg;
    body = bodyArg;
    isIntrinsic = isIntrinsicArg;
  }
}  

class GenericSystemSubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  String library;
  String externalName;

  Null generateInstructions(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    StringList compiledParameterNames = []:String;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
      append(compiledParameterNames, entry[1] as String);
    }
    scope.registerSubroutine(GenericSystemCallSubroutine(
      scope,
      compiledReturnType,
      compiledParameterTypes,
      compiledParameterNames,
      library,
      externalName,
      identifier,
    ));
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') __extern \'', escapeString(library), '\' \'', escapeString(externalName), '\'\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, String libraryArg, String externalNameArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    library = libraryArg;
    externalName = externalNameArg;
  }
}  

class EnumDeclaration extends DeclarationStatement {
  String identifier;
  StringList values;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', identifier, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    if (scope.environment().isCompoundType(identifier)) {
      throw(concat('"', identifier, '" is not a valid enum type name at ', sourceLocation));
    }
    EnumType type = EnumType(scope.environment(), identifier, values);
    globalScope.declareType(type);
    Integer index = 0;
    for (value in values) {
      scope.registerNumericConstant(concat(identifier, value), index, type);
      index += 1;
    }
  }

  Null constructor(String identifierArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    values = valuesArg;
  }
}

class AbstractClassDeclaration extends DeclarationStatement {
  TypeIdentifierNullable superclassName;
  
  ClassType declareType(CompiledScope scope) {
    Type superclass;
    if (superclassName == null) {
      superclass = scope.environment().intrinsicsLibrary.coreClassType;
      if (!(superclass is ClassType)) {
        throw(concat('Specified type is not a class at ', superclassName!.sourceLocation));
      }
    } else {
      superclass = superclassName!.generateInstructions(scope);
    }
    ClassType type = ClassType(scope.environment(), identifier, superclass as ClassType);
    scope.globalScope().declareType(type);
    return type;
  }

  Slot declareConstructor(CompiledScope scope, ClassType type, TypeList parameters) {
    SubroutineTypeWithSpecificParameters subroutineType = createOrFindSubroutineTypeWithSpecificParameters(
      scope.environment(),
      type,
      parameters,
    );
    CompiledSubroutineWithSpecificParameters constructor = CompiledSubroutineWithSpecificParameters(scope, subroutineType, identifier);
    // TODO: type-check parameters
    return scope.registerSubroutine(constructor);
  }

  Null constructor(String identifierArg, TypeIdentifierNullable superclassNameArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    superclassName = superclassNameArg;
  }
}

class ClassDeclaration extends AbstractClassDeclaration {
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', identifier, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    TypeNullable type = scope.globalScope().lookupType(identifier);
    if (type == null) {
      type = declareType(scope);
      declareConstructor(scope, type! as ClassType, []:Type /* TODO: constructor parameters */);
    } else {
      // TODO: verify that |type| is a matching forward class declaration
      // TODO: add our constructor if necessary
    }
    // TODO: declare class members
    // TODO: compile scope of constructor
    throw('classes not implemented');
  }

  Null constructor(String classNameArg, TypeIdentifierNullable superclassNameArg, DeclarationStatementList membersArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, sourceLocationArg);
    members = membersArg;
  }
}

class ForwardClassDeclaration extends AbstractClassDeclaration {
  TypeIdentifierListNullable constructorParameterTypes;
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['fwdclass ', identifier, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, ';\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    ClassType type = declareType(scope);
    if (constructorParameterTypes != null) {
      TypeList parameterTypes = []:Type;
      for (identifier in constructorParameterTypes!) {
        append(parameterTypes, identifier.generateInstructions(scope));
      }
      Slot constructor = declareConstructor(scope, type, parameterTypes);
      // TODO: register the constructor with the class type somehow
    }
  }

  Null constructor(String classNameArg, TypeIdentifierListNullable constructorParameterTypesArg, TypeIdentifierNullable superclassNameArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, sourceLocationArg);
    constructorParameterTypes = constructorParameterTypesArg;
  }
}

class ForwardClassPropertyDeclaration extends DeclarationStatement {
  TypeIdentifier propertyType;
  TypeIdentifier hostClass;
  
  String toStringIndent(Integer indent) {
    return concat('fwdclassprop ', propertyType.toStringIndent(indent), ' ', hostClass.toStringIndent(indent), '.', identifier, ';\n');
  }

  Null generateInstructions(CompiledScope scope) {
    // TODO: declare the property on the class
  }

  Null constructor(TypeIdentifier hostClassArg, TypeIdentifier propertyTypeArg, String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    hostClass = hostClassArg;
    propertyType = propertyTypeArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    if (!(scope.stackFrame() is CompiledSubroutine)) {
      throw(concat('Invalid return; not in a function at ', sourceLocation));
    }
    CompiledSubroutine subroutine = scope.stackFrame() as CompiledSubroutine;
    if (expression != null) {
      subroutine.emitReturnFrom(scope, expression!.generateInstructions(scope));
    } else {
      subroutine.emitReturnFrom(scope, scope.environment().intrinsicsLibrary.coreNull);
    }
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class BreakStatement extends Statement {
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'break;\n');
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid break; not in a loop at ', this));
    }
    (loopScope as CompiledLoopScope).emitBreakInstructionFrom(scope);
  }
}

class ContinueStatement extends Statement {
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'continue;\n');
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid continue; not in a loop at ', this));
    }
    (loopScope as CompiledLoopScope).emitContinueInstructionFrom(scope);
  }
}

class ImportStatement extends Statement {
  String path;
  
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope.environment().getLibraryState(path) == lsDefined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(path) as CompiledLibrary);
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class AssignmentStatement extends Statement {
  Expression lValue; // with isLValue true
  Expression rValue;

  String describeOperator() { abstract(); }
  Slot computeResult(CompiledScope scope, Slot lSlot, Slot rSlot) { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null generateInstructions(CompiledScope scope) {
    // xxxx static type check
    Slot lSlot = lValue.generateInstructions(scope);
    Slot rSlot = rValue.generateInstructions(scope);
    Slot result = computeResult(scope, lSlot, rSlot);
    scope.emitInstruction(DecrefInstruction(lSlot, scope.environment().intrinsicsLibrary.coreStringType));
    scope.emitInstruction(MoveInstruction(lSlot, result, 'store value'));
    scope.emitInstruction(MoveTypeToTypeInstruction(lSlot, result, scope.environment(), 'store type'));
    scope.emitIncref(lSlot);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(Expression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    assert(lValueArg.isLValue(), 'lvalue is not assignable');
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class StraightAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '=';
  }

  Slot computeResult(CompiledScope scope, Slot lSlot, Slot rSlot) {
    return rSlot;
  }
}

class OperatorAssignmentStatement extends AssignmentStatement {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhsValue.source), true);
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhsValue.source), true);
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }

  Slot computeResult(CompiledScope scope, Slot lSlot, Slot rSlot) {
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot lhsValue = lSlot;
    Slot rhsValue = rSlot;
    Slot result = scope.registerDynamicValue(lSlot.staticType, concat(describeOperator(), ' operator result'));
    generateTypeCheckInstructions(lhsValue, rhsValue, scope, intrinsics);
    generateExpressionInstructions(lhsValue, rhsValue, result, scope, intrinsics);
    return result;
  }
}

class NumericOperatorAssignmentStatement extends OperatorAssignmentStatement {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, lhsValue.debugName, true);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, rhsValue.debugName, true);
  }
}

class PlusAssignmentStatement extends NumericOperatorAssignmentStatement {
  String describeOperator() {
    return '+=';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('add', lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
    scope.emitInstruction(SetTypeInstruction(result, intrinsics.coreIntegerType));
  }
}

class MinusAssignmentStatement extends NumericOperatorAssignmentStatement {
  String describeOperator() {
    return '-=';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('sub', lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
    scope.emitInstruction(SetTypeInstruction(result, intrinsics.coreIntegerType));
  }
}

class AsteriskAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '*=';
  }
}

class SlashAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '/=';
  }
}

class ModulusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '%=';
  }
}

class BitwiseAndAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '&=';
  }
}

class BitwiseXorAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '^=';
  }
}

class BitwiseOrAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '|=';
  }
}

class ElseClause extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  Null generateInstructions(CompiledScope scope) {
    Slot expressionHandle = expression.generateInstructions(scope);
    CompiledNestedScope blockScope = CompiledNestedScope(scope, scope.environment().generateLabel(concat(camelCase(scope.name), '$if')));
    block.generateInstructions(blockScope);
    CompiledNestedScopeNullable elseBlockScope = null;
    if (elseClause != null) {
      elseBlockScope = CompiledNestedScope(scope, scope.environment().generateLabel(concat(camelCase(scope.name), '$else')));
      elseClause!.generateInstructions(elseBlockScope!);
    }
    scope.emitConditionalBlock(blockScope, elseBlockScope, expressionHandle, (scope.environment().intrinsicsLibrary.coreFalse as Slot), 'if', concat(expression));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
    if (elseClause != null) {
      callback(elseClause, context);
    }
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    block.generateInstructions(scope);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(ifClause, context);
  }

  Null generateInstructions(CompiledScope scope) {
    ifClause.generateInstructions(scope);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'while');
    String loopBodyLabel = loopScope.environment().generateLabel(concat(scope.labelPrefix(), '$', loopScope.name, '$body'));
    loopScope.emitInstruction(JumpIfNotEqualInstruction(
      expression.generateInstructions(loopScope),
      scope.environment().intrinsicsLibrary.coreFalse,
      loopBodyLabel,
      'while condition',
    ));
    loopScope.emitBreakInstructionFrom(loopScope);
    loopScope.emitInstruction(LabelInstruction(loopBodyLabel, concat('start of ', loopScope.name)));
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variable;
  Expression iterable;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variable,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(iterable, context);
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    // TODO: implement for loop
    throw('for not implemented');
  }

/*
  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'for');
    Slot expressionHandle = expression.generateInstructions(loopScope).read(loopScope);
    // verify that expressionHandle is an *Iterable
    // if it is statically a *ReadOnlyList
    
    loopScope.emitConditionalJump(loopScope.loopBottomLabel, expressionHandle, (scope.environment().intrinsicsLibrary.coreFalse as Slot), 'while condition');
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }
*/

  Null constructor(String variableArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variable = variableArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }

  CompiledLibrary generateScopes(CompilationEnvironment compilationEnvironmentArg) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    generateInstructions(result);
    return result;
  }
}

class Program extends Library {
  Null generateInstructions(CompiledScope scope) {
    super.generateInstructions(scope);
    scope.emitInstruction(CommentInstruction('Terminate application - call exit(0)'));
    Slot exitCode = scope.environment().integer(0);
    Slot exit = scope.environment().intrinsicsLibrary.coreExit;
    scope.emitSubroutineCall(exit, [exitCode]);
  }
}