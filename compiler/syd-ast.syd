import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';

class TypeIdentifier extends AstNode {
  String name;
  
  //#override
  String toStringIndent(Integer indent) {
    return name;
  }

  Type generateInstructions(CompiledScope scope) {
    TypeNullable result = scope.environment().parseType(name, scope.globalScope().lookupType);
    if (result == null) {
      throw(concat('Type "', name, '" not known at ', sourceLocation));
    }
    return result;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    for (child in children) {
      scope.markSourceLocation(child);
      child.generateInstructions(scope);
    }
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class StringLiteralExpression extends Expression {
  String value;

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return scope.environment().registerStringConstant(
      scope.label.deriveWith('string'),
      value,
      scope.environment().coreStringType,
      concat(sourceLocation),
      commentNameForString(value),
    );
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    scope.environment().coreIntegerType.markConstructed();
    return scope.environment().integer(value);
  }
  
  //#override
  String toStringIndent(Integer indent) {
    if (value > -10 && value < 10) {
      return concat(value);
    }
    if (value < 0) {
      return concat(value, ' /* -0x', hex(-value), ' *\/');
    }
    return concat(value, ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;
  TypeIdentifierNullable elementType;

  //#override
  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent + 2);
    }
    String elementTypeString = '';
    if (elementType != null) {
      elementTypeString = concat(':', elementType!.toStringIndent(indent));
    }
    return concat('[', join(map(values, indenter) as StringList, ','), ']', elementTypeString);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();

    // Determine the elements of the list.
    BucketList elements = []:Bucket;
    for (value in values) {
      append(elements, value.generateInstructions(scope));
    }
    Integer initialLength = 1;
    if (len(elements) > initialLength) {
      initialLength = len(elements);
    }

    // Determine type of list.
    Type evaluatedElementType;
    if (elementType != null) {
      evaluatedElementType = elementType!.generateInstructions(scope);
    } else {
      // infer the type based on the elements of the list
      TypeNullable currentType = null;
      for (element in elements) {
        if (!(element.staticType is WhateverType)) {
          if (currentType == null) {
            currentType = element.staticType;
          } else {
            if (currentType != element.staticType) {
              currentType = environment.coreAnythingType;
              break;
            }
          }
        }
      }
      if (currentType == null) {
        currentType = environment.coreAnythingType;
      }
      evaluatedElementType = currentType!;
    }
      
    Integer index = 0;
    for (element in elements) {
      if (!element.staticType.isSubtypeOf(evaluatedElementType)) {
        throw(concat('List of type ', evaluatedElementType.name, ' cannot contain element of type ', element.staticType.name, ' at ', values[index].sourceLocation));
      }
      index += 1;
    }

    Type type = createOrFindListType(environment, evaluatedElementType);
    type.markConstructed();
    createOrFindIteratorType(environment, evaluatedElementType).markConstructed();
    assert(initialLength > 0, 'List must not be constructed with zero elements.');
    Bucket list = scope.emitIntrinsicCall(environment.listConstructorIntrinsicName, [ TypeCodeBucket(type, scope.environment().coreIntegerType), environment.integer(initialLength) ]:Bucket).asType(type);
    for (element in elements) {
      scope.emitIntrinsicCall(environment.appendIntrinsicName, [ list, element ]:Bucket);
    }
    return list;
  }

  Null constructor(ExpressionList valuesArg, TypeIdentifierNullable elementTypeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
    elementType = elementTypeArg;
  }
}

class LValue extends Object {
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    abstract();
  }
}

class LValueExpression extends Expression {
  LValue generateLValue(CompiledScope scope) {
    abstract();
  }
}

class VariableLValue extends LValue {
  IdentifierEntity variable;

  //#override
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    if (!variable.writeable()) {
      throw(concat('Cannot assign to immutable value at ', sourceLocation));
    }
    if (!rValue.staticType.isSubtypeOf(variable.staticType())) {
      throw(concat('Cannot assign ', rValue.staticType.name, ' to variable of type ', variable.staticType().name, ' at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rValue, 
      variable.staticType(), 
      'tried to assign to variable of wrong type compared to rvalue', 
      true, 
      LazyComment('check assignment is type-safe'),
    ));
    variable.write(scope, rValue);
  }

  Null constructor(IdentifierEntity variableArg) {
    super.constructor();
    variable = variableArg;
  }
}

class VariableExpression extends LValueExpression {
  String name;
  
  //#override
  String toStringIndent(Integer indent) {
    return name;
  }

  IdentifierEntity lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable result = scope.lookupIdentifier(name);
    if (result == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    if (!result!.isDeclared()) {
      // for compatibility with the interpreter
      throw(concat('Identifier "', name, '" has not yet been defined at ', sourceLocation));
    }
    return result!;
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return lookupCurrentIdentifier(scope).forRead(scope);
  }

  //#override
  LValue generateLValue(CompiledScope scope) {
    return VariableLValue(lookupCurrentIdentifier(scope));
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubscriptLValue extends LValue {
  Type elementType;
  Bucket pointer;

  //#override
  Null assign(CompiledScope scope, Bucket rValue, SourceLocation sourceLocation) {
    if (!rValue.staticType.isSubtypeOf(elementType)) {
      throw(concat('Cannot assign ', rValue.staticType.name, ', to list element of type ', elementType.name, ' at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rValue, 
      elementType, 
      'tried to assign to subscript lvalue of type that does not match rvalue', 
      true, 
      LazyComment('check subscript assignment is type-safe'),
    ));
    scope.emit(HeapUpdateInstruction(pointer, rValue, elementType));
  }

  Null constructor(Type elementTypeArg, Bucket pointerArg) {
    super.constructor();
    elementType = elementTypeArg;
    pointer = pointerArg;
  }
}

class SubscriptExpression extends LValueExpression {
  Expression list;
  Expression argument;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Boolean _prepared = false;
  Bucket _evaluatedList;
  Bucket _evaluatedArgument;
  Type _evaluatedElementType;

  Null _prepare(CompiledScope scope) {
    if (_prepared) {
      return;
    }
    _evaluatedList = list.generateInstructions(scope);
    if (_evaluatedList.staticType is AbstractListType) {
      _evaluatedElementType = (_evaluatedList.staticType as AbstractListType).elementType;
    } else if (_evaluatedList.staticType.isSubtypeOf(scope.environment().coreSubscriptableType)) {
      _evaluatedElementType = scope.environment().coreAnythingType;
    } else {
      throw(concat('"', list, '", a ', _evaluatedList.staticType.name, ', is not a list (and therefore cannot be subscripted) at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      _evaluatedList,
      scope.environment().coreSubscriptableType, 
      'tried to subscript non-list', 
      true, 
      LazyComment('check subscript receiver is a list'),
    ));
    _evaluatedArgument = argument.generateInstructions(scope);
    if (!_evaluatedArgument.staticType.isSubtypeOf(scope.environment().coreIntegerType)) {
      throw(concat('Subscript index is not an Integer at ', sourceLocation, ' (is ', _evaluatedArgument.staticType.name, ')'));
    }
    scope.emit(TypeCheckInstruction(
      _evaluatedArgument,
      scope.environment().coreIntegerType,
      'tried to subscript with non-integer index',
      true,
      LazyComment('check subscript index is an integer'),
    ));
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    _prepare(scope);
    return DereferenceWithOffsetsBucket(
      scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument), 
      scope.environment().integer(0x08), 
      scope.environment().integer(0x00), 
      ow.QWord, 
      _evaluatedElementType,
      LazyComment('subscript result'),
    );
  }

  //#override
  LValue generateLValue(CompiledScope scope) {
    _prepare(scope);
    return SubscriptLValue(_evaluatedElementType, scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument));
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends LValueExpression {
  Expression object;
  String member;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lBucket = object.generateInstructions(scope);
    CompilationEnvironment environment = scope.environment();
    if (lBucket.staticType is ClassType) {
      ClassType class = lBucket.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDeclared()) {
        return class.createIdentifierEntity(scope, lBucket, member).forRead(scope);
      }
      throw(concat('Class "', class.name, '" does not have a member "', member, '", as used at ', sourceLocation));
    }
    if (lBucket.staticType is ReifiedEnumType) {
      ReifiedEnumType enum = lBucket.staticType as ReifiedEnumType;
      BucketNullable result = enum.values.get(member) as BucketNullable;
      if (result != null) {
        return result;
      }
      throw(concat('Enum "', enum.name, '" does not have a value "', member, '", as used at ', sourceLocation));
    }
    if (lBucket.staticType.isSubtypeOf(environment.lookupIntrinsicClass(environment.coreClassTypeIntrinsicName)) || 
        lBucket.staticType.isSubtypeOf(environment.coreRootReifiedEnumType)) {
      Integer memberId = scope.environment().atomizeForDynamicDispatch(member);
      return scope.emitIntrinsicCall(scope.environment().dynamicLookupIntrinsicName, [ lBucket, scope.environment().integer(memberId) ]:Bucket);
    }
    throw(concat('Type ', lBucket.staticType.name, ' does not support member access as used at ', sourceLocation));
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

CompiledSubroutine evaluateSuper(CompiledScope scope, String method, SourceLocation sourceLocation) {
  CompiledStackFrameScope stackFrame = scope.stackFrame();
  if (!stackFrame is CompiledSubroutine) {
    throw(concat('super expression used outside method at ', sourceLocation));
  }
  ClassTypeNullable hostClass = (stackFrame as CompiledSubroutine).parentClass;
  if (hostClass == null) {
    throw(concat('super expression used in function instead of method at ', sourceLocation));
  }
  if (hostClass!.supertype == hostClass) {
    assert(hostClass!.supertype == scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName), 'unexpected other root class');
    throw(concat('super expression used in internal base class at ', sourceLocation));
  }
  if (hostClass!.supertype == scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName)) {
    throw(concat('super expression used in base class at ', sourceLocation));
  }
  ClassType superclass = hostClass!.supertype;
  MemberDescriptionNullable memberDescription = superclass.getMember(method);
  if (memberDescription == null) {
    throw(concat('Superclass does not have a method "', method, '" as referenced at ', sourceLocation));
  }
  assert(memberDescription!.isDefined(), concat('superclass method ', method, ' not defined'));
  while (memberDescription!.isField) {
    if (superclass.supertype == superclass) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
    superclass = superclass.supertype;
    memberDescription = superclass.getMember(method);
    if (memberDescription == null) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
  }
  return memberDescription!.methodImplementation!;
}

class SuperExpression extends Expression {
  String method;

  //#override
  String toStringIndent(Integer indent) {
    return concat('super.', method);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    targetMethod.type.markConstructed();
    return scope.emitIntrinsicCall(
      scope.environment().createMethodPointerIntrinsicName,
      [
        thisMethod.thisPointer,
        targetMethod.codePointer,
        TypeCodeBucket(targetMethod.type, scope.environment().coreIntegerType),
      ]:Bucket,
    );
  }

  Null constructor(String methodArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
  }
}

Null generateInstructionsForArguments(CompilationEnvironment environment, CompiledScope scope, Expression subroutineReference, SourceLocation sourceLocation, Type subroutineType, ExpressionList arguments, BucketList argumentValues, SourceLocationList sourceLocations) {
  if (subroutineType.isSubtypeOf(environment.coreSubroutineType)) {
    for (argument in arguments) {
      append(sourceLocations, argument.sourceLocation);
      append(argumentValues, argument.generateInstructions(scope));
    }
  } else {
    throw(concat('"', subroutineReference.toStringIndent(0), '" is not a function pointer at ', sourceLocation, ' (is ', subroutineType.name, ')'));
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return generateInstructionsForSubroutinePointerCallExpression(scope, subroutineReference.generateInstructions(scope), arguments, subroutineReference, sourceLocation);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class VariableSubroutineCallExpression extends Expression {
  String name;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(name, '(', joinList(argumentsList), ')');
  }
  
  IdentifierEntity lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable entity = scope.lookupIdentifier(name);
    if (entity == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    if (!entity!.isDeclared()) {
      // for compatibility with the interpreter
      throw(concat('Identifier "', name, '" is known but has not yet been declared at ', sourceLocation));
    }
    return entity;
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    return lookupCurrentIdentifier(scope).emitCall(scope, arguments, this, sourceLocation);
  }

  Null constructor(String nameArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
    arguments = argumentsArg;
  }
}

class MemberAccessSubroutineCallExpression extends Expression {
  Expression object;
  String member;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(object.toStringIndent(indent), '.', member, '(', joinList(argumentsList), ')');
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lBucket = object.generateInstructions(scope);
    if (lBucket.staticType is ClassType) {
      ClassType class = lBucket.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDeclared()) {
        return class.createIdentifierEntity(scope, lBucket, member).emitCall(scope, arguments, this, sourceLocation);
      }
      throw(concat('nonexistent member ', member, ' at ', sourceLocation));
    } else {
      throw(concat('cannot call member on non-class type ', lBucket.staticType.name, ' at ', sourceLocation));
    }
  }

  Null constructor(Expression objectArg, String memberArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
    arguments = argumentsArg;
  }
}

class SuperSubroutineCallExpression extends Expression {
  String method;
  ExpressionList arguments;

  //#override
  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat('super.', method, '(', joinList(argumentsList), ')');
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    return generateInstructionsForSubroutineCallExpression(
      scope,
      ForCallResult(targetMethod.codePointer, targetMethod.type, thisMethod.thisPointer),
      null,
      arguments,
      this,
      sourceLocation,
    );
  }

  Null constructor(String methodArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
    arguments = argumentsArg;
  }
}

class UnwrapExpression extends Expression {
  Expression lhs;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(lhs.toStringIndent(indent), '!');
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // check that it's not nullable
    // return a static cast
    Bucket value = lhs.generateInstructions(scope);
    if (value.staticType is NullableType) {
      Type unwrappedType = (value.staticType as NullableType).subtype;
      assert(value.staticType.needRuntimeTypeCheckFor(unwrappedType), 'internal error');
      assert(unwrappedType.isSubtypeOf(value.staticType), 'internal error');
      scope.emit(TypeCheckInstruction(value, unwrappedType, 'value is null', true, LazyComment('check type of ', value, ' is ', unwrappedType, ' and not null')));
      return StaticCastBucket(value, unwrappedType);
    } else if (value.staticType is WhateverType) {
      BoundInstruction error = ErrorInstruction('unexpected null value');
      error.bind(scope.label);
      scope.emit(IfBlockInstruction(
        scope.compute(EqualityInstruction(value, scope.environment().coreNull, scope.environment().coreBooleanType, false, LazyComment('check ', value, ' is not null'))),
        [ error ]:BoundInstruction,
        []:BoundInstruction,
      ));
      return value;
    } else {
      throw(concat('Type of expression (', value.staticType.name, ') is not a nullable type at ', sourceLocation));
    }
  }

  Null constructor(Expression lhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', type);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    if (!lhs.staticType.needRuntimeTypeCheckFor(rhs)) {
      // always true
      return scope.environment().coreTrue;
    }
    if (!rhs.isSubtypeOf(lhs.staticType)) {
      // always false
      return scope.environment().coreFalse;
    }
    return scope.compute(StoreTypeCheckInstruction(rhs, lhs, scope.environment().coreBooleanType, 'evaluate is operator', LazyComment('result of "is" operator')));
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class AsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' as ', type);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket exprBucket = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    if (rhs.isSubtypeOf(exprBucket.staticType)) {
      scope.emit(TypeCheckInstruction(
        exprBucket, 
        rhs, 
        'tried to cast but type mismatch (x as y)', 
        true, 
        LazyComment('check as operator cast is valid'),
      ));
      return exprBucket.asType(rhs);
    }
    if (rhs is AbstractListType) {
      return scope.emitIntrinsicCall(
        scope.environment().listCastIntrinsicName,
        [
          exprBucket,
          TypeCodeBucket(rhs, scope.environment().coreIntegerType),
        ]:Bucket,
      ).asType(rhs);
    }
    throw(concat('Cannot cast ', exprBucket.staticType.name, ' to ', rhs.name, ' at ', sourceLocation));
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretAsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __as__ ', type);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket exprBucket = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    rhs.markConstructed();
    return StaticReinterpretCastBucket(exprBucket, rhs);
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class DynamicIsOperatorExpression extends Expression {
  Expression expression;
  Expression type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __dynamic_is__ ', type.toStringIndent(indent));
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Bucket rhs = type.generateInstructions(scope);
    return scope.compute(StoreDynamicTypeCheckInstruction(rhs, lhs, scope.environment().coreBooleanType, 'evaluate __dynamic_is_ operator', LazyComment('result of "__dynamic_is__" operator')));
  }

  Null constructor(Expression expressionArg, Expression typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretDynamicAsOperatorExpression extends Expression {
  Expression expression;
  Expression type;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __dynamic_as__ ', type);
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhs = expression.generateInstructions(scope);
    Bucket rhs = type.generateInstructions(scope);
    return DynamicCastBucket(lhs, rhs, scope.environment().coreAnythingType);
  }

  Null constructor(Expression expressionArg, Expression typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  Type rhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type returnType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // return scope.compute(AdditionInstruction(rhsValue, concat(describeOperator(), ' operator')));
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket rhsValue = rhs.generateInstructions(scope);
    Type rhsType = rhsType(scope.environment());
    if (!rhsValue.staticType.isSubtypeOf(rhsType)) {
      throw(concat('Expected ', rhsType.name, ', but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      rhsType, 
      'expected %s but got %s (in unary %s expression)', 
      true, 
      LazyComment('check ', describeOperator(), ' operator\'s operand is valid type'),
    ));
    assert(returnType(scope.environment()).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    return generateExpressionInstructions(rhsValue, scope);
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '-';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(NegateInstruction(rhsValue, scope.environment().coreIntegerType, LazyComment('result of unary -')));
  }
}

class PlusExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '+';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return rhsValue;
  }
}

class BooleanNotExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '!';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(BooleanNotInstruction(rhsValue, scope.environment().coreBooleanType, LazyComment('result of unary ! operator')));
  }
}

class BitwiseNotExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '~';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return scope.compute(BitwiseNotInstruction(rhsValue, scope.environment().coreIntegerType, LazyComment('result of unary ~ operator')));
  }
}

class TypeOfExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__typeOf';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    return TypeOfBucket(rhsValue, scope.environment().coreIntegerType);
  }
}

class ElementTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__elementTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    // input: type code of iterable
    // output: type code of elements in iterable
    // the elementTypeTableLabel is a table of 32 bit wide codes (4 bytes wide)
    // first, multiply the type code by 4 to get the offset into the table in bytes
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into element type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().elementTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('element type of ', rhsValue),
    );
  }
}

class IteratorTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__iteratorTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    // input: type code of iterable
    // output: type code of iterator version of input
    // the iteratorTypeTableLabel is a table of 32 bit wide codes (4 bytes wide)
    // first, multiply the type code by 4 to get the offset into the table in bytes
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into iterator type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().iteratorTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('iterator type version of ', rhsValue),
    );
  }
}

class ListTypeFromExpression extends UnaryExpression {
  //#override
  String describeOperator() {
    return '__listTypeFrom';
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket rhsValue, CompiledScope scope) {
    Bucket index = scope.compute(ShiftLeftInstruction(rhsValue, scope.environment().integer(2), scope.environment().coreIntegerType, LazyComment('offset into list type table')));
    // add the offset of the table to the index to find the memory location of our entry
    return DereferenceWithStaticTypeBucket(
      scope.environment().listTypeTablePointer, 
      index, 
      ow.DWord, 
      scope.environment().coreIntegerType, 
      LazyComment('list type version of ', rhsValue),
    );
  }
}

// This marks the type as constructed, but not as type checked.
class TypeToCodeExpression extends Expression {
  TypeIdentifier rhs;

  String describeOperator() {
    return '__typeToCode';
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Type rhsValue = rhs.generateInstructions(scope);
    rhsValue.markConstructed();
    return TypeCodeBucket(rhsValue, scope.environment().coreIntegerType);
  }

  Null constructor(TypeIdentifier rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    abstract();
    // e.g.:
    // return '+';
  }

  Type lhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type rhsType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Type returnType(CompilationEnvironment environment) {
    abstract();
    // e.g.:
    // return environment.coreIntegerType;
  }

  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // return scope.compute(AdditionInstruction(rhsValue, concat(describeOperator(), ' operator')));
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    Type lhsType = lhsType(scope.environment());
    if (!lhsValue.staticType.isSubtypeOf(lhsType)) {
      throw(concat('expected ', lhsType.name, ', but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      lhsType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    Type rhsType = rhsType(scope.environment());
    if (!rhsValue.staticType.isSubtypeOf(rhsType)) {
      throw(concat('Expected ', rhsType.name, ', but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      rhsType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    Bucket lhsValue = lhs.generateInstructions(scope);
    Bucket rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(lhsValue, rhsValue, scope);
    assert(returnType(scope.environment()).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    Bucket result = generateExpressionInstructions(lhsValue, rhsValue, scope);
    assert(result.staticType == returnType(scope.environment()), concat(className, '\'s returnType is not respected by its generateExpressionInstructions method'));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class NumericOperatorExpression extends OperatorExpression {
  //#override
  Type lhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }
}

class OperatorAdditionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '+';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedAddInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary + operator')));
  }
}

class OperatorSubtractionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '-';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedSubtractInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary - operator')));
  }
}

class OperatorExponentiationExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '**';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedExponentiationInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary ** operator')));
  }
}

class OperatorMultiplicationExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '*';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedMultiplyInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary * operator')));
  }
}

class OperatorDivisionExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '/';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedDivideInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary / operator')));
  }
}

class OperatorModulusExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '%';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedModulusInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary % operator')));
  }
}

class OperatorBitwiseAndExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '&';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary & operator')));
  }
}

class OperatorBitwiseOrExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '|';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary | operator')));
  }
}

class OperatorBitwiseXorExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '^';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(XOrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary ^ operator')));
  }
}

class OperatorLeftShiftExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '<<';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(ShiftLeftInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary << operator')));
  }
}

class OperatorRightShiftExpression extends NumericOperatorExpression {
  //#override
  String describeOperator() {
    return '>>';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(ShiftRightInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, LazyComment('result of binary >> operator')));
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  //#override
  String describeOperator() {
    return '==';
  }

  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType.name, ' and ', rhsValue.staticType.name));
    }
  }

  //#override
  Type lhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(EqualityInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, false, LazyComment('result of binary == operator')));
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  //#override
  String describeOperator() {
    return '!=';
  }

  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType, ' and ', rhsValue.staticType));
    }
  }

  //#override
  Type lhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    assert(false, 'unreachable');
    return environment.coreWhateverType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(EqualityInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, true, LazyComment('result of binary != operator')));
  }
}

class OperatorNumericCmpExpression extends OperatorExpression {
  Comparison flag() {
    abstract();
  }
  
  //#override
  Type lhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type rhsType(CompilationEnvironment environment) {
    return environment.coreIntegerType;
  }

  //#override
  Type returnType(CompilationEnvironment environment) {
    return environment.coreBooleanType;
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(InequalityInstruction(flag(), lhsValue, rhsValue, scope.environment().coreBooleanType, LazyComment('result of binary ', describeOperator(), ' operator')));
  }
}

class OperatorLessThanExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '<';
  }

  //#override
  Comparison flag() {
    return Comparison.LessThan;
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '<=';
  }

  //#override
  Comparison flag() {
    return Comparison.LessThanOrEqual;
  }
}

class OperatorGreaterThanExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '>';
  }

  //#override
  Comparison flag() {
    return Comparison.GreaterThan;
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorNumericCmpExpression {
  //#override
  String describeOperator() {
    return '>=';
  }

  //#override
  Comparison flag() {
    return Comparison.GreaterThanOrEqual;
  }
}

class OperatorLogicalAndExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    return '&&';
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // evaluate lhs
    LocalVariable result = LocalVariable(scope.environment().coreBooleanType, scope.environment().coreSentinel, '$result$');
    scope.emit(VariableDeclarationInstruction(result));
    Bucket lhsValue = lhs.generateInstructions(scope);
    if (!lhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    // create a scope for when lhs is not false, that returns rhs
    CompiledScope rhsScope = CompiledScope(scope, '&&');
    Bucket rhsValue = rhs.generateInstructions(rhsScope);
    if (!rhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    rhsScope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    rhsScope.emit(UpdateVariableInstruction(result, rhsValue));
    // create a scope for when lhs is false, that returns false
    CompiledScope falseScope = CompiledScope(scope, '&&');
    falseScope.emit(UpdateVariableInstruction(result, scope.environment().coreFalse)); // 'short-circuited &&'
    // put it all together
    scope.emit(IfScopeInstruction(lhsValue, rhsScope, falseScope));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class OperatorLogicalOrExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    return '||';
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  //#override
  Bucket generateInstructions(CompiledScope scope) {
    // evaluate lhs
    LocalVariable result = LocalVariable(scope.environment().coreBooleanType, scope.environment().coreSentinel, '$result$');
    scope.emit(VariableDeclarationInstruction(result));
    Bucket lhsValue = lhs.generateInstructions(scope);
    if (!lhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as lhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in lhs of binary %s expression)', 
      true, 
      LazyComment('check left hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    // create scope for when lhs is not false, that returns true
    CompiledScope trueScope = CompiledScope(scope, '||');
    trueScope.emit(UpdateVariableInstruction(result, scope.environment().coreTrue)); // 'short-circuited ||'
    // create scope for when lhs is false, that returns rhs
    CompiledScope rhsScope = CompiledScope(scope, '||');
    Bucket rhsValue = rhs.generateInstructions(rhsScope);
    if (!rhsValue.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as rhs of binary ', describeOperator(), ' operator at ', sourceLocation));
    }
    rhsScope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'expected %s but got %s (in rhs of binary %s expression)', 
      true, 
      LazyComment('check right hand side operand of ', describeOperator(), ' operator is valid type'),
    ));
    rhsScope.emit(UpdateVariableInstruction(result, rhsValue));
    // put it all together
    scope.emit(IfScopeInstruction(lhsValue, trueScope, rhsScope));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class DeclarationStatement extends Statement {
  String identifier;

  // Static type of the thing being declared.
  Type staticType; // must be set by generateInstructions

  Null constructor(String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
  }
}

class FieldDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  //#override
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }

  Null generateInitializerInstructions(CompiledScope constructor) {
    if (rValue != null) {
      Bucket rBucket = rValue!.generateInstructions(constructor);
      if (!rBucket.staticType.isSubtypeOf(staticType)) {
        throw(concat('Cannot assign ', rBucket.staticType.name, ' to field of type ', staticType.name, ' at ', sourceLocation));
      }
      constructor.emit(TypeCheckInstruction(
        rBucket, 
        staticType, 
        'tried to assign %s to field of type %s at %s', 
        true, 
        LazyComment('check type of field initializer is valid'), // TODO: better error message
      ));
      IdentifierEntity entity = (constructor as CompiledSubroutine).parentClass!.createIdentifierEntity(
        constructor as CompiledSubroutine,
        (constructor as CompiledSubroutine).thisPointer,
        identifier,
      );
      if (entity.writeable()) {
        entity.write(constructor, rBucket);
      }
    }
  }

  Null declare(ClassType classType, CompiledScope scope) {
    staticType = type.generateInstructions(scope);
    MemberDescriptionNullable inheritedMember = classType.getRealMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (!staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    classType.registerMember(identifier, staticType, true, generateInitializerInstructions, sourceLocation);
  }
  
  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledSubroutine, 'FieldDeclarationStatement compiled outside of class constructor');
    assert((scope as CompiledSubroutine).parentClass != null, 'FieldDeclarationStatement compiled outside of class');
    if (identifier == kConstructor) {
      throw(concat('Identifier "', identifier, '" is an invalid name for a field at ', sourceLocation));
    }
    generateInitializerInstructions(scope);
    (scope as CompiledSubroutine).parentClass!.getMember(identifier)!.markDeclared();
    (scope as CompiledSubroutine).parentClass!.getMember(identifier)!.markDefined();
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    type = typeArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  //#override
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }
  
  //#override
  Null generateInstructions(CompiledScope scope) {
    staticType = type.generateInstructions(scope);
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Bucket rhs;
    if (rValue != null) {
      // TODO: for literals assigned to globals, instead of doing it this way, we should put the initialized value in the .data section
      rhs = rValue!.generateInstructions(scope);
    }
    IdentifierEntity lhs = scope.registerVariable(identifier, staticType);
    assert(lhs.writeable(), 'variable is not writeable');
    if (rValue != null) {
      if (!rhs.staticType.isSubtypeOf(lhs.staticType())) {
        throw(concat('Cannot assign ', rhs.staticType.name, ' to variable of type ', lhs.staticType().name, ' at ', sourceLocation));
      }
      scope.emit(TypeCheckInstruction(
        rhs, 
        staticType, 
        'type mismatch in assignment.', 
        true, 
        LazyComment('check type of variable initializer (', rhs, ')'), // TODO: more detailed error message
      ));
      lhs.write(scope, rhs);
    }
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    type = typeArg;
    rValue = rValueArg;
  }
}

class AbstractSubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  Boolean isVarArgs;
  StatementBlock body;

  ClassTypeNullable receiverType() {
    abstract();
  }

  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    abstract();
  }

  CompiledSubroutine subroutine;

  Null generateStaticType(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
    }
    if (isVarArgs) {
      assert(len(compiledParameterTypes) == 1, 'unexpected number of parameters to varargs function');
      staticType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
      createOrFindIteratorType(scope.environment(), compiledParameterTypes[0]).markConstructed();
      createOrFindListType(scope.environment(), compiledParameterTypes[0]).markConstructed();
    } else {
      staticType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
    }
    staticType.markConstructed();
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(staticType != null, 'call generateStaticType before generateInstructions');
    if (isVarArgs) {
      subroutine = CompiledVarArgsSubroutine(scope, staticType as SubroutineTypeWithVarArgs, identifier, receiverType());
      String name = parameters[0][1] as String;
      Type type = (staticType as SubroutineTypeWithVarArgs).parameterType;
      (subroutine as CompiledVarArgsSubroutine).emitVarArgsParameterChecks(type, (subroutine as CompiledVarArgsSubroutine).registerVarArgsParameter(name, type) as VarArgsParameterBucket);
    } else {
      subroutine = CompiledSubroutineWithSpecificParameters(scope, staticType as SubroutineTypeWithSpecificParameters, identifier, receiverType());
      ParameterBucketList parameterBuckets = []:ParameterBucket;
      Integer index = 0;
      for (parameter in parameters) {
        String name = parameter[1] as String;
        Type type = (staticType as SubroutineTypeWithSpecificParameters).parameterTypes[index];
        append(parameterBuckets, (subroutine as CompiledSubroutineWithSpecificParameters).registerParameter(name, type, index));
        index += 1;
      }
      (subroutine as CompiledSubroutineWithSpecificParameters).emitParameterChecks(parameterBuckets);
    }
    registerSubroutine(scope, subroutine);
    body.generateInstructions(subroutine);
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg) {
    assert(!isVarArgsArg || (len(parametersArg) == 1), 'varargs is only valid with a single parameter');
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    isVarArgs = isVarArgsArg;
    body = bodyArg;
  }
}

class MethodDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  ClassType parentClass;

  Null declare(ClassType classType, CompiledScope scope) {
    generateStaticType(scope);
    MemberDescriptionNullable inheritedMember = classType.getRealMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (inheritedMember!.name != kConstructor && !staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    classType.registerMember(identifier, staticType, false, null, sourceLocation);
    parentClass = classType;
  }

  //#override
  ClassTypeNullable receiverType() {
    return parentClass;
  }

  //#override
  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    scope.registerNestedScope(subroutine);
    MemberDescription member = parentClass.getMember(identifier)!;
    member.markDeclared();
    member.markDefined();
    member.setMethodImplementation(subroutine);
    scope.environment().addSubroutine(subroutine);
  }
}

class SubroutineDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  Boolean isIntrinsic;

  //#override
  ClassTypeNullable receiverType() {
    return null;
  }

  //#override
  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    scope.registerSubroutine(subroutine, false);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(subroutine);
    }
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    super.generateStaticType(scope);
    super.generateInstructions(scope);
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(returnTypeArg, identifierArg, parametersArg, isVarArgsArg, bodyArg, sourceLocationArg);
    isIntrinsic = isIntrinsicArg;
  }
}  

class GenericSystemSubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  String library;
  String externalName;
  Boolean isIntrinsic;

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    StringList compiledParameterNames = []:String;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
      append(compiledParameterNames, entry[1] as String);
    }
    CompiledSubroutine subroutine = GenericSystemCallSubroutine(
      scope,
      compiledReturnType,
      compiledParameterTypes,
      library,
      externalName,
      identifier,
      compiledParameterNames,
    );
    staticType = subroutine.type;
    scope.registerSubroutine(subroutine, false);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(subroutine);
    }
  }

  //#override
  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') __extern \'', escapeString(library), '\' \'', escapeString(externalName), '\'\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, String libraryArg, String externalNameArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    library = libraryArg;
    externalName = externalNameArg;
    isIntrinsic = isIntrinsicArg;
  }
}

class EnumDeclaration extends DeclarationStatement {
  String identifier;
  StringList values;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', identifier, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    CompilationEnvironment environment = globalScope.environment();
    if (environment.isCompoundType(identifier)) {
      throw(concat('"', identifier, '" is not a valid enum type name at ', sourceLocation));
    }
    EnumPropertyType enumPropertyType = EnumPropertyType(environment, identifier);
    AssemblerLabel enumLabel = scope.label.deriveWith(identifier);
    Map enumValues = Map(); // String -> StringBucket
    for (value in values) {
      enumValues.set(value, environment.registerStringConstant(
        enumLabel.deriveWith(value),
        concat(identifier, '.', value),
        enumPropertyType,
        concat(identifier, '.', value, ' stringification'),
        concat(identifier, '.', value),
      ));
    }
    ReifiedEnumType reifiedEnumType = ReifiedEnumType(
      environment,
      enumLabel, 
      environment.registerStringConstant(enumLabel.deriveWith('name'), identifier, environment.coreStringType, identifier, identifier),
      enumPropertyType,
      enumValues,
    );
    staticType = reifiedEnumType;
    globalScope.declareType(enumPropertyType);
    globalScope.declareType(reifiedEnumType);
    globalScope.registerConstant(identifier, environment.registerEnumType(reifiedEnumType));
  }

  Null constructor(String identifierArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    values = valuesArg;
  }
}

class AbstractClassDeclaration extends DeclarationStatement {
  TypeIdentifierNullable superclassName;
  Boolean isIntrinsic;
  
  Null declareType(CompiledScope scope) {
    TypeNullable superclass;
    if (isIntrinsic && identifier == scope.environment().coreClassTypeIntrinsicName) {
      if (superclassName != null) {
        throw(concat('Intrinsic class cannot have a superclass as ', sourceLocation));
      }
      superclass = null;
    } else if (superclassName == null) {
      superclass = scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName);
    } else {
      superclass = superclassName!.generateInstructions(scope);
    }
    staticType = ClassType(scope, identifier, superclass);
    scope.globalScope().declareType(staticType);
    if (isIntrinsic) {
      scope.environment().registerClassIntrinsic(staticType as ClassType);
    }
  }

  Null createGeneratedConstructor(CompiledScope scope, TypeList parameters, Boolean isVarArgs) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    AbstractSubroutineTypeWithSpecificParameters subroutineType;
    if (isVarArgs) {
      subroutineType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        staticType,
        parameters,
      );
    } else {
      subroutineType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        staticType,
        parameters,
      );
    }
    subroutineType.markConstructed();
    CompiledGeneratedConstructorSubroutine constructor = CompiledGeneratedConstructorSubroutine(scope, subroutineType, identifier, staticType as ClassType);
    (staticType as ClassType).setConstructorSubroutine(scope.registerSubroutine(constructor, true));
  }

  Null constructor(String identifierArg, TypeIdentifierNullable superclassNameArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    superclassName = superclassNameArg;
    isIntrinsic = isIntrinsicArg;
  }
}

class ForwardClassDeclaration extends AbstractClassDeclaration {
  TypeIdentifierListNullable constructorParameterTypes;
  Boolean isVarArgs;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['fwdclass ', identifier];
    if (constructorParameterTypes != null) {
      append(buffer, '(');
      Integer index = 0;
      while (index < len(constructorParameterTypes!)) {
        if (index > 0) {
          append(buffer, ', ');
        }
        append(buffer, constructorParameterTypes![index].toStringIndent(indent));
        index += 1;
      }
      append(buffer, ')');
    }
    if (superclassName != null) {
      append(buffer, ' extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, ';\n');
    return joinList(buffer);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    declareType(scope);
    if (constructorParameterTypes != null) {
      TypeList parameterTypes = []:Type;
      for (identifier in constructorParameterTypes!) {
        append(parameterTypes, identifier.generateInstructions(scope));
      }
      assert(!isVarArgs || len(parameterTypes) == 1, 'varargs must have one parameter in their list');
      createGeneratedConstructor(scope, parameterTypes, isVarArgs);
    } else {
      assert((staticType as ClassType).supertype != scope.environment().lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName), 'parser failed to give empty list of arguments');
      // If no parameters are given on the fwdclass declaration, but the declaration
      // has a superclass, then the arguments from the superclass constructor are implied.
      createGeneratedConstructor(
        scope,
        ((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes,
        (staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithVarArgs,
      );
    }
    (staticType as ClassType).constructorSubroutine.markConstructorAsDeclared();
  }

  Null constructor(String classNameArg, TypeIdentifierListNullable constructorParameterTypesArg, Boolean isVarArgsArg, TypeIdentifierNullable superclassNameArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, isIntrinsicArg, sourceLocationArg);
    constructorParameterTypes = constructorParameterTypesArg;
    isVarArgs = isVarArgsArg;
  }
}

class ClassDeclaration extends AbstractClassDeclaration {
  DeclarationStatementList members;
  
  //#override
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', identifier, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    TypeNullable existingStaticType = scope.globalScope().lookupType(identifier);
    if (existingStaticType == null) {
      declareType(scope);
      assert(staticType != null, 'invariant violation');
      assert(scope.globalScope().lookupType(identifier) == staticType, 'invariant violation');
    } else {
      staticType = existingStaticType!;
      // either someone declared an unrelated type with the same name (bad)
      // or, they used fwdclass (good).
      if (!(staticType is ClassType)) {
        throw(concat('Type ', identifier, ' redeclared at ', sourceLocation));
      } else if ((staticType as ClassType).members.length != 0) {
        throw(concat('Class ', identifier, ' redeclared at ', sourceLocation));
      } else if (superclassName == null) {
        if ((staticType as ClassType).supertype.supertype != (staticType as ClassType).supertype) {
          throw(concat('Forward class declaration for ', identifier, ' used supertype ', (staticType as ClassType).supertype.name, ', but class declaration had no supertype at ', sourceLocation));
        }
      } else {
        Type superclass = superclassName!.generateInstructions(scope);
        if (superclass != (staticType as ClassType).supertype) {
          throw(concat('Forward class declaration for ', identifier, ' used supertype ', (staticType as ClassType).supertype.name, ', but class declaration uses supertype ', superclass.name, ', at ', sourceLocation));
        }
      }
    }
    ClassType classType = staticType as ClassType;
    classType.inheritMembersFromSupertype();
    classType.markAsDefined();
    if (!classType.supertype.isDefined) {
      if (superclassName == null) {
        throw(concat('Class defined before __Object is defined at ', sourceLocation));
      }
      assert(superclassName != null, 'we were not defined');
      throw(concat('Cannot extend a class that has not yet been defined at ', superclassName!.sourceLocation));
    }
    // register members on the class type
    for (member in members) {
      if (member is FieldDeclarationStatement) {
        (member as FieldDeclarationStatement).declare(staticType as ClassType, scope);
      } else if (member is MethodDeclarationStatement) {
        (member as MethodDeclarationStatement).declare(staticType as ClassType, scope);
      } else {
        assert(false, concat('unexpected declaration statement (', member.className, ') in class at ', member.sourceLocation));
      }
    }
    classType.checkForMissingForwardDeclaredMembers(sourceLocation);
    DeclarationStatementNullable constructorMember = null;
    for (member in members) {
      if (member.identifier == kConstructor) {
        // we found it!
        constructorMember = member;
        break;
      }
    }
    TypeList constructorParameters;
    Boolean constructorIsVarArgs;
    if (constructorMember != null) {
      // we have an explicit constructor
      if (!constructorMember!.staticType.isSubtypeOf(createOrFindSubroutineTypeWithAnyArgs(scope.environment(), scope.environment().coreNullType))) {
        throw(concat('Constructor must be a NullFunction, but is declared as a ', constructorMember!.staticType.name, ' at ', constructorMember!.sourceLocation));
      }
      if (constructorMember is AbstractSubroutineDeclarationStatement) {
        // constructor was declared as a method on this class
        if ((constructorMember as AbstractSubroutineDeclarationStatement).isVarArgs) {
          constructorParameters = [(constructorMember!.staticType as SubroutineTypeWithVarArgs).parameterType]:Type;
          constructorIsVarArgs = true;
        } else {
          assert(constructorMember!.staticType is SubroutineTypeWithSpecificParameters, 'unexpected subroutine type');
          Type getTypes(Anything tuple) {
            return ((tuple as AnythingList)[0] as TypeIdentifier).generateInstructions(scope);
          }
          constructorParameters = map((constructorMember as AbstractSubroutineDeclarationStatement).parameters, getTypes) as TypeList;
          constructorIsVarArgs = false;
        }
      } else {
        // constructor was probably declared as a property on this class (grr!)
        assert(constructorMember!.staticType is SubroutineTypeWithAnyArguments, 'unexpected subroutine type');
        constructorParameters = [scope.environment().coreAnythingType]:Type;
        constructorIsVarArgs = true;
      }
    } else if ((staticType as ClassType).supertype == staticType) {
      // this must be the __Object definition
      throw(concat('Base class must have an explicit constructor but has none at ', sourceLocation));
    } else {
      // we did not have an explicit constructor, so our constructor just defers to the superclass constructor
      if ((staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithVarArgs) {
        constructorParameters = [((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithVarArgs).parameterType]:Type;
        constructorIsVarArgs = true;
      } else {
        assert((staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithSpecificParameters, 'unexpected subroutine type');
        constructorParameters = ((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes;
        constructorIsVarArgs = false;
      }
    }
    if (existingStaticType != null) {
      // we must have had a forward class declaration; check that what we are going to define matches it
      if (constructorIsVarArgs) {
        assert(len(constructorParameters) == 1, 'internal inconsistency');
        if (!((staticType as ClassType).constructorSubroutine.staticType is SubroutineTypeWithVarArgs) ||
             ((staticType as ClassType).constructorSubroutine.staticType as SubroutineTypeWithVarArgs).parameterType != constructorParameters[0]) {
          throw(concat('Forward class declaration constructor signature did not match constructor declaration at ', constructorMember!.sourceLocation));
        }
      } else {
        if (!((staticType as ClassType).constructorSubroutine.staticType is SubroutineTypeWithSpecificParameters) ||
            !listEqualsWithComparator(
              ((staticType as ClassType).constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes,
              constructorParameters,
              typesEquivalent,
             )) {
          throw(concat('Forward class declaration constructor signature for class ', staticType.name, ' did not match constructor declaration at ', constructorMember!.sourceLocation));
        }
      }
    } else {
      createGeneratedConstructor(scope, constructorParameters, constructorIsVarArgs);
    }
    SubroutinePointerBucket generatedConstructorBucket = (staticType as ClassType).constructorSubroutine;
    CompiledGeneratedConstructorSubroutine generatedConstructorScope = generatedConstructorBucket.subroutine as CompiledGeneratedConstructorSubroutine;
    Bucket thisPointer = generatedConstructorScope.emitIntrinsicCall(scope.environment().classAllocatorIntrinsicName, [ VmtPointerBucket(scope.environment(), staticType as ClassType) ]:Bucket);
    generatedConstructorScope.setThisPointer(thisPointer);
    // call initializers
    ClassTypeList classHierarchy = []:ClassType;
    while (classType.supertype != classType) {
      classType = classType.supertype;
      append(classHierarchy, classType);
    }
    Integer index = len(classHierarchy) - 1;
    while (index >= 0) {
      for (initializer in classHierarchy[index].initializers) {
        initializer(generatedConstructorScope);
      }
      index -= 1;
    }
    for (member in members) {
      member.generateInstructions(generatedConstructorScope);
    }
    generatedConstructorBucket.markConstructorAsDeclared();
    // userConstructor should never be null, because the base class must have a constructor
    // userConstructor should never be a field, because we prevent properties from being declared with the name kConstructor
    CompiledSubroutine userConstructor = (staticType as ClassType).getMember(kConstructor)!.methodImplementation!;
    generatedConstructorScope.setActualConstructor(userConstructor);
    // Finally, we set the generated constructor's return type and value to the
    // newly allocated thisPointer. The CompiledGeneratedConstructorSubroutine logic
    // will invoke the actualConstructor (the user's "constructor" method) using a
    // "jmp" and will ensure that the return value is not overridden by the
    // actualConstructor; that constructor will do the final "ret".
    generatedConstructorScope.emitReturnFrom(generatedConstructorScope, thisPointer, false);
  }

  Null constructor(String classNameArg, TypeIdentifierNullable superclassNameArg, DeclarationStatementList membersArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, isIntrinsicArg, sourceLocationArg);
    members = membersArg;
  }
}

class ForwardClassPropertyDeclaration extends DeclarationStatement {
  TypeIdentifier propertyType;
  TypeIdentifier hostClass;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('fwdclassprop ', propertyType.toStringIndent(indent), ' ', hostClass.toStringIndent(indent), '.', identifier, ';\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    TypeNullable existingStaticType = hostClass.generateInstructions(scope);
    if (existingStaticType == null) {
      throw(concat('nonexistent class ', hostClass.name, ' at ', sourceLocation));
    }
    if (!(existingStaticType is ClassType)) {
      throw(concat('type ', hostClass.name, ' is not a class at ', sourceLocation));
    }
    ClassType classType = existingStaticType as ClassType;
    if (classType.isDefined) {
      throw(concat('type ', hostClass.name, ' is already defined and cannot have a forward-declared property at ', sourceLocation));
    }
    staticType = propertyType.generateInstructions(scope);
    classType.registerForwardMember(identifier, staticType, sourceLocation);
  }

  Null constructor(TypeIdentifier hostClassArg, TypeIdentifier propertyTypeArg, String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    hostClass = hostClassArg;
    propertyType = propertyTypeArg;
  }
}

class TypeIntrinsicDeclaration extends DeclarationStatement {
  String identifier;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('typedef# ', identifier, ' is GarbageCollectable;\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found typedef# in non-global scope');
    if (scope.environment().isCompoundType(identifier)) {
      throw(concat('"', identifier, '" is not a valid intrinsic type name at ', sourceLocation));
    }
    IntrinsicType type = IntrinsicType(scope.environment(), identifier);
    (scope as CompiledLibrary).declareType(type);
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  //#override
  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    if (!(scope.stackFrame() is CompiledSubroutine)) {
      throw(concat('Invalid return; not in a function at ', sourceLocation));
    }
    CompiledSubroutine subroutine = scope.stackFrame() as CompiledSubroutine;
    if (expression != null) {
      Bucket returnValue = expression!.generateInstructions(scope);
      if (!returnValue.staticType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Type of return statement (', returnValue.staticType.name, ') does not match expected return type (', subroutine.type.returnType.name, ') at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, returnValue, false);
    } else {
      if (!scope.environment().coreNullType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Tried to return null from a function whose expected return type is ', subroutine.type.returnType.name, ' at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, scope.environment().coreNull, false);
    }
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class BreakStatement extends Statement {
  //#override
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'break;\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid break; not in a loop at ', this));
    }
    scope.emit(BreakInstruction());
  }
}

class ContinueStatement extends Statement {
  //#override
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'continue;\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid continue; not in a loop at ', this));
    }
    scope.emit(ContinueInstruction());
  }
}

class ImportStatement extends Statement {
  String path;
  String resolvedPath;

  Null setResolvedPath(String resolvedPathArg) {
    resolvedPath = resolvedPathArg;
  }
  
  //#override
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    assert(scope.environment().getLibraryState(resolvedPath) == ls.Defined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(resolvedPath) as CompiledLibrary);
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class StraightAssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' = ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket rBucket = rValue.generateInstructions(scope);
    lValue.generateLValue(scope).assign(scope, rBucket, sourceLocation);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class AssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  String describeOperator() { abstract(); }
  Bucket computeResult(CompiledScope scope, Bucket lBucket, Bucket rBucket) { abstract(); }

  LazyComment comment() {
    return LazyComment('result of ', describeOperator(), ' operator');
  }

  //#override
  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket lBucket = lValue.generateInstructions(scope);
    // TODO: verify that lBucket is assignable
    // In particular, parameters (including dereferenced varargs) and constants are not assignable.
    Bucket rBucket = rValue.generateInstructions(scope);
    Bucket result = computeResult(scope, lBucket, rBucket);
    lValue.generateLValue(scope).assign(scope, result, sourceLocation);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class OperatorAssignmentStatement extends AssignmentStatement {
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
  }

  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }

  //#override
  Bucket computeResult(CompiledScope scope, Bucket lBucket, Bucket rBucket) {
    Bucket lhsValue = lBucket;
    Bucket rhsValue = rBucket;
    generateTypeCheckInstructions(lhsValue, rhsValue, scope);
    return generateExpressionInstructions(lhsValue, rhsValue, scope);
  }
}

class NumericOperatorAssignmentStatement extends OperatorAssignmentStatement {
  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreIntegerType, 
      'type error', 
      true, 
      LazyComment('verify type of left hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreIntegerType, 
      'type error', 
      true, 
      LazyComment('verify type of right hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
  }
}

class PlusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '+=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedAddInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class MinusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '-=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedSubtractInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class AsteriskAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '*=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedMultiplyInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class AsteriskAsteriskAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '**=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedExponentiationInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class SlashAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '/=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedDivideInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class ModulusAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '%=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(SignedModulusInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseAndAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '&=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseXorAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '^=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(XOrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BitwiseOrAssignmentStatement extends NumericOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '|=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreIntegerType, comment()));
  }
}

class BooleanOperatorAssignmentStatement extends OperatorAssignmentStatement {
  //#override
  Null generateTypeCheckInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    scope.emit(TypeCheckInstruction(
      lhsValue, 
      scope.environment().coreBooleanType, 
      'type error', 
      true, 
      LazyComment('verify type of left hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
    scope.emit(TypeCheckInstruction(
      rhsValue, 
      scope.environment().coreBooleanType, 
      'type error', 
      true, 
      LazyComment('verify type of right hand side operand of ', describeOperator(), ' operator is valid'), // TODO: elaborate on error message
    ));
  }
}

class LogicalAndAssignmentStatement extends BooleanOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '&&=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(AndInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, comment()));
  }
}

class LogicalOrAssignmentStatement extends BooleanOperatorAssignmentStatement {
  //#override
  String describeOperator() {
    return '||=';
  }

  //#override
  Bucket generateExpressionInstructions(Bucket lhsValue, Bucket rhsValue, CompiledScope scope) {
    return scope.compute(OrInstruction(lhsValue, rhsValue, scope.environment().coreBooleanType, comment()));
  }
}

class ElseClause extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  //#override
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    Bucket expressionHandle = expression.generateInstructions(scope);
    if (!expressionHandle.staticType.isSubtypeOf(scope.environment().coreBooleanType)) {
      throw(concat('If expression must be a boolean, not a ', expressionHandle.staticType.name, ', at ', sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      expressionHandle, 
      scope.environment().coreBooleanType, 
      'if expression must be boolean', 
      true, 
      LazyComment('verify type of if condition'), // TODO: better error messages
    ));
    CompiledScope blockScope = CompiledScope(scope, 'if');
    block.generateInstructions(blockScope);
    CompiledScopeNullable elseBlockScope = null;
    if (elseClause != null) {
      elseBlockScope = CompiledScope(scope, 'else');
      elseClause!.generateInstructions(elseBlockScope!);
    }
    scope.emit(IfScopeInstruction(expressionHandle, blockScope, elseBlockScope));
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    block.generateInstructions(scope);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    ifClause.generateInstructions(scope);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'while');
    CompiledScope emptyScope = CompiledScope(loopScope, 'while condition is true');
    CompiledScope breakScope = CompiledScope(loopScope, 'while condition is false');
    breakScope.emit(BreakInstruction());
    Bucket expressionHandle = expression.generateInstructions(loopScope);
    if (!expressionHandle.staticType.isSubtypeOf(loopScope.environment().coreBooleanType)) {
      throw(concat('While expression must be a boolean, not a ', expressionHandle.staticType.name, ', at ', sourceLocation));
    }
    loopScope.emit(TypeCheckInstruction(
      expressionHandle, 
      loopScope.environment().coreBooleanType, 
      'while expression must be boolean', 
      true, 
      LazyComment('verify type of while condition'), // TODO: better error messages
    ));
    loopScope.emit(IfScopeInstruction(expressionHandle, emptyScope, breakScope));
    block.generateInstructions(loopScope);
    scope.emit(LoopScopeInstruction(loopScope));
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variableName;
  Expression iterable;
  StatementBlock block;
  
  //#override
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variableName,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  //#override
  Null generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();
    Bucket iterableBucket = iterable.generateInstructions(scope);
    if (!iterableBucket.staticType.isSubtypeOf(environment.coreIterableType)) {
      throw(concat('Expected an iterable type in "for" statement, but ', iterable.toStringIndent(0), ' is of type ', iterableBucket.staticType.name, ' at ', iterable.sourceLocation));
    }
    scope.emit(TypeCheckInstruction(
      iterableBucket, 
      environment.coreIterableType, 
      'non-iterable in for', 
      true, 
      LazyComment('verify type of for loop iterable'), // TODO: better error messages
    ));
    assert(!(iterableBucket is VarArgsParameterBucket), 'iteration on varargs list not yet supported');
    // TODO: for varargs, instead of calling iteratorIntrinsicName, we call varargsIteratorIntrinsicName
    // and pass it the number of arguments and a pointer to the first entry on the stack
    Bucket iteratorBucket = scope.emitIntrinsicCall(
      environment.iteratorIntrinsicName,
      [ iterableBucket ]:Bucket,
    );
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'for loop');
    CompiledScope emptyScope = CompiledScope(loopScope, 'iterator continues');
    CompiledScope breakScope = CompiledScope(loopScope, 'iterator finished');
    breakScope.emit(BreakInstruction());
    loopScope.emit(
      IfScopeInstruction(
        loopScope.emitIntrinsicCall(
          environment.nextIntrinsicName,
          [ iteratorBucket ]:Bucket,
        ),
        emptyScope,
        breakScope,
      ),
    );
    Type variableType;
    if (iterableBucket.staticType is IterableType) {
      variableType = (iterableBucket.staticType as IterableType).elementType;
    } else if (iterableBucket.staticType is AbstractListType) {
      variableType = (iterableBucket.staticType as AbstractListType).elementType;
    } else {
      variableType = environment.coreWhateverType;
    }
    assert(loopScope.identifiers.length == 0, 'newly created scope has identifiers in scope');
    Bucket currentValue = loopScope.emitIntrinsicCall(
      environment.currentIntrinsicName,
      [ iteratorBucket ]:Bucket,
    ).asType(variableType);
    loopScope.registerImmutableValue(variableName, currentValue);
    block.generateInstructions(loopScope);
    scope.emit(LoopScopeInstruction(loopScope));
  }

  Null constructor(String variableNameArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variableName = variableNameArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }

  // TODO: this should be split into "declaration" and "definition" phases
  //       the "declaration" phase does declareType-type stuff, setIsAmbiguous-type stuff, etc.
  //       the "definition" phase actually generates scopes and instructions, sets isDeclared, calls forRead, etc.
  //       this would fix class_16.syd
  CompiledLibrary generateScopes(CompilationEnvironment compilationEnvironmentArg) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    generateInstructions(result);
    return result;
  }
}

class Program extends Library {
  //#override
  Null generateInstructions(CompiledScope scope) {
    (scope as CompiledLibrary).setAsProgram();
    super.generateInstructions(scope);
    scope.emit(CommentInstruction(LazyComment('Terminate application - call exit(0)')));
    Bucket exitCode = scope.environment().integer(0);
    scope.emitIntrinsicCall(scope.environment().exitIntrinsicName, [exitCode]:Bucket);
  }
}