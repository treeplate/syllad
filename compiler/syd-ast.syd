import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';
import 'syd-loop-scopes.syd';

// TODO: remove "walk"

class TypeIdentifier extends AstNode {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Type generateInstructions(CompiledScope scope) {
    TypeNullable result = scope.environment().parseType(name, scope.globalScope().lookupType);
    if (result == null) {
      throw(concat('Type "', name, '" not known at ', sourceLocation));
    }
    return result;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in children) {
      callback(child, context);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    Null compileChild(Statement child, CompiledScope scope) {
      scope.markSourceLocation(child);
      child.generateInstructions(scope);
    }
    walk(compileChild, scope);
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class Expression extends AstNode {
  // Expressions are expected to declare (or identify) a Slot, and return it.
  Slot generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StringLiteralExpression extends Expression {
  String value;

  Slot generateInstructions(CompiledScope scope) {
    scope.environment().intrinsicsLibrary.coreStringType.markConstructed();
    Slot result = scope.environment().registerStringConstant('string', value, sourceLocation.lineNo, sourceLocation.colNo, sourceLocation.filename);
    scope.references.add(result); // TODO: ideally we would be able to tree shake references from dead code too, not just unreferenced functions
    return result;
  }

  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  Slot generateInstructions(CompiledScope scope) {
    return ImmediateIntegerSlot(scope.environment().intrinsicsLibrary.coreIntegerType, value, concat(this));
  }
  
  String toStringIndent(Integer indent) {
    if (value > -10 && value < 10) {
      return intToStr(value);
    }
    if (value < 0) {
      return concat(intToStr(value), ' /* -0x', hex(-value), ' *\/');
    }
    return concat(intToStr(value), ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;
  TypeIdentifierNullable elementType;

  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent + 2);
    }
    String elementTypeString = '';
    if (elementType != null) {
      elementTypeString = concat(':', elementType!.toStringIndent(indent));
    }
    return concat('[', join(map(values, indenter) as StringList, ','), ']', elementTypeString);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in values) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();
    SlotList elements = []:Slot;
    for (value in values) {
      append(elements, value.generateInstructions(scope));
      // xxxx static type checks
    }
    Integer initialLength = 1;
    if (len(elements) > initialLength) {
      initialLength = len(elements);
    }
    Type evaluatedElementType;
    if (elementType != null) {
      evaluatedElementType = elementType!.generateInstructions(scope);
    } else {
      // TODO: infer the type based on the elements of the list
      evaluatedElementType = environment.intrinsicsLibrary.coreAnythingType;
    }
    Type type = createOrFindListType(environment, evaluatedElementType);
    type.markConstructed();
    createOrFindIteratorType(environment, evaluatedElementType).markConstructed();
    Slot listContructor = scope.lookupIntrinsic(environment.listConstructorIntrinsicName);
    assert(initialLength > 0, 'List must not be constructed with zero elements.');
    Slot subroutineResult = scope.emitSubroutineCall(listContructor, [ TypeCodeSlot(environment, type), environment.integer(initialLength) ]:Slot, null);
    Slot list = scope.registerDynamicValue(type, rcNever, 'list literal');
    // TODO: avoid the redundant code below (which is just here to make the static type right)
    scope.emitInstruction(MoveInstruction(list, subroutineResult, 'copy list literal\'s value over to slot with better static type'));
    scope.emitInstruction(MoveTypeToTypeInstruction(list, subroutineResult, scope.environment(), 'copy list literal\'s dynamic type over to slot with better static type'));
    Slot appendIntrinsic = scope.lookupIntrinsic(environment.appendIntrinsicName);
    for (element in elements) {
      scope.emitSubroutineCall(appendIntrinsic, [ list, element ]:Slot, null);
    }
    return list;
  }

  Null constructor(ExpressionList valuesArg, TypeIdentifierNullable elementTypeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
    elementType = elementTypeArg;
  }
}

class LValue extends Object {
  Null assign(CompiledScope scope, Slot rValue, SourceLocation sourceLocation) {
    abstract();
  }
}

class LValueExpression extends Expression {
  LValue generateLValue(CompiledScope scope) {
    abstract();
  }
}

class VariableLValue extends LValue {
  IdentifierEntity variable;

  Null assign(CompiledScope scope, Slot rValue, SourceLocation sourceLocation) {
    if (!rValue.staticType.isSubtypeOf(variable.staticType())) {
      throw(concat('Cannot assign ', rValue.staticType.name, ' to variable of type ', variable.staticType().name, ' at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage);
    scope.emitTypeCheck(rValue, variable.staticType(), scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage, rValue.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
    variable.write(scope, rValue);
  }

  Null constructor(IdentifierEntity variableArg) {
    super.constructor();
    variable = variableArg;
  }
}

class VariableExpression extends LValueExpression {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  IdentifierEntity lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable result = scope.lookupIdentifier(name);
    if (result == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    if (!result!.isDefined()) {
      // for compatibility with the interpreter
      throw(concat('Class "', name, '" has not yet been defined at ', sourceLocation));
    }
    return result!;
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot originalSlot = lookupCurrentIdentifier(scope).forRead(scope);
    if (originalSlot.isMutable()) {
      rc referenceCountStyle;
      if (originalSlot.staticType.neverReferenceCounted()) {
        referenceCountStyle = rcNever;
      } else {
        referenceCountStyle = rcOnStack;
      }
      DynamicSlot copy = scope.registerDynamicValue(originalSlot.staticType, referenceCountStyle, concat('copy of ', name));
      // TODO: optimizer should elide the copy if not needed
      scope.emitInstruction(MoveInstruction(copy, originalSlot, concat('make a copy of ', name, '\'s value in case it changes before we use it')));
      scope.emitInstruction(MoveTypeToTypeInstruction(copy, originalSlot, scope.environment(), concat('make a copy of ', name, '\'s type in case it changes before we use it')));
      if (!copy.staticType.neverReferenceCounted()) {
        scope.emitIncref(copy, true /* isGCRoot */);
      }
      return copy;
    }
    return originalSlot;
  }

  LValue generateLValue(CompiledScope scope) {
    return VariableLValue(lookupCurrentIdentifier(scope));
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubscriptLValue extends LValue {
  Type elementType;
  Slot pointer;

  Null assign(CompiledScope scope, Slot rValue, SourceLocation sourceLocation) {
    if (!rValue.staticType.isSubtypeOf(elementType)) {
      throw(concat('Cannot assign ', rValue.staticType.name, ', to list element of type ', elementType.name, ' at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage);
    scope.emitTypeCheck(rValue, elementType, scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage as Slot, rValue.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
    DynamicSlot oldValue = scope.registerDynamicValue(elementType, rcOnHeap, concat('old value in list'));
    scope.emitInstruction(MoveDerefInstruction(oldValue, pointer, 0x08, 'read old value'));
    scope.emitInstruction(MoveDerefToTypeInstruction(oldValue, pointer, 0x00, 'read old type'));
    scope.emitInstruction(MoveToDerefInstruction(pointer, rValue, 0x08, 'write new value'));
    scope.emitInstruction(MoveTypeToDerefInstruction(pointer, rValue, 0x00, scope.environment(), 'write new type'));
    scope.emitIncref(rValue, false /* isGCRoot */);
  }

  Null constructor(Type elementTypeArg, Slot pointerArg) {
    super.constructor();
    elementType = elementTypeArg;
    pointer = pointerArg;
  }
}

class SubscriptExpression extends LValueExpression {
  Expression list;
  Expression argument;
  
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Boolean _prepared = false;
  Slot _evaluatedList;
  Slot _evaluatedArgument;
  Type _evaluatedElementType;

  Null _prepare(CompiledScope scope) {
    if (_prepared) {
      return;
    }
    _evaluatedList = list.generateInstructions(scope);
    if (_evaluatedList.staticType is AbstractListType) {
      _evaluatedElementType = (_evaluatedList.staticType as AbstractListType).elementType;
    } else if (_evaluatedList.staticType.isSubtypeOf(scope.environment().subscriptableType)) {
      _evaluatedElementType = scope.environment().intrinsicsLibrary.coreAnythingType;
    } else {
      throw(concat('"', list, '", a ', _evaluatedList.staticType.name, ', is not a list (and therefore cannot be subscripted) at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(_evaluatedList, scope.environment().subscriptableType, scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage, concat(list), true); // TODO: replace toString ("what" argument) with real explanation
    _evaluatedArgument = argument.generateInstructions(scope);
    if (!_evaluatedArgument.staticType.isSubtypeOf(scope.environment().intrinsicsLibrary.coreIntegerType)) {
      throw(concat('Subscript index is not an Integer at ', sourceLocation, ' (is ', _evaluatedArgument.staticType.name, ')'));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.subscriptTypeCheckFailureMessage);
    scope.emitTypeCheck(
      _evaluatedArgument,
      scope.environment().intrinsicsLibrary.coreIntegerType,
      scope.environment().intrinsicsLibrary.subscriptTypeCheckFailureMessage as Slot,
      _evaluatedArgument.debugName,
      true,
    ); // TODO: replace debugName ("what" argument) with real explanation
  }

  Slot generateInstructions(CompiledScope scope) {
    _prepare(scope);
    Slot pointer = scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument);
    // TODO: optimizer should elide the copy if not needed
    rc referenceCountStyle;
    if (_evaluatedElementType.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    DynamicSlot result = scope.registerDynamicValue(_evaluatedElementType, referenceCountStyle, concat('copy of ', _evaluatedList.debugName, '[', _evaluatedArgument.debugName, ']'));
    scope.emitInstruction(MoveDerefInstruction(result, pointer, 0x08, concat('value of ', _evaluatedList.debugName, '[', _evaluatedArgument.debugName, ']')));
    scope.emitInstruction(MoveDerefToTypeInstruction(result, pointer, 0, concat('type of ', _evaluatedList.debugName, '[', _evaluatedArgument.debugName, ']')));
    if (!_evaluatedElementType.neverReferenceCounted()) {
      scope.emitIncref(result, true /* isGCRoot */);
    }
    return result;
  }

  LValue generateLValue(CompiledScope scope) {
    _prepare(scope);
    return SubscriptLValue(_evaluatedElementType, scope.emitSubscriptEvaluation(_evaluatedList, _evaluatedArgument));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(list, context);
    callback(argument, context);
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends LValueExpression {
  Expression object;
  String member;
  
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot lSlot = object.generateInstructions(scope);
    if (lSlot.staticType is ClassType) {
      assert(lSlot is DynamicSlot, 'How could an expression with static type that is a class not return a DynamicSlot when compiled?');
      ClassType class = lSlot.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDefined()) {
        return class.createIdentifierEntity(scope, lSlot as DynamicSlot, member).forRead(scope);
      }
      throw(concat('nonexistent member ', member, ' at ', sourceLocation));
    }
    Integer memberId = scope.environment().atomizeForDynamicDispatch(member);
    Slot dynamicLookup = scope.lookupIntrinsic(scope.environment().dynamicLookupIntrinsicName);
    Slot getter = scope.emitSubroutineCall(dynamicLookup, [ lSlot, scope.environment().integer(memberId) ]:Slot, null);
    Slot result = scope.emitSubroutineCall(getter, [ ]:Slot, null);
    return result;
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

CompiledSubroutine evaluateSuper(CompiledScope scope, String method, SourceLocation sourceLocation) {
  CompiledStackFrameScope stackFrame = scope.stackFrame();
  if (!stackFrame is CompiledSubroutine) {
    throw(concat('super expression used outside method at ', sourceLocation));
  }
  ClassTypeNullable hostClass = (stackFrame as CompiledSubroutine).parentClass;
  if (hostClass == null) {
    throw(concat('super expression used in function instead of method at ', sourceLocation));
  }
  if (hostClass!.supertype == hostClass) {
    assert(hostClass!.supertype == scope.lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName), 'unexpected root class');
    throw(concat('super expression used in base class at ', sourceLocation));
  }
  if (hostClass!.supertype == scope.lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName)) {
    throw(concat('super expression used in base class at ', sourceLocation));
  }
  ClassType superclass = hostClass!.supertype;
  MemberDescriptionNullable memberDescription = superclass.getMember(method);
  if (memberDescription == null) {
    throw(concat('Superclass does not have a method "', method, '" as referenced at ', sourceLocation));
  }
  assert(memberDescription!.isDefined(), 'superclass methods not all defined');
  if (memberDescription == null) {
    throw(concat('Superclass does not have a method "', method, '" as referenced at ', sourceLocation));
  }
  while (memberDescription!.isField) {
    if (superclass.supertype == superclass) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
    superclass = superclass.supertype;
    memberDescription = superclass.getMember(method);
    if (memberDescription == null) {
      throw(concat('Superclass member "', method, '" is a field, not a method, but was referenced in super expression at ', sourceLocation));
    }
  }
  return memberDescription!.methodImplementation!;
}

class SuperExpression extends Expression {
  String method;

  String toStringIndent(Integer indent) {
    return concat('super.', method);
  }

  Slot generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    targetMethod.type.markConstructed();
    return scope.emitSubroutineCall(
      scope.lookupIntrinsic(scope.environment().createMethodPointerIntrinsicName),
      [
        thisMethod.thisPointer,
        CompiledSubroutineSlot(targetMethod, thisMethod.thisPointer /* not used */),
        TypeCodeSlot(scope.environment(), targetMethod.type),
      ]:Slot,
      null /* sourceLocations */,
    );
  }

  Null constructor(String methodArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
  }
}

Slot generateInstructionsForSubroutineCallExpression(CompiledScope scope, Slot subroutine, ExpressionList arguments, Expression subroutineReference, SourceLocation sourceLocation) {
  CompilationEnvironment environment = scope.environment();
  SlotList argumentValues = []:Slot;
  SourceLocationList sourceLocations = []:SourceLocation;
  Type subroutineType;
  if (subroutine is MethodSlot) {
    subroutineType = (subroutine as MethodSlot).subroutineType;
  } else if (subroutine is CompiledSubroutineSlot) {
    subroutineType = (subroutine as CompiledSubroutineSlot).subroutine.type;
  } else {
    subroutineType = subroutine.staticType;
  }
  if (subroutineType.isSubtypeOf(environment.subroutineType)) {
    for (argument in arguments) {
      // xxxx static type checks
      append(sourceLocations, argument.sourceLocation);
      append(argumentValues, argument.generateInstructions(scope));
    }
  } else {
    throw(concat('"', subroutineReference.toStringIndent(0), '" is not a subroutine at ', sourceLocation, ' (is ', subroutineType.name, ')'));
  }
  if (subroutineType is SubroutineTypeWithSpecificParameters) {
    if (len(argumentValues) != len((subroutineType as SubroutineTypeWithSpecificParameters).parameterTypes)) {
      throw(concat('wrong number of arguments to subroutine at ', sourceLocation, ' (expected ', len((subroutineType as SubroutineTypeWithSpecificParameters).parameterTypes), ', got ', len(argumentValues), ')'));
    }
  }
  Type expectedType;
  if (subroutine is MethodSlot || subroutine is CompiledSubroutineSlot) {
    expectedType = environment.intrinsicsLibrary.coreSubroutineCodeAddressType;
  } else {
    expectedType = environment.subroutineType;
  }
  scope.references.add(scope.environment().intrinsicsLibrary.subroutineCallTypeCheckFailureMessage);
  scope.emitTypeCheck(
    subroutine,
    expectedType,
    environment.intrinsicsLibrary.subroutineCallTypeCheckFailureMessage as Slot,
    subroutine.debugName,
    true,
  ); // TODO: replace debugName ("what" argument) with real explanation
  return scope.emitSubroutineCall(subroutine, argumentValues, sourceLocations);
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(subroutineReference, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    return generateInstructionsForSubroutineCallExpression(scope, subroutineReference.generateInstructions(scope), arguments, subroutineReference, sourceLocation);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class VariableSubroutineCallExpression extends Expression {
  String name;
  ExpressionList arguments;

  Null walk(NullFunction callback, Anything context) {
    for (child in arguments) {
      callback(child, context);
    }
  }

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(name, '(', joinList(argumentsList), ')');
  }
  
  Slot lookupCurrentIdentifier(CompiledScope scope) {
    IdentifierEntityNullable entity = scope.lookupIdentifier(name);
    if (entity == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    Slot result = entity!.forCall(scope);
    if (!result.isDefined()) {
      // for compatibility with the interpreter
      throw(concat('Identifier "', name, '" has not yet been defined at ', sourceLocation));
    }
    return result;
  }

  Slot generateVariable(CompiledScope scope) {
    Slot originalSlot = lookupCurrentIdentifier(scope);
    if (originalSlot.isMutable()) {
      rc referenceCountStyle;
      if (originalSlot.staticType.neverReferenceCounted()) {
        referenceCountStyle = rcNever;
      } else {
        referenceCountStyle = rcOnStack;
      }
      DynamicSlot copy = scope.registerDynamicValue(originalSlot.staticType, referenceCountStyle, concat('copy of ', name));
      // TODO: optimizer should elide the copy if not needed
      scope.emitInstruction(MoveInstruction(copy, originalSlot, concat('make a copy of ', name, '\'s value in case it changes before we use it')));
      scope.emitInstruction(MoveTypeToTypeInstruction(copy, originalSlot, scope.environment(), concat('make a copy of ', name, '\'s type in case it changes before we use it')));
      if (!copy.staticType.neverReferenceCounted()) {
        scope.emitIncref(copy, true /* isGCRoot */);
      }
      copy.freeze();
      return copy;
    }
    return originalSlot;
  }

  Slot generateInstructions(CompiledScope scope) {
    return generateInstructionsForSubroutineCallExpression(scope, generateVariable(scope), arguments, this, sourceLocation);
  }

  Null constructor(String nameArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
    arguments = argumentsArg;
  }
}

class MemberAccessSubroutineCallExpression extends Expression {
  Expression object;
  String member;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(object.toStringIndent(indent), '.', member, '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot subroutine;
    Slot lSlot = object.generateInstructions(scope);
    if (lSlot.staticType is ClassType) {
      assert(lSlot is DynamicSlot, 'How could an expression with static type that is a class not return a DynamicSlot when compiled?');
      ClassType class = lSlot.staticType as ClassType;
      MemberDescriptionNullable memberDescription = class.getMember(member);
      if (memberDescription != null && memberDescription!.isDefined()) {
        subroutine = class.createIdentifierEntity(scope, lSlot as DynamicSlot, member).forCall(scope);
      } else {
        throw(concat('nonexistent member ', member, ' at ', sourceLocation));
      }
    } else {
      throw(concat('cannot call member whose static type is not known at compile time; consider casting to AnythingFunction at ', sourceLocation));
      // Integer memberId = scope.environment().atomizeForDynamicDispatch(member);
      // Slot dynamicLookup = scope.lookupIntrinsic(scope.environment().dynamicLookupIntrinsicName);
      // Slot getter = scope.emitSubroutineCall(dynamicLookup, [ lSlot, scope.environment().integer(memberId) ]:Slot, null);
      // subroutine = scope.emitSubroutineCall(getter, [ ]:Slot, null);
    }
    return generateInstructionsForSubroutineCallExpression(scope, subroutine, arguments, this, sourceLocation);
  }

  Null constructor(Expression objectArg, String memberArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
    arguments = argumentsArg;
  }
}

class SuperSubroutineCallExpression extends Expression {
  String method;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat('super.', method, '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in arguments) {
      callback(child, context);
    }
  }

  Slot generateInstructions(CompiledScope scope) {
    CompiledSubroutine targetMethod = evaluateSuper(scope, method, sourceLocation);
    CompiledSubroutine thisMethod = scope.stackFrame() as CompiledSubroutine;
    Slot subroutine = CompiledSubroutineSlot(targetMethod, thisMethod.thisPointer);
    return generateInstructionsForSubroutineCallExpression(scope, subroutine, arguments, this, sourceLocation);
  }

  Null constructor(String methodArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    method = methodArg;
    arguments = argumentsArg;
  }
}

class UnwrapExpression extends Expression {
  Expression lhs;
  
  String toStringIndent(Integer indent) {
    return concat(lhs.toStringIndent(indent), '!');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    // TODO: implement unwrap
    throw('unwrap not implemented');
  }

  Null constructor(Expression lhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot lhs = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    Slot slot = scope.registerDynamicValue(scope.environment().intrinsicsLibrary.coreBooleanType, rcNever, 'is expression result');
    scope.emitStoreTypeCheck(rhs, lhs, slot, concat(expression));
    return slot;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class AsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' as ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot exprSlot = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    if (!rhs.isSubtypeOf(exprSlot.staticType)) {
      throw(concat('Cannot cast ', exprSlot.staticType.name, ' to ', rhs.name, ' at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.asOperatorFailureMessage);
    scope.emitTypeCheck(exprSlot, rhs, scope.environment().intrinsicsLibrary.asOperatorFailureMessage, concat(this), true); // xxx mention the fact that it's a type check in the [what] argument
    // TODO: this new slot should be identical to the source except for the static type, but right now the slot manager can't handle that
    DynamicSlot result = scope.registerDynamicValue(rhs, rcNever, concat('cast of ', exprSlot.debugName, ' to ', rhs.name));
    scope.emitInstruction(MoveInstruction(result, exprSlot, concat('copy value of ', exprSlot.debugName, ' for cast to ', rhs.name)));
    scope.emitInstruction(MoveTypeToTypeInstruction(result, exprSlot, scope.environment(), concat('copy type of ', exprSlot.debugName, ' for cast to ', rhs.name)));
    return result;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretAsOperatorExpression extends Expression {
  Expression expression;
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __as__ ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot exprSlot = expression.generateInstructions(scope);
    Type rhs = type.generateInstructions(scope);
    DynamicSlot result = scope.registerDynamicValue(rhs, rcNever, concat('force cast of ', exprSlot.debugName, ' to ', rhs.name));
    scope.emitInstruction(MoveInstruction(result, exprSlot, result.debugName));
    scope.emitInstruction(SetTypeInstruction(result, rhs));
    return result;
  }

  Null constructor(Expression expressionArg, TypeIdentifier typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class ReinterpretDynamicAsOperatorExpression extends Expression {
  Expression expression;
  Expression type;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' __dynamic_as__ ', type);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    Slot lhs = expression.generateInstructions(scope);
    Slot rhs = type.generateInstructions(scope);
    DynamicSlot result = scope.registerDynamicValue(scope.environment().intrinsicsLibrary.coreAnythingType, rcNever, concat('force cast of ', lhs.debugName, ' to the type with code ', rhs.debugName));
    scope.emitInstruction(MoveInstruction(result, lhs, result.debugName));
    scope.emitInstruction(MoveValueToTypeInstruction(result, rhs));
    return result;
  }

  Null constructor(Expression expressionArg, Expression typeArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    type = typeArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(rhsValue, result, concat(describeOperator(), ' operator')));
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(rhsValue, scope, intrinsics);
    assert(returnType(intrinsics).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    Slot result = scope.registerDynamicValue(returnType(intrinsics), rcNever, concat(describeOperator(), ' unary operator result'));
    generateExpressionInstructions(rhsValue, result, scope, intrinsics);
    scope.emitInstruction(SetTypeInstruction(result, returnType(intrinsics)));
    return result;
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  String describeOperator() {
    return '-';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(MonoOperandInstruction('neg', rhsValue, result, concat(describeOperator(), ' unary operator')));
  }
}

class PlusExpression extends UnaryExpression {
  String describeOperator() {
    return '+';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: hmm
    abstract();
  }
}

class BooleanNotExpression extends UnaryExpression {
  String describeOperator() {
    return '!';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SetSlotIfEqualInstruction(rhsValue, scope.environment().integer(0), result, intrinsics.coreBooleanType, concat(describeOperator(), ' unary operator')));
  }
}

class BitwiseNotExpression extends UnaryExpression {
  String describeOperator() {
    return '~';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(MonoOperandInstruction('not', rhsValue, result, concat(describeOperator(), ' unary operator')));
  }
}

class TypeOfExpression extends UnaryExpression {
  String describeOperator() {
    return '__typeOf';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // no type check at all, we can be called with anything even an internal type
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(MoveTypeToValueInstruction(result, rhsValue));
  }
}

class IteratorTypeOfExpression extends UnaryExpression {
  String describeOperator() {
    return '__iteratorTypeOf';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(ShiftInstruction('shl', rhsValue, scope.environment().integer(2), result, 'multiply type code by 4'));
    scope.emitInstruction(AddInstruction(result, ImmediateDataLabelSlot(scope.environment().intrinsicsLibrary.coreIntegerType, scope.environment().iteratorTypeTableLabel, 'iterator type table pointer'), result, 'offset by the start of the iterator type table'));
    scope.emitInstruction(MoveDwordDerefInstruction(result, result, scope.registerDynamicValue(scope.environment().intrinsicsLibrary.coreIntegerType, rcNever, 'scratch'), 0, 'dereference to get iterator type'));
  }
}

class ListTypeOfExpression extends UnaryExpression {
  String describeOperator() {
    return '__listTypeOf';
  }

  Null generateTypeCheckInstructions(Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as operand of unary ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(ShiftInstruction('shl', rhsValue, scope.environment().integer(2), result, 'multiply type code by 4'));
    scope.emitInstruction(AddInstruction(result, ImmediateDataLabelSlot(scope.environment().intrinsicsLibrary.coreIntegerType, scope.environment().listTypeTableLabel, 'list type table pointer'), result, 'offset by the start of the list type table'));
    scope.emitInstruction(MoveDwordDerefInstruction(result, result, scope.registerDynamicValue(scope.environment().intrinsicsLibrary.coreIntegerType, rcNever, 'scratch'), 0, 'dereference to get list type'));
  }
}

// This marks the type as constructed, but not as type checked.
class TypeToCodeExpression extends Expression {
  TypeIdentifier rhs;

  String describeOperator() {
    return '__typeToCode';
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Slot generateInstructions(CompiledScope scope) {
    Type rhsValue = rhs.generateInstructions(scope);
    rhsValue.markConstructed();
    return TypeCodeSlot(scope.environment(), rhsValue);
  }

  Null constructor(TypeIdentifier rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() {
    abstract();
    // e.g.:
    // return '+';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true);
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true);
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // return intrinsics.coreIntegerType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }
  
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
    callback(rhs, context);
  }

  Slot generateInstructions(CompiledScope scope) {
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot lhsValue = lhs.generateInstructions(scope);
    Slot rhsValue = rhs.generateInstructions(scope);
    generateTypeCheckInstructions(lhsValue, rhsValue, scope, intrinsics);
    assert(returnType(intrinsics).neverReferenceCounted(), concat(className, '\'s returnType is potentially reference countable?!'));
    Slot result = scope.registerDynamicValue(returnType(intrinsics), rcNever, concat(describeOperator(), ' operator result'));
    generateExpressionInstructions(lhsValue, rhsValue, result, scope, intrinsics);
    scope.emitInstruction(SetTypeInstruction(result, returnType(intrinsics)));
    return result;
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class NumericOperatorExpression extends OperatorExpression {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!lhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', lhsValue.staticType.name, ', as left hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true); // TODO: replace toString ("what" argument) with real explanation
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as right hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreIntegerType;
  }
}

class OperatorAdditionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '+';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(AddInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorSubtractionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '-';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SubInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorMultiplicationExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '*';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(SignedMultiplyInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorDivisionExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '/';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(IntegerDivisionInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorModulusExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '%';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(IntegerRemainderInstruction(lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseAndExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '&';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('and', lhsValue, rhsValue, result,   concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseOrExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '|';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('or', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorBitwiseXorExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '^';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('xor', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorLeftShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '<<';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: this needs to check if the count operand is more than 6 bits
    scope.emitInstruction(ShiftInstruction('shl', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorRightShiftExpression extends NumericOperatorExpression {
  String describeOperator() {
    return '>>';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: this needs to check if the count operand is more than 6 bits
    scope.emitInstruction(ShiftInstruction('shr', lhsValue, rhsValue, result, concat('compute (', lhsValue.debugName, ') ', describeOperator(), ' (', rhsValue.debugName, ')')));
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '==';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType.name, ' and ', rhsValue.staticType.name));
    }
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.storeEquality(lhsValue, rhsValue, result, false);
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '!=';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // accepts any type if it's plausibly useful to compare them
    if (!(lhsValue.staticType.isSubtypeOf(rhsValue.staticType) || rhsValue.staticType.isSubtypeOf(lhsValue.staticType))) {
      throw(concat('Expected compatible types for ', describeOperator(), ' operator at ', sourceLocation, ' but found ', lhsValue.staticType, ' and ', rhsValue.staticType));
    }
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.storeEquality(lhsValue, rhsValue, result, true);
  }
}

class OperatorNumericCmpExpression extends OperatorExpression {
  cc flag() {
    abstract();
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!lhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', lhsValue.staticType.name, ', as left hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true); // TODO: replace toString ("what" argument) with real explanation
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreIntegerType)) {
      throw(concat('Expected Integer, but found ', rhsValue.staticType.name, ', as right hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(StoreCmpInstruction(lhsValue, rhsValue, result, flag()));
  }
}

class OperatorLessThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<';
  }

  cc flag() {
    return ccLessThan;
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '<=';
  }

  cc flag() {
    return ccLessThanOrEqual;
  }
}

class OperatorGreaterThanExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>';
  }

  cc flag() {
    return ccGreaterThan;
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorNumericCmpExpression {
  String describeOperator() {
    return '>=';
  }

  cc flag() {
    return ccGreaterThanOrEqual;
  }
}

class OperatorLogicalAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&&';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!lhsValue.staticType.isSubtypeOf(intrinsics.coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as left hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(lhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true); // TODO: replace toString ("what" argument) with real explanation
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as right hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: implement logical and 
    throw('&& not implemented');
  }
}

class OperatorLogicalOrExpression extends OperatorExpression {
  String describeOperator() {
    return '||';
  }

  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    if (!lhsValue.staticType.isSubtypeOf(intrinsics.coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', lhsValue.staticType.name, ', as left hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(lhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(lhs), true); // TODO: replace toString ("what" argument) with real explanation
    if (!rhsValue.staticType.isSubtypeOf(intrinsics.coreBooleanType)) {
      throw(concat('Expected Boolean, but found ', rhsValue.staticType.name, ', as right hand operand of ', describeOperator(), ' operator at ', sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(rhsValue, intrinsics.coreBooleanType, intrinsics.operandTypeCheckFailureMessage, concat(rhs), true); // TODO: replace toString ("what" argument) with real explanation
  }

  Type returnType(CompiledIntrinsicsLibrary intrinsics) {
    return intrinsics.coreBooleanType;
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    // TODO: implement logical or
    throw('|| not implemented');
  }
}

class DeclarationStatement extends Statement {
  String identifier;

  // Static type of the thing being declared.
  Type staticType; // must be set by generateInstructions

  Null constructor(String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
  }
}

class FieldDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }

  Null generateInitializerInstructions(CompiledScope constructor) {
    if (rValue != null) {
      Slot rSlot = rValue!.generateInstructions(constructor);
      if (!rSlot.staticType.isSubtypeOf(staticType)) {
        throw(concat('Cannot assign ', rSlot.staticType.name, ' to field of type ', staticType.name, ' at ', sourceLocation));
      }
      constructor.references.add(constructor.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage);
      constructor.emitTypeCheck(rSlot, staticType, constructor.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage as Slot, rSlot.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
      (constructor as CompiledSubroutine).parentClass!.createIdentifierEntity(constructor as CompiledSubroutine, (constructor as CompiledSubroutine).thisPointer, identifier).write(constructor, rSlot);
    }
  }

  Null declare(ClassType classType, CompiledScope scope) {
    staticType = type.generateInstructions(scope);
    MemberDescriptionNullable inheritedMember = classType.getMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (!staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    classType.registerMember(identifier, staticType, true, generateInitializerInstructions);
  }
  
  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledSubroutine, 'FieldDeclarationStatement compiled outside of class constructor');
    assert((scope as CompiledSubroutine).parentClass != null, 'FieldDeclarationStatement compiled outside of class');
    generateInitializerInstructions(scope);
    (scope as CompiledSubroutine).parentClass!.getMember(identifier)!.define();
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    type = typeArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  ExpressionNullable rValue;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }
  
  Null generateInstructions(CompiledScope scope) {
    staticType = type.generateInstructions(scope);
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    DynamicSlot lSlot = scope.registerVariable(identifier, staticType);
    if (rValue != null) {
      Slot rSlot = rValue!.generateInstructions(scope);
      if (!rSlot.staticType.isSubtypeOf(lSlot.staticType)) {
        throw(concat('Cannot assign ', rSlot.staticType.name, ' to variable of type ', lSlot.staticType.name, ' at ', sourceLocation));
      }
      scope.references.add(scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage);
      scope.emitTypeCheck(rSlot, staticType, scope.environment().intrinsicsLibrary.assignmentTypeCheckFailureMessage as Slot, rSlot.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
      scope.emitInstruction(MoveInstruction(lSlot, rSlot, concat('value initialization of variable declaration for ', lSlot.debugName, ' (', rSlot.debugName, ')')));
      scope.emitInstruction(MoveTypeToTypeInstruction(lSlot, rSlot, scope.environment(), concat('type initialization of variable declaration for ', lSlot.debugName)));
      scope.emitIncref(lSlot, true);
    }
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    type = typeArg;
    rValue = rValueArg;
  }
}

class AbstractSubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  Boolean isVarArgs;
  StatementBlock body;

  Null walk(NullFunction callback, Anything context) {
    callback(body, context);
  }

  ClassTypeNullable receiverType() {
    abstract();
  }

  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    abstract();
  }

  CompiledSubroutine subroutine;

  Null generateStaticType(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
    }
    if (isVarArgs) {
      assert(len(compiledParameterTypes) == 1, 'unexpected number of parameters to varargs function');
      staticType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
      createOrFindIteratorType(scope.environment(), compiledParameterTypes[0]).markConstructed();
      createOrFindListType(scope.environment(), compiledParameterTypes[0]).markConstructed();
    } else {
      staticType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        compiledReturnType,
        compiledParameterTypes,
      );
    }
  }

  Null generateInstructions(CompiledScope scope) {
    assert(staticType != null, 'call generateStaticType before generateInstructions');
    if (isVarArgs) {
      subroutine = CompiledVarArgsSubroutine(scope, staticType as SubroutineTypeWithVarArgs, identifier, receiverType());
      String name = parameters[0][1] as String;
      Type type = (staticType as SubroutineTypeWithVarArgs).parameterType;
      (subroutine as CompiledVarArgsSubroutine).emitVarArgsParameterChecks(type, (subroutine as CompiledVarArgsSubroutine).registerVarArgsParameter(name, type) as VarArgsParameterSlot);
    } else {
      subroutine = CompiledSubroutineWithSpecificParameters(scope, staticType as SubroutineTypeWithSpecificParameters, identifier, receiverType());
      SlotList parameterSlots = []:Slot;
      Integer index = 0;
      for (parameter in parameters) {
        String name = parameter[1] as String;
        Type type = (staticType as SubroutineTypeWithSpecificParameters).parameterTypes[index];
        append(parameterSlots, (subroutine as CompiledSubroutineWithSpecificParameters).registerParameter(name, type, index));
        index += 1;
      }
      (subroutine as CompiledSubroutineWithSpecificParameters).emitParameterChecks(parameterSlots);
    }
    registerSubroutine(scope, subroutine);
    body.generateInstructions(subroutine);
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg) {
    assert(!isVarArgsArg || (len(parametersArg) == 1), 'varargs is only valid with a single parameter');
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    isVarArgs = isVarArgsArg;
    body = bodyArg;
  }
}

class MethodDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  ClassType parentClass;

  Null declare(ClassType classType, CompiledScope scope) {
    generateStaticType(scope);
    MemberDescriptionNullable inheritedMember = classType.getMember(identifier);
    if (inheritedMember != null) {
      if (inheritedMember!.isInherited) {
        if (!staticType.isSubtypeOf(inheritedMember!.staticType)) {
          throw(concat('Inherited ', identifier, ' has type ', inheritedMember!.staticType.name,
                       ', but is overridden with incompatible type ', staticType.name, ' at ', sourceLocation));
        }
      } else {
        throw(concat('Identifier ', identifier, ' redeclared at ', sourceLocation));
      }
    }
    classType.registerMember(identifier, staticType, false, null);
    parentClass = classType;
  }
  
  ClassTypeNullable receiverType() {
    return parentClass;
  }

  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    scope.registerNestedScope(subroutine);
    MemberDescription member = parentClass.getMember(identifier)!;
    member.define();
    member.setMethodImplementation(subroutine);
    scope.environment().addSubroutine(subroutine);
    scope.references.add(SubroutineSlot(subroutine, false));
  }
}

class SubroutineDeclarationStatement extends AbstractSubroutineDeclarationStatement {
  Boolean isIntrinsic;

  ClassTypeNullable receiverType() {
    return null;
  }

  Null registerSubroutine(CompiledScope scope, CompiledSubroutine subroutine) {
    SubroutineSlot slot = scope.registerSubroutine(subroutine, false);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(slot);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    super.generateStaticType(scope);
    super.generateInstructions(scope);
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, Boolean isVarArgsArg, StatementBlock bodyArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(returnTypeArg, identifierArg, parametersArg, isVarArgsArg, bodyArg, sourceLocationArg);
    isIntrinsic = isIntrinsicArg;
  }
}  

class GenericSystemSubroutineDeclarationStatement extends DeclarationStatement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  String library;
  String externalName;
  Boolean isIntrinsic;

  Null generateInstructions(CompiledScope scope) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    StringList compiledParameterNames = []:String;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
      append(compiledParameterNames, entry[1] as String);
    }
    CompiledSubroutine subroutine = GenericSystemCallSubroutine(
      scope,
      compiledReturnType,
      compiledParameterTypes,
      compiledParameterNames,
      library,
      externalName,
      identifier,
    );
    staticType = subroutine.type;
    SubroutineSlot slot = scope.registerSubroutine(subroutine, false);
    if (isIntrinsic) {
      scope.environment().registerIntrinsic(slot);
    }
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') __extern \'', escapeString(library), '\' \'', escapeString(externalName), '\'\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, String libraryArg, String externalNameArg, SourceLocation sourceLocationArg, Boolean isIntrinsicArg) {
    super.constructor(identifierArg, sourceLocationArg);
    returnType = returnTypeArg;
    parameters = parametersArg;
    library = libraryArg;
    externalName = externalNameArg;
    isIntrinsic = isIntrinsicArg;
  }
}  

class EnumDeclaration extends DeclarationStatement {
  String identifier;
  StringList values;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', identifier, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    if (scope.environment().isCompoundType(identifier)) {
      throw(concat('"', identifier, '" is not a valid enum type name at ', sourceLocation));
    }
    staticType = EnumType(scope.environment(), identifier);
    globalScope.declareType(staticType);
    Integer index = 0;
    for (value in values) {
      String name = concat(identifier, value);
      if (scope.isIdentifierDeclaredInLocalScope(name)) {
        throw(concat('Cannot redeclare identifier "', name, '" at ', sourceLocation));
      }
      scope.registerNumericConstant(name, index, staticType);
      index += 1;
    }
  }

  Null constructor(String identifierArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    values = valuesArg;
  }
}

class AbstractClassDeclaration extends DeclarationStatement {
  TypeIdentifierNullable superclassName;
  Boolean isIntrinsic;
  
  Null declareType(CompiledScope scope) {
    TypeNullable superclass;
    if (isIntrinsic && identifier == scope.environment().coreClassTypeIntrinsicName) {
      if (superclassName != null) {
        throw(concat('Intrinsic class cannot have a superclass as ', sourceLocation));
      }
      superclass = null;
    } else if (superclassName == null) {
      superclass = scope.lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName);
    } else {
      superclass = superclassName!.generateInstructions(scope);
    }
    staticType = ClassType(scope.environment(), identifier, superclass);
    scope.globalScope().declareType(staticType);
    if (isIntrinsic) {
      scope.environment().registerClassIntrinsic(staticType as ClassType);
    }
  }

  Null declareConstructor(CompiledScope scope, TypeList parameters, Boolean isVarArgs) {
    if (scope.isIdentifierDeclaredInLocalScope(identifier)) {
      throw(concat('Cannot redeclare identifier "', identifier, '" at ', sourceLocation));
    }
    AbstractSubroutineTypeWithSpecificParameters subroutineType;
    if (isVarArgs) {
      subroutineType = createOrFindSubroutineTypeWithVarArgs(
        scope.environment(),
        staticType,
        parameters,
      );
    } else {
      subroutineType = createOrFindSubroutineTypeWithSpecificParameters(
        scope.environment(),
        staticType,
        parameters,
      );
    }
    CompiledGeneratedConstructorSubroutine constructor = CompiledGeneratedConstructorSubroutine(scope, subroutineType, identifier, staticType as ClassType);
    (staticType as ClassType).setConstructorSubroutine(scope.registerSubroutine(constructor, true));
  }

  Null constructor(String identifierArg, TypeIdentifierNullable superclassNameArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    superclassName = superclassNameArg;
    isIntrinsic = isIntrinsicArg;
  }
}

class ForwardClassDeclaration extends AbstractClassDeclaration {
  TypeIdentifierListNullable constructorParameterTypes;
  Boolean isVarArgs;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['fwdclass ', identifier, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, ';\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    declareType(scope);
    if (constructorParameterTypes != null) {
      TypeList parameterTypes = []:Type;
      for (identifier in constructorParameterTypes!) {
        append(parameterTypes, identifier.generateInstructions(scope));
      }
      assert(!isVarArgs || len(parameterTypes) == 1, 'varargs must have one parameter in their list');
      declareConstructor(scope, parameterTypes, isVarArgs);
    } else {
      assert((staticType as ClassType).supertype != scope.lookupIntrinsicClass(scope.environment().coreClassTypeIntrinsicName), 'parser failed to give empty list of arguments');
      // If no parameters are given on the fwdclass declaration, but the declaration
      // has a superclass, then the arguments from the superclass constructor are implied.
      declareConstructor(
        scope,
        ((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes,
        (staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithVarArgs,
      );
    }
  }

  Null constructor(String classNameArg, TypeIdentifierListNullable constructorParameterTypesArg, Boolean isVarArgsArg, TypeIdentifierNullable superclassNameArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, isIntrinsicArg, sourceLocationArg);
    constructorParameterTypes = constructorParameterTypesArg;
    isVarArgs = isVarArgsArg;
  }
}

class ClassDeclaration extends AbstractClassDeclaration {
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', identifier, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName!.toStringIndent(indent));
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  String kConstructor = 'constructor';

  Null generateInstructions(CompiledScope scope) {
    TypeNullable existingStaticType = scope.globalScope().lookupType(identifier);
    if (existingStaticType == null) {
      declareType(scope);
    } else {
      staticType = existingStaticType!;
      // either someone declared an unrelated type with the same name (bad)
      // or, they used fwdclass (good).
      if (!(staticType is ClassType)) {
        throw(concat('Type ', identifier, ' redeclared at ', sourceLocation));
      } else if ((staticType as ClassType).members.length != 0) {
        throw(concat('Class ', identifier, ' redeclared at ', sourceLocation));
      } else if (superclassName == null) {
        if ((staticType as ClassType).supertype != staticType) {
          throw(concat('Forward class declaration for ', identifier, ' used supertype ', (staticType as ClassType).supertype.name, ', but class declaration had no supertype at ', sourceLocation));
        }
      } else {
        Type superclass = superclassName!.generateInstructions(scope);
        if (superclass != (staticType as ClassType).supertype) {
          throw(concat('Forward class declaration for ', identifier, ' used supertype ', (staticType as ClassType).supertype.name, ', but class declaration uses supertype ', superclass.name, ', at ', sourceLocation));
        }
      }
    }
    (staticType as ClassType).markAsDefined();
    if (!(staticType as ClassType).supertype.isDefined) {
      assert(superclassName != null, 'we were not defined wat');
      throw(concat('Cannot extend a class that has not yet been defined at ', superclassName!.sourceLocation));
    }
    // register members on the class type
    (staticType as ClassType).inheritMembersFromSupertype();
    for (member in members) {
      if (member is FieldDeclarationStatement) {
        (member as FieldDeclarationStatement).declare(staticType as ClassType, scope);
      } else if (member is MethodDeclarationStatement) {
        (member as MethodDeclarationStatement).declare(staticType as ClassType, scope);
      } else {
        assert(false, concat('unexpected declaration statement (', member.className, ') in class at ', member.sourceLocation));
      }
    }
    DeclarationStatementNullable constructorMember = null;
    for (member in members) {
      if (member.identifier == kConstructor) {
        // we found it!
        constructorMember = member;
        break;
      }
    }
    TypeList constructorParameters;
    Boolean constructorIsVarArgs;
    if (constructorMember != null) {
      // we have an explicit constructor
      if (!constructorMember!.staticType.isSubtypeOf(createOrFindSubroutineTypeWithAnyArgs(scope.environment(), scope.environment().intrinsicsLibrary.coreNullType))) {
        throw(concat('Constructor must be a NullFunction, but is declared as a ', constructorMember!.staticType.name, ' at ', constructorMember!.sourceLocation));
      }
      if (constructorMember is AbstractSubroutineDeclarationStatement) {
        // constructor was declared as a method on this class
        if ((constructorMember as AbstractSubroutineDeclarationStatement).isVarArgs) {
          constructorParameters = [(constructorMember!.staticType as SubroutineTypeWithVarArgs).parameterType]:Type;
          constructorIsVarArgs = true;
        } else {
          assert(constructorMember!.staticType is SubroutineTypeWithSpecificParameters, 'unexpected subroutine type');
          Type getTypes(Anything tuple) {
            return ((tuple as AnythingList)[0] as TypeIdentifier).generateInstructions(scope);
          }
          constructorParameters = map((constructorMember as AbstractSubroutineDeclarationStatement).parameters, getTypes) as TypeList;
          constructorIsVarArgs = false;
        }
      } else {
        // constructor was probably declared as a property on this class (grr!)
        assert(constructorMember!.staticType is SubroutineTypeWithAnyArguments, 'unexpected subroutine type');
        constructorParameters = [scope.environment().intrinsicsLibrary.coreAnythingType]:Type;
        constructorIsVarArgs = true;
      }
    } else if ((staticType as ClassType).supertype == staticType) {
      // this must be the __Object definition
      throw(concat('Base class must have an explicit constructor but has none at ', sourceLocation));
    } else {
      // we did not have an explicit constructor, so our constructor just defers to the superclass constructor
      if ((staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithVarArgs) {
        constructorParameters = [((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithVarArgs).parameterType]:Type;
        constructorIsVarArgs = true;
      } else {
        assert((staticType as ClassType).supertype.constructorSubroutine.staticType is SubroutineTypeWithSpecificParameters, 'unexpected subroutine type');
        constructorParameters = ((staticType as ClassType).supertype.constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes;
        constructorIsVarArgs = false;
      }
    }
    if (existingStaticType != null) {
      // we must have had a forward class declaration; check that what we are going to define matches it
      if (constructorIsVarArgs) {
        assert(len(constructorParameters) == 1, 'internal inconsistency');
        if (!((staticType as ClassType).constructorSubroutine.staticType is SubroutineTypeWithVarArgs) ||
             ((staticType as ClassType).constructorSubroutine.staticType as SubroutineTypeWithVarArgs).parameterType != constructorParameters[0]) {
          throw(concat('Forward class declaration constructor signature did not match constructor declaration at ', constructorMember!.sourceLocation));
        }
      } else {
        if (!((staticType as ClassType).constructorSubroutine.staticType is SubroutineTypeWithSpecificParameters) ||
            !listEquals(((staticType as ClassType).constructorSubroutine.staticType as SubroutineTypeWithSpecificParameters).parameterTypes, constructorParameters)) {
          throw(concat('Forward class declaration constructor signature did not match constructor declaration at ', constructorMember!.sourceLocation));
        }
      }
    } else {
      declareConstructor(scope, constructorParameters, constructorIsVarArgs);
    }
    SubroutineSlot constructorScopeSlot = (staticType as ClassType).constructorSubroutine;
    constructorScopeSlot.markAsDefined();
    CompiledGeneratedConstructorSubroutine constructorScope = constructorScopeSlot.subroutine as CompiledGeneratedConstructorSubroutine;
    Slot classAllocator = constructorScope.lookupIntrinsic(scope.environment().classAllocatorIntrinsicName);
    Slot thisSlot = constructorScope.emitSubroutineCall(classAllocator, [ VmtSlot(scope.environment(), staticType as ClassType) ]:Slot, null);
    assert(thisSlot is DynamicSlot, 'Tried to inline class allocator?');
    constructorScope.setThisPointer(thisSlot as DynamicSlot);
    // call initializers
    ClassTypeList classHierarchy = []:ClassType;
    ClassType classType = staticType as ClassType;
    while (classType.supertype != classType) {
      classType = classType.supertype;
      append(classHierarchy, classType);
    }
    Integer index = len(classHierarchy) - 1;
    while (index >= 0) {
      for (initializer in classHierarchy[index].initializers) {
        initializer(constructorScope);
      }
      index -= 1;
    }
    for (member in members) {
      member.generateInstructions(constructorScope);
    }
    if ((staticType as ClassType).supertype != staticType) {
      (staticType as ClassType).constructorSubroutine.subroutine.references.add((staticType as ClassType).supertype.constructorSubroutine);
    }
    Slot lookup = constructorScope.localLookupIdentifier('constructor')!.forCall(constructorScope);
    constructorScope.setActualConstructor(TailRecursionCodePointerSlot(scope.environment().intrinsicsLibrary.coreSubroutineCodeAddressType, 'class constructor code address'));
    constructorScope.emitInstruction(MoveInstruction(constructorScope.actualConstructor, lookup, concat('copy address of \'', constructorScope.parentClass!.name, '.constructor\' method for use with "jmp" below' /* in generateFinalReturn */)));
    constructorScope.emitReturnFrom(constructorScope, thisSlot);
  }

  Null constructor(String classNameArg, TypeIdentifierNullable superclassNameArg, DeclarationStatementList membersArg, Boolean isIntrinsicArg, SourceLocation sourceLocationArg) {
    super.constructor(classNameArg, superclassNameArg, isIntrinsicArg, sourceLocationArg);
    members = membersArg;
  }
}

class ForwardClassPropertyDeclaration extends DeclarationStatement {
  TypeIdentifier propertyType;
  TypeIdentifier hostClass;
  
  String toStringIndent(Integer indent) {
    return concat('fwdclassprop ', propertyType.toStringIndent(indent), ' ', hostClass.toStringIndent(indent), '.', identifier, ';\n');
  }

  Null generateInstructions(CompiledScope scope) {
    // TODO: declare the property on the class
    // TODO: must set this.staticType (from DeclarationStatement)
  }

  Null constructor(TypeIdentifier hostClassArg, TypeIdentifier propertyTypeArg, String identifierArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, sourceLocationArg);
    hostClass = hostClassArg;
    propertyType = propertyTypeArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    if (!(scope.stackFrame() is CompiledSubroutine)) {
      throw(concat('Invalid return; not in a function at ', sourceLocation));
    }
    CompiledSubroutine subroutine = scope.stackFrame() as CompiledSubroutine;
    if (expression != null) {
      Slot returnValue = expression!.generateInstructions(scope);
      if (!returnValue.staticType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Type of return statement (', returnValue.staticType.name, ') does not match expected return type (', subroutine.type.returnType.name, ') at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, returnValue);
    } else {
      if (!scope.environment().intrinsicsLibrary.coreNullType.isSubtypeOf(subroutine.type.returnType)) {
        throw(concat('Tried to return null from a function whose expected return type is ', subroutine.type.returnType.name, ' at ', sourceLocation));
      }
      subroutine.emitReturnFrom(scope, scope.environment().intrinsicsLibrary.coreNull);
    }
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class BreakStatement extends Statement {
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'break;\n');
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid break; not in a loop at ', this));
    }
    (loopScope as CompiledLoopScope).emitBreakInstructionFrom(scope);
  }
}

class ContinueStatement extends Statement {
  String toStringIndent(Integer indent) {
    return concat(stringTimes(' ', indent), 'continue;\n');
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledScopeNullable loopScope = scope;
    while (loopScope != null && !(loopScope is CompiledLoopScope)) {
      loopScope = loopScope!.parent;
    }
    if (loopScope == null) {
      throw(concat('Invalid continue; not in a loop at ', this));
    }
    (loopScope as CompiledLoopScope).emitContinueInstructionFrom(scope);
  }
}

class ImportStatement extends Statement {
  String path;
  
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope.environment().getLibraryState(path) == lsDefined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(path) as CompiledLibrary);
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class StraightAssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' = ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null generateInstructions(CompiledScope scope) {
    Slot rSlot = rValue.generateInstructions(scope);
    lValue.generateLValue(scope).assign(scope, rSlot, sourceLocation);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class AssignmentStatement extends Statement {
  LValueExpression lValue;
  Expression rValue;

  String describeOperator() { abstract(); }
  Slot computeResult(CompiledScope scope, Slot lSlot, Slot rSlot) { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null generateInstructions(CompiledScope scope) {
    Slot lSlot = lValue.generateInstructions(scope);
    // TODO: verify that lSlot is assignable
    // In particular, parameters (including dereferenced varargs) and constants are not assignable.
    Slot rSlot = rValue.generateInstructions(scope);
    Slot result = computeResult(scope, lSlot, rSlot);
    lValue.generateLValue(scope).assign(scope, result, sourceLocation);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(LValueExpression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class OperatorAssignmentStatement extends AssignmentStatement {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(lhsValue.source), true);
    // scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, concat(rhsValue.source), true);
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    abstract();
    // e.g.:
    // scope.emitInstruction(AdditionInstruction(scope, lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
  }

  Slot computeResult(CompiledScope scope, Slot lSlot, Slot rSlot) {
    CompiledIntrinsicsLibrary intrinsics = scope.environment().intrinsicsLibrary as CompiledIntrinsicsLibrary;
    Slot lhsValue = lSlot;
    Slot rhsValue = rSlot;
    rc referenceCountStyle;
    if (lSlot.staticType.neverReferenceCounted()) {
      referenceCountStyle = rcNever;
    } else {
      referenceCountStyle = rcOnStack;
    }
    Slot result = scope.registerDynamicValue(lSlot.staticType, referenceCountStyle, concat(describeOperator(), ' operator result'));
    generateTypeCheckInstructions(lhsValue, rhsValue, scope, intrinsics);
    generateExpressionInstructions(lhsValue, rhsValue, result, scope, intrinsics);
    if (!lSlot.staticType.neverReferenceCounted()) {
      scope.emitIncref(result, true /* isGCRoot */); // should never actually do anything but since we can't prove it...
    }
    return result;
  }
}

class NumericOperatorAssignmentStatement extends OperatorAssignmentStatement {
  Null generateTypeCheckInstructions(Slot lhsValue, Slot rhsValue, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(lhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, lhsValue.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
    scope.emitTypeCheck(rhsValue, intrinsics.coreIntegerType, intrinsics.operandTypeCheckFailureMessage, rhsValue.debugName, true); // TODO: replace debugName ("what" argument) with real explanation
  }
}

class PlusAssignmentStatement extends NumericOperatorAssignmentStatement {
  String describeOperator() {
    return '+=';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('add', lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
    scope.emitInstruction(SetTypeInstruction(result, intrinsics.coreIntegerType));
  }
}

class MinusAssignmentStatement extends NumericOperatorAssignmentStatement {
  String describeOperator() {
    return '-=';
  }

  Null generateExpressionInstructions(Slot lhsValue, Slot rhsValue, Slot result, CompiledScope scope, CompiledIntrinsicsLibrary intrinsics) {
    scope.emitInstruction(BiOperandInstruction('sub', lhsValue, rhsValue, result, concat(describeOperator(), ' operator')));
    scope.emitInstruction(SetTypeInstruction(result, intrinsics.coreIntegerType));
  }
}

class AsteriskAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '*=';
  }
}

class SlashAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '/=';
  }
}

class ModulusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '%=';
  }
}

class BitwiseAndAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '&=';
  }
}

class BitwiseXorAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '^=';
  }
}

class BitwiseOrAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '|=';
  }
}

class ElseClause extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  Null generateInstructions(CompiledScope scope) {
    Slot expressionHandle = expression.generateInstructions(scope);
    if (!expressionHandle.staticType.isSubtypeOf(scope.environment().intrinsicsLibrary.coreBooleanType)) {
      throw(concat('If expression must be a boolean, not a ', expressionHandle.staticType.name, ', at ', sourceLocation));
    }
    CompiledNestedScope blockScope = CompiledNestedScope(scope, scope.environment().generateLabel(concat(camelCase(scope.name), '$if')));
    block.generateInstructions(blockScope);
    CompiledNestedScopeNullable elseBlockScope = null;
    if (elseClause != null) {
      elseBlockScope = CompiledNestedScope(scope, scope.environment().generateLabel(concat(camelCase(scope.name), '$else')));
      elseClause!.generateInstructions(elseBlockScope!);
    }
    scope.references.add(scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage);
    scope.emitTypeCheck(expressionHandle, scope.environment().intrinsicsLibrary.coreBooleanType, scope.environment().intrinsicsLibrary.operandTypeCheckFailureMessage, 'if condition', true); // xxx mention the fact that it's a type check in the [what] argument
    scope.emitConditionalBlock(blockScope, elseBlockScope, expressionHandle, (scope.environment().intrinsicsLibrary.coreFalse as Slot), 'if', concat(expression));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
    if (elseClause != null) {
      callback(elseClause, context);
    }
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    block.generateInstructions(scope);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(ifClause, context);
  }

  Null generateInstructions(CompiledScope scope) {
    ifClause.generateInstructions(scope);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'while');
    String loopBodyLabel = loopScope.environment().generateLabel(concat(scope.labelPrefix(), '$', loopScope.name, '$body'));
    loopScope.emitInstruction(JumpIfNotEqualInstruction(
      expression.generateInstructions(loopScope),
      scope.environment().intrinsicsLibrary.coreFalse,
      loopBodyLabel,
      'while condition',
    ));
    loopScope.emitBreakInstructionFrom(loopScope);
    loopScope.emitInstruction(LabelInstruction(loopBodyLabel, concat('start of ', loopScope.name)));
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variable;
  Expression iterable;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variable,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(iterable, context);
    callback(block, context);
  }

  Null generateInstructions(CompiledScope scope) {
    CompilationEnvironment environment = scope.environment();
    Slot iterableSlot = iterable.generateInstructions(scope);
    if (!iterableSlot.staticType.isSubtypeOf(environment.iterableType)) {
      throw(concat('Expected an iterable type in "for" statement, but ', iterable.toStringIndent(0), ' is of type ', iterableSlot.staticType.name, ' at ', iterable.sourceLocation));
    }
    scope.references.add(scope.environment().intrinsicsLibrary.forLoopIterableTypeCheckFailureMessage);
    scope.emitTypeCheck(iterableSlot, environment.iterableType, environment.intrinsicsLibrary.forLoopIterableTypeCheckFailureMessage, concat(iterable), true); // TODO: replace toString ("what" argument) with real explanation
    Slot iteratorSlot = scope.emitSubroutineCall(
      scope.lookupIntrinsic(environment.iteratorIntrinsicName),
      [ iterableSlot ]:Slot,
      null,
    );
    CompiledLoopScope loopScope = CompiledLoopScope(scope, 'for');
    String loopBodyLabel = environment.generateLabel(concat(scope.labelPrefix(), '$', loopScope.name, '$body'));
    loopScope.emitInstruction(JumpIfNotEqualInstruction(
      loopScope.emitSubroutineCall(
        loopScope.lookupIntrinsic(environment.nextIntrinsicName),
        [ iteratorSlot ]:Slot,
        null,
      ),
      environment.intrinsicsLibrary.coreFalse,
      loopBodyLabel,
      'for loop condition',
    ));
    Type variableType;
    if (iterableSlot.staticType is IterableType) {
      variableType = (iterableSlot.staticType as IterableType).elementType;
    } else {
      variableType = environment.intrinsicsLibrary.coreWhateverType;
    }
    loopScope.emitBreakInstructionFrom(loopScope);
    loopScope.emitInstruction(LabelInstruction(loopBodyLabel, concat('start of ', loopScope.name)));
    assert(loopScope.identifiers.length == 0, 'newly created scope has identifiers in scope');
    DynamicSlot variableSlot = loopScope.registerVariable(variable, variableType);
    Slot currentValue = loopScope.emitSubroutineCall(
      loopScope.lookupIntrinsic(environment.currentIntrinsicName),
      [ iteratorSlot ]:Slot,
      null,
    );
    loopScope.emitInstruction(MoveInstruction(variableSlot, currentValue, concat('value initialization of for loop variable ', variable)));
    loopScope.emitInstruction(MoveTypeToTypeInstruction(variableSlot, currentValue, environment, concat('type initialization of for loop variable ', variable)));
    loopScope.emitIncref(variableSlot, true);
    block.generateInstructions(loopScope);
    scope.emitBlock(loopScope);
  }

  Null constructor(String variableArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variable = variableArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }

  CompiledLibrary generateScopes(CompilationEnvironment compilationEnvironmentArg) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    generateInstructions(result);
    return result;
  }
}

class Program extends Library {
  Null generateInstructions(CompiledScope scope) {
    super.generateInstructions(scope);
    scope.emitInstruction(CommentInstruction('Terminate application - call exit(0)'));
    Slot exitCode = scope.environment().integer(0);
    scope.emitSubroutineCall(scope.lookupIntrinsic(scope.environment().exitIntrinsicName), [exitCode]:Slot, null /* sourceLocations */);
  }
}