import 'core.syd';
import 'syd-tokenizer.syd';
import 'syd-utils.syd';
import 'syd-compiler.syd';

class AstNode extends SourceCode {
  String toStringIndent(Integer indent) {
    abstract();
  }

  String toString() {
    return toStringIndent(0);
  }

  Null walk(NullFunction callback, Anything context) {
    // no children
  }
}

class TypeIdentifier extends AstNode {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Type generateInstructions(CompiledScope scope) {
    TypeNullable result = (scope.globalScope() as CompiledLibrary).lookupType(name);
    if (result == null) {
      throw(concat('Type "', name, '" not known at ', sourceLocation));
    }
    return result;
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class Statement extends AstNode {
  Null generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StatementBlock extends AstNode {
  StatementList children;
  
  String toStringIndent(Integer indent) {
    StringList buffer = []:String;
    for (statement in children) {
      append(buffer, stringTimes(' ', indent));
      append(buffer, statement.toStringIndent(indent));
    }
    return joinList(buffer);
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in children) {
      callback(child, context);
    }
  }

  Null generateInstructions(CompiledScope scope) {
    Null compileChild(AstNode child, CompiledScope scope) {
      scope.emitInstruction(SourceLocationInstruction(child));
      cast(cast(child).generateInstructions)(scope); // workaround because self-reference doesn't work in closures
    }
    walk(compileChild, scope);
  }

  Null constructor(StatementList statementsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    children = statementsArg;
  }
}

class Expression extends AstNode {
  Boolean isLValue() {
    return false;
  }

  // Expressions are expected to declare a Slot then return a ValueHandle read from that Slot
  ValueHandle generateInstructions(CompiledScope scope) {
    abstract();
  }
}

class StringLiteralExpression extends Expression {
  String value;
  String label;

  ValueHandle generateInstructions(CompiledScope scope) {
    label = scope.environment().generateLabel('string');
    scope.emitInstruction(StringConstantDataInstruction(
      label,
      value,
      sourceLocation,
    ));
    Type type = (scope.environment().runtimeLibrary! as CompiledRuntimeLibrary).coreStringType;
    return scope.registerStaticValue(LabelPointerVot(type, label), concat(this)).read(scope);
  }

  String toStringIndent(Integer indent) {
    return concat('\'', escapeString(value), '\'');
  }

  Null constructor(String valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class IntegerLiteralExpression extends Expression {
  Integer value;

  ValueHandle generateInstructions(CompiledScope scope) {
    Slot slot = scope.registerStaticValue(LiteralIntegerVot((scope.environment().runtimeLibrary! as CompiledRuntimeLibrary).coreIntegerType, value), concat(this));
    return slot.read(scope);
  }
  
  String toStringIndent(Integer indent) {
    return concat(intToStr(value), ' /* 0x', hex(value), ' *\/');
  }

  Null constructor(Integer valueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    value = valueArg;
  }
}

class ListLiteralExpression extends Expression {
  ExpressionList values;

  String toStringIndent(Integer indent) {
    String indenter(AstNode node) {
      return node.toStringIndent(indent);
    }
    return concat('[', join(cast(map(values, indenter)), ','), ']');
  }

  Null walk(NullFunction callback, Anything context) {
    for (child in values) {
      callback(child, context);
    }
  }

  Null constructor(ExpressionList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    values = valuesArg;
  }
}

class VariableExpression extends Expression {
  String name;
  
  String toStringIndent(Integer indent) {
    return name;
  }

  Boolean isLValue() {
    return true;
  }

  ValueHandle generateInstructions(CompiledScope scope) {
    SlotNullable slot = scope.lookupIdentifier(name);
    if (slot == null) {
      throw(concat('Identifier "', name, '" not known at ', sourceLocation));
    }
    return slot!.read(scope);
  }

  Null constructor(String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
  }
}

class SubroutineCallExpression extends Expression {
  Expression subroutineReference;
  ExpressionList arguments;

  String toStringIndent(Integer indent) {
    StringList argumentsList = []:String;
    Integer index = 0;
    while (index < len(arguments)) {
      if (index > 0) {
        append(argumentsList, ', ');
      }
      append(argumentsList, arguments[index].toStringIndent(indent));
      index += 1;
    }
    return concat(subroutineReference.toStringIndent(indent), '(', joinList(argumentsList), ')');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(subroutineReference, context);
    for (child in arguments) {
      callback(child, context);
    }
  }

  ValueHandle generateInstructions(CompiledScope scope) {
    ValueHandle subroutine = subroutineReference.generateInstructions(scope);
    ValueHandleList argumentValues = []:ValueHandle;
    if (subroutine.source.staticType is AbstractSubroutineType) {
      for (argument in arguments) {
        append(argumentValues, argument.generateInstructions(scope));
      }
    } else {
      throw(concat('"', subroutineReference, '" is not a subroutine at ', sourceLocation));
    }
    return scope.emitSubroutineCall(subroutine, argumentValues);
  }

  Null constructor(Expression subroutineReferenceArg, ExpressionList argumentsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    subroutineReference = subroutineReferenceArg;
    arguments = argumentsArg;
  }
}

class SubscriptExpression extends Expression {
  Expression list;
  Expression argument;
  
  String toStringIndent(Integer indent) {
    return concat(list.toStringIndent(indent), '[', argument.toStringIndent(indent), ']');
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(list, context);
    callback(argument, context);
  }

  Null constructor(Expression listArg, Expression argumentArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    list = listArg;
    argument = argumentArg;
  }
}

class MemberAccessExpression extends Expression {
  Expression object;
  String member;
  
  String toStringIndent(Integer indent) {
    return concat(object.toStringIndent(indent), '.', member);
  }

  Boolean isLValue() {
    return true;
  }

  Null walk(NullFunction callback, Anything context) {
    callback(object, context);
  }

  Null constructor(Expression objectArg, String memberArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    object = objectArg;
    member = memberArg;
  }
}

class IsOperatorExpression extends Expression {
  Expression expression;
  String typeName;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ' is ', typeName);
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null constructor(Expression expressionArg, String typeNameArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    typeName = typeNameArg;
  }
}

class UnaryExpression extends Expression {
  Expression rhs;

  String describeOperator() { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      describeOperator(),
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(rhs, context);
  }

  Null constructor(Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    rhs = rhsArg;
  }
}

class IntegerNegationExpression extends UnaryExpression {
  String describeOperator() {
    return '-';
  }
}

class PlusExpression extends UnaryExpression {
  String describeOperator() {
    return '+';
  }
}

class BooleanNotExpression extends UnaryExpression {
  String describeOperator() {
    return '!';
  }
}

class BitwiseNotExpression extends UnaryExpression {
  String describeOperator() {
    return '~';
  }
}

class OperatorExpression extends Expression {
  Expression lhs;
  Expression rhs;

  String describeOperator() { abstract(); }
  
  String toStringIndent(Integer indent) {
    return concat(
      lhs.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rhs.toStringIndent(indent),
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lhs, context);
    callback(rhs, context);
  }

  Null constructor(Expression lhsArg, Expression rhsArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    lhs = lhsArg;
    rhs = rhsArg;
  }
}

class OperatorAdditionExpression extends OperatorExpression {
  String describeOperator() {
    return '+';
  }
}

class OperatorSubtractionExpression extends OperatorExpression {
  String describeOperator() {
    return '-';
  }
}

class OperatorMultiplicationExpression extends OperatorExpression {
  String describeOperator() {
    return '*';
  }
}

class OperatorDivisionExpression extends OperatorExpression {
  String describeOperator() {
    return '/';
  }
}

class OperatorModulusExpression extends OperatorExpression {
  String describeOperator() {
    return '%';
  }
}

class OperatorEqualsEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '==';
  }
}

class OperatorBangEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '!=';
  }
}

class OperatorLessThanExpression extends OperatorExpression {
  String describeOperator() {
    return '<';
  }
}

class OperatorLeftShiftExpression extends OperatorExpression {
  String describeOperator() {
    return '<<';
  }
}

class OperatorLessThanOrEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '<=';
  }
}

class OperatorGreaterThanExpression extends OperatorExpression {
  String describeOperator() {
    return '>';
  }
}

class OperatorRightShiftExpression extends OperatorExpression {
  String describeOperator() {
    return '>>';
  }
}

class OperatorGreaterThanOrEqualsExpression extends OperatorExpression {
  String describeOperator() {
    return '>=';
  }
}

class OperatorBitwiseAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&';
  }
}

class OperatorLogicalAndExpression extends OperatorExpression {
  String describeOperator() {
    return '&&';
  }
}

class OperatorBitwiseOrExpression extends OperatorExpression {
  String describeOperator() {
    return '|';
  }
}

class OperatorLogicalOrExpression extends OperatorExpression {
  String describeOperator() {
    return '||';
  }
}

class OperatorBitwiseXorExpression extends OperatorExpression {
  String describeOperator() {
    return '^';
  }
}

class DeclarationStatement extends Statement {
  String identifier;
  ExpressionNullable rValue;
  
  Null walk(NullFunction callback, Anything context) {
    if (rValue != null) {
      callback(rValue, context);
    }
  }

  Null constructor(String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    identifier = identifierArg;
    rValue = rValueArg;
  }
}

class VariableDeclarationStatement extends DeclarationStatement {
  TypeIdentifier type;
  
  String toStringIndent(Integer indent) {
    if (rValue == null) {
      return concat(type.toStringIndent(indent), ' ', identifier, ';\n');
    }
    return concat(type.toStringIndent(indent), ' ', identifier, ' = ', rValue!.toStringIndent(indent), ';\n');
  }

  Null constructor(TypeIdentifier typeArg, String identifierArg, ExpressionNullable rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(identifierArg, rValueArg, sourceLocationArg);
    type = typeArg;
  }
}

class SubroutineDeclarationStatement extends Statement {
  TypeIdentifier returnType;
  String identifier;
  AnythingListList parameters; // pairs of type (TypeIdentifier) and identifier (String)
  StatementBlock body;

  Null walk(NullFunction callback, Anything context) {
    callback(body, context);
  }

  Null generateInstructions(CompiledScope scope) {
    Type compiledReturnType = returnType.generateInstructions(scope);
    TypeList compiledParameterTypes = []:Type;
    for (entry in parameters) {
      append(compiledParameterTypes, (entry[0] as TypeIdentifier).generateInstructions(scope));
    }
    SubroutineTypeWithSpecificParameters subroutineType = createOrFindSubroutineType(
      scope.environment(),
      compiledReturnType,
      compiledParameterTypes,
    );
    CompiledSubroutine subroutine = CompiledSubroutine(scope, subroutineType, identifier);
    scope.registerSubroutine(subroutine);
    SlotList parameterSlots = []:Slot;
    Integer index = 0;
    for (parameter in parameters) {
      String name = parameter[1] as String;
      Type type = compiledParameterTypes[index];
      append(parameterSlots, subroutine.registerParameter(name, type, index));
      index += 1;
    }
    subroutine.emitParameterChecks(parameterSlots);
    // TODO: declare slot for "this" and "closure"
    body.generateInstructions(subroutine);
  }

  String toStringIndent(Integer indent) {
    StringList parametersList = []:String;
    for (parameter in parameters) {
      if (len(parametersList) > 0) {
        append(parametersList, ', ');
      }
      append(parametersList, (parameter[0] as TypeIdentifier).toStringIndent(indent));
      append(parametersList, ' ');
      append(parametersList, parameter[1]);
    }
    String bodyString = body.toStringIndent(indent + 2);
    return concat(returnType.toStringIndent(indent), ' ', identifier, '(', joinList(parametersList), ') {\n', bodyString, '}\n');
  }

  Null constructor(TypeIdentifier returnTypeArg, String identifierArg, AnythingListList parametersArg, StatementBlock bodyArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    returnType = returnTypeArg;
    identifier = identifierArg;
    parameters = parametersArg;
    body = bodyArg;
  }
}  

class EnumDeclaration extends Statement {
  String name;
  StringList values;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['enum ', name, ' { '];
    Integer index = 0;
    while (index < len(values)) {
      if (index > 0) {
        append(buffer, ' ');
      }
      append(buffer, values[index]);
      index += 1;
    }
    append(buffer, ' }\n');
    return joinList(buffer);
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope is CompiledLibrary, 'found enum in non-global scope');
    CompiledLibrary globalScope = scope as CompiledLibrary;
    globalScope.declareType(EnumType(scope.environment(), name, values));
  }

  Null constructor(String nameArg, StringList valuesArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    name = nameArg;
    values = valuesArg;
  }
}

class ClassDeclaration extends Statement {
  String className;
  StringNullable superclassName;
  DeclarationStatementList members;
  
  String toStringIndent(Integer indent) {
    StringList buffer = ['class ', className, ' '];
    if (superclassName != null) {
      append(buffer, 'extends ');
      append(buffer, superclassName);
    }
    append(buffer, '{\n');
    for (member in members) {
      append(buffer, stringTimes(' ', indent + 2));
      append(buffer, member.toStringIndent(indent + 2));
    }
    append(buffer, stringTimes(' ', indent));
    append(buffer, '}\n');
    return joinList(buffer);
  }

  Null constructor(String classNameArg, StringNullable superclassNameArg, DeclarationStatementList membersArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    className = classNameArg;
    superclassName = superclassNameArg;
    members = membersArg;
  }
}

class ExpressionStatement extends Statement {
  Expression expression;
  
  String toStringIndent(Integer indent) {
    return concat(expression.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null generateInstructions(CompiledScope scope) {
    expression.generateInstructions(scope); // return value is discarded
  }

  Null constructor(Expression expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ReturnStatement extends Statement {
  ExpressionNullable expression;

  String toStringIndent(Integer indent) {
    if (expression == null) {
      return 'return;';
    }
    return concat('return ', expression!.toStringIndent(indent), ';\n');
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
  }

  Null constructor(ExpressionNullable expressionArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
  }
}

class ImportStatement extends Statement {
  String path;
  
  String toStringIndent(Integer indent) {
    return concat('import "', path, '";\n');
  }

  Null generateInstructions(CompiledScope scope) {
    assert(scope.environment().getLibraryState(path) == lsDefined, concat('tried to import library "', path, '" before it was compiled'));
    assert(scope is CompiledLibrary, 'found import outside global scope');
    (scope as CompiledLibrary).importLibrary(scope.environment().getLibrary(path) as CompiledLibrary);
  }

  Null constructor(String pathArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    path = pathArg;
  }
}

class AssignmentStatement extends Statement {
  Expression lValue; // with isLValue true
  Expression rValue;

  String describeOperator() { abstract(); }

  String toStringIndent(Integer indent) {
    return concat(
      lValue.toStringIndent(indent),
      ' ',
      describeOperator(),
      ' ',
      rValue.toStringIndent(indent),
      ';\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(lValue, context);
    callback(rValue, context);
  }

  Null constructor(Expression lValueArg, Expression rValueArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    assert(lValueArg.isLValue(), 'lvalue is not assignable');
    lValue = lValueArg;
    rValue = rValueArg;
  }
}

class StraightAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '=';
  }
}

class PlusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '+=';
  }
}

class MinusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '-=';
  }
}

class AsteriskAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '*=';
  }
}

class SlashAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '/=';
  }
}

class ModulusAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '%=';
  }
}

class BitwiseAndAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '&=';
  }
}

class BitwiseXorAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '^=';
  }
}

class BitwiseOrAssignmentStatement extends AssignmentStatement {
  String describeOperator() {
    return '|=';
  }
}

class ElseClause extends AstNode { }

class IfStatement extends Statement {
  Expression expression;
  StatementBlock block;
  ElseClauseNullable elseClause;
  
  String toStringIndent(Integer indent) {
    String elseString;
    if (elseClause != null) {
      elseString = elseClause!.toStringIndent(indent);
    } else {
      elseString = '\n';
    }
    return concat(
      'if (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}', elseString,
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
    if (elseClause != null) {
      callback(elseClause, context);
    }
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, ElseClauseNullable elseClauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
    elseClause = elseClauseArg;
  }
}

class DefaultElseClause extends ElseClause {
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      ' else {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(block, context);
  }

  Null constructor(StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    block = blockArg;
  }
}

class ElseIfClause extends ElseClause {
  IfStatement ifClause;
  
  String toStringIndent(Integer indent) {
    return concat(' else ', ifClause.toStringIndent(indent));
  }

  Null walk(NullFunction callback, Anything context) {
    callback(ifClause, context);
  }

  Null constructor(IfStatement clauseArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    ifClause = clauseArg;
  }
}

class WhileStatement extends Statement {
  Expression expression;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'while (', expression.toStringIndent(indent), ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(expression, context);
    callback(block, context);
  }

  Null constructor(Expression expressionArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    expression = expressionArg;
    block = blockArg;
  }
}

class ForStatement extends Statement {
  String variable;
  Expression iterable;
  StatementBlock block;
  
  String toStringIndent(Integer indent) {
    return concat(
      'for (',
      variable,
      ' in ',
      iterable.toStringIndent(indent),
      ') {\n',
      block.toStringIndent(indent + 2),
      stringTimes(' ', indent), '}\n',
    );
  }

  Null walk(NullFunction callback, Anything context) {
    callback(iterable, context);
    callback(block, context);
  }

  Null constructor(String variableArg, Expression iterableArg, StatementBlock blockArg, SourceLocation sourceLocationArg) {
    super.constructor(sourceLocationArg);
    variable = variableArg;
    iterable = iterableArg;
    block = blockArg;
  }
}

class Library extends StatementBlock {
  String name;

  Null constructor(StatementList childrenArg, String nameArg, SourceLocation sourceLocationArg) {
    super.constructor(childrenArg, sourceLocationArg);
    name = nameArg;
  }

  CompiledLibrary generateScopes(CompilationEnvironment compilationEnvironmentArg) { 
    CompiledLibrary result = CompiledLibrary(compilationEnvironmentArg, name);
    generateInstructions(result);
    return result;
  }
}

class Program extends Library {
  Null generateInstructions(CompiledScope scope) {
    super.generateInstructions(scope);
    Slot slot = scope.registerStaticValue(LiteralIntegerVot((scope.environment().runtimeLibrary! as CompiledRuntimeLibrary).coreIntegerType, 0), 'default exit code');
    ValueHandle exitCode = slot.read(scope);
    ValueHandle exit = (scope.environment().runtimeLibrary! as CompiledRuntimeLibrary).coreExit.read(scope);
    scope.emitSubroutineCall(exit, [exitCode]);
  }
}