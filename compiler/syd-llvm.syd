import 'syd-assembler.syd';

// strings are double-quote delimited
String escapeLL(String value) {
  StringList buffer = []:String;
  for (char in utf8Encode(value)) {
    if (char == 0x5c) { // \
      append(buffer, '\\\\');
    } else if (char < 0x20 || char == 0x22 || char > 0x7e) {
      append(buffer, concat('\\', padLeft(hex(char), 2, '0')));
    } else {
      append(buffer, chr(char));
    }
  }
  return joinList(buffer);
}

String widthToIntegerType(ow width) {
  return concat('i', bytesFor(width) * 8);
}

String comparisonToIcmpCondition(Comparison comparison) {
  if (comparison == Comparison.Equal) {
    return 'eq';
  } else if (comparison == Comparison.NotEqual) {
    return 'ne';
  } else if (comparison == Comparison.LessThan) {
    return 'slt';
  } else if (comparison == Comparison.LessThanOrEqual) {
    return 'sle';
  } else if (comparison == Comparison.GreaterThanOrEqual) {
    return 'sge';
  } else if (comparison == Comparison.GreaterThan) {
    return 'sgt';
  } else {
    throw(concat('unexpected Comparison ', comparison));
  }
}

enum RegisterType { ptr i64 other }

fwdclass LLVMAssembler(AssemblerLabel) extends Assembler;
fwdclassmethod Null LLVMAssembler.addLine(Integer, String, StringNullable, Boolean, Boolean);
fwdclassmethod Null LLVMAssembler.addPendingComment(Integer, String);
fwdclassmethod Null LLVMAssembler.addComment(Integer, String);
fwdclassmethod String LLVMAssembler.addDebugLine(String);
fwdclassmethod Null LLVMAssembler.enterNewFunction(String);
fwdclassfield String LLVMAssembler.cuCode;
fwdclassfield String LLVMAssembler.fileCode;
fwdclassfield String LLVMAssembler.subroutineTypeCode;
fwdclassfield Integer LLVMAssembler.currentLine;
fwdclass LLVMInstruction(Integer) extends Object;
fwdclass LLVMOpcode(Integer, AnythingList, String) extends LLVMInstruction;
fwdclass LLVMSubroutineBuilder(AssemblerLabelNullable, AssemblerLabel, AssemblerLabelNullable, AssemblerLabelNullable, AssemblerLabelNullable, AssemblerLabelNullable, AssemblerLabelNullable, AssemblerLabelNullable) extends Object;
fwdclassfield LLVMInstructionList LLVMSubroutineBuilder.currentBlockInstructions;
fwdclassfield Integer LLVMSubroutineBuilder.indent;
fwdclassfield AssemblerLabel LLVMSubroutineBuilder.rootLabel;
fwdclass LLVMOperand() extends Object;
fwdclass LLVMSymbolicOperand(AssemblerLabel, String, RegisterType) extends LLVMOperand;
fwdclass LLVMRegisterOperand(AssemblerLabel, String, RegisterType) extends LLVMSymbolicOperand;

class LLVMOperand extends Object {
  String serialize(StringFunction serializeLabel) {
    abstract();
  }

  LLVMOperand asInteger64(LLVMSubroutineBuilder builder) {
    abstract();
  }

  LLVMOperand asPointer(LLVMSubroutineBuilder builder) {
    abstract();
  }
}

class LLVMSymbolicOperand extends LLVMOperand {
  AssemblerLabel symbolLabel;
  RegisterType registerType;
  String commentName;

  Null constructor(AssemblerLabel symbolLabelArg, String commentNameArg, RegisterType registerTypeArg) {
    super.constructor();
    symbolLabel = symbolLabelArg;
    commentName = commentNameArg;
    registerType = registerTypeArg;
  }

  //#override
  LLVMOperand asInteger64(LLVMSubroutineBuilder subroutineBuilder) {
    if (registerType == RegisterType.i64) {
      return this;
    }
    if (registerType == RegisterType.other) {
      throw('cannot convert this operand to i64');
    }
    LLVMRegisterOperand result = LLVMRegisterOperand(symbolLabel.deriveWith('_int'), commentName, RegisterType.i64);
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = ptrtoint ptr ', this, ' to i64'], concat('convert ', commentName, ' pointer to integer')));
    return result;
  }

  //#override
  LLVMOperand asPointer(LLVMSubroutineBuilder subroutineBuilder) {
    if (registerType == RegisterType.ptr) {
      return this;
    }
    if (registerType == RegisterType.other) {
      throw('cannot convert this operand to ptr');
    }
    LLVMRegisterOperand result = LLVMRegisterOperand(symbolLabel.deriveWith('_ptr'), commentName, RegisterType.ptr);
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = inttoptr i64 ', this, ' to ptr'], concat('convert ', commentName, ' integer to pointer')));
    return result;
  }
}

// %foo
class LLVMRegisterOperand extends LLVMSymbolicOperand {
  //#override
  String serialize(StringFunction serializeLabel) {
    return concat('%', serializeLabel(symbolLabel));
  }
}

// @foo
// this includes global variables and functions
class GlobalOperand extends LLVMSymbolicOperand {
  //#override
  String serialize(StringFunction serializeLabel) {
    return concat('@', serializeLabel(symbolLabel));
  }

  Null constructor(AssemblerLabel symbolLabelArg, String commentNameArg) {
    super.constructor(symbolLabelArg, commentNameArg, RegisterType.ptr);
  }
}

// e.g. 123
class IntegerOperand extends LLVMOperand {
  Integer value;

  //#override
  String serialize(StringFunction serializeLabel) {
    return concat(value);
  }

  //#override
  LLVMOperand asInteger64(LLVMSubroutineBuilder subroutineBuilder) {
    return this;
  }

  //#override
  LLVMOperand asPointer(LLVMSubroutineBuilder subroutineBuilder) {
    assert(false, 'we did not expect this ever to be used');
    LLVMRegisterOperand result = LLVMRegisterOperand(subroutineBuilder.rootLabel.deriveWith(concat(value, '_ptr')), concat(value), RegisterType.ptr);
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = inttoptr i64 ', this, ' to ptr'], 'convert integer to pointer'));
    return result;
  }

  Null constructor(Integer valueArg) {
    super.constructor();
    value = valueArg;
  }
}

// "foo"
class LLVMStringOperand extends LLVMOperand {
  String value;

  //#override
  String serialize(StringFunction serializeLabel) {
    return concat('c"', escapeLL(value), '"');
  }

  //#override
  LLVMOperand asInteger64(LLVMSubroutineBuilder subroutineBuilder) {
    throw('cannot convert string operands');
  }

  //#override
  LLVMOperand asPointer(LLVMSubroutineBuilder subroutineBuilder) {
    throw('cannot convert string operands');
  }

  Null constructor(String valueArg) {
    super.constructor();
    value = valueArg;
  }
}

class LLVMInstruction extends Object {
  Integer indent;

  Null serialize(LLVMAssembler assembler) {
    abstract();
  }

  Boolean isTerminator() {
    return false;
  }

  Null constructor(Integer indentArg) {
    super.constructor();
    indent = indentArg;
  }
}

class LLVMComment extends LLVMInstruction {
  String comment;
  Boolean includeOnlyIfFollowedByCode;
  
  //#override
  Null serialize(LLVMAssembler assembler) {
    if (includeOnlyIfFollowedByCode) {
      assembler.addPendingComment(indent, comment);
    } else {
      assembler.addComment(indent, comment);
    }
  }

  Null constructor(Integer indentArg, String commentArg, Boolean includeOnlyIfFollowedByCodeArg) {
    super.constructor(indentArg);
    comment = commentArg;
    includeOnlyIfFollowedByCode = includeOnlyIfFollowedByCodeArg;
  }
}

class LLVMOpcode extends LLVMInstruction {
  AnythingList parts;
  String comment;

  //#override
  Null serialize(LLVMAssembler assembler) {
    StringBuffer line = createStringBuffer();
    for (part in parts) {
      if (part is String) {
        writeStringBuffer(line, part as String);
      } else if (part is AssemblerLabel) {
        writeStringBuffer(line, assembler.serializeLabel(part as AssemblerLabel));
      } else if (part is LLVMOperand) {
        writeStringBuffer(line, (part as LLVMOperand).serialize(assembler.serializeLabel));
      } else {
        throw(concat('unexpected opcode part: ', part));
      }
    }
    assembler.addLine(indent, readStringBuffer(line), comment, true, true);
  }

  //#override
  Boolean isTerminator() {
    Anything firstPart = first(parts);
    if (!(firstPart is String)) {
      return false;
    }
    String opcode = first(split(firstPart as String, ' '));
    return opcode == 'ret'
        || opcode == 'br'
        || opcode == 'switch'
        || opcode == 'indirectbr'
        || opcode == 'invoke'
        || opcode == 'callbr'
        || opcode == 'resume'
        || opcode == 'catchswitch'
        || opcode == 'catchret'
        || opcode == 'cleanupret'
        || opcode == 'unreachable';
  }

  Null constructor(Integer indentArg, AnythingList partsArg, String commentArg) {
    super.constructor(indentArg);
    assert(len(partsArg) >= 1, 'contract violation');
    parts = partsArg;
    comment = commentArg;
  }
}

class LLVMBlock extends Object {
  AssemblerLabel name;
  LLVMInstructionList instructions;
  Integer indent;

  
  Null serialize(LLVMAssembler assembler) {
    assembler.addLine(indent, concat(assembler.serializeLabel(name), ':'), null, true, false);
    assert(len(instructions) > 0, 'invariant violation');
    assert((last(instructions) as LLVMInstruction).isTerminator(), 'contract violation');
    Integer remaining = len(instructions);
    for (instruction in instructions as LLVMInstructionList) {
      instruction.serialize(assembler);
      remaining -= 1;
      assert(remaining > 0 || instruction.isTerminator(), 'contract violation');
    }
  }

  Null constructor(AssemblerLabel nameArg, LLVMInstructionList instructionsArg, Integer indentArg) {
    super.constructor();
    name = nameArg;
    instructions = instructionsArg;
    indent = indentArg;
  }
}


// Represents functions and the top-level scope.
// "annotation" is assumed to be null for the top-level scope and not for functions;
// argument processing is only added when "annotation" is non-null.
class LLVMSubroutine extends Object {
  AssemblerLabel name;
  AssemblerLabelNullable annotation;
  LLVMBlockList blocks;
  Boolean isThunk;
  AssemblerLabelNullable parameterCount;
  AssemblerLabelNullable closurePointer;
  AssemblerLabelNullable thisPointer;
  AssemblerLabelNullable thisType;
  AssemblerLabelNullable returnValuePointer;
  AssemblerLabelNullable returnTypePointer;
  LLVMRegisterOperandList localVariables;
  AssemblerLabel varargsBaseAddress;

  Null serialize(LLVMAssembler assembler) {
    String debugCode = assembler.addDebugLine(concat(
      'distinct !DISubprogram(',
        'name: "', escapeLL(assembler.serializeLabel(name)), '", ',
        'scope: ', assembler.fileCode, ', ',
        'file: ', assembler.fileCode, ', ',
        'line: ', assembler.currentLine, ', ',
        'type: ', assembler.subroutineTypeCode, ', ',
        'scopeLine: 1, ',
        'spFlags: DISPFlagDefinition, ',
        'unit: ', assembler.cuCode,
      ')',
    ));
    assembler.enterNewFunction(debugCode);
    if (annotation != null) {
      String attributes = '';
      if (isThunk) {
        attributes = '"thunk" ';
      }
      assembler.addLine(0, concat(
        'define void @', assembler.serializeLabel(name), ' ',
        '(i64 %', assembler.serializeLabel(parameterCount!), ', ',
         'i64 %', assembler.serializeLabel(closurePointer!), ', ',
         'i64 %', assembler.serializeLabel(thisType!), ', ',
         'i64 %', assembler.serializeLabel(thisPointer!), ', ',
         'i64 %', assembler.serializeLabel(returnTypePointer!), ', ',
         'i64 %', assembler.serializeLabel(returnValuePointer!), ', ',
        '...) ',
        attributes,
        'prefix ptr @', assembler.serializeLabel(annotation!),
        ' !dbg ', debugCode,
        ' {',
      ), null, false, false);
      // TODO: comments
      assembler.addLine(1, concat('%$varargs_count = mul i64 2, %', assembler.serializeLabel(parameterCount!)), null, false, true);
      assembler.addLine(1, concat('%', assembler.serializeLabel(varargsBaseAddress), ' = alloca i64, i64 %$varargs_count'), null, false, true);
      assembler.addLine(1, '%$valist = alloca ptr', null, false, true);
      assembler.addLine(1, 'call void @llvm.va_start(ptr %$valist)', null, false, true);
      assembler.addLine(1, '%$cursor_ptr_ptr = alloca ptr', null, false, true);
      assembler.addLine(1, '%$remaining_ptr_ptr = alloca i64', null, false, true);
      assembler.addLine(1, concat('store ptr %', assembler.serializeLabel(varargsBaseAddress), ', ptr %$cursor_ptr_ptr'), null, false, true);
      assembler.addLine(1, 'store i64 %$varargs_count, ptr %$remaining_ptr_ptr', null, false, true);
      assembler.addComment(1, 'for each argument...');
      assembler.addLine(1, 'br label %$arguments_copying_loop', null, false, true);
      assembler.addLine(1, '$arguments_copying_loop:', null, false, false);
      assembler.addLine(2, '%$remaining_i64 = load i64, ptr %$remaining_ptr_ptr', null, false, true);
      assembler.addLine(2, '%$has_remaining = icmp ugt i64 %$remaining_i64, 0', null, false, true);
      assembler.addLine(2, 'br i1 %$has_remaining, label %$arguments_copying_continue, label %$arguments_copying_done', null, false, true);
      assembler.addLine(2, '$arguments_copying_continue:', null, false, false);
      assembler.addLine(2, '%$cursor_i64 = load i64, ptr %$cursor_ptr_ptr', null, false, true);
      assembler.addLine(2, '%$cursor_ptr = inttoptr i64 %$cursor_i64 to ptr', null, false, true);
      assembler.addComment(2, 'store next argument into cursor');
      assembler.addLine(2, '%$argvalue = va_arg ptr %$valist, i64', null, false, true);
      assembler.addLine(2, 'store i64 %$argvalue, ptr %$cursor_ptr', null, false, true);
      assembler.addComment(2, 'increment cursor');
      assembler.addLine(2, '%$new_cursor_i64 = add i64 %$cursor_i64, 8', null, false, true);
      assembler.addLine(2, '%$new_cursor_ptr = inttoptr i64 %$new_cursor_i64 to ptr', null, false, true);
      assembler.addLine(2, 'store ptr %$new_cursor_ptr, ptr %$cursor_ptr_ptr', null, false, true);
      assembler.addComment(2, 'decrement remaining');
      assembler.addLine(2, '%$new_remaining_i64 = sub i64 %$remaining_i64, 1', null, false, true);
      assembler.addLine(2, 'store i64 %$new_remaining_i64, ptr %$remaining_ptr_ptr', null, false, true);
      assembler.addLine(2, 'br label %$arguments_copying_loop', null, false, true);
      assembler.addLine(1, '$arguments_copying_done:', null, false, false);
    } else {
      String attributes = '';
      if (isThunk) {
        attributes = '"thunk" ';
      }
      assembler.addLine(0, concat('define void @', assembler.serializeLabel(name), '() ', attributes, '!dbg ',
        debugCode, ' {'), null, false, false);
    }
    for (variable in localVariables) {
      assembler.addLine(1, concat(variable.serialize(assembler.serializeLabel), ' = alloca i64'), null, false, true);
    }
    assembler.addLine(1, 'br label %$entry', null, false, true);
    for (block in blocks) {
      block.serialize(assembler);
    }
    assembler.addLine(0, '}', null, false, false);
  }

  Null constructor(
    AssemblerLabel nameArg,
      AssemblerLabelNullable annotationArg,
      LLVMBlockList blocksArg,
      Boolean isThunkArg,
      AssemblerLabelNullable parameterCountArg,
      AssemblerLabelNullable closurePointerArg,
      AssemblerLabelNullable thisPointerArg,
      AssemblerLabelNullable thisTypeArg,
      AssemblerLabelNullable returnValuePointerArg,
      AssemblerLabelNullable returnTypePointerArg,
      LLVMRegisterOperandList localVariablesArg,
      AssemblerLabel varargsBaseAddressArg,
    ) {
    super.constructor();
    name = nameArg;
    annotation = annotationArg;
    blocks = blocksArg;
    isThunk = isThunkArg;
    parameterCount = parameterCountArg;
    closurePointer = closurePointerArg;
    thisPointer = thisPointerArg;
    thisType = thisTypeArg;
    returnValuePointer = returnValuePointerArg;
    returnTypePointer = returnTypePointerArg;
    localVariables = localVariablesArg;
    varargsBaseAddress = varargsBaseAddressArg;
  }
}

class LLVMSubroutineBuilder extends Object {
  AssemblerLabel rootLabel;
  LLVMBlockList blocks = []:LLVMBlock;
  AssemblerLabelNullable name;
  AssemblerLabelNullable annotation = null;
  Boolean isThunk = false;
  LLVMInstructionList currentBlockInstructions = []:LLVMInstruction;
  AssemblerLabel currentBlockName;
  Map localVariables = Map(); // Datum -> LLVMRegisterOperand
  Integer indent = 1;
  LLVMOperand trampolineParameterCount;
  LLVMOperand trampolineThisPointer;
  LLVMOperand trampolineThisType;
  LLVMOperand trampolineReturnValuePointer;
  LLVMOperand trampolineReturnTypePointer;
  AssemblerLabelNullable parameterCount;
  AssemblerLabelNullable closurePointer;
  AssemblerLabelNullable thisPointer;
  AssemblerLabelNullable thisType;
  AssemblerLabelNullable returnValuePointer;
  AssemblerLabelNullable returnTypePointer;
  LLVMRegisterOperand varargsBaseAddress;
  Integer saveStackSize = 0;
  LLVMOperandList saveStack = []:LLVMOperand; // used to implement Push and Pop instructions

  LLVMRegisterOperand createRegisterOperand(String name, RegisterType registerType) {
    return LLVMRegisterOperand(rootLabel.deriveWith(name), name, registerType);
  }

  Null prepareTrampoline(LLVMOperand trampolineParameterCountArg,
    LLVMOperand trampolineThisTypeArg,
    LLVMOperand trampolineThisPointerArg,
  ) {
    trampolineParameterCount = trampolineParameterCountArg;
    trampolineThisType = trampolineThisTypeArg;
    trampolineThisPointer = trampolineThisPointerArg;
  }

  Null replaceParameterForTrampoline(Integer parameterNumber, LLVMOperand newOperand) {
    if (parameterNumber == 4) {
      trampolineReturnTypePointer = newOperand;
    } else {
      assert(parameterNumber == 5, 'contract violation: parameterNumber must be 4 or 5');
      trampolineReturnValuePointer = newOperand;
    }
  }

  Null pushSaveStack(LLVMOperand operand) {
    assert(saveStackSize <= len(saveStack), 'invariant violation');
    if (saveStackSize == len(saveStack)) {
      append(saveStack, operand);
    } else {
      saveStack[saveStackSize] = operand;
    }
    saveStackSize += 1;
  }

  LLVMOperand popSaveStack() {
    assert(saveStackSize > 0, 'invariant violation');
    saveStackSize -= 1;
    return saveStack[saveStackSize];
  }

  Null adjustIndent(Integer delta) {
    indent += delta;
  }

  Null newBlock(AssemblerLabel label) {
    append(blocks, LLVMBlock(currentBlockName, currentBlockInstructions, indent));
    currentBlockName = label;
    currentBlockInstructions = []:LLVMInstruction;
  }

  Null handleLabel(AssemblerLabel label) {
    if (name == null) {
      assert(single(currentBlockInstructions) is LLVMComment, 'first label should be after one comment and no opcodes');
      name = label;
    } else {
      if (len(currentBlockInstructions) == 0 || !(last(currentBlockInstructions) as LLVMInstruction).isTerminator()) {
        append(currentBlockInstructions, LLVMOpcode(indent, ['br label %', label], 'continue to next block'));
      }
      newBlock(label);
    }
  }

  Null addAnnotation(AssemblerLabel label) {
    assert(annotation == null, 'multiple annotations in one function');
    annotation = label;
  }

  Null setThunk() {
    isThunk = true;
  }

  LLVMSubroutine build() {
    return LLVMSubroutine(
      name!,
      annotation,
      blocks,
      isThunk,
      parameterCount,
      closurePointer,
      thisPointer,
      thisType,
      returnValuePointer,
      returnTypePointer,
      localVariables.values() as LLVMRegisterOperandList,
      varargsBaseAddress.symbolLabel,
    );
  }

  Null constructor(
    AssemblerLabelNullable currentFunctionNameArg,
    AssemblerLabel currentRootLabelArg,
    AssemblerLabelNullable parameterCountArg,
    AssemblerLabelNullable closurePointerArg,
    AssemblerLabelNullable thisPointerArg,
    AssemblerLabelNullable thisTypeArg,
    AssemblerLabelNullable returnValuePointerArg,
    AssemblerLabelNullable returnTypePointerArg,
  ) {
    super.constructor();
    name = currentFunctionNameArg;
    rootLabel = currentRootLabelArg;
    parameterCount = parameterCountArg;
    closurePointer = closurePointerArg;
    thisPointer = thisPointerArg;
    thisType = thisTypeArg;
    returnValuePointer = returnValuePointerArg;
    returnTypePointer = returnTypePointerArg;
    varargsBaseAddress = createRegisterOperand('syd arguments array', RegisterType.ptr);
    currentBlockName = rootLabel.deriveWith('$entry'); // this must match the block jumped to in LLVMSubroutine
  }
}

class LLVMAssembler extends Assembler {
  Integer lineLength = 128;
  StringNullable pendingComment = null;
  StringList code = []:String;
  String currentSerializedFunctionDebugCode; // the !n representing the current function

  //#override
  String stringToIdentifier(String value) {
    return snakeCase(value);
  }
  
  Null enterNewFunction(String newFunctionCode) {
    currentSerializedFunctionDebugCode = newFunctionCode;
  }

  Integer currentLine;

  Null addLine(Integer indent, String line, StringNullable comment, Boolean includePendingComment, Boolean includeDebugInformation) {
    assert(indent >= 0, 'contract violation: negative indent');
    assert(!containsString(line, '\n'), 'contract violation: line should not contain a newline');
    assert(comment == null || !containsString(comment!, '\n'), 'contract violation: comment should not contain a newline');
    if (pendingComment != null) {
      if (includePendingComment) {
        append(code, pendingComment); 
      }
      pendingComment = null;
    }
    String indentedLine = concat(stringTimes('  ', indent), line);
    if (includeDebugInformation) {
      String debug = addDebugLine(concat('!DILocation(line: ', currentLine, ', scope: ', currentSerializedFunctionDebugCode, ')'));
      indentedLine = concat(indentedLine, ', !dbg ', debug);
    }
    if (comment != null) {
      append(code, concat(padRight(indentedLine, lineLength, ' '), ' ; ', comment));
    } else {
      append(code, indentedLine);
    }
    currentLine += 1;
  }

  Null addComment(Integer indent, String message) {
    addLine(indent, concat('; ', message), null, true, false);
  }

  Null addPendingComment(Integer indent, String message) {
    pendingComment = concat(stringTimes('  ', indent), '; ', message);
  }

  Null addBlankLine() {
    pendingComment = null;
    if (len(code) > 1) {
      append(code, '');
    }
  }

  AssemblerLabel scratchSpaceLabel;

  String serializedDebugComments;
  String serializedConst;
  String serializedData;
  String serializedGlobalVariables;
  String serializedImports;
  
  String serializeDebugComments(StringListList data) {
    StringList buffer = []:String;
    for (entry in data) {
      for (line in entry) {
        // TODO: handle linebreaks in comments
        assert(!containsString(line, '\n'), 'debugcomments with newlines unimplemented in llvm');
        append(buffer, concat('; ', line, '\n'));
      }
    }
    return join(buffer, '');
  }

  String serializeGlobalVariables(UninitializedGlobalList data) {
    StringList buffer = []:String;
    for (entry in data) {
      String prefix = concat('i', entry.bytes * 8);
      append(buffer,
        concat(
          padRight(
            concat('@', serializeLabel(entry.label), ' = internal global ', prefix, ' 0'),
            lineLength, ' ',
          ),
          ' ; ', entry.comment,
          '\n',
        )
      );
    }
    append(buffer, concat('@', serializeLabel(scratchSpaceLabel), ' = internal global i64 0\n'));
    return join(buffer, '');
  }

  Map externSignatures = Map(); // String -> SubroutineTypeWithSpecificParameters
  Set defaultLibraries = Set(); // String

  String serializeImports() {
    StringBuffer buffer = createStringBuffer();
    for (name in externSignatures.keys() as StringList) {
      writeStringBuffer(buffer, 'declare dllimport i64 @');
      writeStringBuffer(buffer, name);
      writeStringBuffer(buffer, '(');
      Boolean firstArg = true;
      //#ignore_unused
      for (parameter in (externSignatures.get(name) as SubroutineTypeWithSpecificParameters).parameterTypes) {
        if (!firstArg) {
          writeStringBuffer(buffer, ', ');
        }
        firstArg = false;
        writeStringBuffer(buffer, 'i64 noundef');
      } 
      writeStringBuffer(buffer, ')\n');
    }
    return readStringBuffer(buffer);
  }

  // sourcePointer must be of type 'ptr'
  LLVMRegisterOperand dereferenceOperandIntoRegister(LLVMSubroutineBuilder subroutineBuilder, String name, ow width, LLVMOperand sourcePointer) {
    LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand(name, RegisterType.i64); // if it's actually "other", we're going to discard this register before its type matters
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = load ', widthToIntegerType(width), ', ptr ', sourcePointer], concat('load ', name, ' into register')));
    if (width == ow.QWord) {
      return result;
    }
    LLVMRegisterOperand newResult = LLVMRegisterOperand(result.symbolLabel.deriveWith('i64'), name, RegisterType.i64);
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [newResult, ' = zext ', widthToIntegerType(width), ' ', result, ' to i64'], concat('convert ', name, ', to i64')));
    return newResult;
  }

  LLVMRegisterOperand obtainIdentifiedStackAllocatedOperand(Anything key, String commentName, LLVMSubroutineBuilder subroutineBuilder) {
    if (subroutineBuilder.localVariables.get(key) == null) {
      LLVMRegisterOperand register = LLVMRegisterOperand(subroutineBuilder.rootLabel.deriveWith(concat(commentName, '_ptr')), commentName, RegisterType.ptr);
      subroutineBuilder.localVariables.set(key, register);
    }
    return subroutineBuilder.localVariables.get(key) as LLVMRegisterOperand;
  }

  Null writeToLocalDatum(LLVMOperand source, LocalDatum target, LLVMSubroutineBuilder subroutineBuilder, String comment) {
    LLVMRegisterOperand pointer = obtainIdentifiedStackAllocatedOperand(target, target.commentName, subroutineBuilder);
    assert(pointer.registerType == RegisterType.ptr, 'obtainIdentifiedStackAllocatedOperand should return a RegisterType.ptr');
    append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['store i64 ', source.asInteger64(subroutineBuilder), ', ptr ', pointer], comment));
  }

  // The resulting operand should always be of type i64.
  LLVMOperand convertDatumToOperandForRead(Datum datum, LLVMSubroutineBuilder subroutineBuilder) {
    if (datum is LocalDatum) {
      return dereferenceOperandIntoRegister(
        subroutineBuilder,
        datum.commentName,
        ow.QWord,
        obtainIdentifiedStackAllocatedOperand(datum, datum.commentName, subroutineBuilder),
      );
    } else if (datum is StackDatum) {
      return dereferenceOperandIntoRegister(
        subroutineBuilder,
        datum.commentName,
        ow.QWord,
        obtainIdentifiedStackAllocatedOperand(datum, datum.commentName, subroutineBuilder),
      );
    } else if (datum is CompileTimeNumericDatum) {
      return IntegerOperand((datum as CompileTimeNumericDatum).numericValue()!);
    } else if (datum is VarArgsBaseAddressDatum) {
      return subroutineBuilder.varargsBaseAddress;
    } else if (datum is DereferenceDatum) {
      LLVMRegisterOperand sum = subroutineBuilder.createRegisterOperand(concat('pointer to ', datum.commentName), RegisterType.i64);
      append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [sum, ' = add i64 ', convertDatumToOperandForRead((datum as DereferenceDatum).base, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((datum as DereferenceDatum).offset, subroutineBuilder)], 'calculate sum of base and offset for dereference'));
      return dereferenceOperandIntoRegister(
        subroutineBuilder,
        datum.commentName,
        (datum as DereferenceDatum).width,
        sum.asPointer(subroutineBuilder),
      );
    } else if (datum is ReferenceDatum) {
      LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand(datum.commentName, RegisterType.i64);
      append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = add i64 ', convertDatumToOperandForRead((datum as ReferenceDatum).base, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((datum as ReferenceDatum).offset, subroutineBuilder)], datum.commentName));
      return result;
    } else if (datum is ScratchDatum) {
      return dereferenceOperandIntoRegister(
        subroutineBuilder,
        datum.commentName,
        ow.QWord,
        GlobalOperand(scratchSpaceLabel, 'scratch space'),
      );
    } else if (datum is ParameterDatum) {
      Integer index = (datum as ParameterDatum).index;
      if (index == 0) {
        return LLVMRegisterOperand(subroutineBuilder.parameterCount!, 'parameter count', RegisterType.i64);
      } else if (index == 1) {
        return LLVMRegisterOperand(subroutineBuilder.closurePointer!, 'closure pointer', RegisterType.i64);
      } else if (index == 2) {
        return LLVMRegisterOperand(subroutineBuilder.thisType!, 'this type', RegisterType.i64);
      } else if (index == 3) {
        return LLVMRegisterOperand(subroutineBuilder.thisPointer!, 'this pointer', RegisterType.i64);
      } else if (index == 4) {
        return LLVMRegisterOperand(subroutineBuilder.returnTypePointer!, 'return type pointer', RegisterType.i64);
      } else if (index == 5) {
        return LLVMRegisterOperand(subroutineBuilder.returnValuePointer!, 'return value pointer', RegisterType.i64);
      } else {
        LLVMRegisterOperand parameterOffset = subroutineBuilder.createRegisterOperand(concat(datum.commentName, ' offset'), RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [parameterOffset, ' = mul i64 ', IntegerOperand(index - 6), ', 8'], 'convert parameter index to offset from base address'));
        LLVMRegisterOperand parameterPtr = subroutineBuilder.createRegisterOperand(concat('pointer to ', datum.commentName), RegisterType.i64);
        append(
          subroutineBuilder.currentBlockInstructions,
          LLVMOpcode(
            subroutineBuilder.indent, [
              parameterPtr, ' = add i64 ', subroutineBuilder.varargsBaseAddress.asInteger64(subroutineBuilder), ', ', parameterOffset
            ],
            'calculate sum of varargs base and paramter offset for dereference',
          ),
        );
        return dereferenceOperandIntoRegister(
          subroutineBuilder,
          datum.commentName, 
          ow.QWord,
          parameterPtr.asPointer(subroutineBuilder),
        );
      }
    } else if (datum is GlobalVariableDatum) {
      return dereferenceOperandIntoRegister(
        subroutineBuilder,
        datum.commentName,
        ow.QWord,
        GlobalOperand((datum as GlobalVariableDatum).label, (datum as GlobalVariableDatum).commentName),
      );
    } else if (datum is DataLabelDatum) {
      return GlobalOperand((datum as DataLabelDatum).label, (datum as DataLabelDatum).commentName);
    } else if (datum is CodeLabelDatum) {
      return GlobalOperand((datum as CodeLabelDatum).label, (datum as CodeLabelDatum).commentName);
    } else if (datum is ConstantDatum) {
      return GlobalOperand((datum as ConstantDatum).constant.label, (datum as ConstantDatum).commentName);
    } else {
      throw(concat('unexpected datum ', datum.className));
    }
  }   

  // The resulting operand should always be of type i64.
  LLVMOperand convertDatumToOperandForConstant(Datum datum) {
    if (datum is CompileTimeNumericDatum) {
      return IntegerOperand((datum as CompileTimeNumericDatum).numericValue()!);
    } else if (datum is DataLabelDatum) {
      return GlobalOperand((datum as DataLabelDatum).label, (datum as DataLabelDatum).commentName);
    } else if (datum is CodeLabelDatum) {
      return GlobalOperand((datum as CodeLabelDatum).label, (datum as CodeLabelDatum).commentName);
    } else if (datum is ConstantDatum) {
      return GlobalOperand((datum as ConstantDatum).constant.label, (datum as ConstantDatum).constant.commentName);
    } else if (datum is StringDatum) {
      return LLVMStringOperand((datum as StringDatum).value);
    } else {
      throw(concat('unexpected datum ', datum.className));
    }
  }     

  // The resulting operand should always be of type i64.
  LLVMOperand readAddressOfDatumAsOperand(Datum datum, LLVMSubroutineBuilder subroutineBuilder) {
    if (datum is StackDatum) {
      return obtainIdentifiedStackAllocatedOperand(datum, datum.commentName, subroutineBuilder);
    } else if (datum is DereferenceDatum) {
      LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand(datum.commentName, RegisterType.i64);
      append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = add i64 ', convertDatumToOperandForRead((datum as ReferenceDatum).base, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((datum as ReferenceDatum).offset, subroutineBuilder)], datum.commentName));
      return result;
    } else if (datum is ScratchDatum) {
      return GlobalOperand(scratchSpaceLabel, 'scratch space');
    } else if (datum is GlobalVariableDatum) {
      return GlobalOperand((datum as GlobalVariableDatum).label, (datum as GlobalVariableDatum).commentName);
    } else {
      throw(concat('unexpected datum for loadaddress ', datum.className));
    }
    return IntegerOperand(7);
  }

  String serializeData(ConstantList data, Boolean isConstant) {
    StringBuffer buffer = createStringBuffer();
    for (constant in data) {
      writeStringBuffer(buffer, '@');
      writeStringBuffer(buffer, serializeLabel(constant.label));
      writeStringBuffer(buffer, ' = ');
      if (isConstant) {
        writeStringBuffer(buffer, 'constant');
      } else {
        writeStringBuffer(buffer, 'global');
      }
      writeStringBuffer(buffer,' <{');
      Boolean first = true;
      Integer i = 0;
      for (part in constant.data) {
        for (datum in part.data) {
          i += 1;
          if (!first) {
            writeStringBuffer(buffer, ', ');
          }
          first = false;
          if (datum is StringDatum) {
            writeStringBuffer(buffer, '[');
            writeStringBuffer(buffer, concat(len(utf8Encode((datum as StringDatum).value))));
            writeStringBuffer(buffer, ' x i8]');
          } else if (datum is CompileTimeNumericDatum) {
            writeStringBuffer(buffer, widthToIntegerType(part.width));
          } else {
            writeStringBuffer(buffer, 'ptr');
          }          
        }
      }
      writeStringBuffer(buffer, '}> <{');
      first = true;
      for (part in constant.data) {
        for (datum in part.data) {
          i -= 1;
          if (!first) {
            writeStringBuffer(buffer, ', ');
          }
          first = false;
          if (datum is CompileTimeNumericDatum) {
            writeStringBuffer(buffer, widthToIntegerType(part.width));
          } else if (datum is StringDatum) {
            writeStringBuffer(buffer, '[');
            writeStringBuffer(buffer, concat(len(utf8Encode((datum as StringDatum).value))));
            writeStringBuffer(buffer, 'x i8]');
          } else {
            writeStringBuffer(buffer, 'ptr');
          }
          writeStringBuffer(buffer, ' ');
          writeStringBuffer(buffer, convertDatumToOperandForConstant(datum).serialize(serializeLabel));
        }
      }
      assert(i == 0, concat(i));
      writeStringBuffer(buffer, '}>\n');
    }
    return readStringBuffer(buffer);
  }

  LLVMSubroutineList functions = []:LLVMSubroutine;

  //#override
  Null assemble(PseudoInstructionList pseudoInstructions) {
    LLVMSubroutineBuilder subroutineBuilder = LLVMSubroutineBuilder(rootLabel.deriveWith('main'), AssemblerLabel(null, ''), null, null, null, null, null, null);
    for (instruction in pseudoInstructions) {
      if (instruction is Label) {
        subroutineBuilder.handleLabel((instruction as Label).label);
      } else if (instruction is StartSubroutine) {
        assert(subroutineBuilder.indent == 1, 'unmatched BlockStartMarker');
        append(subroutineBuilder.blocks, LLVMBlock(subroutineBuilder.currentBlockName, subroutineBuilder.currentBlockInstructions, subroutineBuilder.indent));
        append(functions, subroutineBuilder.build());
        AssemblerLabel root = AssemblerLabel(null, '');
        subroutineBuilder = LLVMSubroutineBuilder(null, root, root.deriveWith('parameterCount'), root.deriveWith('closurePointer'), root.deriveWith('thisPointer'), root.deriveWith('thisType'), root.deriveWith('returnValuePointer'), root.deriveWith('returnTypePointer'));
      } else if (instruction is Annotation) {
        subroutineBuilder.addAnnotation((instruction as Annotation).label);
      } else if (instruction is Prolog) {
        // llvm does its own prolog
      } else if (instruction is Epilog) {
        // llvm does its own epilog
      } else if (instruction is FinalReturn) {
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['ret void']:Anything, 'exit function'));
      } else if (instruction is PrepareConstructorTrampoline) {
        subroutineBuilder.prepareTrampoline(
          convertDatumToOperandForRead((instruction as PrepareConstructorTrampoline).parameterCount, subroutineBuilder),
          convertDatumToOperandForRead((instruction as PrepareConstructorTrampoline).thisType, subroutineBuilder),
          convertDatumToOperandForRead((instruction as PrepareConstructorTrampoline).thisPointer, subroutineBuilder),
        );
      } else if (instruction is ConstructorTrampoline) {
        subroutineBuilder.setThunk();
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(
          subroutineBuilder.indent,
          ['musttail call void (i64, i64, i64, i64, i64, i64, ...) @',
          (instruction as ConstructorTrampoline).actualConstructor,
          '(i64 ', subroutineBuilder.trampolineParameterCount.asInteger64(subroutineBuilder), ', i64 0, ', 
           'i64 ', subroutineBuilder.trampolineThisType.asInteger64(subroutineBuilder), ', ', 
           'i64 ', subroutineBuilder.trampolineThisPointer.asInteger64(subroutineBuilder), ', ', 
           'i64 ', subroutineBuilder.trampolineReturnTypePointer.asInteger64(subroutineBuilder), ', ', 
           'i64 ', subroutineBuilder.trampolineReturnValuePointer.asInteger64(subroutineBuilder), ', ...)'],
          'tail-call to actual constructor',
        ));
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['ret void']:Anything, 'exit function'));
      } else if (instruction is AstNodeReference) {
        AstNode node = (instruction as AstNodeReference).node;
        append(subroutineBuilder.currentBlockInstructions, LLVMComment(subroutineBuilder.indent, concat('line ', node.sourceLocation.lineNo, ': ', truncateString(concat(node), 64)), false));
      } else if (instruction is BlockStartMarker) {
        subroutineBuilder.adjustIndent(1);
      } else if (instruction is BlockEndMarker) {
        subroutineBuilder.adjustIndent(-1);
        assert(subroutineBuilder.indent >= 1, 'more blockends than blockstarts');
      } else if (instruction is Mov) {
        writeToLocalDatum(convertDatumToOperandForRead((instruction as Mov).source, subroutineBuilder), (instruction as Mov).target, subroutineBuilder, (instruction as Mov).comment);
      } else if (instruction is Push) {
        subroutineBuilder.pushSaveStack(convertDatumToOperandForRead((instruction as Push).source, subroutineBuilder));
      } else if (instruction is Pop) {
        writeToLocalDatum(subroutineBuilder.popSaveStack(), (instruction as Pop).target, subroutineBuilder, (instruction as Pop).comment);
      } else if (instruction is KeepAlive) {
        // not neccesary with llvm
      } else if (instruction is ReplaceParameter) {
        subroutineBuilder.replaceParameterForTrampoline(
          (instruction as ReplaceParameter).target.index,
          convertDatumToOperandForRead((instruction as ReplaceParameter).source, subroutineBuilder),
        );
      } else if (instruction is UpdateGlobalVariable) {
        append(
          subroutineBuilder.currentBlockInstructions,
          LLVMOpcode(
            subroutineBuilder.indent,
            [
              'store i64 ',
              convertDatumToOperandForRead((instruction as UpdateGlobalVariable).source, subroutineBuilder).asInteger64(subroutineBuilder),
              ', ptr ',
              GlobalOperand(((instruction as UpdateGlobalVariable).target).label, ((instruction as UpdateGlobalVariable).target).commentName),
            ],
            concat('set ', (instruction as UpdateGlobalVariable).target.commentName, ' to ', (instruction as UpdateGlobalVariable).source.commentName),
          ),
        );
      } else if (instruction is Comment) {
        append(subroutineBuilder.currentBlockInstructions, LLVMComment(subroutineBuilder.indent, (instruction as Comment).comment, false));
      } else if (instruction is Jmp) {
        if ((instruction as Jmp).condition != null) {
          AssemblerLabel afterLabel = subroutineBuilder.rootLabel.deriveWith('continue');
          LLVMRegisterOperand conditionI1 = subroutineBuilder.createRegisterOperand(concat((instruction as Jmp).condition!.commentName, ' boolean'), RegisterType.other);
          append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [conditionI1, ' = trunc i64 ', convertDatumToOperandForRead((instruction as Jmp).condition!, subroutineBuilder).asInteger64(subroutineBuilder), ' to i1'], 'truncate i64 to boolean'));
          append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['br i1 ', conditionI1, ', label %', (instruction as Jmp).label, ', label %', afterLabel], (instruction as Jmp).comment));
          subroutineBuilder.newBlock(afterLabel);
        } else {
          append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['br label %', (instruction as Jmp).label], (instruction as Jmp).comment));
        }
      } else if (instruction is StoreByte) {
        LLVMRegisterOperand sourceI8 = subroutineBuilder.createRegisterOperand(concat((instruction as StoreByte).source.commentName, ' i8'), RegisterType.other);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [sourceI8, ' = trunc i64 ', convertDatumToOperandForRead((instruction as StoreByte).source, subroutineBuilder).asInteger64(subroutineBuilder), ' to i8'], 
        'truncate i64 to byte'));
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['store i8 ', sourceI8, ', ptr ', convertDatumToOperandForRead((instruction as StoreByte).targetPointer, subroutineBuilder).asPointer(subroutineBuilder)], (instruction as StoreByte).comment));
      } else if (instruction is StoreQuad) {
        LLVMRegisterOperand sum = subroutineBuilder.createRegisterOperand(concat((instruction as StoreQuad).targetPointer.commentName, ' plus ', (instruction as StoreQuad).offset.commentName), RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [sum, ' = add i64 ', convertDatumToOperandForRead((instruction as StoreQuad).targetPointer, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as StoreQuad).offset, subroutineBuilder)], 'calculate sum of base and offset for dereference'));
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['store i64 ', convertDatumToOperandForRead((instruction as StoreQuad).source, subroutineBuilder).asInteger64(subroutineBuilder), ', ptr ', sum.asPointer(subroutineBuilder)], (instruction as StoreQuad).comment));
      } else if (instruction is Call) {
        AnythingList instructionParts = ['call i64 ', convertDatumToOperandForRead((instruction as Call).target, subroutineBuilder).asPointer(subroutineBuilder), '('];
        Boolean first = true;
        for (arg in (instruction as Call).arguments) {
          if (!first) {
            append(instructionParts, ', ');
          }
          first = false;
          append(instructionParts, 'i64 ');
          append(instructionParts, convertDatumToOperandForRead(arg, subroutineBuilder).asInteger64(subroutineBuilder));
        }
        append(instructionParts, ')');
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, instructionParts, (instruction as Call).comment));
      } else if (instruction is CallSystem) {
        externSignatures.set((instruction as CallSystem).functionName, (instruction as CallSystem).signature);
        defaultLibraries.add((instruction as CallSystem).libraryName); 
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand(concat('return value of ', (instruction as CallSystem).functionName), RegisterType.i64);
        AnythingList instructionParts = [result, ' = call i64 @', (instruction as CallSystem).functionName, '('];
        Boolean first = true;
        for (arg in (instruction as CallSystem).arguments) {
          if (!first) {
            append(instructionParts, ', ');
          }
          first = false;
          append(instructionParts, 'i64 ');
          append(instructionParts, convertDatumToOperandForRead(arg, subroutineBuilder).asInteger64(subroutineBuilder));
        }
        append(instructionParts, ')');
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, instructionParts, (instruction as CallSystem).comment));
        writeToLocalDatum(result, (instruction as PseudoComputation).result, subroutineBuilder, concat('store ', (instruction as PseudoComputation).result.commentName));
      } else if (instruction is LoadByte) {
        LLVMRegisterOperand resultI8 = subroutineBuilder.createRegisterOperand(concat((instruction as LoadByte).result.commentName, ' byte'), RegisterType.other);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [resultI8, ' = load i8, ptr ', convertDatumToOperandForRead((instruction as LoadByte).source, subroutineBuilder).asPointer(subroutineBuilder)], (instruction as PseudoComputation).comment));
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = zext i8 ', resultI8, ' to i64'], 'zero-extend load result to i64'));
        writeToLocalDatum(result, (instruction as PseudoComputation).result, subroutineBuilder, concat('store ', (instruction as PseudoComputation).result.commentName));
      } else if (instruction is LoadQuad) {
        LLVMRegisterOperand sum = subroutineBuilder.createRegisterOperand(concat('pointer to ', (instruction as LoadQuad).result.commentName), RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [sum, ' = add i64 ', convertDatumToOperandForRead((instruction as LoadQuad).source, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as LoadQuad).offset, subroutineBuilder).asInteger64(subroutineBuilder)], 'calculate sum of base and offset for dereference'));
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = load i64, ptr ', sum.asPointer(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as PseudoComputation).result, subroutineBuilder, concat('store ', (instruction as PseudoComputation).result.commentName));
      } else if (instruction is LoadAddress) {
        writeToLocalDatum(readAddressOfDatumAsOperand((instruction as LoadAddress).source, subroutineBuilder), (instruction as LoadAddress).result, subroutineBuilder, (instruction as PseudoComputation).comment);
      } else if (instruction is Cmp) {
        LLVMRegisterOperand i1 = subroutineBuilder.createRegisterOperand(concat((instruction as Cmp).result.commentName, ' boolean'), RegisterType.other);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [i1, ' = icmp ', comparisonToIcmpCondition((instruction as Cmp).comparison), ' i64 ', convertDatumToOperandForRead((instruction as Cmp).left, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as Cmp).right, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = zext i1 ', i1, ' to i64'], 'zero-extend icmp result to i64'));
        writeToLocalDatum(result, (instruction as PseudoComputation).result, subroutineBuilder, concat('store ', (instruction as PseudoComputation).result.commentName));
      } else if (instruction is BitTest) {
        LLVMRegisterOperand mask = subroutineBuilder.createRegisterOperand('bit mask for bit test', RegisterType.i64);
        LLVMOperand bitOffset = convertDatumToOperandForRead((instruction as BitTest).bitOffset, subroutineBuilder);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [mask, ' = shl i64 1, ', bitOffset], 'calculate bit mask for bit test'));
        LLVMRegisterOperand andResult = subroutineBuilder.createRegisterOperand('masked bit base', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [andResult, ' = and i64 ', convertDatumToOperandForRead((instruction as BitTest).bitBase, subroutineBuilder).asInteger64(subroutineBuilder), ', ', mask], (instruction as PseudoComputation).comment));
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = lshr i64 ', andResult, ', ', bitOffset], 'shift right to produce boolean'));
        writeToLocalDatum(result, (instruction as BitTest).result, subroutineBuilder, 'store result');
      } else if (instruction is BooleanNot) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = xor i64 1, ', convertDatumToOperandForRead((instruction as BooleanNot).operand, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as BooleanNot).result, subroutineBuilder, 'store result');
      } else if (instruction is BitwiseNot) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        // s0x1 means two's complement -1
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = xor i64 s0x1, ', convertDatumToOperandForRead((instruction as BitwiseNot).operand, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as BitwiseNot).result, subroutineBuilder, 'store result');
      } else if (instruction is Negate) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = sub i64 0, ', convertDatumToOperandForRead((instruction as Negate).operand, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as Negate).result, subroutineBuilder, 'store result');
      } else if (instruction is And) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = and i64 ', convertDatumToOperandForRead((instruction as And).left, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as And).right, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as And).result, subroutineBuilder, 'store result');
      } else if (instruction is Or) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = or i64 ', convertDatumToOperandForRead((instruction as Or).left, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as Or).right, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as Or).result, subroutineBuilder, 'store result');
      } else if (instruction is XOr) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = xor i64 ', convertDatumToOperandForRead((instruction as XOr).left, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as XOr).right, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as XOr).result, subroutineBuilder, 'store result');
      } else if (instruction is SignedAdd) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = add i64 ', convertDatumToOperandForRead((instruction as SignedAdd).augend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as SignedAdd).addend, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as SignedAdd).result, subroutineBuilder, 'store result');
      } else if (instruction is SignedSubtract) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = sub i64 ', convertDatumToOperandForRead((instruction as SignedSubtract).minuend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as SignedSubtract).subtrahend, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as SignedSubtract).result, subroutineBuilder, 'store result');
      } else if (instruction is SignedMultiply) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = mul i64 ', convertDatumToOperandForRead((instruction as SignedMultiply).multiplicand, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as SignedMultiply).multiplier, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as SignedMultiply).result, subroutineBuilder, 'store result');
      } else if (instruction is SignedDivide) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = sdiv i64 ', convertDatumToOperandForRead((instruction as SignedDivide).dividend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as SignedDivide).divisor, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as SignedDivide).result, subroutineBuilder, 'store result');
      } else if (instruction is SignedModulus) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = srem i64 ', convertDatumToOperandForRead((instruction as SignedModulus).dividend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as SignedModulus).divisor, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as SignedModulus).result, subroutineBuilder, 'store result');
      } else if (instruction is UnsignedAdd) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = add i64 ', convertDatumToOperandForRead((instruction as UnsignedAdd).augend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as UnsignedAdd).addend, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as UnsignedAdd).result, subroutineBuilder, 'store result');
      } else if (instruction is UnsignedSubtract) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = sub i64 ', convertDatumToOperandForRead((instruction as UnsignedSubtract).minuend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as UnsignedSubtract).subtrahend, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as UnsignedSubtract).result, subroutineBuilder, 'store result');
      } else if (instruction is UnsignedMultiply) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = mul i64 ', convertDatumToOperandForRead((instruction as UnsignedMultiply).multiplicand, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as UnsignedMultiply).multiplier, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as UnsignedMultiply).result, subroutineBuilder, 'store result');
      } else if (instruction is UnsignedDivide) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = udiv i64 ', convertDatumToOperandForRead((instruction as UnsignedDivide).dividend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as UnsignedDivide).divisor, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as UnsignedDivide).result, subroutineBuilder, 'store result');
      } else if (instruction is UnsignedModulus) {
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = urem i64 ', convertDatumToOperandForRead((instruction as UnsignedModulus).dividend, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as UnsignedModulus).divisor, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as UnsignedModulus).result, subroutineBuilder, 'store result');
      } else if (instruction is ShiftPseudoComputation) {
        String operation;
        if (instruction is ShiftLeft) {
          operation = 'shl';
        } else {
          assert(instruction is ShiftRight, 'unexpected shift type');
          operation = 'lshr';
        }
        LLVMRegisterOperand result = subroutineBuilder.createRegisterOperand('result', RegisterType.i64);
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, [result, ' = ', operation, ' i64 ', convertDatumToOperandForRead((instruction as ShiftPseudoComputation).lhs, subroutineBuilder).asInteger64(subroutineBuilder), ', ', convertDatumToOperandForRead((instruction as ShiftPseudoComputation).rhs, subroutineBuilder).asInteger64(subroutineBuilder)], (instruction as PseudoComputation).comment));
        writeToLocalDatum(result, (instruction as ShiftPseudoComputation).result, subroutineBuilder, 'store result');
      } else if (instruction is Debugger) {
        append(subroutineBuilder.currentBlockInstructions, LLVMOpcode(subroutineBuilder.indent, ['call void @llvm.debugtrap()']:Anything, 'call debugger'));
      } else {
        throw(concat("Unknown PseudoInstruction ", instruction.className));
      }
    }
    append(subroutineBuilder.blocks, LLVMBlock(subroutineBuilder.currentBlockName, subroutineBuilder.currentBlockInstructions, subroutineBuilder.indent));
    append(functions, subroutineBuilder.build());
  }
  
  StringList debugLines = []:String;

  String addDebugLine(String line) {
    Integer lineCode = len(debugLines);
    append(debugLines, concat('!', lineCode, ' = ', line));
    return concat('!', lineCode);
  }

  String serializedDebugPrefix;
  String fileCode;
  String subroutineTypeCode;
  String cuCode;

  Null initDebugLines(String mainProgramFilename, String mainProgramDirectory) {
    fileCode = addDebugLine(concat('!DIFile(filename: "', escapeLL(mainProgramFilename), '", directory: "', escapeLL(mainProgramDirectory), '")'));
    cuCode = addDebugLine(concat('distinct !DICompileUnit(file: ', fileCode, ', language: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)'));
    StringBuffer defaultLibs = createStringBuffer();
    writeStringBuffer(defaultLibs, '/entry:main');
    for (lib in defaultLibraries.values() as StringList) {
      writeStringBuffer(defaultLibs, ' /defaultlib:');
      writeStringBuffer(defaultLibs, lib);
      writeStringBuffer(defaultLibs, '.lib');
    }
    serializedDebugPrefix = concat(
      '!llvm.dbg.cu = !{', cuCode, '}\n',
      '!llvm.module.flags = !{', addDebugLine('!{i32 2, !"CodeView", i32 1}'), ', ', addDebugLine('!{i32 2, !"Debug Info Version", i32 3}'), '}\n',
      '!llvm.linker.options = !{', addDebugLine(concat('!{!"', readStringBuffer(defaultLibs), '"}')), '}',
    );
    subroutineTypeCode = addDebugLine(concat('!DISubroutineType(types: ', addDebugLine('!{}'), ')'));
  }

  //#override
  String serialize(String mainProgramFilename) {
    initDebugLines(concat(mainProgramFilename, '.ll'), ''); // TODO: check on the directory thing, TODO: consider not hardcoding <input>.ll
    stderr('serializeData...');
    serializedDebugComments = serializeDebugComments(debugComments);
    serializedConst = serializeData(constants);
    serializedData = serializeData(data);
    serializedImports = serializeImports();
    stderr('serializeGlobalVariables...');
    serializedGlobalVariables = serializeGlobalVariables(uninitializedGlobals);
    String output1 = concat(
      '; syd compiler output for ', mainProgramFilename, '\n',
      '; target platform: win64 on x86_64\n',
      '\n',
      'source_filename = "', escapeLL(mainProgramFilename), '"\n',
      'target datalayout = "S128" ; win64 requires 16-byte alignment of the stack\n',
      'target triple = "x86_64-pc-windows-msvc19.30.30706"\n',
      '\n',
      '; Declare the LLVM intrinsics used by the syd compiler.\n',
      'declare void @llvm.debugtrap()\n',
      'declare void @llvm.va_start(ptr)\n',
      'declare void @llvm.va_end(ptr)\n',
      '\n',
      serializedDebugComments,
      '\n',
      '; CONSTANTS\n',
      serializedConst,
      '\n',
      '; MUTABLE DATA\n',
      serializedData,
      '\n',
      '; IMPORTS\n',
      serializedImports,
      '\n',
      '; GLOBAL VARIABLES\n',
      serializedGlobalVariables,
      '\n',
    );
    Integer lineCount = 0;
    for (char in scalarValues(output1)) {
      if (char == 0x0a) {
        lineCount += 1;
      }
    }
    currentLine = lineCount + 1;
    stderr('serializing functions...');
    for (function in functions) {
      function.serialize(this);
    }
    return concat(
      output1,
      join(code, '\n'),
      '\n\n',
      serializedDebugPrefix,
      join(debugLines, '\n'),
    );
  }

  Null constructor(AssemblerLabel rootLabel) {
    super.constructor(rootLabel);
    scratchSpaceLabel = rootLabel.deriveWith('scratchSpace');
  }
}
