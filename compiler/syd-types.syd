import 'core.syd';
import 'syd-assembler.syd';

fwdclass Type extends Object;
fwdclass AbstractSubroutineType extends Type;
fwdclass AbstractSubroutineTypeWithSpecificParameters extends AbstractSubroutineType;
fwdclass AbstractListType extends Type;
fwdclass ReadOnlyListType extends AbstractListType;
fwdclass TypeRegistry extends Object;

fwdclassprop TypeList AbstractSubroutineTypeWithSpecificParameters.parameterTypes;
fwdclassprop NullFunction TypeRegistry.registerType;
fwdclassprop AbstractSubroutineTypeWithSpecificParametersList TypeRegistry.typesOfSubroutinesWithSpecificParameters;
fwdclassprop ReadOnlyListTypeList TypeRegistry.typesOfReadOnlyLists;

class Type extends Object {
  IntegerNullable code = null;
  String name;

  Boolean isSubtypeOf(Type other) {
    abstract();
  }

  Boolean isSubroutineType() {
    return false;
  }

  // XXX do we need this?
  Boolean literalValueIsAppropriate(Anything value) {
    return false;
  }

  Operand asOperand() {
    assert(code != null, concat('cannot read type operand (', name, ') before codes are assigned (did you forget to call markConstructed?)'));
    return Operand(hex32(code!), otImm32);
  }

  Boolean hasDynamicType() {
    abstract();
  }

  Boolean isConstructed = false;
  Boolean isUsedInTypeCheck = false;

  Null markConstructed() {
    isConstructed = true;
  }

  Null markUsedInTypeCheck() {
    isUsedInTypeCheck = true;
  }

  Null assignCode(Integer codeArg) {
    code = codeArg;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    name = nameArg;
    super.constructor();
    typeRegistryArg.registerType(this, isSubroutineType());
  }

  String toString() {
    if (code != null) {
      return concat(name, '\'', code!);
    }
    return name;
  }
}

class WhateverType extends Type {
  Boolean isSubtypeOf(Type other) {
    return true;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null markConstructed() {
    assert(false, 'Whatever type cannot be constructed.');
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Whatever');
  }
}

class AnythingType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is WhateverType;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null markConstructed() {
    assert(false, 'Anything type cannot be constructed.');
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Anything');
  }
}

class SentinelType extends Type {
  Boolean isSubtypeOf(Type other) {
    return true;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<sentinel>');
  }
}

class NullableType extends Type {
  Type subtype;

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is NullableType && subtype.isSubtypeOf((other as NullableType).subtype));
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null markConstructed() {
    assert(false, 'Nullable types cannot be constructed.');
  }

  Null constructor(TypeRegistry typeRegistryArg, Type subtypeArg) {
    super.constructor(typeRegistryArg, concat(subtypeArg.name, 'Nullable'));
    subtype = subtypeArg;
  }
}

class NumericType extends Type {
  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    super.constructor(typeRegistryArg, nameArg);
  }
}

class NullType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || other is NullType
        || other is NullableType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value == null;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Null');
  }
}

class BooleanType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || other is BooleanType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value == true || value == false;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Boolean');
  }
}

class IntegerType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || other is IntegerType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is Integer;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Integer');
  }
}

class StringType extends Type {
  // pointer to heap-allocated structure (or structure in data segment)

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || other is StringType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is String;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'String');
  }
}

class EnumValue extends Object {
  Object type; // XXX Object should be EnumType
  String name;
  Integer index;

  Null constructor(Object typeArg, String nameArg, Integer indexArg) {
    super.constructor();
    type = typeArg;
    name = nameArg;
    index = indexArg;
  }
}

class EnumType extends NumericType {
  Map values = Map();

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || other is StringType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is EnumValue && cast(value).type == this;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg, StringList valuesArg) {
    super.constructor(typeRegistryArg, nameArg);
    Integer index = 0;
    for (value in valuesArg) {
      values.set(value, EnumValue(this, value, index));
      index += 1;
    }
  }
}

class ClassType extends Type {
  // xxx properties, methods, constructor...

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    super.constructor(typeRegistryArg, nameArg);
  }
}

class RootClassType extends Type {
  // pointer to class instance

  Boolean isSubtypeOf(Type other) {
    return other is ClassType || other is RootClassType;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<object>');
  }
}

class AbstractSubroutineType extends Type {
  Type returnType;

  String createName() {
    return concat(returnType.name, 'Function');
  }

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is AbstractSubroutineType && returnType.isSubtypeOf((other as AbstractSubroutineType).returnType));
  }

  Boolean isSubroutineType() {
    return true;
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg) {
    returnType = returnTypeArg;
    super.constructor(typeRegistryArg, createName());
  }
}

class SubroutineTypeWithAnyArguments extends AbstractSubroutineType {
  Null markConstructed() {
    assert(false, concat(name, ' type cannot be constructed.'));
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg) {
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

class AbstractSubroutineTypeWithSpecificParameters extends AbstractSubroutineType {
  Boolean equals(Type returnTypeArg, TypeList parameterTypesArg, Boolean isVarArgsArg) {
    abstract();
  }
}

class SubroutineTypeWithVarArgs extends AbstractSubroutineTypeWithSpecificParameters {
  Type parameterType;

  String createName() {
    return concat(super.createName(), '(', parameterType.name, '...)');
  }

  Boolean equals(Type returnTypeArg, TypeList parameterTypesArg, Boolean isVarArgsArg) {
    return isVarArgsArg && returnTypeArg == returnType && len(parameterTypesArg) == 1 && parameterTypesArg[0] == parameterType;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg, Type parameterTypeArg) {
    parameterType = parameterTypeArg;
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

class SubroutineTypeWithSpecificParameters extends AbstractSubroutineTypeWithSpecificParameters {
  TypeList parameterTypes;

  String createName() {
    String stringify(Type type) {
      return type.name;
    }
    return concat(super.createName(), '(', join(map(parameterTypes, stringify) as StringList, ', '), ')');
  }

  Boolean equals(Type returnTypeArg, TypeList parameterTypesArg, Boolean isVarArgsArg) {
    if (isVarArgsArg || returnTypeArg != returnType || len(parameterTypesArg) != len(parameterTypes)) {
      return false;
    }
    Integer index = 0;
    while (index < len(parameterTypes)) {
      if (parameterTypesArg[index] != parameterTypes[index]) {
        return false;
      }
      index += 1;
    }
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg, TypeList parameterTypesArg) {
    parameterTypes = parameterTypesArg;
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

AbstractSubroutineTypeWithSpecificParameters createOrFindSubroutineType(TypeRegistry typeRegistry, Type returnType, TypeList parameterTypes, Boolean isVarArgs) {
  for (entry in typeRegistry.typesOfSubroutinesWithSpecificParameters) {
    if (entry.equals(returnType, parameterTypes, isVarArgs)) {
      return entry;
    }
  }
  if (isVarArgs) {
    assert(len(parameterTypes) == 1, 'varargs must have exactly one parameter type');
    return SubroutineTypeWithVarArgs(typeRegistry, returnType, parameterTypes[0]);
  }
  return SubroutineTypeWithSpecificParameters(typeRegistry, returnType, parameterTypes);
}

// xxx ListLiteral

class AbstractListType extends Type {
  Type elementType;

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, nameArg);
    elementType = elementTypeArg;
  }
}

class ListType extends AbstractListType {
  // pointer to heap-allocated structure

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is AbstractListType &&
            elementType.isSubtypeOf((other as AbstractListType).elementType) &&
            (other as AbstractListType).elementType.isSubtypeOf(elementType));
  }

  // xxx literals

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'List'), elementTypeArg);
  }
}

class ReadOnlyListType extends AbstractListType {
  // pointer to heap-allocated structure, or a VarArgsParameterVot

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is ReadOnlyListType && elementType.isSubtypeOf((other as ReadOnlyListType).elementType));
  }

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'ReadOnlyList'), elementTypeArg);
  }
}

ReadOnlyListType createOrFindReadOnlyListType(TypeRegistry typeRegistry, Type elementType) {
  for (entry in typeRegistry.typesOfReadOnlyLists) {
    if (entry.elementType == elementType) {
      return entry;
    }
  }
  return ReadOnlyListType(typeRegistry, elementType);
}

class IterableType extends Type {
  // pointer to heap-allocated structure

  Type elementType;

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is IterableType && elementType.isSubtypeOf(cast(cast(other).elementType)));
  }

  Boolean hasDynamicType() {
    return true;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'Iterable'));
    elementType = elementTypeArg;
  }
}

class IteratorType extends Type {
  // pointer to heap-allocated structure

  Type elementType;

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType
        || other is WhateverType
        || (other is IteratorType && elementType.isSubtypeOf(cast(cast(other).elementType)));
  }

  Boolean hasDynamicType() {
    return true; 
  }

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'Iterator'));
    elementType = elementTypeArg;
  }
}

class ClosureType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is ClosureType;
  }

  Boolean hasDynamicType() {
    return false;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<closure>');
  }
}

class SystemType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is SystemType;
  }

  Boolean hasDynamicType() {
    return false;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<system>');
  }
}

class TypeRegistry extends Object {
  TypeList types = []:Type;

  Null registerType(Object type, Boolean isSubroutineType) { // XXX Object should be Type
    assert(type is Type, concat('tried to registerType ', type));
    append(types, type);
  }

  // These are used by createOrFindSubroutineType(), createOrFindReadOnlyListType(), et al.
  // TODO: right now managing this is O(N), could be made faster
  // e.g. keep the list sorted and binary search.
  AbstractSubroutineTypeWithSpecificParametersList typesOfSubroutinesWithSpecificParameters = []:AbstractSubroutineTypeWithSpecificParameters;
  ReadOnlyListTypeList typesOfReadOnlyLists = []:ReadOnlyListType;

  TypeList sortedTypes;

  Integer assignTypeCodes() {
    TypeList constructedNotTypeChecked = []:Type;
    TypeList constructedAndTypeChecked = []:Type;
    TypeList typeCheckedNotConstructed = []:Type;
    for (type in types) {
      if (type.isConstructed) {
        if (type.isUsedInTypeCheck) {
          append(constructedAndTypeChecked, type);
        } else {
          append(constructedNotTypeChecked, type);
        }
      } else {
        if (type.isUsedInTypeCheck) {
          append(typeCheckedNotConstructed, type);
        } else {
          // not used
        }
      }
    }
    sortedTypes = addLists(constructedNotTypeChecked, constructedAndTypeChecked, typeCheckedNotConstructed) as TypeList;
    Integer code = 0;
    for (type in sortedTypes) {
      type.assignCode(code);
      code += 1;
    }
    return len(constructedNotTypeChecked);
  }
}
