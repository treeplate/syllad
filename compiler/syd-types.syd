import 'core.syd';
import 'syd-assembler.syd';

class TypeRegistry extends Object {
  Map typesByCode = Map(); // Type to Integer

  // This is used by createOrFindSubroutineType().
  // TODO: right now managing this is O(N), could be made faster
  // e.g. keep the list sorted and binary search, or shard it by
  // number of parameters or return type or whatever...
  ObjectList typesOfSubroutinesWithSpecificParameters = [];

  Integer lastType = 0;
  Integer kSubroutineTypeBit = 0x40000000;

  Integer registerType(Anything type, Boolean isSubroutineType) { // XXX Anything should be Type
    assert(lastType < 0xFFFFFFFF, 'too many types');
    lastType += 1;
    Integer result = lastType;
    assert(result < kSubroutineTypeBit, 'too many types');
    if (isSubroutineType) {
      result += kSubroutineTypeBit;
    }
    typesByCode.set(type, result);
    return result;
  }

  Null constructor() {
    super.constructor();
  }
}

// xxx Type knows how to do things like + - * / % () [] etc

class Type extends Object {
  Integer code;
  String name;

  Boolean isSubtypeOf(Type other) {
    abstract();
  }

  Boolean isSubroutineType() {
    return false;
  }

  // XXX do we need this?
  Boolean literalValueIsAppropriate(Anything value) {
    return false;
  }

  Operand asOperand() {
    return Operand(hex32(code), otImm32);
  }

  // storage size in bytes; should probably always be either 0x08 or 0x10
  Integer size() {
    abstract();
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    code = typeRegistryArg.registerType(this, isSubroutineType());
    name = nameArg;
  }

  String toString() {
    return concat(name, '\'', code);
  }
}

class NothingType extends Type {
  Boolean isSubtypeOf(Type other) {
    return false;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value == this;
  }

  Integer size() {
    return 0x00;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<nothing>');
  }
}

class AnythingType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType;
  }

  Integer size() {
    return 0x10;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Anything');
  }
}

class NullableType extends Type {
  Type subtype;

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || (other is NullableType && subtype.isSubtypeOf(cast(cast(other).subtype)));
  }

  Integer size() {
    return 0x10;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type subtypeArg) {
    super.constructor(typeRegistryArg, concat(subtypeArg.name, 'Nullable'));
    subtype = subtypeArg;
  }
}

class NumericType extends Type {
  Integer size() {
    return 0x10;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    super.constructor(typeRegistryArg, nameArg);
  }
}

class NullType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is NullType || other is NullableType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value == null;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Null');
  }
}

class BooleanType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is BooleanType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value == true || value == false;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Boolean');
  }
}

class IntegerType extends NumericType {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is IntegerType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is Integer;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'Integer');
  }
}

class StringType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is StringType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is String;
  }

  Integer size() {
    return 0x10; // pointer to heap-allocated structure (or structure in data segment)
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, 'String');
  }
}

class EnumValue extends Object {
  Object type; // XXX Object should be EnumType
  String name;
  Integer index;

  Null constructor(Object typeArg, String nameArg, Integer indexArg) {
    super.constructor();
    type = typeArg;
    name = nameArg;
    index = indexArg;
  }
}

class EnumType extends NumericType {
  Map values = Map();

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || other is StringType;
  }

  Boolean literalValueIsAppropriate(Anything value) {
    return value is EnumValue && cast(value).type == this;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg, StringList valuesArg) {
    super.constructor(typeRegistryArg, nameArg);
    Integer index = 0;
    for (value in valuesArg) {
      values.set(value, EnumValue(this, value, index));
      index += 1;
    }
  }
}

class ClassType extends Type {
  // xxx properties, methods, constructor...

  Integer size() {
    return 0x10;
  }

  Null constructor(TypeRegistry typeRegistryArg, String nameArg) {
    super.constructor(typeRegistryArg, nameArg);
  }
}

class RootClassType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is ClassType || other is RootClassType;
  }

  Integer size() {
    return 0x10; // pointer to class instance
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<object>');
  }
}

class AbstractSubroutineType extends Type {
  Type returnType;

  String createName() {
    return concat(returnType.name, 'Function');
  }

  Boolean isSubtypeOf(Type other) {
    return other is AnythingType || (other is AbstractSubroutineType && returnType.isSubtypeOf(cast(cast(other).returnType)));
  }

  Boolean isSubroutineType() {
    return true;
  }

  Integer size() {
    return 0x10;
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg) {
    returnType = returnTypeArg;
    super.constructor(typeRegistryArg, createName());
  }
}

class SubroutineTypeWithAnyArguments extends AbstractSubroutineType {
  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg) {
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

class SubroutineTypeWithVarArgs extends AbstractSubroutineType {
  Type argumentType;

  String createName() {
    return concat(super.createName(), '(', argumentType.name, '...)');
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg, Type argumentTypeArg) {
    argumentType = argumentTypeArg;
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

class SubroutineTypeWithSpecificParameters extends AbstractSubroutineType {
  TypeList parameterTypes;

  String createName() {
    String stringify(Type type) {
      return type.name;
    }
    return concat(super.createName(), '(', join(cast(map(parameterTypes, stringify)), ', '), ')');
  }

  Null constructor(TypeRegistry typeRegistryArg, Type returnTypeArg, TypeList parameterTypesArg) {
    parameterTypes = parameterTypesArg;
    super.constructor(typeRegistryArg, returnTypeArg);
  }
}

SubroutineTypeWithSpecificParameters createOrFindSubroutineType(TypeRegistry typeRegistry, Type returnType, TypeList parameterTypes) {
  for (entry in typeRegistry.typesOfSubroutinesWithSpecificParameters) {
    SubroutineTypeWithSpecificParameters type = entry as SubroutineTypeWithSpecificParameters;
    if (type.returnType != returnType) {
      continue;
    }
    if (len(type.parameterTypes) != len(parameterTypes)) {
      continue;
    }
    Integer index = 0;
    Boolean found = true;
    while (index < len(parameterTypes)) {
      if (parameterTypes[index] != type.parameterTypes[index]) {
        found = false;
        break;
      }
      index += 1;
    }
    if (!found) {
      continue;
    }
    return type;
  }
  return SubroutineTypeWithSpecificParameters(typeRegistry, returnType, parameterTypes);
}

// xxx ListLiteral

class ListType extends Type {
  Type elementType;

  Boolean isSubtypeOf(Type other) {
    return other is Anything || (other is ListType && elementType.isSubtypeOf(cast(cast(other).elementType)));
  }

  Integer size() {
    return 0x10; // pointer to heap-allocated structure
  }

  // xxx literals

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'List'));
    elementType = elementTypeArg;
  }
}

class IterableType extends Type {
  Type elementType;

  Boolean isSubtypeOf(Type other) {
    return other is Anything || (other is IterableType && elementType.isSubtypeOf(cast(cast(other).elementType)));
  }

  Integer size() {
    return 0x10; // pointer to heap-allocated structure
  }

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'Iterable'));
    elementType = elementTypeArg;
  }
}

class IteratorType extends Type {
  Type elementType;

  Boolean isSubtypeOf(Type other) {
    return other is Anything || (other is IteratorType && elementType.isSubtypeOf(cast(cast(other).elementType)));
  }

  Integer size() {
    return 0x10; // pointer to heap-allocated structure
  }

  Null constructor(TypeRegistry typeRegistryArg, Type elementTypeArg) {
    super.constructor(typeRegistryArg, concat(elementTypeArg.name, 'Iterator'));
    elementType = elementTypeArg;
  }
}

class ClosureType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is ClosureType;
  }

  Integer size() {
    return 0x08;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<closure>');
  }
}

class SystemType extends Type {
  Boolean isSubtypeOf(Type other) {
    return other is SystemType;
  }

  Integer size() {
    return 0x08;
  }

  Null constructor(TypeRegistry typeRegistryArg) {
    super.constructor(typeRegistryArg, '<system>');
  }
}
