import 'core.syd';
import 'syd-slots.syd';
import 'syd-dynamic-slot.syd';
import 'syd-operands.syd';

fwdclass SlotManager extends Object;
fwdclassprop NullFunction SlotManager._releaseOperand;

// Managed Operand
// TODO: this really should be an AssignedOperand or something like that, it's slots that are managed not operands
class Mop extends Operand {
  Operand operand;
  SlotManager slotManager;

  Boolean debugValid = true;

  Boolean isOperandKind(Integer kind) {
    assert(debugValid, 'cannot use released Mop');
    return operand.isOperandKind(kind);
  }

  String toString() {
    assert(debugValid, 'cannot use released Mop');
    return operand.toString();
  }

  Anything snapshot() {
    assert(debugValid, 'cannot use released Mop');
    return operand.snapshot();
  }

  Operand low8Bits() {
    assert(debugValid, 'cannot use released Mop');
    return operand.low8Bits();
  }

  Boolean equals(Operand other) {
    assert(debugValid, 'cannot use released Mop');
    if (other is Mop) {
      return operand.equals((other as Mop).operand);
    }
    return operand.equals(other);
  }

  Boolean isImmediate() {
    assert((operand is ImmediateOperand) == isOperandKind(immediate8 | immediate32 | immediate64), 'inconsistency in Mop');
    return operand is ImmediateOperand;
  }

  Boolean isMemory() {
    assert((operand is MemoryOperand) == isOperandKind(memory), 'inconsistency in Mop');
    return operand is MemoryOperand;
  }

  // After this is called, the Mop should never be used again.
  Null release() {
    assert(debugValid, 'cannot use released Mop');
    slotManager._releaseOperand(this);
    debugValid = false;
  }

  Null constructor(Operand operandArg, SlotManager slotManagerArg) {
    super.constructor();
    assert(!(operandArg is Mop), 'cannot manage an already-managed operand');
    operand = operandArg;
    slotManager = slotManagerArg;
  }
}

enum Storing { Value Type Internal Nothing Immediate }
String describeWhat(Storing what) {
  if (what == StoringValue) {
    return 'value';
  }
  if (what == StoringType) {
    return 'type';
  }
  if (what == StoringInternal) {
    return 'internal';
  }
  if (what == StoringNothing) {
    return 'nothing';
  }
  if (what == StoringImmediate) {
    return 'immediate';
  }
  assert(false, concat('unsupported what value: ', what));
}

Null emitMov(AssemblerBlock block, Operand targetArg, Operand sourceArg, String comment) {
  Operand source = sourceArg;
  Operand target = targetArg;
  if (source is Mop) {
    source = (source as Mop).operand;
  }
  if (target is Mop) {
    target = (target as Mop).operand;
  }
  if (target is MemoryOperand && ((source is ImmediateOperand && (source as ImmediateOperand).minBits() > 32) || source is MemoryOperand)) {
    block.addCode('mov', [r11, source], concat('indirect through r11 because operand pair (', target, ', ', source, ') is not allowed with mov'));
    source = r11;
  }
  block.addCode('mov', [target, source]:Anything, comment);
}

class SlotStatusEntry extends Object {
  SlotNullable slot = null;
  MopNullable mop = null;
  Storing what = StoringNothing;

  Null assignMop(MopNullable mopArg) {
    assert(what == StoringImmediate || slot != null, concat('mop assigned for ', what, ' with no slot'));
    mop = mopArg;
  }

  Null assignSlot(SlotNullable slotArg, Storing whatArg) {
    assert(mop == null, 'slot changed while entry had a mop');
    slot = slotArg;
    what = whatArg;
  }
}

class RegisterEntry extends SlotStatusEntry {
  Register64Operand operand;

  RegisterEntryNullable nextLeastRecentlyUsed = null;

  Null assignNextLeastRecentlyUsed(RegisterEntryNullable next) {
    nextLeastRecentlyUsed = next;
  } 

  String toString() {
    return concat(className, ' [', operand, ' ', what, ']: ', slot, ' (mop=', mop, ')');
  }

  Null constructor(Register64Operand operandArg) {
    super.constructor();
    operand = operandArg;
  }
}

class StackEntry extends SlotStatusEntry {
  StackOperand operand;
  Integer index;
  
  String toString() {
    return concat(className, '#', index, ' [', operand, ' ', what, ']: ', slot, ' (mop=', mop, ')');
  }

  Null constructor(Integer indexArg, StackMetrics stackMetrics) {
    super.constructor();
    index = indexArg;
    operand = StackOperand(stackMetrics, index);
  }
}

// the list of register operands we prefer to use, in order of best to worst
Register64OperandList preferredRegisters = [
  r10, // volatile
  // r11, // volatile, but used as a scratch register by emitMov
  rax, // volatile
  // the general-purpose non-volatiles:
  rbx,
  rsi,
  rdi,
  r12,
  r13,
  r14,
  r15,
  // used by calling convention:
  rcx, // volatile
  rdx, // volatile
  r8, // volatile
  r9, // volatile
  rbp, // used for frame pointer - immediately saved
  rsp, // stack pointer - immediately saved
];

// when this is created, by definition none of the registers are assigned and all slots are
// in their "home" positions with no active nesting.
// owner should call save() to lock all magic operands (e.g. rbp)
// owner should find a home location on the stack for all slots.
// TODO: eventually, we should avoid allocating stack for slots we don't need to allocate stack for
// TODO: we should be more clever about slots being in multiple locations (for example, if
// you read something into rax and rcx, then read it into rax again, it should be a no-op).
// TODO: track when a slot is used for the last time, and stop maintaining it after that point.
// TODO: track which non-volatile registers we used so that we can properly write prolog/epilog.
// TODO: consider using the shadow space in addition to the stack

Integer slotManagers = 0;

class Chains extends Object {
  Map forwards = Map(); // Operand -> Operand
  Map backwards = Map(); // Operand <- Operand

  OperandNullable goForwards(Operand from) {
    return forwards.get(from) as OperandNullable;
  }

  OperandNullable goBackwards(Operand to) {
    return backwards.get(to) as OperandNullable;
  }

  Null addEntry(Operand from, Operand to) {
    assert(forwards.get(from) == null, concat('double of ', from, ' in forwards'));
    assert(backwards.get(to) == null, concat('double of ', to, ' in backwards'));
    forwards.set(from, to);
    backwards.set(to, from);
  }

  Null removeEntry(Operand from, Operand to) {
    assert(forwards.get(from) == to, 'removeEntry args inconsistent with forwards');
    assert(backwards.get(to) == from, 'chains are confused');
    forwards.set(from, null);
    backwards.set(to, null);
  }

  OperandList forwardsKeys() {
    return forwards.keys() as OperandList;
  }

  OperandList backwardsKeys() {
    return backwards.keys() as OperandList;
  }

  String toString() {
    return forwards.toString();
  }
}

class SlotManager extends Object {
  SlotContextList scopes = []:SlotContext;
  AssemblerBlockList blocks = []:AssemblerBlock;
  Integer nestedScopeDepth = -1;

  // The list of currently outstanding managed operands.
  Set managedOperands = Set(); // of Mop

  // The list of all slots we have managed so far.
  Set trackedSlots = Set(); // of DynamicSlot

  // The list of all registers we ended up using.
  Set usedRegisters = Set(); // of Register64Operand

  // The slots that each register is assigned to
  Map registerStatus = Map(); // of register bit (Integer) to RegisterEntry instance
  RegisterEntryNullable leastRecentlyUsed = null;
  RegisterEntry mostRecentlyUsed;

  StackEntryList stackStatus = []:StackEntry;

  StackMetrics stackMetrics = StackMetrics();

  Integer stackSize() {
    assert(len(stackStatus) == stackMetrics.stackSize, 'inconsistent');
    return len(stackStatus) * 0x08;
  }

  String basicSETS(Anything se) {
    StackEntry stackEntry = se as StackEntry;
    String slotName = '(no slot)';
    if(stackEntry.slot != null) {
      slotName = stackEntry.slot!.debugName;
    }
    return concat(stackEntry.operand, ': ', slotName, concat(' storing ', stackEntry.what));
  }

  String prettyStackStatus() {
    return join(map(stackStatus, basicSETS) as StringList, '\n');
  }

  String basicRETS(Anything se) {
    RegisterEntry registerEntry = se as RegisterEntry;
    String slotName = '(no slot)';
    if(registerEntry.slot != null) {
      slotName = registerEntry.slot!.debugName;
    }
    return concat(registerEntry.operand, ': ', slotName, concat(' storing ', registerEntry.what));
  }

  String prettyRegisterStatus() {
    return join(map(registerStatus.values(), basicRETS) as StringList, '\n');
  }

  Mop findMop(Operand value) {
    // TODO: need to make this O(1) not O(N)
    assert(!(value is Mop), 'unexpected managed operand');
    for (candidate in managedOperands.values()) {
      if ((candidate as Mop).operand.equals(value)) {
        return candidate as Mop;
      } 
    }
    assert(false, 'tried and failed to find mop');
  }

  Operand operandFor(Slot slot, Storing what) {
    assert(what != StoringInternal && what != StoringNothing && what != StoringImmediate, 'invalid location for operandFor');
    if (what == StoringValue) {
      return slot.value();
    }
    assert(what == StoringType, 'unknown Storing variant');
    return slot.dynamicType();
  }

  Boolean isPinned(Slot slot, Storing what) {
    assert(what != StoringInternal && what != StoringNothing && what != StoringImmediate, 'invalid location for isPinned');
    if (!(slot is DynamicSlot)) {
      return false;
    }
    if (what == StoringValue) {
      return (slot as DynamicSlot).valuePinned;
    }
    assert(what == StoringType, 'unknown Storing variant');
    return (slot as DynamicSlot).typePinned;
  }

  Null unpinIfDead(Slot slot, Storing what) {
    if (isPinned(slot, what) && !(slot as DynamicSlot).stillAlive()) {
      if (what == StoringValue) {
        (slot as DynamicSlot).unpinValue();
      } else {
        (slot as DynamicSlot).unpinType();
      }
    }
  }

  SlotStatusEntryNullable getEntry(Operand operand) {
    if (operand is Register64Operand) {
      return registerStatus.get((operand as Register64Operand).bit) as RegisterEntry;
    }
    if (operand is StackOperand) {
      assert((operand as StackOperand).stackMetrics == stackMetrics, concat('slot contamination detected for ', operand));
      return stackStatus[(operand as StackOperand).index];
    }
    if (operand is ImmediateOperand || operand is AddressComputationOperand || operand is DereferenceLabelOperand) {
      return null;
    }
    throw(concat('getEntry failed to find entry for ', operand.className, ' operand ', operand));
  }

  Null updateStatus(DynamicSlot slot, Storing what, Operand oldOperand, OperandNullable newOperand) {
    if (oldOperand is Register64Operand || oldOperand is StackOperand) {
      SlotStatusEntry oldEntry = getEntry(oldOperand)!;
      assert(oldEntry.mop == null, concat('updateStatus called when oldOperand had a mop'));
      assert(operandFor(slot, what).equals(oldOperand), 'slot not in oldOperand when calling updateStatus');
      assert(oldEntry.slot == slot, concat("oldOperand (", oldOperand, ") has a slot status entry does not have the right slot (expected ", slot, ' got ', oldEntry.slot, ')'));
      oldEntry.assignSlot(null, StoringNothing);
    }
    if (newOperand != null) {
      assert(!newOperand!.equals(oldOperand), 'updateStatus called redundantly');
      SlotStatusEntryNullable newEntry = getEntry(newOperand!);
      if (newEntry != null) {
        newEntry!.assignSlot(slot, what);
        assert(newEntry!.slot == slot, 'slot manager is confused');
        assert(newEntry!.what == what, 'slot manager is confused');
        assert(newEntry!.mop == null, 'slot manager is confused');
      }
    }
  }

  Null updateOperandFor(DynamicSlot slot, Storing what, OperandNullable newOperand) {
    assert(what != StoringInternal && what != StoringNothing && what != StoringImmediate, 'invalid location for operand');
    updateStatus(slot, what, operandFor(slot, what), newOperand);
    if (what == StoringValue) {
      slot.updateValue(newOperand);
      return;
    }
    assert(what == StoringType, 'unknown Storing variant');
    slot.updateDynamicType(newOperand);
  }
  
  // finds a suitable register (if possible) from the given list
  // returns least recently used suitable unpinned register
  // if none match, returns null
  RegisterEntryNullable findRegisterEntry(Integer allowedOperandKinds) {
    assert((allowedOperandKinds & register) > 0, concat('findRegister needs at least one register to be allowed; allowedOperandKinds was: ', describeOperandKinds(allowedOperandKinds)));
    RegisterEntry candidate = leastRecentlyUsed!;
    RegisterEntryNullable previousCandidate = null;
    while (true) {
      Integer register = candidate.operand.bit;
      // TODO: when a register has a mop or is StoringInternal, we really should just take it out of the linked list entirely
      if ((register & allowedOperandKinds) > 0 &&
          candidate.mop == null &&
          candidate.what != StoringInternal &&
          (candidate.what == StoringNothing || !isPinned(candidate.slot!, candidate.what))) {
        if ((register & nonvolatileRegister) > 0) {
          usedRegisters.add(candidate.operand);
        }
        if (previousCandidate != null) {
          if (candidate.nextLeastRecentlyUsed != null) {
            previousCandidate!.assignNextLeastRecentlyUsed(candidate.nextLeastRecentlyUsed);
          } else {
            assert(candidate == mostRecentlyUsed, 'inconsistency');
            assert(candidate.nextLeastRecentlyUsed == null, 'inconsistency');
            return candidate; // we are at the end, let's stay that way
          }
        } else {
          leastRecentlyUsed = candidate.nextLeastRecentlyUsed;
        }
        candidate.assignNextLeastRecentlyUsed(null);
        mostRecentlyUsed.assignNextLeastRecentlyUsed(candidate);
        mostRecentlyUsed = candidate;
        return candidate;
      }
      if (candidate.nextLeastRecentlyUsed == null) {
        return null;
      }
      previousCandidate = candidate;
      candidate = candidate.nextLeastRecentlyUsed!;
    }
    assert(false, 'escaped from while (true)');
  }

  // returns an available stack entry (one with no live or pinned slot)
  // increases required stack size for scope if necessary
  StackEntry findStackEntry() {
    Integer index = 1;
    while (index < len(stackStatus)) {
      StackEntry entry = stackStatus[index];
      if (entry.what == StoringNothing || 
          (entry.what != StoringInternal &&
           (((entry.slot is DynamicSlot) && !(entry.slot as DynamicSlot).stillAlive() && !isPinned(entry.slot!, entry.what))) ||
            ((entry.what == StoringImmediate) && (entry.mop == null)))) {
        if (entry.slot != null) {
          // Null _ = blocks[nestedScopeDepth].addComment(concat('discarding ', entry.slot!.debugName, ' ', describeWhat(entry.what), ' which was in ', entry.operand));
          updateOperandFor(entry.slot! as DynamicSlot, entry.what, null);
        }
        assert(entry.slot == null, 'StoringNothing had a slot');
        return entry;
      }
      index += 1;
    }
    append(stackStatus, StackEntry(index, stackMetrics));
    stackMetrics.growStack();
    return stackStatus[index];
  }

  Operand findHome(Slot slot, Storing what, Integer allowedOperandKinds) {
    Operand candidate = operandFor(slot, what);
    if (candidate is Register64Operand) {
      if ((allowedOperandKinds & (candidate as Register64Operand).bit) > 0) {
        return candidate;
      }
    } else if (candidate is StackOperand) {
      if ((allowedOperandKinds & stack) > 0) {
        return candidate;
      }
    } else if (candidate is ImmediateOperand) {
      if ((allowedOperandKinds & immediate64) > 0) {
        return candidate;
      }
      Integer minBits = (candidate as ImmediateOperand).minBits();
      if (minBits <= 32) {
        if ((allowedOperandKinds & immediate32) > 0) {
          return candidate;
        }
      }
      if (minBits <= 8) {
        if ((allowedOperandKinds & immediate8) > 0) {
          return candidate;
        }
      }
    } else {
      assert(false, concat('findHome does not support ', candidate.className, ' operands such as ', candidate));
    }
    if ((allowedOperandKinds & global) > 0) {
      // XXX if this is a slot that has a home in the global space, put it back there
    }
    if ((allowedOperandKinds & stack) > 0) {
      StackEntry entry = findStackEntry();
      assert(entry.mop == null, 'findStackEntry returned an entry that had a managed operand');
      if (slot is DynamicSlot) {
        entry.assignSlot(slot as DynamicSlot, what);
      } else {
        entry.assignSlot(null, StoringImmediate);
      }
      return entry.operand;
    }
    throw(concat('unable to find home for ', slot, '; findHome does not support allowed operands (', describeOperandKinds(allowedOperandKinds), ')'));
  }

  // should be called when something in a register needs to be thrown out of that register
  Null clearRegisterEntry(RegisterEntry entry) {
    if (entry.slot is DynamicSlot) {
      assert(!isPinned(entry.slot!, entry.what), 'clearRegisterEntry tried to clear live pinned slot');
      if ((entry.slot! as DynamicSlot).stillAlive()) {
        assert(entry.operand == operandFor(entry.slot!, entry.what), concat('RegisterEntry inconsistent - it\'s slot is in a different place (', operandFor(entry.slot!, entry.what), ') than the register it represents: ', entry));
        // move original slot into anything but registers
        Operand target = findHome(entry.slot!, entry.what, ~register);
        if (!(target is ImmediateOperand)) {
          emitMov(blocks[nestedScopeDepth], target, operandFor(entry.slot!, entry.what), concat('move ', entry.slot!.debugName, ' ', describeWhat(entry.what), ' out of ', entry.operand));
        }
        updateOperandFor(entry.slot! as DynamicSlot, entry.what, target);
      } else {
        // Null _ = blocks[nestedScopeDepth].addComment(concat('discarding ', entry.slot!.debugName, ' ', describeWhat(entry.what), ' which was in ', entry.operand));
        updateOperandFor(entry.slot! as DynamicSlot, entry.what, null);
      }
      assert(entry.slot == null, 'updateOperandFor did not clear entry');
      assert(entry.what == StoringNothing, 'updateOperandFor did not clear entry');
    } else {
      // XXX can it be an ImmediateOperand?
      assert(entry.slot == null, 'inconsistency');
    }
  }

  Null makeMutable(DynamicSlot slot, Storing what) {
    if (operandFor(slot, what) is ImmediateOperand) {
      Operand target = findHome(slot, what, ~immediate);
      emitMov(blocks[nestedScopeDepth], target, operandFor(slot, what), concat('move ', slot.debugName, ' ', describeWhat(what), ' into a mutable location'));
      updateOperandFor(slot, what, target);
    }
  }

  Null trackSlot(DynamicSlot slot) {
    if (!trackedSlots.has(slot)) {
      trackedSlots.add(slot);
    }
  }

  Null verifySlotMatchesEntry(DynamicSlot slot, Storing what) {
    Operand operand = operandFor(slot, what);
    SlotStatusEntryNullable entry = getEntry(operand);
    if (entry != null) {
      assert(entry!.slot == slot, concat('slot\'s operand\'s SlotStatusEntry\'s slot is not the same as the original slot (expected ', slot, ' got ', entry!.slot, ')\n',)); //prettyStackStatus(), '\n', prettyRegisterStatus(),));
      assert(entry!.what == what, 'slot manager is confused (what)'); 
    } else {
      // XXX we're expecting this to be hit with AddressComputationOperand (used by parameters) but it hasn't yet, which is weird
      assert((operand is ImmediateOperand) || (operand is DereferenceLabelOperand), concat('getEntry returned null for a non-immediate: ', operand));
    }
  }

  Null verifyInvariants() {
    //return;
    assert(slotManagers == 1, concat(slotManagers, ' slot managers alive when calling verifyInvariants()'));
    for (slot in trackedSlots.values() as DynamicSlotIterable) {
      if (slot.stillAlive()) {
        verifySlotMatchesEntry(slot, StoringValue);
        verifySlotMatchesEntry(slot, StoringType);
      }
    }
    for (entryRaw in registerStatus.values()) {
      RegisterEntry entry = entryRaw as RegisterEntry;
      if (entry.what == StoringValue || entry.what == StoringType) {
        assert(entry.slot != null, 'entry was storing value or type with no associated slot');
        assert(operandFor(entry.slot!, entry.what) == entry.operand, 'entry\'s operand does not match it\'s slot\'s value/dynamicType');
      } else if (entry.what == StoringImmediate) {
        assert(entry.slot == null, 'StoringImmediate had a slot');
        assert(entry.mop != null, 'StoringImmediate had no mop');
      } else if (entry.what == StoringNothing) {
        assert(entry.slot == null, 'StoringNothing had a slot');
        assert(entry.mop == null, 'StoringNothing had a mop');
      } else {
        assert(entry.what == StoringInternal, 'unknown Storing variant');
      }
    }
    for (entry in stackStatus) {
      if (entry.what == StoringValue || entry.what == StoringType) {
        assert(entry.slot != null, 'entry was storing value or type with no associated slot');
        assert(operandFor(entry.slot!, entry.what) == entry.operand, 'entry\'s operand does not match it\'s slot\'s value/dynamicType');
      } else if (entry.what == StoringImmediate) {
        assert(entry.slot == null, 'StoringImmediate had a slot');
        assert(entry.mop != null, 'StoringImmediate had no mop');
      } else if (entry.what == StoringNothing) {
        assert(entry.slot == null, 'StoringNothing had a slot');
        assert(entry.mop == null, 'StoringNothing had a mop');
      } else {
        assert(entry.what == StoringInternal, 'unknown Storing variant');
        assert(entry.mop == null, 'StoringInternal on the stack had a mop');
      }
    }
  }

  Boolean debugOperandIsAlreadyManaged(Operand value) {
    assert(!(value is Mop), 'unexpected managed operand');
    for (candidate in managedOperands.values()) {
      if ((candidate as Mop).operand.equals(value)) {
        return true;
      } 
    }
    return false;
  }

  // readComment will be used as the comment if you need to move the slot and willRead is true
  Mop manageSlot(Slot slot, Storing what, Boolean willRead, Integer allowedOperandKinds, String readComment) {
    assert(willRead || ((allowedOperandKinds & immediate) == 0), 'cannot write to an immediate');
    verifyInvariants();
    Integer debugOriginalStackSize = stackSize();
    Operand result = operandFor(slot, what);
    //stderr(concat('manageSlot(', slot, ', ', what, ', willRead=', willRead, ', [', describeOperandKinds(allowedOperandKinds), '], "', readComment, '"); // slot is currently in ', result));
    assert(!(result is Mop), 'Slot location was a Mop?!');
    assert(!(result is Register8Operand), 'Slot location was a Register8Operand?!');
    assert(!debugOperandIsAlreadyManaged(result) || result is ImmediateOperand, concat('Tried to manage an already-managed slot ', slot, ' at ', result, '. Call release() on the Mop before re-managing the slot.'));
    if (result.isOperandKind(allowedOperandKinds)) { // we can just leave it where it is
      if (debugOperandIsAlreadyManaged(result)) { // TODO: need to make this O(1) not O(N)
        assert(result is ImmediateOperand, 'very confuse');
        assert(debugOriginalStackSize == stackSize(), 'stack size changed for immediate');
        return findMop(result);
      }
      Mop managedResult = Mop(result, this);
      managedOperands.add(managedResult);
      SlotStatusEntryNullable entry = getEntry(result);
      if (entry != null) {
        if (entry is RegisterEntry) {
          assert(entry!.slot == slot, concat('Slot manager is confused about register state (entry is ', entry, ' at ', result, ') but expected ', slot, ').'));
          assert((entry!.what == what) || ((entry!.what == StoringInternal) && (entry!.slot is RegisterSlot)), 'Slot manager is confused about register state (what).');
          assert((entry! as RegisterEntry).operand == result, 'slot manager is confused');
          assert(entry!.mop == null, 'Tried to use a managed register while it was still under management.');
        } else if (entry is StackEntry) {
          assert(entry!.slot == slot, concat('Slot manager is confused about stack state (entry is ', entry, ' at ', result, ') but expected ', slot, ').'));
          assert(entry!.what == what, 'Slot manager is confused about stack state. (what)');
          assert((entry! as StackEntry).index == (result as StackOperand).index, 'slot manager is confused');
          assert(entry!.mop == null, 'Tried to use a managed stack while it was still under management.');
        } else {
          // in due course we should support moving things in and out of shadow space
          assert(entry == null, 'slot manager is confused');
        }
        entry!.assignMop(managedResult);
      }
      verifyInvariants();
      assert(debugOriginalStackSize == stackSize(), 'stack size changed for doing nothing');
      return managedResult;
    }
    assert((allowedOperandKinds & ~immediate) > 0, 'manageSlot called only with immediate allowed operand kinds');
    if (slot is DynamicSlot) {
      trackSlot(slot as DynamicSlot);
    }
    if ((allowedOperandKinds & register) > 0) {
      RegisterEntryNullable entry = findRegisterEntry(allowedOperandKinds);
      assert(debugOriginalStackSize == stackSize(), 'stack size changed for not doing anything yet');
      if (entry != null) {
        // we decided to put it in a register
        assert(entry!.mop == null, 'entry already includes a managed operand!');
        assert(entry!.slot != slot || entry!.what != what, 'slot unexpectedly already in register!');
        assert((entry!.slot == null) || (operandFor(entry!.slot!, entry!.what) == entry!.operand), concat('entry confused: ', entry));
        assert((entry!.slot == null) || !isPinned(entry!.slot!, entry!.what), 'manageSlot tried to clear live pinned slot');
        clearRegisterEntry(entry!);
        assert(entry!.slot == null, 'slot was not moved out properly');
        assert(slot is DynamicSlot || willRead, 'if it is not a DynamicSlot, we do not support writing to it');
        if (willRead) {
          emitMov(blocks[nestedScopeDepth], entry!.operand, operandFor(slot, what), readComment);
        }
        if (slot is DynamicSlot) {
          entry!.assignSlot(slot, what);
          updateOperandFor(slot as DynamicSlot, what, entry!.operand);
        } else {
          //assert(slot is ImmediateSlot, concat('got a non-dynamic non-immediate slot in manageSlot: ', slot));
          // TODO: we should track ParameterSlots the way we track DynamicSlots, so we don't move them into registers multiple times
          entry!.assignSlot(null, StoringImmediate);
        }
        Mop managedResult = Mop(entry!.operand, this);
        managedOperands.add(managedResult);
        entry!.assignMop(managedResult);
        verifyInvariants();
        return managedResult;
      }
    }
    assert((allowedOperandKinds & ~register) > 0, concat('no available registers for ', slot));
    // we're not putting it in a register
    Operand target;
    target = findHome(slot, what, allowedOperandKinds);
    assert(!target.isOperandKind(register), 'inconsistent behaviour in slot manager');
    assert(target.isOperandKind(allowedOperandKinds), concat('requested operand kinds not supported: ', describeOperandKinds(allowedOperandKinds)));
    assert(slot is DynamicSlot || willRead, 'if it is not a DynamicSlot, we do not support writing to it');
    if (willRead) {
      //stderr(concat('force ', slot.debugName, '\'s ', describeWhat(what), ' to ', describeOperandKinds(allowedOperandKinds), '\n', stackTrace()));
      emitMov(blocks[nestedScopeDepth], target, operandFor(slot, what), concat('force ', slot.debugName, '\'s ', describeWhat(what), ' to ', describeOperandKinds(allowedOperandKinds)));
    }
    if (slot is DynamicSlot) {
      updateOperandFor(slot as DynamicSlot, what, target);
    }
    Mop managedResult = Mop(target, this);
    managedOperands.add(managedResult);
    verifyInvariants();
    return managedResult;
  }

  // Ensures that the returned Mop allows you to read the given slot's value.
  // Comment will be used as the comment if you need to move the slot.
  Mop read(Slot slot, Integer allowedOperandKinds, String comment) {
    Mop result = manageSlot(slot, StoringValue, true, allowedOperandKinds, comment);
    slot.didRead(scopes[nestedScopeDepth]);
    return result;
  }

  // provides a Mop that _must_ be written to before being released.
  // updates the value of slot.
  Mop write(Slot slot, Integer allowedOperandKinds) {
    Mop result = manageSlot(slot, StoringValue, false, allowedOperandKinds, '(this comment should not be used)');
    slot.didWrite(scopes[nestedScopeDepth]);
    return result;
  }

  // provides a Mop that will contain source's value until it is written to,
  // and thereafter contains target. If not written to, target will have had
  // source assigned to it.
  Mop readForMutation(Slot source, Slot target, Integer allowedOperandKinds, StringNullable comment) {
    // TODO: if this is the last time we read source, then rather than moving source to target,
    // we could just forget source now and reuse its operand for target (making this a no-op
    // in the assembler output).
    Mop result = manageSlot(target, StoringValue, source == target, allowedOperandKinds, concat('move ', source.debugName, ' to ', target.debugName));
    if (source != target) {
      // TODO: if the operand we assigned to result happens to be where source was just before, we can omit this mov
      String nonNullComment;
      if (comment != null) {
        nonNullComment = comment!;
      } else {
        nonNullComment = concat('assign value of ', source.debugName, ' to value of ', target.debugName);
      }
      emitMov(blocks[nestedScopeDepth], result.operand, source.value(), nonNullComment);
    }
    source.didRead(scopes[nestedScopeDepth]);
    target.didWrite(scopes[nestedScopeDepth]);
    return result;
  }

  // ensures that the returned Mop allows you to read the given slot's type.
  Mop readType(Slot slot, Integer allowedOperandKinds, String comment) {
    Mop result = manageSlot(slot, StoringType, true, allowedOperandKinds, comment);
    slot.didRead(scopes[nestedScopeDepth]);
    return result;
  }

  // provides a Mop that _must_ be written to before being released.
  // updates the type of slot.
  Mop writeType(Slot slot, Integer allowedOperandKinds) {
    Mop result = manageSlot(slot, StoringType, false, allowedOperandKinds, '(this comment should not be used)');
    slot.didWrite(scopes[nestedScopeDepth]);
    return result;
  }

  // provides a Mop that will contain source's dynamic type until it is written to,
  // and thereafter contains target's dynamicType. If not written to, target will have had
  // source assigned to it.
  Mop readTypeForMutation(Slot source, Slot target, Integer allowedOperandKinds, StringNullable comment) {
    Mop result = manageSlot(target, StoringType, source == target, allowedOperandKinds, concat('move ', source.debugName, '\'s type to ', target.debugName, '\'s type'));
    if (source != target) {
      String nonNullComment;
      if (comment != null) {
        nonNullComment = comment!;
      } else {
        nonNullComment = concat('set ', target.debugName, ' type to type of ', source.debugName);
      }
      // TODO: if the operand we assigned to result happens to be where source was just before, we can omit this mov
      emitMov(blocks[nestedScopeDepth], result.operand, source.dynamicType(), nonNullComment);
    }
    source.didRead(scopes[nestedScopeDepth]);
    target.didWrite(scopes[nestedScopeDepth]);
    return result;
  }

  // provides a Mop that will contain source's dynamic type until it is written to,
  // and thereafter contains target's value. If not written to, target will have had
  // source assigned to it.
  Mop readTypeToValueForMutation(Slot source, Slot target, Integer allowedOperandKinds) {
    Mop result = manageSlot(target, StoringValue, false, allowedOperandKinds, '(this comment should not be used)');
    emitMov(blocks[nestedScopeDepth], result.operand, source.dynamicType(), concat('store ', source.debugName, ' type in ', target.debugName, ' type slot'));
    source.didRead(scopes[nestedScopeDepth]);
    target.didWrite(scopes[nestedScopeDepth]);
    return result;
  }

  Null initializeInternal(DynamicSlot slot, Storing what) {
    Operand result = operandFor(slot, what);
    assert(result is Register64Operand, concat('Tried to initialize ', slot, ' to something other than a register.'));
    assert(!debugOperandIsAlreadyManaged(result), concat('Tried to initialize ', slot, ' to an already-managed register.'));
    RegisterEntry entry = registerStatus.get((result as Register64Operand).bit) as RegisterEntry;
    assert(entry.slot == null, concat('Tried to initialize ', slot, ' to a register that contains a slot already (', entry.slot, ').'));
    assert(entry.what != StoringInternal, concat('Slot manager is confused about register state (what is ', entry.what, ').'));
    assert(entry.operand == result, 'slot manager is confused');
    assert(entry.mop == null, 'Tried to use a managed register while it was still under management.');
    entry.assignSlot(slot, what);
    verifyInvariants();
  }

  // if either operand is a register, then that register must have been save()d first
  Null initialize(DynamicSlot slot, Operand newValue, Operand newType) {
    verifyInvariants();
    assert(!(newValue is StackOperand), 'cannot initialize slot value to stack operand');
    assert(!(newType is StackOperand), 'cannot initialize slot type to stack operand');
    slot.initialize(newValue, newType);
    trackSlot(slot as DynamicSlot);
    if (newValue is Register64Operand) {
      initializeInternal(slot, StoringValue);
    }
    if (newType is Register64Operand) {
      initializeInternal(slot, StoringType);
    }
    verifyInvariants();
  }

  Boolean debugOperandKindsAreAlreadyManaged(Integer kinds) {
    for (operand in managedOperands.values()) {
      if ((operand as Mop).isOperandKind(kinds)) {
        return true;
      }
    }
    return false;
  }

  // Declares that the given operand kinds are about to be trashed.
  // If any of them are in use, their contents are moved to another location.
  // If any of them are pinned, they must not be stillAlive.
  // Given operand kinds must not be in use by outstanding managed operands.
  // Given operand kinds are locked as StoringInternal with a null slot.
  // Use releaseOperands() to release the locks.
  Null save(Integer operandKinds) {
    verifyInvariants();
    assert((operandKinds & ~register) == 0, 'cannot save non-register operand kinds');
    assert(!debugOperandKindsAreAlreadyManaged(operandKinds), concat('specified registers are already in use by Mop; call release() on a Mop before using save() for its register'));
    for (register in preferredRegisters) {
      if ((register.bit & operandKinds) > 0) {
        RegisterEntry entry = registerStatus.get(register.bit) as RegisterEntry;
        if ((register.bit & nonvolatileRegister) > 0) {
          usedRegisters.add(register);
        }
        if (entry.what != StoringInternal) {
          assert(entry.mop == null, 'inconsistency in slot manager: register is managed and non-managed at the same time!');
          if (entry.slot != null) {
            unpinIfDead(entry.slot!, entry.what);
          }
          clearRegisterEntry(entry);
          assert(entry.slot == null, 'slot was not moved out properly');
          entry.assignSlot(null, StoringInternal);
        }
      }
    }
    verifyInvariants();
  }

  Null pin(RegisterSlot slot) {
    verifyInvariants();
    RegisterEntry entry = registerStatus.get((slot.value() as Register64Operand).bit) as RegisterEntry;
    if ((entry.operand.bit & nonvolatileRegister) > 0 && entry.operand != rsp) {
      usedRegisters.add(entry.operand);
    }
    assert(entry.mop == null, 'specified register is in use (unrelease mop)');
    assert(entry.slot == null, 'specified register is in use (slot assigned)');
    assert(entry.what == StoringNothing, 'specified register is in use (inconsistent storage)');
    entry.assignSlot(slot, StoringInternal);
    verifyInvariants();
  }

  // Indicates that the given managed operand is no longer needed.
  Null _releaseOperand(Mop operand) {
    verifyInvariants();
    assert(managedOperands.has(operand), concat('tried to release operand that is no longer being managed: ', operand));
    managedOperands.remove(operand);
    if (operand.operand is Register64Operand) {
      RegisterEntry entry = registerStatus.get((operand.operand as Register64Operand).bit) as RegisterEntry;
      entry.assignMop(null);
      if (entry.what == StoringImmediate) {
        entry.assignSlot(null, StoringNothing);
      }
    }
    if (operand.operand is StackOperand) {
      StackEntry entry = stackStatus[(operand.operand as StackOperand).index];
      entry.assignMop(null);
      if (entry.what == StoringImmediate) {
        entry.assignSlot(null, StoringNothing);
      }
    }
    verifyInvariants();
  }

  // Releases all the managed operands and locked registers (see [save]) that correspond to the given operand kinds.
  // This should only be called if the corresponding Mop objects have already been discarded.
  // Only registers can be released this way.
  Null releaseOperands(Integer operandKinds) {
    verifyInvariants();
    assert((operandKinds & ~register) == 0, 'cannot release non-register operand kinds');
    // we have to make the list first because otherwise we would be mutating the list
    // while iterating over it which is very brittle.
    MopList discardList = []:Mop;
    for (register in preferredRegisters) {
      if ((operandKinds & register.bit) > 0) {
        RegisterEntry entry = registerStatus.get(register.bit) as RegisterEntry;
        if (entry.what == StoringInternal) {
          assert(entry.mop == null, 'internal entry had a managed operand');
          entry.assignSlot(null, StoringNothing);
        } else if (entry.what == StoringImmediate) {
          assert(entry.slot == null, 'immediate entry had a slot');
          assert(entry.mop != null, 'StoringImmediate inconsistent with mop');
          entry.mop!.release();
          entry.assignSlot(null, StoringNothing);
        } else if (entry.what != StoringNothing) {
          assert(entry.mop != null, 'entry did not have a managed operand');
          assert(entry.slot != null, 'entry did not have a slot');
          entry.mop!.release();
          assert(entry.mop == null, 'managed operand release failed');
          assert(entry.slot != null, 'entry lost its slot upon release');
        }
      }
    }
    verifyInvariants();
  }

  Null assertBlockIdentityMatches(AssemblerBlock block) {
    assert(blocks[nestedScopeDepth] == block, 'unexpected assembler block');
  }

  // Asserts that there are no outstanding managed operands.
  Null assertAllReleased() {
    verifyInvariants();
    assert(managedOperands.length == 0, concat('leaked managed operands: ', managedOperands));
    for (register in preferredRegisters) {
      RegisterEntry entry = registerStatus.get(register.bit) as RegisterEntry;
      assert(entry.operand == register, 'inconsistency in slot manager detected');
      assert(entry.mop == null, 'inconsistency in slot manager detected');
      assert(entry.what == StoringInternal || ((entry.slot != null) == (entry.what == StoringValue || entry.what == StoringType)), 'inconsistency in slot manager detected');
    }
    for (entry in stackStatus) {
      assert(entry.mop == null, concat('inconsistency in slot manager detected - managedOperands is empty: ', managedOperands, ' but ', entry, ' has a mop: ', entry.mop));
      assert((entry.slot != null) == (entry.what == StoringValue || entry.what == StoringType), 'inconsistency in slot manager detected');
    }
  }

  Null enterNestedScope(SlotContext scope, AssemblerBlock block) {
    assert(len(blocks) == len(scopes), 'slot manager inconsistency');
    nestedScopeDepth += 1;
    if (nestedScopeDepth == len(blocks)) {
      append(blocks, block);
      append(scopes, scope);
    } else {
      blocks[nestedScopeDepth] = block;
      scopes[nestedScopeDepth] = scope;
    }
    verifyInvariants();
    assertAllReleased();
    for (entry in trackedSlots.values()) {
      DynamicSlot slot = entry as DynamicSlot;
      if (slot.stillAlive()) {
        if (nestedScopeDepth > 0 && slot.needsToBeMutable(scopes[nestedScopeDepth - 1])) {
          makeMutable(slot, StoringValue);
          makeMutable(slot, StoringType);
        }
        slot.enterNestedScope();
      }
    }
    verifyInvariants();
  }

  Null unwindChains(Chains chains, Operand end, Boolean doUpdates) {
    assert(!(end is ImmediateOperand), 'invalid chain end');
    Operand to = end;
    SlotStatusEntryNullable toEntry = null;
    if (doUpdates) {
      toEntry = getEntry(to);
    }
    while (true) {
      OperandNullable from = chains.goBackwards(to);
      assert(!(from is ImmediateOperand), 'should never need to move from immediate');
      if (from == null) {
        if (doUpdates && toEntry != null) {
          toEntry!.assignSlot(null, StoringNothing);
        }
        break;
      }
      SlotStatusEntryNullable fromEntry = null;
      if (doUpdates) {
        fromEntry = getEntry(from!)!;
        if (toEntry != null) {
          toEntry!.assignSlot(fromEntry!.slot, fromEntry!.what);
        }
      }
      chains.removeEntry(from!, to);
      emitMov(blocks[nestedScopeDepth], to, from!, 'restoring slots to previous scope state');
      to = from!;
      if (doUpdates) {
        toEntry = fromEntry;
      }
    }
  }

  Null recordLink(Chains chains, Operand from, Operand to, Boolean doUpdates, String comment) {
    assert(chains.goForwards(from) == null, concat('chains forwards inconsistent: entry for ', from, ' (going to ', to, ') already exists'));
    assert(chains.goBackwards(to) == null, concat('chains backwards inconsistent: entry for ', to, ' (going from ', from, ') already exists'));
    if (from.equals(to)) {
      assert(from == to, concat('imposters detected: ', from, ' vs ', to));
      return;
    }
    // Null _ = blocks[nestedScopeDepth].addComment(comment);
    if (to is ImmediateOperand) {
      if (chains.goBackwards(from) != null) {
        unwindChains(chains, from, doUpdates);
      } else {
        if (doUpdates) {
          getEntry(from)!.assignSlot(null, StoringNothing);
        }
      }
      return;
    }
    // look for a loop
    OperandNullable index = to;
    while (index != null && index != from) {
      index = chains.goForwards(index!);
    }
    if (index != null) {
      assert(index == from, 'inconsistency');
      // found loop, indirect through scratch and unwind
      Operand scratch = stackStatus[0].operand;
      chains.addEntry(from, scratch);
      chains.addEntry(scratch, to);
      unwindChains(chains, scratch, doUpdates);
    } else {
      chains.addEntry(from, to);
    }
  }

  Null doScopeExit(Set exitingScopes, Boolean doUpdates) {
    verifyInvariants();
    assertAllReleased();
    Chains chains = Chains();
    Set remainingTrackedSlots = Set();
    Integer scopeExitDelta = exitingScopes.length;
    assert(scopeExitDelta == 1 || !doUpdates, 'cannot update if scopeExitDelta > 1');
    for (entry in trackedSlots.values()) {
      DynamicSlot slot = entry as DynamicSlot;
      if (slot.stillAlive() && !exitingScopes.has(slot.homeScope)) {
        assert(slot.depth > 1, concat('slot ', slot, ' is not in nested scope but is also not exiting its home scope.\n   home=', slot.homeScope, '\n   exitingScopes=', exitingScopes, '\n'));
        Operand lastValue = slot.value();
        Operand lastDynamicType = slot.dynamicType();
        Operand newValue;
        Operand newDynamicType;
        newValue = slot.previousValue(scopeExitDelta);
        newDynamicType = slot.previousDynamicType(scopeExitDelta);
        recordLink(chains, lastValue, newValue, doUpdates, concat('move ', slot.debugName, ' value from ', lastValue, ' back to ', newValue));
        recordLink(chains, lastDynamicType, newDynamicType, doUpdates, concat(slot.debugName, ' type from ', lastDynamicType, ' back to ', newDynamicType));
        if (doUpdates) {
          slot.exitNestedScope();
          remainingTrackedSlots.add(slot);
        }
      }
    }
    OperandList operands = copy(chains.backwardsKeys() as OperandList);
    for (end in operands) {
      if (chains.goForwards(end) == null && chains.goBackwards(end) != null) {
        unwindChains(chains, end, doUpdates);
      }
    }
    if (doUpdates) {
      trackedSlots = remainingTrackedSlots;
      nestedScopeDepth -= 1;
    }
    verifyInvariants();
  }

  Null emitNestedScopeExit(SlotContext exitingScope) {
    assertAllReleased();
    Integer exitCount = 0;
    Set exitingTrackedScopes = Set();
    while (scopes[nestedScopeDepth - exitCount] != exitingScope) {
      exitingTrackedScopes.add(scopes[nestedScopeDepth - exitCount]);
      exitCount += 1;
      assert(exitCount <= nestedScopeDepth, 'inconsistent scopes');
    }
    exitingTrackedScopes.add(exitingScope);
    doScopeExit(exitingTrackedScopes, false);
  }

  Null exitNestedScope(SlotContext exitingScope) {
    assert(exitingScope == scopes[nestedScopeDepth], 'cannot exit multiple scopes at once');
    assertAllReleased();
    Set exitingTrackedScopes = Set();
    exitingTrackedScopes.add(exitingScope);
    doScopeExit(exitingTrackedScopes, true);
    assert(nestedScopeDepth >= -1, 'too deep');
  }

  Null recordPushes(Integer count) {
    verifyInvariants();
    stackMetrics.push(count);
    verifyInvariants();
 }

  Null recordPops(Integer count) {
    verifyInvariants();
    stackMetrics.pop(count);
    verifyInvariants();
  }

  Null constructor() {
    super.constructor();
    for (register in preferredRegisters) {
      RegisterEntry entry = RegisterEntry(register);
      if (leastRecentlyUsed == null) {
        leastRecentlyUsed = entry;
      } else {
        assert(mostRecentlyUsed is RegisterEntry, 'inconsistency');
        mostRecentlyUsed.assignNextLeastRecentlyUsed(entry);
      }
      mostRecentlyUsed = entry;
      registerStatus.set(register.bit, entry);
    }
    assert(len(stackStatus) == 0, 'unexpected contents in stackStatus');
    append(stackStatus, StackEntry(0, stackMetrics));
    stackMetrics.growStack();
    slotManagers++;
    verifyInvariants();
  }
  
  Null dispose() {
    slotManagers--;
  }
}
