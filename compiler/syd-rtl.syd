// RUNTIME LIBRARY
// Code in this file defines and uses compiler intrinsics.

// TODO: turn RTL privates into foo# syntax
// TODO: complain if a function is __intrinsic and we don't know about it

// CONSTANTS // TODO: don't declare these here - just import syd-constants.syd

Integer _blockEntrySize = 8; // stride size in block entry list
Integer _gcBlockHeaderRefCount = 0 * 8;
Integer _gcBlockHeaderLength = 1 * 8;
Integer _gcBlockHeaderScratchSpace = 2 * 8;
Integer _gcBlockHeaderEntryPointer = 3 * 8;
Integer _gcBlockData = 4 * 8;

Integer _vmtTypeCode = 0x00;
Integer _vmtFieldCount = 0x08;
Integer _vmtClassName = 0x10;
Integer _vmtParent = 0x18;
Integer _vmtDynamicDispatchTable = 0x20;
Integer _vmtMethods = 0x28;

Integer _fieldVmt = _gcBlockData + 0x00;
Integer _fieldClassName = _gcBlockData + 0x10;
Integer _fieldsRemainder = _gcBlockData + 0x20;

Integer _subroutineReceiverType = _gcBlockData + 0 * 16;
Integer _subroutineReceiverPointer = _gcBlockData + 0 * 16 + 8;
Integer _subroutineClosureType = _gcBlockData + 1 * 16; // either sentinel or internal closure type
Integer _subroutineClosurePointer = _gcBlockData + 1 * 16 + 8;
Integer _subroutineCodeType = _gcBlockData + 2 * 16; // for completeness, always code address type
Integer _subroutineCodePointer = _gcBlockData + 2 * 16 + 8;

fwdclass __Object __intrinsic;

// ERROR MANAGEMENT

Integer exit(Integer exitCode) __intrinsic __extern 'kernel32.lib' 'ExitProcess';
Integer __getLastError() __extern 'kernel32.lib' 'GetLastError';

NullFunction stderr;

// TODO: this should be a compiler intrinsic so that the message evaluation can be lazy and so it can be skipped in release builds
Null assert(Boolean condition, String message) {
  if (!condition) {
    stderr(message);
    exit(1);
  }
}

Null throw(String message) {
  stderr(message);
  exit(1);
}


// HEAP MANAGEMENT

Integer __getProcessHeap() __extern 'kernel32.lib' 'GetProcessHeap';

Integer _heapHandle = __getProcessHeap();

Integer __heapAlloc(Integer hHeap, Integer dwFlags, Integer dwBytes) __extern 'kernel32.lib' 'HeapAlloc';

// Number of calls to alloc minus number of calls to free.
Integer _blockCount = 0;

NullFunction _garbageCollector;

/// Allocates a block on the heap.
///
/// Block must be freed with [_free].
Integer _alloc(Integer size) {
  Integer pointer = __heapAlloc(_heapHandle, 0x00, size);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  _garbageCollector();
  pointer = __heapAlloc(_heapHandle, 0x00, size);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  stderr('Out of memory.');
  exit(1);
}

/// returns positive for success, zero for failure
Integer __heapFree(Integer hHeap, Integer dwFlags, Integer lpMem) __extern 'kernel32.lib' 'HeapFree';

/// Frees a heap allocation obtained from [_alloc].
Null _free(Integer pointer) __intrinsic {
  _blockCount -= 1;
  if (__heapFree(_heapHandle, 0x00, pointer) == 0) {
    stderr('failed to free pointer, error code: ', __getLastError());
    exit(1);
  }
}

Null _moveBytes(Integer from, Integer to, Integer length) {
  // TODO: move this to inlined assembler (using the string-copy instructions) for performance
  // (or optimize the compiler enough that it generates good code somehow!)
  assert(length > 0, '_moveBytes expects positive number of bytes to copy');
  Integer fromCursor = from;
  Integer toCursor = to;
  Integer end = from + (length / 8) * 8;
  assert(fromCursor != end || length < 8, 'inconsistency');
  assert(fromCursor != end || length > 0, 'inconsistency');
  while (fromCursor < end) {
    Integer value = __readFromAddress(fromCursor);
    __writeToAddress(toCursor, value);
    fromCursor += 8;
    toCursor += 8;
  }
  end = from + length;
  assert((fromCursor < end) || (from < fromCursor), 'no moves on either side');
  if (fromCursor < end) {
    Integer newValue = __readFromAddress(fromCursor);
    Integer oldValue = __readFromAddress(toCursor);
    Integer extraBytes = end - fromCursor;
    assert(extraBytes > 0, 'internal error: zero extra bytes but fromCursor is before end');
    assert(extraBytes < 8, 'internal error: more than 7 extra bytes');
    Integer mask = 0xFFFFFFFFFFFFFFFF << (extraBytes * 8);
    Integer finalValue = (newValue & ~mask) | (oldValue & mask);
    __writeToAddress(toCursor, finalValue);
  }
}

// length is in bytes
Null _fillQuadWords(Integer destination, Integer length, Integer value) {
  // TODO: is there an x64 intrinsic that does this faster?
  assert(length > 0, '_fillQuadWords expects positive number of bytes to fill');
  assert(length % 8 == 0, '_fillQuadWords expects number of bytes to fill to be a multiple of 8');
  Integer cursor = destination;
  Integer end = destination + length;
  while (cursor < end) {
    __writeToAddress(cursor, value);
    cursor += 8;
  }
}


// STRINGS

StringFunction concat;

Integer _stringByteLength(String data) {
  Integer pointer = data __as__ Integer;
  return __readFromAddress(pointer + 8);
}

String digitToStr(Integer digit) {
  if (digit == 0) {
    return '0';
  }
  if (digit == 1) {
    return '1';
  }
  if (digit == 2) {
    return '2';
  }
  if (digit == 3) {
    return '3';
  }
  if (digit == 4) {
    return '4';
  }
  if (digit == 5) {
    return '5';
  }
  if (digit == 6) {
    return '6';
  }
  if (digit == 7) {
    return '7';
  }
  if (digit == 8) {
    return '8';
  }
  if (digit == 9) {
    return '9';
  }
  stderr('Invalid digit passed to digitToStr (digit as exit code)');
  exit(digit);
}

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  if (value < 0) {
    return concat('-', intToStr(-value));
  }
  if (value < 10) {
    return digitToStr(value);
  }
  String buffer = ''; 
  Integer newValue = value; // parameters are final
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    buffer = concat(digitToStr(digit), buffer); // TODO: optimize this, it's O(N^2)
  }
  return buffer;
}

String join(StringList items, String joiner) {
  if (len(items) == 0) {
    return '';
  }
  Integer length = 0;
  Integer index = 0;
  while (index < len(items)) {
    length += _stringByteLength(items[index]);
    index += 1;
  }
  Integer joinerLength = _stringByteLength(joiner);
  length += joinerLength * (len(items) - 1);
  assert(length >= 0, 'negative length detected');
  if (length >= 2147483648) {
    stderr('absurd length detected (as exit code)');
    exit(length);
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(items)) {
    String segment = items[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    if (index < len(items) - 1) {
      if (joinerLength > 0) {
        Integer joinerPointer = joiner __as__ Integer;
        _moveBytes(joinerPointer + 16, cursor, joinerLength);
        cursor += joinerLength;
      }
    }
    index += 1;
  }
  return resultPointer __as__ String;
}


// GARBAGE COLLECTION

// Allocated blocks that participate in garbage collection are a subtype of GarbageCollectable.
// We have a list for every allocated GarbageCollectable block (list starts at _blockListStart).
// Each allocated GarbageCollectable block has the same header (each line is 64 bits):
//
//   ref count (number of known references from stack)
//   length N
//   scratch space (used by GC, can otherwise be ignored)
//   block entry (pointer into block list, minus _blockListStart)
//
// After this there are N fields, which are type/value pairs (64 bit type codes, 64 bit values)
// which the garbage collector can walk to find all references.

Integer _gcLocked = 0; // when non-zero, GC cannot happen
Integer _blockListStart; // start of allocation list
Integer _blockListEnd; // end of allocation list
Integer _blockListNext; // next allocation entry
Integer _debugLiveBlocks = 0;

Null _blockListInit(Integer initialCount) {
  _gcLocked += 1;
  Integer initialSize = initialCount * _blockEntrySize;
  _blockListStart = _alloc(initialSize);
  _blockListEnd = _blockListStart + initialSize;
  _blockListNext = _blockListStart;
  _fillQuadWords(_blockListStart, initialSize, 0);
  _gcLocked -= 1;
}

_blockListInit(1024);

Null _growBlockList() {
  assert(_gcLocked > 0, '_growBlockList called without _gcLocked set');
  Integer oldLength = _blockListEnd - _blockListStart;
  Integer newLength = oldLength * 2;
  Integer newBlock = _alloc(newLength); // TODO: use realloc instead
  _moveBytes(_blockListStart, newBlock, oldLength);
  _fillQuadWords(newBlock + oldLength, oldLength, 0);
  _free(_blockListStart);
  _blockListStart = newBlock;
  _blockListNext = newBlock + oldLength;
  _blockListEnd = newBlock + newLength;
}

Null _advanceToNextBlock() {
  assert(_gcLocked > 0, '_advanceToNextBlock called without _gcLocked set');
  Integer last = _blockListNext;
  while (true) {
    Integer pointer = __readFromAddress(_blockListNext);
    if (pointer == 0) {
      // found a free slot
      return;
    }
    _blockListNext += _blockEntrySize;
    if (_blockListNext == last) {
      // looped all the way around, need to grow the list
      _growBlockList();
      return;
    }
    if (_blockListNext == _blockListEnd) {
      _blockListNext = _blockListStart;
    }
  }
}

GarbageCollectable _constructor(Integer typeCode, Integer length, Integer size) {
  assert(_gcLocked > 0, '_constructor called without _gcLocked set');
  assert(size >= length, 'length cannot be bigger than size');
  Integer resultPointer = _alloc(64 + 16 * size);
  __writeToAddress(resultPointer + _gcBlockHeaderRefCount, 0); // ref count
  __writeToAddress(resultPointer + _gcBlockHeaderLength, length); // length
  __writeToAddress(resultPointer + _gcBlockHeaderScratchSpace, 0); // scratch space
  __writeToAddress(resultPointer + _gcBlockHeaderEntryPointer, _blockListNext - _blockListStart); // block pointer
  __writeToAddress(_blockListNext, resultPointer);
  _advanceToNextBlock();
  _debugLiveBlocks += 1;
  return (resultPointer __dynamic_as__ typeCode) as GarbageCollectable;
}

Null _mark(Integer pointer, Integer tag) {
  Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
  if (blockScratchSpace == tag) {
    return;
  }
  __writeToAddress(pointer + _gcBlockHeaderScratchSpace, tag);
  Integer blockLength = __readFromAddress(pointer + _gcBlockHeaderLength);
  Integer cursor = pointer + _gcBlockData;
  Integer end = cursor + blockLength * 16;
  while (cursor < end) {
    Whatever value = __readFromAddress(cursor + 8) __dynamic_as__ __readFromAddress(cursor + 0);
    if (value is GarbageCollectable) {
      _mark(value __as__ Integer, tag);
    }
    cursor += 16;
  }
}

Integer _currentTag = 0;

Null _garbageCollectorImplementation() {
  if (_gcLocked > 0) {
    return;
  }
  _gcLocked += 1;
  _currentTag += 1;
  Integer cursor = _blockListStart;
  while (cursor < _blockListEnd) {
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockRefCount = __readFromAddress(pointer + _gcBlockHeaderRefCount);
      assert(blockRefCount >= 0, 'Reference count underflow.');
      if (blockRefCount != 0) {
        _mark(pointer, _currentTag);
      }
    }
    cursor += _blockEntrySize;
  }
  while (cursor > _blockListStart) {
    cursor -= _blockEntrySize;
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
      if (blockScratchSpace != _currentTag) {
        // destructor:
        _free(pointer);
        __writeToAddress(cursor, 0);
        _debugLiveBlocks -= 1;
      }
    }
  }
  _gcLocked -= 1;
}
_garbageCollector = _garbageCollectorImplementation;


// LISTS

// Lists are represented as pointers to an intermediary block that itself contains a pointer to
// the data. Both are GarbageCollectable blocks as described above.
//
// The list intermediary has length two.
// The first value is size (type Integer), the number of allocated entries in the list data.
// This may be bigger than the length, to allow cheaper appends.
// The second value is a pointer to the data block (type __ListData).
//
// The list data just has the values.

WhateverList _listConstructor(Integer typeCode, Integer initialSize) __intrinsic {
  _gcLocked += 1;
  WhateverList list = _constructor(typeCode, 2, 2) as WhateverList;
  __ListData data = _constructor(__typeToCode __ListData, 0, initialSize) as __ListData;
  __writeToAddress(list __as__ Integer + _gcBlockData + 0, __typeOf initialSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, initialSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16, __typeOf data);
  __writeToAddress(list __as__ Integer + _gcBlockData + 24, data __as__ Integer);
  _gcLocked -= 1;
  return list;
}

Null _growList(WhateverList list) {
  _gcLocked += 1;
  Integer newSize = len(list) * 2;
  __ListData newData = _constructor(__typeToCode __ListData, len(list), newSize) as __ListData;
  __ListData oldData = __readFromAddress(list __as__ Integer + _gcBlockData + 16 + 8) __as__ __ListData;
  _moveBytes(oldData __as__ Integer + _gcBlockData, newData __as__ Integer + _gcBlockData, len(list) * 16);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, newSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16 + 8, newData __as__ Integer);
  _gcLocked -= 1;
}

Null append(WhateverList list, Anything element) __intrinsic {
  if (!(element __dynamic_is__ __elementTypeFrom __typeOf list)) {
    throw('type error in append');
  }
  _gcLocked += 1;
  Integer intermediaryAddress = list __as__ Integer;
  Integer size = __readFromAddress(intermediaryAddress + _gcBlockData + 0 + 8);
  Integer dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  Integer length = len(list);
  if (length == size) {
    _growList(list);
    dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  }
  __writeToAddress(dataAddress + _gcBlockData + length * 16, __typeOf element);
  __writeToAddress(dataAddress + _gcBlockData + length * 16 + 8, element __as__ Integer);
  __writeToAddress(dataAddress + _gcBlockHeaderLength, length + 1);
  if (element is String) {
    Integer refcount = __readFromAddress(element __as__ Integer + _gcBlockHeaderRefCount);
    if (refcount >= 0) {
      __writeToAddress(element __as__ Integer + _gcBlockHeaderRefCount, refcount + 1);
    }
  }
  _gcLocked -= 1;
}


// ITERABLES AND ITERATORS

// Iterators are blocks with the following values:
//  1: pointer to iterable
//  2: cursor (semantics vary based on the iterable)

// Iterables are currently just lists. This will have to change when we implement scalarValues.

// returns value at cursor of iterator
// it is a fatal error to call current when the cursor
// points before the beginning or after the end of the iterable
// (i.e. if next() has not been called or has returned false)
Whatever current(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  return list[index];
}

// advances cursor of iterator by one
// return true if cursor is before end of iterable; current returns value at cursor
// return false if cursor is after end of iterable
Boolean next(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  index += 1;
  __writeToAddress(iteratorArg __as__ Integer + _gcBlockData + 24, index);
  return index < len(list);
}

// creates an iterator for the iterable
WhateverIterator iterator(WhateverIterable iterable) __intrinsic {
  assert(iterable is WhateverList, 'iterables are only implemented for lists');
  _gcLocked += 1;
  WhateverIterator result = _constructor(__iteratorTypeFrom __typeOf iterable, 2, 2) as WhateverIterator;
  __writeToAddress(result __as__ Integer + _gcBlockData + 0, __typeOf iterable);
  __writeToAddress(result __as__ Integer + _gcBlockData + 8, iterable __as__ Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 16, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 24, -1);
  _gcLocked -= 1;
  return result;
}

WhateverList copy(WhateverIterable iterable) {
  Integer length;
  if (iterable is WhateverList) {
    length = len(iterable as WhateverList);
  } else {
    length = 1;
  }
  WhateverList list = _listConstructor(__listTypeFrom __typeOf iterable, length);
  for (value in iterable) {
    append(list, value);
  }
  return list;
}


// CLASSES

// VMT structure
//
// integer giving type code for this class (-1 if the class is never constructed or type checked)
// integer giving number of fields to allocate (for construction)
// pointer to class name (to implement .className)
// pointer to parent vmt (to implement super.bar)
// pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
// for each member, we have these methods:
//   0. a setter implementation that takes one argument and return nothing
//      for properties, it just sets the right entry of the object
//      for methods, it throws
//   1. a getter implementation that takes no arguments and returns the member
//      for properties, it just fetches the right entry from the object
//      for methods, it creates and returns a method pointer
//   2. a function call implementation
//      for properties, it calls the getter, does type checks, and then invokes it with the arguments
//      for methods, it is the actual code for the method
//   they are stored in the vmt as follows:
//      <type code of member>
//      <code address to setter function>
//      <code address to getter function>
//      <code address to call function>

// member lookup table for dynamic dispatch list
// 32 bit zero
// 32 bit length number of entries
// for each entry (in increasing member name number order):
//   32 bit (high bits) offset into vmt that gives code address to getter function (i.e. address of pointer to code address - address of vmt)
//   32 bit (low bits) member name number

// Instances are GarbageCollectable blocks whose fields are the class fields in declaration order.

__Object _classAllocator(Integer vmt) __intrinsic {
  _gcLocked += 1;
  Integer typeCode = __readFromAddress(vmt + _vmtTypeCode);
  assert(typeCode >= 0, 'tried to construct class without a type code');
  Integer fieldCount = __readFromAddress(vmt + _vmtFieldCount);
  assert(fieldCount >= 2, 'unexpectedly small field count');
  __Object instance = _constructor(typeCode, fieldCount, fieldCount) as __Object;
  __writeToAddress(instance __as__ Integer + _fieldVmt, __typeToCode Integer);
  __writeToAddress(instance __as__ Integer + _fieldVmt + 8, vmt);
  __writeToAddress(instance __as__ Integer + _fieldClassName, __typeToCode String);
  __writeToAddress(instance __as__ Integer + _fieldClassName + 8, __readFromAddress(vmt + _vmtClassName));
  if (fieldCount > 2) {
    _fillQuadWords(instance __as__ Integer + _fieldsRemainder, (fieldCount - 2) * 16, 0);
  }
  _gcLocked -= 1;
  return instance;
}

class __Object __intrinsic {
  Integer vmt#; // must be field 0 to match constants above
  String className; // must be field 1 to match constants above
  String toString() {
    return concat('<', className, '>');
  }
  Null constructor() {}
}

// Code pointers are blocks with the following values:
//  1: pointer to object or closure; null for global scope function pointers
//  2: pointer to code (with annotation at -8 bytes) as an Integer

WhateverFunction _createMethodPointer(__Object receiver, __CodeAddress codePointer, Integer functionTypeCode) __intrinsic {
  _gcLocked += 1;
  WhateverFunction result = _constructor(functionTypeCode, 2, 2) as WhateverFunction;
  __writeToAddress(result __as__ Integer + _subroutineReceiverType, __typeOf receiver);
  __writeToAddress(result __as__ Integer + _subroutineReceiverPointer, receiver __as__ Integer);
  __writeToAddress(result __as__ Integer + _subroutineClosurePointer, 0);
  __writeToAddress(result __as__ Integer + _subroutineClosureType, 0);
  __writeToAddress(result __as__ Integer + _subroutineCodeType, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _subroutineCodePointer, codePointer __as__ Integer);
  _gcLocked -= 1;
  return result;
}

Whatever _dummy1() {
  throw('dummy function called');
}

// This function returns a getter, which you then need to call to get the actual value.
WhateverFunction _dynamicLookup(Anything receiver, Integer methodId) __intrinsic {
  if (!receiver is __Object) {
    throw(concat('Cannot dynamic dispatch on ', receiver, ' which is not an object.'));
  }
  Integer vmt = (receiver as __Object).vmt#;
  Integer ddt = __readFromAddress(vmt + _vmtDynamicDispatchTable);
  // TODO: make this a binary search
  Integer cursor = ddt + 8;
  Integer end = ddt + 8 + __readFromAddress(ddt) * 8;
  while (cursor < end) {
    Integer entry = __readFromAddress(cursor);
    if ((entry & 0x00000000FFFFFFFF) == methodId) {
      return _createMethodPointer(receiver as __Object, __readFromAddress(vmt + (entry >> 32)) __as__ __CodeAddress, __typeOf _dummy1);
    }
    cursor += 8;
  }
  throw(concat('No member with specified name found on "', (receiver as __Object).className, '".'));
}


// STRING BUFFERS

typedef# StringBuffer is GarbageCollectable;

class StringBufferPart# {
  String value;

  StringBufferPart#Nullable next = null;
  Null setNext(StringBufferPart# part) {
    next = part;
  }

  Null constructor(String valueArg) {
    value = valueArg;
  }
}

class StringBuffer# {
  Integer length = 0;

  StringBufferPart#Nullable first = null;
  Null setFirst(StringBufferPart# part) {
    first = part;
  }

  StringBufferPart#Nullable last = null;
  Null add(StringBufferPart# part) {
    last = part;
    length += _stringByteLength(part.value);
  }
}

StringBuffer createStringBuffer() {
  StringBuffer# buffer = StringBuffer#();
  return buffer __as__ StringBuffer;
}

Null writeStringBuffer(StringBuffer buffer, String value) {
  if (value == '') {
    return;
  }
  StringBuffer# target = buffer __as__ StringBuffer#;
  StringBufferPart# part = StringBufferPart#(value);
  if (target.first == null) {
    assert(target.length == 0, 'invariant violation');
    target.setFirst(part);
  } else {
    assert(target.length > 0, 'invariant violation');
    target.last!.setNext(part);
  }
  target.add(part);
}

String readStringBuffer(StringBuffer buffer) {
  StringBuffer# source = buffer __as__ StringBuffer#;
  if (source.first == null) {
    assert(source.length == 0, 'invariant violation');
    return '';
  }
  Integer resultPointer = _alloc(16 + source.length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, source.length);
  Integer cursor = resultPointer + 16;
  StringBufferPart#Nullable part = source.first!;
  while (part != null) {
    Integer segmentLength = _stringByteLength(part!.value);
    Integer segmentPointer = part!.value __as__ Integer;
    _moveBytes(segmentPointer + 16, cursor, segmentLength);
    part = part!.next;
    cursor += segmentLength;
  }
  return resultPointer __as__ String;
}


// I/O

Integer __getStdHandle(Integer handle) __extern 'kernel32.lib' 'GetStdHandle';
Integer __writeFile(Integer hFile, Integer lpBuffer, Integer nNumberOfBytesToWrite, Integer lpNumberOfBytesWritten, Integer lpOverlapped) __extern 'kernel32.lib' 'WriteFile';
Integer __STD_OUTPUT_HANDLE = -11;
Integer __STD_ERROR_HANDLE = -12;
Integer _scratch = _alloc(8); // used for lpNumberOfBytesWritten

Null __writeToHandle(Integer handle, String message) {
  __writeFile(__getStdHandle(handle), (message __as__ Integer) + 16, _stringByteLength(message), _scratch, 0);
}

String _stringify(Anything arg) {
  if (arg is String) {
    return arg as String;
  }
  if (arg is Boolean) {
    if (arg as Boolean) {
      return 'true';
    }
    return 'false';
  }
  if (arg is Null) {
    return 'null';
  }
  if (arg is Integer) {
    return intToStr(arg as Integer);
  }
  if (arg is __Object) {
    return (arg as __Object).toString();
  }
  if (arg is AnythingFunction) {
    Integer func = arg __as__ Integer;
    if (__readFromAddress(func + _subroutineReceiverPointer) != 0) {
      Integer annotation = __readFromAddress(__readFromAddress(func + _subroutineCodePointer) - 8);
      __Object class = (__readFromAddress(func + _subroutineReceiverPointer) __dynamic_as__ __readFromAddress(func + _subroutineReceiverType)) as __Object;
      return concat('<function (method ', class.className, '.', annotation __as__ String, ')>');
    }
    Integer annotation = __readFromAddress(__readFromAddress(func + _subroutineCodePointer) - 8);
    return concat('<function (', annotation __as__ String, ')>');
  }
  if (arg is StringList) {
    return concat('[', join(arg as StringList, ', '), ']');
  }
  if (arg is WhateverList) {
    StringList new = []:String;
    WhateverList old = arg as WhateverList;
    Integer i = 0;
    while (i < len(old)) {
      // TODO: beware infinite loops from cyclic references
      append(new, _stringify(old[i]));
      i += 1;
    }
    return concat('[', join(new, ', '), ']');
  }
  if (arg is __ListData) {
    return '<__ListData>';
  }
  if (arg is StringBuffer) {
    return '<StringBuffer>';
  }
  stderr('value cannot be stringified:', __typeOf arg);
  exit(1);
}

String _concat(Anything... arguments) {
  if (len(arguments) == 0) {
    return '';
  }
  if (len(arguments) == 1) {
    return _stringify(arguments[0]);
  }
  StringList strings = []:String;
  Integer length = 0;
  Integer index = 0;
  while (index < len(arguments)) {
    String segment = _stringify(arguments[index]);
    append(strings, segment);
    length += _stringByteLength(segment);
    index += 1;
  }
  assert(length >= 0, 'negative length detected');
  if (length >= 2147483648) {
    stderr('absurd length detected (as exit code)\n');
    exit(length);
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(strings)) {
    String segment = strings[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    index += 1;
  }
  return resultPointer __as__ String;
}
concat = _concat;

Null print(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeToHandle(__STD_OUTPUT_HANDLE, ' ');
    }
    __writeToHandle(__STD_OUTPUT_HANDLE, _stringify(parts[index]));
    first = false;
    index += 1;
  }
}

Null println(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeToHandle(__STD_OUTPUT_HANDLE, ' ');
    }
    __writeToHandle(__STD_OUTPUT_HANDLE, _stringify(parts[index]));
    first = false;
    index += 1;
  }
  __writeToHandle(__STD_OUTPUT_HANDLE, '\n');
}

Null _stderr(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeToHandle(__STD_ERROR_HANDLE, ' ');
    }
    __writeToHandle(__STD_ERROR_HANDLE, _stringify(parts[index]));
    first = false;
    index += 1;
  }
  __writeToHandle(__STD_ERROR_HANDLE, '\n');
}
stderr = _stderr;

Null _error(Anything... arguments) __intrinsic {
  assert(len(arguments) >= 1, 'insufficient arguments to _error');
  stderr(arguments[0]);
  exit(1);
}

// STRING MANIPULATION

StringList scalarValues(String value) {
  // This should decode UTF-8.
  // For now we only support 8-bit character encodings.
  StringList result = []:String;
  Integer length = _stringByteLength(value);
  Integer cursor = value __as__ Integer + 16;
  Integer end = cursor + length;
  while (cursor < end) {
    Integer code = __readFromAddress(cursor);
    Integer resultPointer = _alloc(16 + 1);
    __writeToAddress(resultPointer, 0); // ref count
    __writeToAddress(resultPointer + 8, 1); // length
    __writeToAddress(resultPointer + 16, code); // the "character"
    append(result, resultPointer __as__ String);
    cursor += 1;
  }
  return result;
}

StringList charsOf(String value) {
  // This should use ICU's BreakIterator.
  // For now we just return Unicode Scalar Values since we only support 8-bit encodings anyway.
  return scalarValues(value);
}
