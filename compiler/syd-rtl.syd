// TODO:
//  - implement string ref counting

// TODO: this should be a compiler intrinsic so that the message evaluation can be lazy and so it can be skipped in release builds
Null assert(Boolean condition, String message) {
  if (!condition) {
    __print(message);
    __print('\n');
    exit(1);
  }
}

Integer __getLastError() __extern 'kernel32.lib' 'GetLastError';

Integer __getProcessHeap() __extern 'kernel32.lib' 'GetProcessHeap';

Integer _heapHandle = __getProcessHeap();

Integer __heapAlloc(Integer hHeap, Integer dwFlags, Integer dwBytes) __extern 'kernel32.lib' 'HeapAlloc';

Integer _blockCount = 0;

/// Allocates a block on the heap.
///
/// Block must be freed with [_free].
Integer _alloc(Integer size) {
  _blockCount += 1;
  return __heapAlloc(_heapHandle, 0x00, size);
}

// returns positive for success, zero for failure
Integer __heapFree(Integer hHeap, Integer dwFlags, Integer lpMem) __extern 'kernel32.lib' 'HeapFree';

/// Frees a heap allocation obtained from [_alloc].
Null _free(Integer pointer) __intrinsic {
  _blockCount -= 1;
  if (__heapFree(_heapHandle, 0x00, pointer) == 0) {
    //println('failed to free pointer, error code: ', __getLastError());
    exit(1);
  }
}

Null _moveBytes(Integer from, Integer to, Integer length) {
  // TODO: move this to inlined assembler (using the string-copy instructions) for performance
  // (or optimize the compiler enough that it generates good code somehow!)
  assert(length > 0, '_moveBytes expects positive number of bytes to copy');
  Integer fromCursor = from;
  Integer toCursor = to;
  Integer end = from + (length / 8) * 8;
  // TODO: implement || (then uncomment these asserts)
  // assert(fromCursor != end || length < 8, 'inconsistency');
  // assert(fromCursor != end || length > 0, 'inconsistency');
  while (fromCursor < end) {
    Integer value = __readFromAddress(fromCursor);
    __writeToAddress(toCursor, value);
    fromCursor += 8;
    toCursor += 8;
  }
  end = from + length;
  // assert((fromCursor < end) || (from < fromCursor), 'no moves on either side');
  if (fromCursor < end) {
    Integer newValue = __readFromAddress(fromCursor);
    Integer oldValue = __readFromAddress(toCursor);
    Integer extraBytes = end - fromCursor;
    assert(extraBytes > 0, 'internal error: zero extra bytes but fromCursor is before end');
    assert(extraBytes < 8, 'internal error: more than 7 extra bytes');
    Integer mask = 0xFFFFFFFFFFFFFFFF << (extraBytes * 8);
    Integer finalValue = (newValue & ~mask) | (oldValue & mask);
    __writeToAddress(toCursor, finalValue);
  }
}

Integer _stringByteLength(String data) {
  Integer pointer = data __as__ Integer;
  return __readFromAddress(pointer + 8);
}

String concat(String... arguments) {
  Integer length = 0;
  Integer index = 0;
  while (index < len(arguments)) {
    length += _stringByteLength(arguments[index]);
    index += 1;
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 1); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(arguments)) {
    String segment = arguments[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    index += 1;
  }
  return resultPointer __as__ String;
}

String digitToStr(Integer digit) {
  if (digit == 0) {
    return '0';
  }
  if (digit == 1) {
    return '1';
  }
  if (digit == 2) {
    return '2';
  }
  if (digit == 3) {
    return '3';
  }
  if (digit == 4) {
    return '4';
  }
  if (digit == 5) {
    return '5';
  }
  if (digit == 6) {
    return '6';
  }
  if (digit == 7) {
    return '7';
  }
  if (digit == 8) {
    return '8';
  }
  if (digit == 9) {
    return '9';
  }
  __print('Invalid digit passed to digitToStr (digit as exit code)\n');
  exit(digit);
}

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  String buffer = ''; 
  Integer newValue = value; // parameters are final
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    buffer = concat(digitToStr(digit), buffer);
  }
  return buffer;
}

String _stringify(Anything arg) {
  if (arg is String) {
    return arg;
  }
  if (arg is Boolean) {
    if (arg) {
      return 'true';
    }
    return 'false';
  }
  if (arg is Null) {
    return 'null';
  }
  if (arg is Integer) {
    return intToStr(arg as Integer);
  }
  __print('value cannot be stringified\n');
  exit(1);
}

Null print(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
}

Null println(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
  __print('\n');
}