// RUNTIME LIBRARY
// Code in this file defines and uses compiler intrinsics.

// TODO: turn RTL privates into foo# syntax
// TODO: complain if a function is __intrinsic and we don't know about it

// CONSTANTS // TODO: don't declare these here - just import syd-constants.syd

Integer _blockEntrySize = 8; // stride size in block entry list
Integer _gcBlockHeaderRefCount = 0 * 8;
Integer _gcBlockHeaderLength = 1 * 8;
Integer _gcBlockHeaderScratchSpace = 2 * 8;
Integer _gcBlockHeaderEntryPointer = 3 * 8;
Integer _gcBlockData = 4 * 8;

Integer _vmtTypeCode = 0x00;
Integer _vmtFieldCount = 0x08;
Integer _vmtClassName = 0x10;
Integer _vmtParent = 0x18;
Integer _vmtDynamicDispatchTable = 0x20;
Integer _vmtMethods = 0x28;

Integer _fieldVmt = _gcBlockData + 0x00;
Integer _fieldClassName = _gcBlockData + 0x10;
Integer _fieldsRemainder = _gcBlockData + 0x20;

Integer _subroutineReceiverType = _gcBlockData + 0 * 16;
Integer _subroutineReceiverPointer = _gcBlockData + 0 * 16 + 8;
Integer _subroutineClosureType = _gcBlockData + 1 * 16; // either sentinel or internal closure type
Integer _subroutineClosurePointer = _gcBlockData + 1 * 16 + 8;
Integer _subroutineCodeType = _gcBlockData + 2 * 16; // for completeness, always code address type
Integer _subroutineCodePointer = _gcBlockData + 2 * 16 + 8;

Integer _enumTableNameOffset = 0x00;
Integer _enumTableLengthOffset = 0x08;
Integer _enumTableEntryTypeOffset = 0x10;
Integer _enumTableFirstEntryOffset = 0x18;

fwdclass __Object() __intrinsic;

// ERROR MANAGEMENT

Integer exit(Integer exitCode) __intrinsic __extern 'kernel32.lib' 'ExitProcess';
Integer __getLastError() __extern 'kernel32.lib' 'GetLastError';

NullFunction stderr;

// TODO: this should be a compiler intrinsic so that the message evaluation can be lazy and so it can be skipped in release builds
Null assert(Boolean condition, String message) {
  if (!condition) {
    stderr(message);
    exit(1);
  }
}

Null throw(String message) {
  stderr(message);
  exit(1);
}


// HEAP MANAGEMENT

Integer __getProcessHeap() __extern 'kernel32.lib' 'GetProcessHeap';

Integer _heapHandle = __getProcessHeap();

Integer __heapAlloc(Integer hHeap, Integer dwFlags, Integer dwBytes) __extern 'kernel32.lib' 'HeapAlloc';

// Number of calls to alloc minus number of calls to free.
Integer _blockCount = 0;

NullFunction _garbageCollector;

// The number of times this file will call _alloc and not _free on startup 
Integer _rtlInitialBlockCount = 3;
// The number of GC blocks at the end of this file.
Integer _rtlInitialLiveBlocks = 2;

/// Allocates a block on the heap.
///
/// Block must be freed with [_free].
///
/// Blocks are always 8-byte aligned.
Integer _alloc(Integer size) {
  Integer alignedSize = size + (size % 8);
  Integer pointer = __heapAlloc(_heapHandle, 0x00, alignedSize);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  _garbageCollector();
  pointer = __heapAlloc(_heapHandle, 0x00, alignedSize);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  stderr('Out of memory.');
  exit(1);
}

/// returns positive for success, zero for failure
Integer __heapFree(Integer hHeap, Integer dwFlags, Integer lpMem) __extern 'kernel32.lib' 'HeapFree';

/// Frees a heap allocation obtained from [_alloc].
Null _free(Integer pointer) __intrinsic {
  _blockCount -= 1;
  if (__heapFree(_heapHandle, 0x00, pointer) == 0) {
    stderr('failed to free pointer, error code:', __getLastError());
    exit(1);
  }
}

Integer _allBits = -1; // 0xFFFFFFFFFFFFFFFF

Null _moveBytes(Integer from, Integer to, Integer length) {
  // TODO: move this to inlined assembler (using the string-copy instructions) for performance
  // (or optimize the compiler enough that it generates good code somehow!)
  assert(length > 0, '_moveBytes expects positive number of bytes to copy');
  Integer fromCursor = from;
  Integer toCursor = to;
  Integer end = from + (length / 8) * 8;
  assert(fromCursor != end || length < 8, 'inconsistency');
  assert(fromCursor != end || length > 0, 'inconsistency');
  while (fromCursor < end) {
    Integer value = __readFromAddress(fromCursor);
    __writeToAddress(toCursor, value);
    fromCursor += 8;
    toCursor += 8;
  }
  end = from + length;
  assert((fromCursor < end) || (from < fromCursor), 'no moves on either side');
  if (fromCursor < end) {
    Integer newValue = __readFromAddress(fromCursor);
    Integer oldValue = __readFromAddress(toCursor);
    Integer extraBytes = end - fromCursor;
    assert(extraBytes > 0, 'internal error: zero extra bytes but fromCursor is before end');
    assert(extraBytes < 8, 'internal error: more than 7 extra bytes');
    Integer mask = _allBits << (extraBytes * 8);
    Integer finalValue = (newValue & ~mask) | (oldValue & mask);
    __writeToAddress(toCursor, finalValue);
  }
}

// length is in bytes
Null _fillQuadWords(Integer destination, Integer length, Integer value) {
  // TODO: is there an x64 intrinsic that does this faster?
  assert(length > 0, '_fillQuadWords expects positive number of bytes to fill');
  assert(length % 8 == 0, '_fillQuadWords expects number of bytes to fill to be a multiple of 8');
  Integer cursor = destination;
  Integer end = destination + length;
  while (cursor < end) {
    __writeToAddress(cursor, value);
    cursor += 8;
  }
}


// GARBAGE COLLECTION

// Allocated blocks that participate in garbage collection are a subtype of GarbageCollectable.
// We have a list for every allocated GarbageCollectable block (list starts at _blockListStart).
// Each allocated GarbageCollectable block has the same header (each line is 64 bits):
//
//   ref count (number of known references from stack)
//   length N
//   scratch space (used by GC, can otherwise be ignored)
//   block entry (pointer into block list, minus _blockListStart)
//
// After this there are N fields, which are type/value pairs (64 bit type codes, 64 bit values)
// which the garbage collector can walk to find all references.

Integer _gcLocked = 0; // when non-zero, GC cannot happen
Integer _blockListStart; // start of allocation list
Integer _blockListEnd; // end of allocation list
Integer _blockListNext; // next allocation entry
Integer _debugLiveBlocks = 0;

Null _blockListInit(Integer initialCount) {
  _gcLocked += 1;
  Integer initialSize = initialCount * _blockEntrySize;
  _blockListStart = _alloc(initialSize);
  _blockListEnd = _blockListStart + initialSize;
  _blockListNext = _blockListStart;
  _fillQuadWords(_blockListStart, initialSize, 0);
  _gcLocked -= 1;
}

_blockListInit(1024);

Null _growBlockList() {
  assert(_gcLocked > 0, '_growBlockList called without _gcLocked set');
  Integer oldLength = _blockListEnd - _blockListStart;
  Integer newLength = oldLength * 2;
  Integer newBlock = _alloc(newLength); // TODO: use realloc instead
  _moveBytes(_blockListStart, newBlock, oldLength);
  _fillQuadWords(newBlock + oldLength, oldLength, 0);
  _free(_blockListStart);
  _blockListStart = newBlock;
  _blockListNext = newBlock + oldLength;
  _blockListEnd = newBlock + newLength;
}

Null _advanceToNextBlock() {
  assert(_gcLocked > 0, '_advanceToNextBlock called without _gcLocked set');
  Integer last = _blockListNext;
  while (true) {
    Integer pointer = __readFromAddress(_blockListNext);
    if (pointer == 0) {
      // found a free slot
      return;
    }
    _blockListNext += _blockEntrySize;
    if (_blockListNext == last) {
      // looped all the way around, need to grow the list
      _growBlockList();
      return;
    }
    if (_blockListNext == _blockListEnd) {
      _blockListNext = _blockListStart;
    }
  }
}

GarbageCollectable _constructor(Integer typeCode, Integer length, Integer size) {
  assert(_gcLocked > 0, '_constructor called without _gcLocked set');
  assert(size >= length, 'length cannot be bigger than size');
  Integer resultPointer = _alloc(64 + 16 * size);
  __writeToAddress(resultPointer + _gcBlockHeaderRefCount, 0); // ref count
  __writeToAddress(resultPointer + _gcBlockHeaderLength, length); // length
  __writeToAddress(resultPointer + _gcBlockHeaderScratchSpace, 0); // scratch space
  __writeToAddress(resultPointer + _gcBlockHeaderEntryPointer, _blockListNext - _blockListStart); // block pointer
  __writeToAddress(_blockListNext, resultPointer);
  _advanceToNextBlock();
  _debugLiveBlocks += 1;
  return (resultPointer __dynamic_as__ typeCode) as GarbageCollectable;
}

Null _mark(Integer pointer, Integer tag) {
  Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
  if (blockScratchSpace == tag) {
    return;
  }
  __writeToAddress(pointer + _gcBlockHeaderScratchSpace, tag);
  Integer blockLength = __readFromAddress(pointer + _gcBlockHeaderLength);
  Integer cursor = pointer + _gcBlockData;
  Integer end = cursor + blockLength * 16;
  while (cursor < end) {
    Whatever value = __readFromAddress(cursor + 8) __dynamic_as__ __readFromAddress(cursor + 0);
    if (value is GarbageCollectable) {
      _mark(value __as__ Integer, tag);
    }
    cursor += 16;
  }
}

Integer _currentTag = 0;

Null _garbageCollectorImplementation() {
  if (_gcLocked > 0) {
    return;
  }
  _gcLocked += 1;
  _currentTag += 1;
  Integer cursor = _blockListStart;
  while (cursor < _blockListEnd) {
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockRefCount = __readFromAddress(pointer + _gcBlockHeaderRefCount);
      assert(blockRefCount >= 0, 'Reference count underflow.');
      if (blockRefCount != 0) {
        _mark(pointer, _currentTag);
      }
    }
    cursor += _blockEntrySize;
  }
  while (cursor > _blockListStart) {
    cursor -= _blockEntrySize;
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
      if (blockScratchSpace != _currentTag) {
        // destructor:
        _free(pointer);
        __writeToAddress(cursor, 0);
        _debugLiveBlocks -= 1;
      }
    }
  }
  _gcLocked -= 1;
}
_garbageCollector = _garbageCollectorImplementation;


// LISTS

// Lists are represented as pointers to an intermediary block that itself contains a pointer to
// the data. Both are GarbageCollectable blocks as described above.
//
// The list intermediary has length two.
// The first value is size (type Integer), the number of allocated entries in the list data.
// This may be bigger than the length, to allow cheaper appends.
// The second value is a pointer to the data block (type __ListData).
//
// The list data just has the values.

WhateverList _listConstructor(Integer typeCode, Integer initialSize) __intrinsic {
  _gcLocked += 1;
  WhateverList list = _constructor(typeCode, 2, 2) as WhateverList;
  __ListData data = _constructor(__typeToCode __ListData, 0, initialSize) as __ListData;
  __writeToAddress(list __as__ Integer + _gcBlockData + 0, __typeOf initialSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, initialSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16, __typeOf data);
  __writeToAddress(list __as__ Integer + _gcBlockData + 24, data __as__ Integer);
  _gcLocked -= 1;
  return list;
}

Null _growList(WhateverList list) {
  _gcLocked += 1;
  Integer newSize = len(list) * 2;
  __ListData newData = _constructor(__typeToCode __ListData, len(list), newSize) as __ListData;
  __ListData oldData = __readFromAddress(list __as__ Integer + _gcBlockData + 16 + 8) __as__ __ListData;
  _moveBytes(oldData __as__ Integer + _gcBlockData, newData __as__ Integer + _gcBlockData, len(list) * 16);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, newSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16 + 8, newData __as__ Integer);
  _gcLocked -= 1;
}

Null append(WhateverList list, Anything element) __intrinsic {
  if (!(element __dynamic_is__ __elementTypeFrom __typeOf list)) {
    throw('type error in append');
  }
  _gcLocked += 1;
  Integer intermediaryAddress = list __as__ Integer;
  Integer size = __readFromAddress(intermediaryAddress + _gcBlockData + 0 + 8);
  Integer dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  Integer length = len(list);
  if (length == size) {
    _growList(list);
    dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  }
  __writeToAddress(dataAddress + _gcBlockData + length * 16, __typeOf element);
  __writeToAddress(dataAddress + _gcBlockData + length * 16 + 8, element __as__ Integer);
  __writeToAddress(dataAddress + _gcBlockHeaderLength, length + 1);
  if (element is String) {
    Integer refcount = __readFromAddress(element __as__ Integer + _gcBlockHeaderRefCount);
    if (refcount >= 0) {
      __writeToAddress(element __as__ Integer + _gcBlockHeaderRefCount, refcount + 1);
    }
  }
  _gcLocked -= 1;
}

Anything pop(WhateverList list) {
  Integer lastIndex = len(list) - 1;
  if (lastIndex < 0) {
    throw('cannot pop from empty list');
  }
  Anything result = list[lastIndex];
  Integer intermediaryAddress = list __as__ Integer;
  Integer dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  __writeToAddress(dataAddress + _gcBlockHeaderLength, lastIndex);
  return result;
}


// ITERABLES AND ITERATORS

// Iterators are blocks with the following values:
//  1: pointer to iterable
//  2: cursor (semantics vary based on the iterable)

// Iterables are currently just lists. This will have to change when we implement scalarValues.

// returns value at cursor of iterator
// it is a fatal error to call current when the cursor
// points before the beginning or after the end of the iterable
// (i.e. if next() has not been called or has returned false)
Whatever current(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  return list[index];
}

// advances cursor of iterator by one
// return true if cursor is before end of iterable; current returns value at cursor
// return false if cursor is after end of iterable
Boolean next(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  index += 1;
  __writeToAddress(iteratorArg __as__ Integer + _gcBlockData + 24, index);
  return index < len(list);
}

// creates an iterator for the iterable
WhateverIterator iterator(WhateverIterable iterable) __intrinsic {
  assert(iterable is WhateverList, 'iterables are only implemented for lists');
  _gcLocked += 1;
  WhateverIterator result = _constructor(__iteratorTypeFrom __typeOf iterable, 2, 2) as WhateverIterator;
  __writeToAddress(result __as__ Integer + _gcBlockData + 0, __typeOf iterable);
  __writeToAddress(result __as__ Integer + _gcBlockData + 8, iterable __as__ Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 16, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 24, -1);
  _gcLocked -= 1;
  return result;
}

WhateverList copy(WhateverIterable iterable) {
  Integer length;
  if (iterable is WhateverList) {
    length = len(iterable as WhateverList);
  } else {
    length = 1;
  }
  WhateverList list = _listConstructor(__listTypeFrom __typeOf iterable, length);
  for (value in iterable) {
    append(list, value);
  }
  return list;
}

WhateverList listCast#(WhateverList list, Integer type) __intrinsic {
  for (value in list) {
    if (!(value __dynamic_is__ type)) {
      throw('type error in list cast');
    }
  }
  return (list __dynamic_as__ type) as WhateverList;
}

//#ignore_unused
WhateverList filledList(Integer length, Whatever value) {
  AnythingList result = _listConstructor(__typeToCode AnythingList, length);
  Integer index = 0;
  while (index < length) {
    result[index] = value;
    index += 1;
  }
  return result;
}


// CONCAT

Integer _stringByteLength(String data) {
  Integer pointer = data __as__ Integer;
  return __readFromAddress(pointer + 8);
}

StringFunction _stringify; // defined later
String concat(Anything... arguments) {
  if (len(arguments) == 0) {
    return '';
  }
  if (len(arguments) == 1) {
    return _stringify(arguments[0]);
  }
  StringList strings = []:String;
  Integer length = 0;
  Integer index = 0;
  while (index < len(arguments)) {
    String segment = _stringify(arguments[index]);
    append(strings, segment);
    length += _stringByteLength(segment);
    index += 1;
  }
  assert(length >= 0, 'negative length detected');
  if (length >= 2147483648) {
    stderr('absurd length detected (as exit code)\n');
    exit(length);
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(strings)) {
    String segment = strings[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    index += 1;
  }
  return resultPointer __as__ String;
}


// CLASSES

// VMT structure
//
// integer giving type code for this class (-1 if the class is never constructed or type checked)
// integer giving number of fields to allocate (for construction)
// pointer to class name (to implement .className)
// pointer to parent vmt (to implement super.bar)
// pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
// for each member, we have these methods:
//   0. a setter implementation that takes one argument and return nothing
//      for properties, it just sets the right entry of the object
//      for methods, it throws
//   1. a getter implementation that takes no arguments and returns the member
//      for properties, it just fetches the right entry from the object
//      for methods, it creates and returns a method pointer
//   2. a function call implementation
//      for properties, it calls the getter, does type checks, and then invokes it with the arguments
//      for methods, it is the actual code for the method
//   they are stored in the vmt as follows:
//      <type code of member>
//      <code address to setter function>
//      <code address to getter function>
//      <code address to call function>

// member lookup table for dynamic dispatch list
// 32 bit zero
// 32 bit length number of entries
// for each entry (in increasing member name number order):
//   32 bit (high bits) offset into vmt that gives code address to getter function (i.e. address of pointer to code address - address of vmt)
//   32 bit (low bits) member name number

// Instances are GarbageCollectable blocks whose fields are the class fields in declaration order.

__Object _classAllocator(Integer vmt) __intrinsic {
  _gcLocked += 1;
  Integer typeCode = __readFromAddress(vmt + _vmtTypeCode);
  assert(typeCode >= 0, 'tried to construct class without a type code');
  Integer fieldCount = __readFromAddress(vmt + _vmtFieldCount);
  assert(fieldCount >= 2, 'unexpectedly small field count');
  __Object instance = _constructor(typeCode, fieldCount, fieldCount) as __Object;
  __writeToAddress(instance __as__ Integer + _fieldVmt, __typeToCode Integer);
  __writeToAddress(instance __as__ Integer + _fieldVmt + 8, vmt);
  __writeToAddress(instance __as__ Integer + _fieldClassName, __typeToCode String);
  __writeToAddress(instance __as__ Integer + _fieldClassName + 8, __readFromAddress(vmt + _vmtClassName));
  if (fieldCount > 2) {
    _fillQuadWords(instance __as__ Integer + _fieldsRemainder, (fieldCount - 2) * 16, 0);
  }
  _gcLocked -= 1;
  return instance;
}

class __Object __intrinsic {
  Integer vmt#; // must be field 0 to match constants above
  String className; // must be field 1 to match constants above
  String toString() {
    return concat('<', className, '>');
  }
  Null constructor() {}
}

// Code pointers are blocks with the following values:
//  1: pointer to object; null for global scope function pointers
//  2: pointer to closure; null for global scope function pointers
//  3: pointer to code (with annotation at -8 bytes) as an Integer

WhateverFunction _createMethodPointer(__Object receiver, __CodeAddress codePointer, Integer functionTypeCode) __intrinsic {
  _gcLocked += 1;
  WhateverFunction result = _constructor(functionTypeCode, 2, 2) as WhateverFunction;
  __writeToAddress(result __as__ Integer + _subroutineReceiverType, __typeOf receiver);
  __writeToAddress(result __as__ Integer + _subroutineReceiverPointer, receiver __as__ Integer);
  __writeToAddress(result __as__ Integer + _subroutineClosurePointer, 0);
  __writeToAddress(result __as__ Integer + _subroutineClosureType, 0);
  __writeToAddress(result __as__ Integer + _subroutineCodeType, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _subroutineCodePointer, codePointer __as__ Integer);
  _gcLocked -= 1;
  return result;
}

Whatever _WhateverFunctionPrototype() { }

Whatever _dynamicLookup(Anything receiver, Integer methodId) __intrinsic {
  if (receiver is __Object) {
    Integer vmt = (receiver as __Object).vmt#;
    Integer ddt = __readFromAddress(vmt + _vmtDynamicDispatchTable);
    // TODO: make this a binary search
    Integer cursor = ddt + 8;
    Integer end = ddt + 8 + __readFromAddress(ddt) * 8;
    while (cursor < end) {
      Integer entry = __readFromAddress(cursor);
      if ((entry & 0x00000000FFFFFFFF) == methodId) {
        WhateverFunction getter = _createMethodPointer(
          receiver as __Object,
          __readFromAddress(vmt + (entry >> 32)) __as__ __CodeAddress,
          __typeOf _WhateverFunctionPrototype,
        );
        return getter();
      }
      cursor += 8;
    }
    throw(concat('No member with specified name found on "', (receiver as __Object).className, '".'));
  }
  if (receiver is ReifiedEnum#) {
    Integer enumTable = receiver __as__ Integer;
    Integer length = __readFromAddress(enumTable + _enumTableLengthOffset);
    // TODO: make this a binary search
    Integer cursor = enumTable + _enumTableFirstEntryOffset;
    Integer end = enumTable + _enumTableFirstEntryOffset + length * 16;
    while (cursor < end) {
      Integer entry = __readFromAddress(cursor);
      if (entry == methodId) {
        return __readFromAddress(cursor + 8) __dynamic_as__ __readFromAddress(enumTable + _enumTableEntryTypeOffset);
      }
      cursor += 16;
    }
    throw(concat('No member with specified name found on "', __readFromAddress(enumTable + _enumTableNameOffset) __as__ String, '".'));
  }
  throw(concat('Cannot dynamic dispatch on ', receiver, '.'));
}


// I/O

Integer __getStdHandle(Integer handle) __extern 'kernel32.lib' 'GetStdHandle';
Integer __createFile(Integer lpFileName, Integer dwDesiredAccess, Integer dwShareMode, Integer lpSecurityAttributes, Integer dwCreationDisposition, Integer dwFlagsAndAttributes, Integer hTemplateFile) __extern 'kernel32.lib' 'CreateFileA';
// access mode
Integer __GENERIC_READ = 0x80000000;
Integer __GENERIC_WRITE = 0x40000000;
// share mode
Integer __FILE_SHARE_READ = 0x00000001;
Integer __FILE_SHARE_WRITE = 0x00000002;
// create mode
Integer __CREATE_NEW = 1; // create, fail if already exists
Integer __CREATE_ALWAYS = 2; // create or truncate
Integer __OPEN_EXISTING = 3; // open, fail if does not exist
Integer __OPEN_ALWAYS = 4; // open, create if does not exist
Integer __TRUNCATE_EXISTING = 5; // truncate, fail if does not exist

Boolean __getFileSize(Integer hFile, Integer lpFileSize) __extern 'kernel32.lib' 'GetFileSizeEx';
Boolean __readFile(Integer hFile, Integer lpBuffer, Integer nNumberOfBytesToRead, Integer lpNumberOfBytesRead, Integer lpOverlapped) __extern 'kernel32.lib' 'ReadFile';
Integer __writeFile(Integer hFile, Integer lpBuffer, Integer nNumberOfBytesToWrite, Integer lpNumberOfBytesWritten, Integer lpOverlapped) __extern 'kernel32.lib' 'WriteFile';
Integer __STD_OUTPUT_HANDLE = -11;
Integer __STD_ERROR_HANDLE = -12;
Integer _scratch = _alloc(8); // used as scratch space for out parameters of Win32 API functions

// createMode is one of the create mode constants defined above
Integer __openFile(String filename, Boolean enableRead, Boolean enableWrite, Integer createMode) {
  assert(enableRead || enableWrite, 'at least one of enableRead and enableWrite must be set');
  String filenameNullTerminated = concat(filename, '\0');
  Integer accessMode = 0x00;
  Integer shareMode = __FILE_SHARE_READ;
  if (enableRead) {
    accessMode |= __GENERIC_READ;
  }
  if (enableWrite) {
    accessMode |= __GENERIC_WRITE;
    shareMode = 0; // reset share mode to exclusive access
  }
  Integer result = __createFile(filenameNullTerminated __as__ Integer + 16, accessMode, shareMode, 0, createMode, 0x80 /* FILE_ATTRIBUTE_NORMAL */, 0);
  if (result == -1) {
    Integer rawError = __getLastError();
    String error = concat('error code: ', rawError);
    if (rawError == 2) {
      error = 'file not found';
    }
    if (rawError == 123) {
      error = 'file path invalid';
    }
    stderr(concat('failed to open file \'', filenameNullTerminated, '\', ', error));
    exit(1);
  }
  return result;
}

Integer __getFileSizeFromHandle(Integer hFile) {
  if (!__getFileSize(hFile, _scratch)) {
    stderr('failed to get file size, error code:', __getLastError());
    exit(1);
  }
  return __readFromAddress(_scratch);
}

String __readStringFromHandle(Integer handle, Integer bytesToRead) {
  Integer resultPointer = _alloc(16 + bytesToRead);
  __writeToAddress(resultPointer, 0); // ref count
  if (!__readFile(handle, resultPointer + 16, bytesToRead, _scratch, 0)) {
    stderr('failed to read file, error code:', __getLastError());
    exit(1);
  }
  __writeToAddress(resultPointer + 8, __readFromAddress(_scratch));
  // TODO: check that data is valid UTF-8, throw if not
  return resultPointer __as__ String;
}

Null __writeStringToHandle(Integer handle, String message) {
  __writeFile(handle, (message __as__ Integer) + 16, _stringByteLength(message), _scratch, 0);
}

String readFile(String filename) {
  Integer handle = __openFile(filename, true, false, __OPEN_EXISTING);
  Integer size = __getFileSizeFromHandle(handle);
  return __readStringFromHandle(handle, size);
}

Null print(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeStringToHandle(__getStdHandle(__STD_OUTPUT_HANDLE), ' ');
    }
    __writeStringToHandle(__getStdHandle(__STD_OUTPUT_HANDLE), _stringify(parts[index]));
    first = false;
    index += 1;
  }
}

Null println(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeStringToHandle(__getStdHandle(__STD_OUTPUT_HANDLE), ' ');
    }
    __writeStringToHandle(__getStdHandle(__STD_OUTPUT_HANDLE), _stringify(parts[index]));
    first = false;
    index += 1;
  }
  __writeStringToHandle(__getStdHandle(__STD_OUTPUT_HANDLE), '\n');
}

Null _stderr(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __writeStringToHandle(__getStdHandle(__STD_ERROR_HANDLE), ' ');
    }
    __writeStringToHandle(__getStdHandle(__STD_ERROR_HANDLE), _stringify(parts[index]));
    first = false;
    index += 1;
  }
  __writeStringToHandle(__getStdHandle(__STD_ERROR_HANDLE), '\n');
}
stderr = _stderr;

Null _error(Anything... arguments) __intrinsic {
  assert(len(arguments) >= 1, 'insufficient arguments to _error');
  stderr(arguments[0]);
  exit(1);
}


// STRING MANIPULATION

typedef# StringBuffer is GarbageCollectable;

class StringBufferPart# {
  String value;

  StringBufferPart#Nullable next = null;
  Null setNext(StringBufferPart# part) {
    next = part;
  }

  Null constructor(String valueArg) {
    value = valueArg;
  }
}

class StringBuffer# {
  Integer length = 0;

  StringBufferPart#Nullable first = null;
  StringBufferPart#Nullable last = null;
  Null add(StringBufferPart# part) {
    if (first == null) {
      assert(length == 0, 'invariant violation');
      first = part;
    } else {
      assert(length > 0, 'invariant violation');
      last!.setNext(part);
    }
    last = part;
    length += _stringByteLength(part.value);
  }
}

StringBuffer createStringBuffer() {
  StringBuffer# buffer = StringBuffer#();
  return buffer __as__ StringBuffer;
}

Null writeStringBuffer(StringBuffer buffer, String value) {
  if (value == '') {
    return;
  }
  StringBuffer# target = buffer __as__ StringBuffer#;
  target.add(StringBufferPart#(value));
}

String readStringBuffer(StringBuffer buffer) {
  StringBuffer# source = buffer __as__ StringBuffer#;
  if (source.first == null) {
    assert(source.length == 0, 'invariant violation');
    return '';
  }
  Integer resultPointer = _alloc(16 + source.length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, source.length);
  Integer cursor = resultPointer + 16;
  StringBufferPart#Nullable part = source.first!;
  while (part != null) {
    Integer segmentLength = _stringByteLength(part!.value);
    Integer segmentPointer = part!.value __as__ Integer;
    _moveBytes(segmentPointer + 16, cursor, segmentLength);
    part = part!.next;
    cursor += segmentLength;
  }
  return resultPointer __as__ String;
}

String _readStringBufferBackwards(StringBuffer buffer) {
  StringBuffer# source = buffer __as__ StringBuffer#;
  if (source.first == null) {
    assert(source.length == 0, 'invariant violation');
    return '';
  }
  Integer resultPointer = _alloc(16 + source.length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, source.length);
  Integer cursor = resultPointer + 16 + source.length;
  StringBufferPart#Nullable part = source.first!;
  while (part != null) {
    Integer segmentLength = _stringByteLength(part!.value);
    cursor -= segmentLength;
    Integer segmentPointer = part!.value __as__ Integer;
    _moveBytes(segmentPointer + 16, cursor, segmentLength);
    part = part!.next;
  }
  return resultPointer __as__ String;
}

String _digitToStr(Integer digit) {
  if (digit == 0) {
    return '0';
  }
  if (digit == 1) {
    return '1';
  }
  if (digit == 2) {
    return '2';
  }
  if (digit == 3) {
    return '3';
  }
  if (digit == 4) {
    return '4';
  }
  if (digit == 5) {
    return '5';
  }
  if (digit == 6) {
    return '6';
  }
  if (digit == 7) {
    return '7';
  }
  if (digit == 8) {
    return '8';
  }
  if (digit == 9) {
    return '9';
  }
  if (digit == 10) {
    return 'a';
  }
  if (digit == 11) {
    return 'b';
  }
  if (digit == 12) {
    return 'c';
  }
  if (digit == 13) {
    return 'd';
  }
  if (digit == 14) {
    return 'e';
  }
  if (digit == 15) {
    return 'f';
  }
  stderr('Invalid digit passed to _digitToStr (digit as exit code)');
  exit(digit);
}

//#ignore_unused
String intToStr(Integer value) {
  if (value >= 0 && value < 10) {
    return _digitToStr(value);
  }
  StringBuffer buffer = createStringBuffer();
  Integer newValue = value; // parameters are final
  if (newValue > 0) {
    newValue = -newValue;
  }
  while (newValue < 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    writeStringBuffer(buffer, _digitToStr(-digit));
  }
  if (value < 0) {
    writeStringBuffer(buffer, '-');
  }
  return _readStringBufferBackwards(buffer);
}

//#ignore_unused
String hex(Integer value) {
  if (value >= 0 && value < 16) {
    return _digitToStr(value);
  }
  StringBuffer buffer = createStringBuffer();
  Integer newValue = value; // parameters are final
  if (newValue > 0) {
    newValue = -newValue;
  }
  while (newValue < 0) {
    Integer digit = newValue % 16;
    newValue = newValue / 16;
    writeStringBuffer(buffer, _digitToStr(-digit));
  }
  if (value < 0) {
    writeStringBuffer(buffer, '-');
  }
  return _readStringBufferBackwards(buffer);
}

//#ignore_unused
String join(StringList items, String joiner) {
  if (len(items) == 0) {
    return '';
  }
  Integer length = 0;
  Integer index = 0;
  while (index < len(items)) {
    length += _stringByteLength(items[index]);
    index += 1;
  }
  Integer joinerLength = _stringByteLength(joiner);
  length += joinerLength * (len(items) - 1);
  assert(length >= 0, 'negative length detected');
  if (length >= 2147483648) {
    stderr('absurd length detected (as exit code)');
    exit(length);
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(items)) {
    String segment = items[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    if (index < len(items) - 1) {
      if (joinerLength > 0) {
        Integer joinerPointer = joiner __as__ Integer;
        _moveBytes(joinerPointer + 16, cursor, joinerLength);
        cursor += joinerLength;
      }
    }
    index += 1;
  }
  return resultPointer __as__ String;
}

String __stringify(Anything arg) {
  if (arg is String) {
    return arg as String;
  }
  if (arg is Boolean) {
    if (arg as Boolean) {
      return 'true';
    }
    return 'false';
  }
  if (arg is Null) {
    return 'null';
  }
  if (arg is Integer) {
    return intToStr(arg as Integer);
  }
  if (arg is __Object) {
    return (arg as __Object).toString();
  }
  if (arg is AnythingFunction) {
    Integer func = arg __as__ Integer;
    if (__readFromAddress(func + _subroutineReceiverPointer) != 0) {
      Integer annotation = __readFromAddress(__readFromAddress(func + _subroutineCodePointer) - 8);
      __Object class = (__readFromAddress(func + _subroutineReceiverPointer) __dynamic_as__ __readFromAddress(func + _subroutineReceiverType)) as __Object;
      return concat('<function (method ', class.className, '.', annotation __as__ String, ')>');
    }
    Integer annotation = __readFromAddress(__readFromAddress(func + _subroutineCodePointer) - 8);
    return concat('<function (', annotation __as__ String, ')>');
  }
  if (arg is StringList) {
    return concat('[', join(arg as StringList, ', '), ']');
  }
  if (arg is WhateverList) {
    StringList new = []:String;
    WhateverList old = arg as WhateverList;
    Integer i = 0;
    while (i < len(old)) {
      // TODO: beware infinite loops from cyclic references
      append(new, _stringify(old[i]));
      i += 1;
    }
    return concat('[', join(new, ', '), ']');
  }
  if (arg is StringBuffer) {
    return '<StringBuffer>';
  }
  if (arg is __ListData) {
    return '<__ListData>';
  }
  if (arg is ReifiedEnum#) {
    return __readFromAddress(arg __as__ Integer + _enumTableNameOffset) __as__ String;
  }
  if (arg is EnumProperty#) {
    return arg __as__ String;
  }
  stderr('value cannot be stringified:', __typeOf arg);
  exit(1);
}
_stringify = __stringify;

String chr(Integer code) {
  assert(code >= 0, 'invalid Unicode value');
  assert(code <= 0x10FFFF, 'invalid Unicode value');
  assert(code <= 255, 'Unicode unimplemented');
  Integer resultPointer = _alloc(16 + 1);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, 1); // length
  __writeToAddress(resultPointer + 16, code); // the character
  return resultPointer __as__ String;
}

// Returns the integer representation of the Unicode Scalar Values in a String
IntegerList scalarValues(String value) {
  // This should decode UTF-8.
  // For now we only support 8-bit character encodings.
  IntegerList result = []:Integer;
  Integer length = _stringByteLength(value);
  Integer cursor = value __as__ Integer + 16;
  assert(cursor % 8 == 0, 'string is misaligned');
  Integer end = cursor + length;
  while (cursor < end) {
    Integer code = __readFromAddress(cursor);
    Integer shift = 0;
    while (shift < 64 && cursor < end) {
      append(result, (code >> shift) & 0xFF);
      cursor += 1;
      shift += 8;
    }
  }
  return result;
}

// Returns the string representation of each extended grapheme cluster in a String
StringList charsOf(String value) {
  // This should use ICU's BreakIterator.
  // For now we just return the string representation of each Unicode Scalar Value since we only support 8-bit encodings anyway.
  StringList result = []:String;
  Integer length = _stringByteLength(value);
  Integer cursor = value __as__ Integer + 16;
  assert(cursor % 8 == 0, 'string is misaligned');
  Integer end = cursor + length;
  while (cursor < end) {
    Integer code = __readFromAddress(cursor);
    Integer shift = 0;
    while (shift < 64 && cursor < end) {
      append(result, chr((code >> shift) & 0xFF));
      cursor += 1;
      shift += 8;
    }
  }
  return result;
}


// ARITHMETIC

Integer pow#(Integer base, Integer exponent) __intrinsic {
  if (exponent == 0) {
    return 1;
  }
  if (base == 0 || base == 1 || exponent == 1) {
    return base;
  }
  if (exponent < 0) {
    throw('negative exponents not supported');
  }
  Integer index = exponent;
  Integer result = base;
  while (index > 1) {
    result *= base;
    index -= 1;
  }
  return result;
}


// STRING MANIPULATION

String substring(String string, Integer start, Integer end) {
  Integer stringPointer = string __as__ Integer;
  Integer stringLength = __readFromAddress(stringPointer + 8);
  if (start < 0) {
    throw('negative start index in substring');
  }
  if (end < 0) {
    throw('negative end index in substring');
  }
  if (end > stringLength) {
    throw('end index past end of string in substring');
  }
  if (start > end) {
    throw('start index past end index in substring');
  }
  Integer length = end - start;
  if (length == 0) {
    return '';
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  _moveBytes(stringPointer + 16 + start, resultPointer + 16, length);
  return resultPointer __as__ String;
}

Boolean substringMatch#(String string, String pattern, Integer index) {
  Integer stringPointer = string __as__ Integer;
  Integer stringLength = __readFromAddress(stringPointer + 8);
  Integer patternPointer = pattern __as__ Integer;
  Integer patternLength = __readFromAddress(patternPointer + 8);
  if (patternLength == 0) {
    return true;
  }
  if (patternLength > stringLength - index) {
    return false;
  }
  Integer cursor = index;
  Boolean match = true;
  Integer patternCursor = 0;
  while (patternCursor < patternLength) {
    Integer inputPart = __readFromAddress(stringPointer + 16 + cursor + patternCursor);
    Integer patternPart = __readFromAddress(patternPointer + 16 + patternCursor);
    if (patternLength - patternCursor < 8) {
      // the next character is the lowest byte on little-endian systems
      // on big-endian systems this would need to shift the other way
      Integer mask = _allBits >> ((8 - (patternLength - patternCursor)) * 8);
      inputPart &= mask;
      patternPart &= mask;
    }
    if (inputPart != patternPart) {
      return false;
    }
    patternCursor += 8;
  }
  return true;
}

Boolean containsString(String string, String pattern) {
  // TODO: use a more efficient algorithm
  Integer cursor = 0;
  Integer end = _stringByteLength(string) - _stringByteLength(pattern) + 1;
  while (cursor < end) {
    if (substringMatch#(string, pattern, cursor)) {
      return true;
    }
    cursor += 1;
  }
  return false;
}

//#ignore_unused
StringList split(String input, String pattern) {
  if (input == '') {
    return ['']:String;
  }
  if (pattern == '') {
    return copy(charsOf(input)) as StringList;
  }
  Integer length = _stringByteLength(input);
  Integer patternLength = _stringByteLength(pattern);
  StringList result = []:String;
  Integer start = 0;
  Integer index = 0;
  while (index < length) {
    if (substringMatch#(input, pattern, index)) {
      append(result, substring(input, start, index));
      index += patternLength;
      start = index;
    } else {
      index += 1;
    }
  }
  append(result, substring(input, start, index));
  return result;
}


// ARGUMENTS

Integer __getCommandLineW() __extern 'kernel32.lib' 'GetCommandLineW';
Integer __commandLineToArgvW(Integer lpCmdLine, Integer pNumArgs) __extern 'shell32.lib' 'CommandLineToArgvW';
Integer __localFree(Integer hMem) __extern 'kernel32.lib' 'LocalFree';
Integer __wideCharToMultiByte(
  Integer codePage,
  Integer dwFlags,
  Integer lpWideCharStr,
  Integer cchWideChar,
  Integer lpMultiByteStr,
  Integer cbMultiByte,
  Integer lpDefaultChar,
  Integer lpUsedDefaultChar
) __extern 'kernel32.lib' 'WideCharToMultiByte';
Integer __CP_UTF8 = 65001;

// buffer must be a pointer to a null-terminated UTF-16 string.
String _wideStringToString(Integer buffer) {
  assert(buffer != 0, 'invalid buffer');
  Integer newLength = __wideCharToMultiByte(__CP_UTF8, 0, buffer, -1 /* string is null terminated */, 0, 0 /* measure output buffer */, 0, 0);
  Integer resultPointer = _alloc(16 + newLength);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, newLength - 1);
  Integer conversionResult = __wideCharToMultiByte(__CP_UTF8, 0, buffer, -1 /* string is null terminated */, resultPointer + 16, newLength, 0, 0);
  if (conversionResult == 0) {
    stderr('failed Unicode conversion, error code:', __getLastError(), 'buffer=',buffer, 'resultPointer+16=', resultPointer + 16, 'newLength=', newLength);
    exit(1);
  }
  return resultPointer __as__ String;
}

StringList _getCommandLineArguments() {
  Integer arrayPointer = __commandLineToArgvW(__getCommandLineW(), _scratch);
  Integer count = __readFromAddress(_scratch) & 0x00000000FFFFFFFF; // return value is a 32 bit value, not 64 bit
  StringList result = []:String;
  Integer index = 0;
  while (index < count) {
    append(result, _wideStringToString(__readFromAddress(arrayPointer + index * 8)));
    index += 1;
  }
  __localFree(arrayPointer);
  return result;
}

StringList args = _getCommandLineArguments();