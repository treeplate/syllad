// TODO:
//  - implement __moveBytes(a, b, length): copy length bytes from a to b
//  - implement string ref counting

Integer _heapHandle = __getProcessHeap();

/// Allocates a block on the heap.
///
/// Block must be freed with [_free].
Integer _alloc(Integer size) {
  return __heapAlloc(_heapHandle, 0x00, size);
}

String _stringAllocLength(String data) {
  Integer pointer = data __as__ Integer;
  return __readFromAddress(pointer + 8);
}

/*
String concat(String... arguments) {
  Integer length = 0;
  Integer index = 0;
  while (index < len(arguments)) {
    length += stringAllocLength(arguments[index]);
    index += 1;
  }
  Integer resultPointer = __alloc(16 + length);
  __writeToAddress(resultPointer, 1); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = 16;
  index = 0;
  while (index < len(arguments)) {
    String segment = arguments[index];
    Integer segmentPointer = segment __as__ Integer;
    Integer segmentLength = stringAllocLength(segment);
    __moveBytes(cursor, segmentPointer + 8, segmentLength);
    cursor += segmentLength;
    index += 1;
  }
  return resultPointer __as__ String;
}

String digitToStr(Integer digit) {
  if (digit == 1) {
    return '1';
  }
  if (digit == 2) {
    return '2';
  }
  if (digit == 3) {
    return '3';
  }
  if (digit == 4) {
    return '4';
  }
  if (digit == 5) {
    return '5';
  }
  if (digit == 6) {
    return '6';
  }
  if (digit == 7) {
    return '7';
  }
  if (digit == 8) {
    return '8';
  }
  if (digit == 9) {
    return '9';
  }
  print("Invalid digit passed to digitToStr\n");
  exit(1);
}

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  String buffer = ''; 
  Integer newValue = value; // parameters are final
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    buffer = concat(digitToStr(digit), buffer);
  }
  return buffer;
}
*/

String _stringify(Anything arg) {
  if (arg is String) {
    return arg;
  }
  if (arg is Boolean) {
    if (arg) {
      return 'true';
    }
    return 'false';
  }
  if (arg is Null) {
    return 'null';
  }
  //if (arg is Integer) {
  //  return intToStr(arg as Integer);
  //}
  __print('value cannot be stringified\n');
  exit(1);
}

Null print(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
}

Null println(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
  __print('\n');
}

/// Frees a heap allocation obtained from [_alloc].
///
/// Return true if successful.
///
/// If false, use [_getLastError] (not yet implemented) to find error code.
Boolean _free(Integer pointer) {
  if (__heapFree(_heapHandle, 0x00, pointer) == 0) {
    println('failed to free pointer, error code: ', __getLastError());
    exit(1);
  }
  return true;
}