// ERROR MANAGEMENT

NullFunction println;

// TODO: this should be a compiler intrinsic so that the message evaluation can be lazy and so it can be skipped in release builds
Null assert(Boolean condition, String message) {
  if (!condition) {
    println(message);
    exit(1);
  }
}

Null throw(String message) {
  println(message);
  exit(1);
}

Integer __getLastError() __extern 'kernel32.lib' 'GetLastError';


// HEAP MANAGEMENT

Integer __getProcessHeap() __extern 'kernel32.lib' 'GetProcessHeap';

Integer _heapHandle = __getProcessHeap();

Integer __heapAlloc(Integer hHeap, Integer dwFlags, Integer dwBytes) __extern 'kernel32.lib' 'HeapAlloc';

Integer _blockCount = 0;

NullFunction _garbageCollector;

/// Allocates a block on the heap.
///
/// Block must be freed with [_free].
Integer _alloc(Integer size) {
  Integer pointer = __heapAlloc(_heapHandle, 0x00, size);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  _garbageCollector();
  pointer = __heapAlloc(_heapHandle, 0x00, size);
  if (pointer > 0) {
    _blockCount += 1;
    return pointer;
  }
  println('Out of memory.');
  exit(1);
}

// returns positive for success, zero for failure
Integer __heapFree(Integer hHeap, Integer dwFlags, Integer lpMem) __extern 'kernel32.lib' 'HeapFree';

/// Frees a heap allocation obtained from [_alloc].
Null _free(Integer pointer) __intrinsic {
  _blockCount -= 1;
  if (__heapFree(_heapHandle, 0x00, pointer) == 0) {
    println('failed to free pointer, error code: ', __getLastError());
    exit(1);
  }
}

Null _moveBytes(Integer from, Integer to, Integer length) {
  // TODO: move this to inlined assembler (using the string-copy instructions) for performance
  // (or optimize the compiler enough that it generates good code somehow!)
  assert(length > 0, '_moveBytes expects positive number of bytes to copy');
  Integer fromCursor = from;
  Integer toCursor = to;
  Integer end = from + (length / 8) * 8;
  // TODO: implement || (then uncomment these asserts)
  // assert(fromCursor != end || length < 8, 'inconsistency');
  // assert(fromCursor != end || length > 0, 'inconsistency');
  while (fromCursor < end) {
    Integer value = __readFromAddress(fromCursor);
    __writeToAddress(toCursor, value);
    fromCursor += 8;
    toCursor += 8;
  }
  end = from + length;
  // assert((fromCursor < end) || (from < fromCursor), 'no moves on either side');
  if (fromCursor < end) {
    Integer newValue = __readFromAddress(fromCursor);
    Integer oldValue = __readFromAddress(toCursor);
    Integer extraBytes = end - fromCursor;
    assert(extraBytes > 0, 'internal error: zero extra bytes but fromCursor is before end');
    assert(extraBytes < 8, 'internal error: more than 7 extra bytes');
    Integer mask = 0xFFFFFFFFFFFFFFFF << (extraBytes * 8);
    Integer finalValue = (newValue & ~mask) | (oldValue & mask);
    __writeToAddress(toCursor, finalValue);
  }
}

Null _fillQuadWords(Integer destination, Integer length, Integer value) {
  // TODO: is there an x64 intrinsic that does this faster?
  assert(length > 0, '_fillQuadWords expects positive number of bytes to fill');
  assert(length % 8 == 0, '_fillQuadWords expects number of bytes to fill to be a multiple of 8');
  Integer cursor = destination;
  Integer end = destination + length;
  while (cursor < end) {
    __writeToAddress(cursor, value);
    cursor += 8;
  }
}


// GARBAGE COLLECTION

// Allocated blocks that participate in garbage collection are a subtype of GarbageCollectable.
// We have a list for every allocated GarbageCollectable block (list starts at _blockListStart).
// Each allocated GarbageCollectable block has the same header (each line is 64 bits):
//
//   ref count (number of known references from stack)
//   length N
//   scratch space (used by GC, can otherwise be ignored)
//   block entry (pointer into block list, minus _blockListStart)
//
// After this there are N type/value pairs (64 bit type codes, 64 bit values) which the garbage
// collector can walk to find all references.

Integer _gcLocked = 0; // when non-zero, GC cannot happen
Integer _blockListStart; // start of allocation list
Integer _blockListEnd; // end of allocation list
Integer _blockListNext; // next allocation entry
Integer _debugLiveBlocks = 0;

Integer _blockEntrySize = 8;
Integer _gcBlockHeaderRefCount = 0 * 8;
Integer _gcBlockHeaderLength = 1 * 8;
Integer _gcBlockHeaderScratchSpace = 2 * 8;
Integer _gcBlockHeaderEntryPointer = 3 * 8;
Integer _gcBlockData = 4 * 8;

Null _blockListInit(Integer initialCount) {
  _gcLocked += 1;
  Integer initialSize = initialCount * _blockEntrySize;
  _blockListStart = _alloc(initialSize);
  _blockListEnd = _blockListStart + initialSize;
  _blockListNext = _blockListStart;
  _fillQuadWords(_blockListStart, initialSize, 0);
  _gcLocked -= 1;
}

_blockListInit(1024);

Null _growBlockList() {
  assert(_gcLocked > 0, '_growBlockList called without _gcLocked set');
  Integer oldLength = _blockListEnd - _blockListStart;
  Integer newLength = oldLength * 2;
  Integer newBlock = _alloc(newLength); // TODO: use realloc instead
  _moveBytes(_blockListStart, newBlock, oldLength);
  _fillQuadWords(newBlock + oldLength, oldLength, 0);
  _free(_blockListStart);
  _blockListStart = newBlock;
  _blockListNext = newBlock + oldLength;
  _blockListEnd = newBlock + newLength;
}

Null _advanceToNextBlock() {
  assert(_gcLocked > 0, '_advanceToNextBlock called without _gcLocked set');
  Integer last = _blockListNext;
  while (true) {
    _blockListNext += _blockEntrySize;
    if (_blockListNext == last) {
      // looped all the way around, need to grow the list
      _growBlockList();
      return;
    }
    if (_blockListNext == _blockListEnd) {
      _blockListNext = _blockListStart;
    }
    Integer pointer = __readFromAddress(_blockListNext);
    if (pointer == 0) {
      // found a free slot
      return;
    }
  }
}

GarbageCollectable _constructor(Integer typeCode, Integer length, Integer size) {
  assert(_gcLocked > 0, '_constructor called without _gcLocked set');
  assert(size >= length, 'length cannot be bigger than size');
  Integer resultPointer = _alloc(64 + 16 * size);
  __writeToAddress(resultPointer + _gcBlockHeaderRefCount, 0); // ref count
  __writeToAddress(resultPointer + _gcBlockHeaderLength, length); // length
  __writeToAddress(resultPointer + _gcBlockHeaderScratchSpace, 0); // scratch space
  __writeToAddress(resultPointer + _gcBlockHeaderEntryPointer, _blockListNext - _blockListStart); // block pointer
  __writeToAddress(_blockListNext, resultPointer);
  _advanceToNextBlock();
  _debugLiveBlocks += 1;
  return resultPointer __dynamic_as__ typeCode;
}

Null _mark(Integer pointer, Integer tag) {
  Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
  if (blockScratchSpace == tag) {
    return;
  }
  __writeToAddress(pointer + _gcBlockHeaderScratchSpace, tag);
  Integer blockLength = __readFromAddress(pointer + _gcBlockHeaderLength);
  Integer cursor = pointer + _gcBlockData;
  Integer end = cursor + blockLength * 16;
  while (cursor < end) {
    Whatever value = __readFromAddress(cursor + 8) __dynamic_as__ __readFromAddress(cursor + 0);
    if (value is GarbageCollectable) {
      _mark(value __as__ Integer, tag);
    }
    cursor += 16;
  }
}

Integer _currentTag = 0;

Null _garbageCollectorImplementation() {
  if (_gcLocked > 0) {
    return;
  }
  _gcLocked += 1;
  _currentTag += 1;
  Integer cursor = _blockListStart;
  while (cursor < _blockListEnd) {
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockRefCount = __readFromAddress(pointer + _gcBlockHeaderRefCount);
      assert(blockRefCount >= 0, 'Reference count underflow.');
      if (blockRefCount != 0) {
        _mark(pointer, _currentTag);
      }
    }
    cursor += _blockEntrySize;
  }
  while (cursor > _blockListStart) {
    cursor -= _blockEntrySize;
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer blockScratchSpace = __readFromAddress(pointer + _gcBlockHeaderScratchSpace);
      if (blockScratchSpace != _currentTag) {
        // destructor:
        _free(pointer);
        __writeToAddress(cursor, 0);
        _debugLiveBlocks -= 1;
      }
    }
  }
  _gcLocked -= 1;
}
_garbageCollector = _garbageCollectorImplementation;


// LISTS

// Lists are represented as pointers to an intermediary block that itself contains a pointer to
// the data. Both are GarbageCollectable blocks as described above.
//
// The list intermediary has length two.
// The first value is size (type Integer), the number of allocated entries in the list data.
// This may be bigger than the length, to allow cheaper appends.
// The second value is a pointer to the data block (type __ListData).
//
// The list data just has the values.

WhateverList _listConstructor(Integer typeCode, Integer initialSize) __intrinsic {
  _gcLocked += 1;
  WhateverList list = _constructor(typeCode, 2, 2) as WhateverList;
  __ListData data = _constructor(__typeToCode __ListData, 0, initialSize) as __ListData;
  __writeToAddress(list __as__ Integer + _gcBlockData + 0, __typeOf initialSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, initialSize __as__ Integer);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16, __typeOf data);
  __writeToAddress(list __as__ Integer + _gcBlockData + 24, data __as__ Integer);
  _gcLocked -= 1;
  return list;
}

Null _growList(WhateverList list) {
  _gcLocked += 1;
  Integer newSize = len(list) * 2;
  __ListData newData = _constructor(__typeToCode __ListData, len(list), newSize) as __ListData;
  __ListData oldData = __readFromAddress(list __as__ Integer + _gcBlockData + 16 + 8) __as__ __ListData;
  _moveBytes(oldData __as__ Integer + _gcBlockData, newData __as__ Integer + _gcBlockData, len(list) * 16);
  __writeToAddress(list __as__ Integer + _gcBlockData + 8, newSize);
  __writeToAddress(list __as__ Integer + _gcBlockData + 16 + 8, newData __as__ Integer);
  _gcLocked -= 1;
}

Null append(WhateverList list, Anything element) __intrinsic {
  _gcLocked += 1;
  Integer intermediaryAddress = list __as__ Integer;
  Integer size = __readFromAddress(intermediaryAddress + _gcBlockData + 0 + 8);
  Integer dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  Integer length = len(list);
  if (length == size) {
    _growList(list);
    dataAddress = __readFromAddress(intermediaryAddress + _gcBlockData + 16 + 8);
  }
  __writeToAddress(dataAddress + _gcBlockData + length * 16, __typeOf element);
  __writeToAddress(dataAddress + _gcBlockData + length * 16 + 8, element __as__ Integer);
  __writeToAddress(dataAddress + _gcBlockHeaderLength, length + 1);
  __incref(element);
  _gcLocked -= 1;
}


// ITERABLES AND ITERATORS

// Iterators are blocks with the following values:
//  1: pointer to iterable
//  2: cursor (semantics vary based on the iterable)

// Iterables are currently just lists. This will have to change when we implement scalarValues.

// returns value at cursor of iterator
// it is a fatal error to call current when the cursor
// points before the beginning or after the end of the iterable
// (i.e. if next() has not been called or has returned false)
Whatever current(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  return list[index];
}

// advances cursor of iterator by one
// return true if cursor is before end of iterable; current returns value at cursor
// return false if cursor is after end of iterable
Boolean next(WhateverIterator iteratorArg) __intrinsic {
  WhateverList list = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 8) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 0)) as WhateverList;
  Integer index = (__readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 24) __dynamic_as__ __readFromAddress(iteratorArg __as__ Integer + _gcBlockData + 16)) as Integer;
  index += 1;
  __writeToAddress(iteratorArg __as__ Integer + _gcBlockData + 24, index);
  return index < len(list);
}

// creates an iterator for the iterable
WhateverIterator iterator(WhateverIterable iterable) __intrinsic {
  assert(iterable is WhateverList, 'iterables are only implemented for lists');
  _gcLocked += 1;
  WhateverIterator result = _constructor(__iteratorTypeOf __typeOf iterable, 2, 2) as WhateverIterator;
  __writeToAddress(result __as__ Integer + _gcBlockData + 0, __typeOf iterable);
  __writeToAddress(result __as__ Integer + _gcBlockData + 8, iterable __as__ Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 16, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 24, -1);
  _gcLocked -= 1;
  return result;
}

WhateverList copy(WhateverIterable iterable) {
  Integer length;
  if (iterable is WhateverList) {
    length = len(iterable as WhateverList);
  } else {
    length = 1;
  }
  WhateverList list = _listConstructor(__listTypeOf __typeOf iterable, length);
  for (value in iterable) {
    append(list, value);
  }
  return list;
}

Whatever first(WhateverIterable iterable) {
  WhateverIterator i = iterator(iterable);
  next(i);
  return current(i);
}

Whatever last(WhateverIterable iterable) {
  if (iterable is WhateverList) {
    return (iterable as WhateverList)[len(iterable as WhateverList) - 1];
  }
  Whatever result;
  for (value in iterable) {
    result = value;
  }
  return result;
}

Whatever single(WhateverIterable iterable) {
  WhateverIterator i = iterator(iterable);
  next(i);
  Whatever result = current(i);
  if (next(i)) {
    __print('single() called with Iterable with more than one element\n');
    exit(1);
  }
  return result;
}


// FUNCTION POINTERS, METHOD POINTERS, CLOSURES

// Code pointers are blocks with the following values:
//  1: pointer to object or closure; null for global scope function pointers
//  2: pointer to code (with annotation at -8 bytes) as an Integer

WhateverFunction _createMethodPointer(Anything receiver, Integer codePointer, Integer functionTypeCode) __intrinsic {
  _gcLocked += 1;
  WhateverFunction result = _constructor(functionTypeCode, 2, 2) as WhateverFunction;
  __writeToAddress(result __as__ Integer + _gcBlockData + 0, __typeOf receiver);
  __writeToAddress(result __as__ Integer + _gcBlockData + 8, receiver __as__ Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 16, __typeToCode Integer);
  __writeToAddress(result __as__ Integer + _gcBlockData + 24, codePointer);
  _gcLocked -= 1;
  return result;
}





// STRINGS AND PRINTING

Integer _stringByteLength(String data) {
  Integer pointer = data __as__ Integer;
  return __readFromAddress(pointer + 8);
}

String concat(String... arguments) {
  Integer length = 0;
  Integer index = 0;
  while (index < len(arguments)) {
    length += _stringByteLength(arguments[index]);
    index += 1;
  }
  assert(length >= 0, 'negative length detected');
  if (length >= 2147483648) {
    __print('absurd length detected (as exit code)\n');
    exit(length);
  }
  Integer resultPointer = _alloc(16 + length);
  __writeToAddress(resultPointer, 0); // ref count
  __writeToAddress(resultPointer + 8, length);
  Integer cursor = resultPointer + 16;
  index = 0;
  while (index < len(arguments)) {
    String segment = arguments[index];
    Integer segmentLength = _stringByteLength(segment);
    if (segmentLength > 0) {
      Integer segmentPointer = segment __as__ Integer;
      _moveBytes(segmentPointer + 16, cursor, segmentLength);
      cursor += segmentLength;
    }
    index += 1;
  }
  return resultPointer __as__ String;
}

String digitToStr(Integer digit) {
  if (digit == 0) {
    return '0';
  }
  if (digit == 1) {
    return '1';
  }
  if (digit == 2) {
    return '2';
  }
  if (digit == 3) {
    return '3';
  }
  if (digit == 4) {
    return '4';
  }
  if (digit == 5) {
    return '5';
  }
  if (digit == 6) {
    return '6';
  }
  if (digit == 7) {
    return '7';
  }
  if (digit == 8) {
    return '8';
  }
  if (digit == 9) {
    return '9';
  }
  __print('Invalid digit passed to digitToStr (digit as exit code)\n');
  exit(digit);
}

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  if (value < 0) {
    return concat('-', intToStr(-value));
  }
  String buffer = ''; 
  Integer newValue = value; // parameters are final
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    buffer = concat(digitToStr(digit), buffer);
  }
  return buffer;
}

String _joinOffset(StringList items, String joiner, Integer offset) {
  if (len(items) - offset == 1) {
    return items[offset];
  }
  return concat(items[offset], joiner, _joinOffset(items, joiner, offset + 1));
}

String join(StringList items, String joiner) {
  if (len(items) == 0) {
    return '';
  }
  // TODO: this should allocate the string ahead of time and just write each string in turn into the buffer
  return _joinOffset(items, joiner, 0);
}

String _stringify(Anything arg) {
  if (arg is String) {
    return arg;
  }
  if (arg is Boolean) {
    if (arg) {
      return 'true';
    }
    return 'false';
  }
  if (arg is Null) {
    return 'null';
  }
  if (arg is Integer) {
    return intToStr(arg as Integer);
  }
  if (arg is AnythingFunction) {
    Integer func = arg __as__ Integer;
    Integer annotation = __readFromAddress(func - 8);
    return concat('<function (', annotation __as__ String, ')>');
  }
  if (arg is StringList) {
    return concat('[', join(arg as StringList, ', '), ']');
  }
  if (arg is WhateverList) {
    StringList new = []:String;
    WhateverList old = arg as WhateverList;
    Integer i = 0;
    while (i < len(old)) {
      // TODO: beware infinite loops from cyclic references
      append(new, _stringify(old[i]));
      i += 1;
    }
    return concat('[', join(new, ', '), ']');
  }
  if (arg is __ListData) {
    return '<__ListData>';
  }
  __print('value cannot be stringified\n');
  exit(1);
}

Null print(Anything... parts) { 
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
}

Null _println(Anything... parts) {
  Boolean first = true;
  Integer index = 0;
  while (index < len(parts)) {
    if (first == false) {
      __print(' ');
    }
    __print(_stringify(parts[index]));
    first = false;
    index += 1;
  }
  __print('\n');
}
println = _println;


// STANDARD LIBRARY

String chr(Integer character) {
  // TODO: implement this
  __print('chr is not implemented\n');
  exit(1);
}

String _joinListOffset(StringList args, Integer offset) {
  if (len(args) - offset == 0) {
    return '';
  }
  if (len(args) - offset == 1) {
    return args[offset];
  }
  return concat(args[offset], _joinListOffset(args, offset+1));
}

String joinList(StringList args) {
  // TODO: this should allocate the buffer ahead of time and copy each list into the buffer
  return _joinListOffset(args, 0);
}

String stringTimes(String str, Integer count) {
  // TODO: implement this
  __print('stringTimes is not implemented\n');
  exit(1);
}

StringList charsOf(String str) {
  // TODO: implement this
  __print('charsOf is not implemented\n');
  exit(1);
}

StringList scalarValues(String str) {
  // TODO: implement this
  __print('scalarValues is not implemented\n');
  exit(1);
}

String hex(Integer num) {
  // TODO: implement this
  __print('hex is not implemented\n');
  exit(1);
}

String readFile(String file) {
  // TODO: implement this
  __print('readFile is not implemented\n');
  exit(1);
}

Null stderr(String str) {
  // TODO: implement this
  __print('stderr is not implemented\n');
  exit(1);
}

/* TODO: depends on charsOf, stringTimes, lists...
String padLeft(String line, Integer length, String padding) {
  return concat(stringTimes(padding, (length - len(charsOf(line))) / len(charsOf(padding))), line);
}
*/

Null _debugDescribeBlock(Integer pointer, String indent) {
  Integer blockLength = __readFromAddress(pointer + _gcBlockHeaderLength);
  Integer cursor = pointer + _gcBlockData;
  Integer end = cursor + blockLength * 16;
  Integer index = 0;
  while (cursor < end) {
    Whatever value = __readFromAddress(cursor + 8) __dynamic_as__ __readFromAddress(cursor + 0);
    if (value is GarbageCollectable) {
      Integer fieldPointer = value __as__ Integer;
      Integer refcount = __readFromAddress(fieldPointer + _gcBlockHeaderRefCount);
      Integer length = __readFromAddress(fieldPointer + _gcBlockHeaderLength);
      Integer entry = __readFromAddress((fieldPointer + _gcBlockHeaderEntryPointer)) / 8;
      println(concat(indent, _stringify(index), '. type ', _stringify(__typeOf value), ': block #', _stringify(entry), ' (', _stringify(length), ' fields, referenced from ', _stringify(refcount), ' roots)'));
      _debugDescribeBlock(fieldPointer, concat(indent, '  '));
    } else {
      println(concat(indent, _stringify(index), '. type ', _stringify(__typeOf value), ': ', _stringify(value)));
    }
    cursor += 16;
    index += 1;
  }
}

Null _debugDumpBlockList() {
  _gcLocked += 1;
  println(concat('Block list (', _stringify(_debugLiveBlocks), ' out of ', _stringify((_blockListEnd - _blockListStart) / 8), ' live blocks):'));
  Integer index = 0;
  Integer cursor = _blockListStart;
  while (cursor < _blockListEnd) {
    Integer pointer = __readFromAddress(cursor);
    if (pointer != 0) {
      Integer refcount = __readFromAddress(pointer + _gcBlockHeaderRefCount);
      Integer length = __readFromAddress(pointer + _gcBlockHeaderLength);
      println(concat('  #', _stringify(index), ': ', _stringify(length), ' fields, referenced from ', _stringify(refcount), ' roots'));
      _debugDescribeBlock(pointer, '    ');
    }
    cursor += _blockEntrySize;
    index += 1;
  }
  _gcLocked -= 1;
}