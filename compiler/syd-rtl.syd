// RUNTIME LIBRARY
// Code in this file defines and uses compiler intrinsics.

// Naming conventions
// foo - publicly accessible Syd API (implemented in the RTL or the compiler)
// foo# - compiler-internal API (implemented in the RTL or the compiler)
// _foo - compiler-specific publicly accessible API (implemented in the RTL)
// __foo - compiler-specific unary operator, keyword, or function (implemented in the compiler)
// __foo__ - compiler-specific binary operator (implemented in the compiler)

// TODO: complain if a function is intrinsic# and we don't know about it

import 'syd-constants.syd';
import 'syd-rtl-memory.syd';
import 'syd-rtl-types.syd';
import 'syd-rtl-strings.syd';
import 'syd-rtl-arguments.syd';
import 'syd-rtl-io.syd';
import 'syd-rtl-system.syd';


// EQUALITY

Boolean equals#(Anything a, Anything b) intrinsic# {
  // This only gets called if the compiler thinks a and b might be both strings or both function pointers.
  // See EqualityInstruction.
  if (a is String && b is String) {
    Integer lengthA = __readFromAddress(a __as__ Integer + _gcBlockHeaderLength);
    Integer lengthB = __readFromAddress(b __as__ Integer + _gcBlockHeaderLength);
    if (lengthA != lengthB) {
      return false;
    }
    return __byteCompare(a __as__ Integer + _gcBlockStringData, b __as__ Integer + _gcBlockStringData, lengthA);
  }
  if (a is WhateverFunction && b is WhateverFunction) {
    return (__readFromAddress(a __as__ Integer + _subroutineReceiverPointer) == __readFromAddress(b __as__ Integer + _subroutineReceiverPointer))
        && (__readFromAddress(a __as__ Integer + _subroutineClosurePointer) == __readFromAddress(b __as__ Integer + _subroutineClosurePointer))
        && (__readFromAddress(a __as__ Integer + _subroutineCodePointer) == __readFromAddress(b __as__ Integer + _subroutineCodePointer));
  }
  return false;
}


// ARITHMETIC

Integer pow#(Integer base, Integer exponent) intrinsic# {
  if (exponent == 0) {
    return 1;
  }
  if (base == 0 || base == 1 || exponent == 1) {
    return base;
  }
  if (exponent < 0) {
    throw('negative exponents not supported');
  }
  Integer index = exponent;
  Integer result = base;
  while (index > 1) {
    result *= base;
    index -= 1;
  }
  return result;
}