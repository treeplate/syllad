
// TODO: add a test for [1]:String

import 'syd-tokenizer.syd';
import 'syd-assembler.syd';
import 'syd-x64-instructions.syd';
import 'syd-parser.syd';
import 'syd-ast.syd';
import 'syd-compiler.syd';

stderr('syllad self-hosting compiler');
// syllad spec:
// some built-in functions
// while loop
// for-in loops
// classical if-else
// classical variables, but with no 'var' or 'final'
// enums (enum X {a b c}  ...  X state = Xa; ... state = Xb;   if(state == Xa) { ... })
// values are functions or true or false or null or int literal or list literal (e.g. [1, 2]) or string literal ('' or "", newlines ok, single-character escapes)
// types, or <t>, are:
// Anything, Integer, String, Boolean, <t>List, <t>Iterable, <t>Iterator, Null, <t> (enums/classes)
// operators: [], <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, <<

// WISHLIST
// P1 (blocking progress):
//   methods can't refer to themselves on child instances, e.g.:
//     class Node {
//       String label;
//       NodeList children;
//       Null walk() {
//         println(label);
//         for (child in children) {
//           child.walk(); // compiler fails here, even though Node.walk is defined already
//         }
//       }
//       Null constructor(String labelArg, NodeList childrenArg) {
//         label = labelArg;
//         children = childrenArg;
//       }
//     }
//     Node('a', [Node('b', [])]).walk();
//   simpler example with probably same cause: class A { Null test() { this.test(); } }
//   language changes that I think have been announced but not yet implemented:
//     - type declarations leak out of blocks (e.g. "if (true) { enum X { a } } X a;" does not fail)
// P3 (nice-to-haves for which i've found workarounds):
//   performance
//   soundness in type system -- a variable being of type X should be a guarantee that it will have a value of type X
//     - returns are "not really type safe"
//     - functions without returns aren't statically checked
//     - toString returning non-string isn't checked for either
//   function types with signatures
//   string interpolation
//   new features in classes: abstract classes and methods
//   utf8 decoder (so that i can get scalarValues out of readFileBytes)
//   functions to have named arguments with default values
//   some way to call syscalls / OS functions
//   switch (especially if the compiler can report missing enum values)
//   no way to catch exceptions
//   try-finally
//   detailed language reference
//   [] could have its type inferred from context

CompiledLibrary processFile(String filename, CompilationEnvironment compilationEnvironment, Boolean isProgram) {
  assert(compilationEnvironment.getLibraryState(filename) == ls.Unknown, 'processFile has already processed this file');
  Library ast = parseTokens(tokenize(scalarValues(readFile(filename)), filename, false), filename, isProgram);
  compilationEnvironment.declareLibrary(filename);
  for (child in ast.children) {
    if (child is ImportStatement) {
      ls childLibraryState = compilationEnvironment.getLibraryState(cast(cast(child).path));
      if (childLibraryState == ls.Declared) {
        throw(concat('Import loop at ', child.sourceLocation));
      } else if (childLibraryState == ls.Unknown) {
        String libraryPath = cast(cast(child).path); // TODO: handle relative paths correctly
        compilationEnvironment.defineLibrary(libraryPath, processFile(libraryPath, compilationEnvironment, false));
      }
    } else {
      break;
    }
  }
  stderr(concat('compiling "', filename, '"...'));
  return ast.generateScopes(compilationEnvironment);
}

assert(len(args) > 0, 'no input file specified');
String mainProgramFileName = args[0];
CompilationEnvironment compilationEnvironment = CompilationEnvironment();
compilationEnvironment.setRuntimeLibrary(
  parseTokens(tokenize(scalarValues(readFile('syd-rtl.syd')), 'runtime library', true), 'runtime library', false).generateScopes(compilationEnvironment)
);
CompiledLibrary program = processFile(mainProgramFileName, compilationEnvironment, true); // this generates the root Program AST node
compilationEnvironment.defineLibrary(mainProgramFileName, program);
Assembler assembler = X64Assembler(compilationEnvironment.rootLabel);
compilationEnvironment.compile(assembler);
stderr('Compilation finished!');
stderr('Result:');
println(assembler.serialize());
