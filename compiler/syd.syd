// TODO
// - something that runs each test in turn (and matches expectation)
// - static type checking ("xxxx")
// - put initialized globals into .data section
// - heap allocation
//    - import GetProcessHeap, HeapAlloc, HeapFree from kernel32
// - string ref counting
// - lists, garbage collection
// - autoimport rtl
// - vararg internal rtl functions
// - concat for strings, joinList for StringLists
// - stringification
// - implement the real "println"

//class A { Null test() { this.test(); } }
//Integer bar = 1; class Foo { Null constructor() { } } println(Foo().bar);

import 'syd-tokenizer.syd';
import 'syd-ast.syd';
import 'syd-parser.syd';
import 'syd-compiler.syd';
import 'syd-assembler.syd';

stderr('syllad self-hosting compiler');
// syllad spec:
// functions 'print', 'charsOf',
// 'addLists', 'parseInt',
// 'concat', 'len', 'input',
// 'iterator', 'next', 'current',
// 'append', 'stringTimes'
// 'first', 'last', 'single'
// 'copy', 'scalarValues',
// 'assert', 'exit',
// 'readFile', 'readFileBytes',
// 'println', 'throw', 'hex',
// 'chr', 'cast'
// 'padLeft', 'joinList'
// while loop
// for-in loops
// classical if-else
// classical variables, but with no 'var' or 'final' or 'const'
// enums (enum X {a b c}  ...  X state = Xa; ... state = Xb;   if(state == Xa) { ... })
// values are functions or true or false or null or int literal or list literal (e.g. [1, 2]) or string literal ('' or "", newlines ok, single-character escapes)
// types, or <t>, are:
// Anything, Integer, String, Boolean, <t>List, <t>Iterable, <t>Iterator, Null, <t> (enums)
// operators: [], <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, <<

// WISHLIST
// P1 (blocking progress):
//   methods can't refer to themselves on child instances, e.g.:
//     class Node {
//       String label;
//       NodeList children;
//       Null walk() {
//         println(label);
//         for (child in children) {
//           child.walk(); // compiler fails here, even though Node.walk is defined already
//         }
//       }
//       Null constructor(String labelArg, NodeList childrenArg) {
//         label = labelArg;
//         children = childrenArg;
//       }
//     }
//     Node('a', [Node('b', [])]).walk();
//   simpler example with probably same cause: class A { Null test() { this.test(); } }
//   no forward class declarations means you can't have classes that deal with their subclasses
//   the language requires gc:
//     - closures can leak out of their stack frame:
//       AnythingFunction makeLoop() {
//         AnythingFunction myself;
//         Anything logic(AnythingFunction what) {
//           myself = what;
//           return myself == logic;
//         }
//         return logic;
//       }
//       AnythingFunction f = makeLoop();
//       println(f(f));
//     - objects can reference each other, but there's no way to dispose of an object
//     - lists are reference types (not copy-on-write value types) and one can form reference loops, but there's no way to dispose of a list
//   language changes that I think have been announced but not yet implemented:
//     - imperative statements being allowed in class declarations (so classes are really functions) is
//     - blocks don't actually introduce scopes for variables (e.g. "Integer y = 0; if (true) { String y = 'bad'; } println(y);" prints "bad")
//     - type declarations leak out of blocks (e.g. "if (true) { enum X { a } } X a;" does not fail)
//     - this should be true (but isn't): 2-3+4 == (2-3)+4
// P2 (making things much harder):
//   some errors with line numbers are... inaccurate
//   instance variables can be used to access variables in scope of class: Integer bar = 1; class Foo { Null constructor() { } } println(Foo().bar);
// P3 (nice-to-haves for which i've found workarounds):
//   performance
//   soundness in type system -- a variable being of type X should be a guarantee that it will have a value of type X
//     - returns are "not really type safe"
//     - functions without returns aren't statically checked
//     - toString returning non-string isn't checked for either
//     - currently not true with uninitialized variables (they start as an instance of Null instead)
//     - shadow rules are weird: class A { } class B extends A { Null println() { } }
//   function types with signatures
//   string interpolation
//   new features in classes: abstract classes and methods
//   utf8 decoder (so that i can get scalarValues out of readFileBytes)
//   functions to have named arguments with default values
//   some way to call syscalls / OS functions
//   switch (especially if the compiler can report missing enum values)
//   no way to catch exceptions
//   try-finally
//   typed empty list constructor
//   constants
//   detailed language reference
//   [] could have its type inferred from context
// P4 (minor typos and such):
//   assigning to an undeclared variable says "Cannot reassign...".
//   error messages are inconsistent in style, e.g. giving file/line/col in different ways:
//     "You cannot return a Constant (<Constant>) from registerConstant, which is supposed to return a Variable! (syd-compiler.syd 226:19)"
//     "CompiledScope's superclass (Object) has no member prepareInstructions; attempted 'super.prepareInstructions' 814, 31, syd-compiler.syd"

CompiledLibrary processFile(String filename, CompilationEnvironment compilationEnvironment, Boolean isProgram) {
  assert(compilationEnvironment.getLibraryState(filename) == lsUnknown, 'processFile has already processed this file');
  Library ast = parseTokens(tokenize(scalarValues(readFile(filename)), filename), filename, isProgram);
  compilationEnvironment.declareLibrary(filename);
  for (child in ast.children) {
    if (child is ImportStatement) {
      ls childLibraryState = compilationEnvironment.getLibraryState(cast(cast(child).path));
      if (childLibraryState == lsDeclared) {
        throw(concat('Import loop at ', child.sourceLocation));
      } else if (childLibraryState == lsUnknown) {
        String libraryPath = cast(cast(child).path); // TODO: handle relative paths correctly
        compilationEnvironment.defineLibrary(libraryPath, processFile(libraryPath, compilationEnvironment, false));
      }
    } else {
      break;
    }
  }
  stderr(concat('compiling "', filename, '"...'));
  return ast.generateScopes(compilationEnvironment);
}

String mainProgramFileName = 'temp.syd';
Assembler assembler = Assembler();
//assembler.addCode(assembler.mainBlockId, 'int 3', 'debugger');
CompilationEnvironment compilationEnvironment = CompilationEnvironment(assembler);
CompiledLibrary program = processFile(mainProgramFileName, compilationEnvironment, true);
compilationEnvironment.defineLibrary(mainProgramFileName, program);
compilationEnvironment.compile(assembler);
assembler.addCode(assembler.mainBlockId, 'ret', 'exit application');
stderr('Compilation finished!');
stderr('Result:');
println(assembler.serialize());
