
/*
StringListList a = [];
append(a, 1);
println(a);
*/

/*
Null test(StringList a) {
  for (x in a) {
    println(charsOf(x));
  }
}

AnythingList a = [];
append(a, 123);
test(a as StringList);
*/


//class A { Null test() { this.test(); } }
//Integer bar = 1; class Foo { Null constructor() { } } println(Foo().bar);/*

import 'syd-tokenizer.syd';
import 'syd-ast.syd';
import 'syd-compiler.syd';
import 'syd-assembler.syd';

stderr('syllad self-hosting compiler');
// syllad spec:
// functions 'print', 'charsOf',
// 'addLists', 'parseInt',
// 'concat', 'len', 'input',
// 'iterator', 'next', 'current',
// 'append', 'stringTimes'
// 'first', 'last', 'single'
// 'copy', 'scalarValues',
// 'assert', 'exit',
// 'readFile', 'readFileBytes',
// 'println', 'throw', 'hex',
// 'chr', 'cast'
// 'padLeft', 'joinList'
// while loop
// for-in loops
// classical if-else
// classical variables, but with no 'var' or 'final' or 'const'
// enums (enum X {a b c}  ...  X state = Xa; ... state = Xb;   if(state == Xa) { ... })
// values are functions or true or false or null or int literal or list literal (e.g. [1, 2]) or string literal ('' or "", newlines ok, single-character escapes)
// types, or <t>, are:
// Anything, Integer, String, Boolean, <t>List, <t>Iterable, <t>Iterator, Null, <t> (enums)
// operators: [], <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, <<

// WISHLIST
// P1 (blocking progress):
//   methods can't refer to themselves on child instances, e.g.:
//     class Node {
//       String label;
//       NodeList children;
//       Null walk() {
//         println(label);
//         for (child in children) {
//           child.walk(); // compiler fails here, even though Node.walk is defined already
//         }
//       }
//       Null constructor(String labelArg, NodeList childrenArg) {
//         label = labelArg;
//         children = childrenArg;
//       }
//     }
//     Node('a', [Node('b', [])]).walk();
//   simpler example with probably same cause: class A { Null test() { this.test(); } }
//   no forward class declarations means you can't have classes that deal with their subclasses
//   the language requires gc:
//     - closures can leak out of their stack frame:
//       AnythingFunction makeLoop() {
//         AnythingFunction myself;
//         Anything logic(AnythingFunction what) {
//           myself = what;
//           return myself == logic;
//         }
//         return logic;
//       }
//       AnythingFunction f = makeLoop();
//       println(f(f));
//     - objects can reference each other, but there's no way to dispose of an object
//     - lists are reference types (not copy-on-write value types) and one can form reference loops, but there's no way to dispose of a list
//   language changes that I think have been announced but not yet implemented:
//     - imperative statements being allowed in class declarations (so classes are really functions) is
//     - blocks don't actually introduce scopes for variables (e.g. "Integer y = 0; if (true) { String y = 'bad'; } println(y);" prints "bad")
//     - type declarations leak out of blocks (e.g. "if (true) { enum X { a } } X a;" does not fail)
//     - this should be true (but isn't): 2-3+4 == (2-3)+4
// P2 (making things much harder):
//   some errors with line numbers are... inaccurate
//   not all errors say where the error happened, e.g.:
//     - stack traces from "assert" and "throw" don't give class/method names, line numbers, or file names, only call expressions (and are different from each other)
//   this crashes compiler: class A { }
//   this prints <String>: class A { Null constructor() { } } println(A());
//   instance variables can be used to access variables in scope of class: Integer bar = 1; class Foo { Null constructor() { } } println(Foo().bar);
// P3 (nice-to-haves for which i've found workarounds):
//   performance
//   soundness in type system -- a variable being of type X should be a guarantee that it will have a value of type X
//     - returns are "not really type safe"
//     - toString returning non-string isn't checked for either
//     - currently not true with uninitialized variables (they start as an instance of Null instead)
//     - covariant by default is not type safe:
//       class A {
//         Null foo(A z) { }
//         Null constructor(){}
//       }
//       class B extends A {
//         String test() { return 'test'; }
//         Null foo(B x) {
//           println(x.test());
//         }
//       }
//       A b = B();
//       b.foo(A());
//   function types with signatures
//   string interpolation
//   new features in classes: "className"...
//   new features in classes: abstract classes and methods
//   new features in classes: constructor shouldn't be required, especially in abstract classes, or classes with no superclass
//   utf8 decoder (so that i can get scalarValues out of readFileBytes)
//   functions to have named arguments with default values
//   some way to call syscalls / OS functions
//   switch (especially if the compiler can report missing enum values)
//   no way to catch exceptions
//   try-finally
//   typed empty list constructor
//   constants
//   detailed language reference
// P4 (minor typos and such):
//   "Expected Boolean, got ImportStatement while parsing expression (Instance of 'IsExpr') on line 595 column 34 file syd.syd"
//   assigning to an undeclared variable says "Cannot reassign...".
//   error messages are inconsistent in style, e.g. giving file/line/col in different ways:
//     "You cannot return a Constant (<Constant>) from registerConstant, which is supposed to return a Variable! (syd-compiler.syd 226:19)"


// forward declaration
ExpressionFunction parseExpression;

Expression parseExpressionLeaves(TokenConsumer source) {
  // bool literals
  if (source.isNext(ttIdentifier)) {
    String identifier = source.readIdentifier();
    return VariableExpression(identifier);
  }
  if (source.isNext(ttString)) {
    String value = source.readString();
    return StringLiteralExpression(value);
  }
  if (source.isNext(ttInteger)) {
    Integer value = source.readInteger();
    return IntegerLiteralExpression(value);
  }
  if (source.isNext(ttOpenBracket)) {
    source.expectPunctuation(ttOpenBracket);
    ExpressionList values = [];
    while (!source.isNext(ttCloseBracket)) {
      append(values, parseExpression(source));
      if (!source.isNext(ttCloseBracket)) {
        source.expectPunctuation(ttComma);
      }
    }
    source.expectPunctuation(ttCloseBracket);
    return ListLiteralExpression(values);
  }
  if (source.isNext(ttOpenParen)) {
    source.expectPunctuation(ttOpenParen);
    Expression expression = parseExpression(source);
    source.expectPunctuation(ttCloseParen);
    return expression;
  }
  throw(source.expected('expression'));
}

Expression parseUnaryExpression(TokenConsumer source) {
  if (source.isNext(ttMinus)) {
    source.expectPunctuation(ttMinus);
    return IntegerNegationExpression(parseUnaryExpression(source));
  }
  if (source.isNext(ttPlus)) {
    source.expectPunctuation(ttPlus);
    return PlusExpression(parseUnaryExpression(source));
  }
  if (source.isNext(ttBang)) {
    source.expectPunctuation(ttBang);
    return BooleanNotExpression(parseUnaryExpression(source));
  }
  if (source.isNext(ttTilde)) {
    source.expectPunctuation(ttTilde);
    return BitwiseNotExpression(parseUnaryExpression(source));
  }
  Expression result = parseExpressionLeaves(source);
  while (true) {
    if (source.isNext(ttOpenParen)) {
      source.expectPunctuation(ttOpenParen);
      ExpressionList arguments = [];
      while (!source.isNext(ttCloseParen)) {
        append(arguments, parseExpression(source));
        if (!source.isNext(ttCloseParen)) {
          source.expectPunctuation(ttComma);
        }
      }
      source.expectPunctuation(ttCloseParen);
      result = SubroutineCallExpression(result, arguments);
      continue;
    }
    if (source.isNext(ttOpenBracket)) {
      source.expectPunctuation(ttOpenBracket);
      Expression argument = parseExpression(source);
      source.expectPunctuation(ttCloseBracket);
      result = SubscriptExpression(result, argument);
      continue;
    }
    if (source.isNext(ttPeriod)) {
      source.expectPunctuation(ttPeriod);
      String identifier = source.readIdentifier();
      result = MemberAccessExpression(result, identifier);
      continue;
    }
    if (source.isNextIdentifier('is')) {
      source.expectIdentifier('is');
      String typeName = source.readIdentifier();
      result = IsOperatorExpression(result, typeName);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionMultiplication(TokenConsumer source) {
  Expression result = parseUnaryExpression(source);
  while (true) {
    if (source.isNext(ttAsterisk)) {
      source.expectPunctuation(ttAsterisk);
      Expression rhs = parseUnaryExpression(source);
      result = OperatorMultiplicationExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttSlash)) {
      source.expectPunctuation(ttSlash);
      Expression rhs = parseUnaryExpression(source);
      result = OperatorDivisionExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttModulus)) {
      source.expectPunctuation(ttModulus);
      Expression rhs = parseUnaryExpression(source);
      result = OperatorModulusExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionAddition(TokenConsumer source) {
  Expression result = parseExpressionMultiplication(source);
  while (true) {
    if (source.isNext(ttPlus)) {
      source.expectPunctuation(ttPlus);
      Expression rhs = parseExpressionMultiplication(source);
      result = OperatorAdditionExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttMinus)) {
      source.expectPunctuation(ttMinus);
      Expression rhs = parseExpressionMultiplication(source);
      result = OperatorSubtractionExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionShift(TokenConsumer source) {
  Expression result = parseExpressionAddition(source);
  while (true) {
    if (source.isNext(ttLessThanLessThan)) {
      source.expectPunctuation(ttLessThanLessThan);
      Expression rhs = parseExpressionAddition(source);
      result = OperatorLeftShiftExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttGreaterThanGreaterThan)) {
      source.expectPunctuation(ttGreaterThanGreaterThan);
      Expression rhs = parseExpressionAddition(source);
      result = OperatorRightShiftExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionRelational(TokenConsumer source) {
  Expression result = parseExpressionShift(source);
  while (true) {
    if (source.isNext(ttLessThan)) {
      source.expectPunctuation(ttLessThan);
      Expression rhs = parseExpressionShift(source);
      result = OperatorLessThanExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttLessThanEquals)) {
      source.expectPunctuation(ttLessThanEquals);
      Expression rhs = parseExpressionShift(source);
      result = OperatorLessThanOrEqualsExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttGreaterThan)) {
      source.expectPunctuation(ttGreaterThan);
      Expression rhs = parseExpressionAddition(source);
      result = OperatorGreaterThanExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttGreaterThanEquals)) {
      source.expectPunctuation(ttGreaterThanEquals);
      Expression rhs = parseExpressionAddition(source);
      result = OperatorGreaterThanOrEqualsExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionLogicalEquality(TokenConsumer source) {
  Expression result = parseExpressionRelational(source);
  while (true) {
    if (source.isNext(ttEqualsEquals)) {
      source.expectPunctuation(ttEqualsEquals);
      Expression rhs = parseExpressionRelational(source);
      result = OperatorEqualsEqualsExpression(result, rhs);
      continue;
    }
    if (source.isNext(ttBangEquals)) {
      source.expectPunctuation(ttBangEquals);
      Expression rhs = parseExpressionRelational(source);
      result = OperatorBangEqualsExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionBitwiseAnd(TokenConsumer source) {
  Expression result = parseExpressionLogicalEquality(source);
  while (true) {
    if (source.isNext(ttAmpersand)) {
      source.expectPunctuation(ttAmpersand);
      Expression rhs = parseExpressionLogicalEquality(source);
      result = OperatorBitwiseAndExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionBitwiseXor(TokenConsumer source) {
  Expression result = parseExpressionBitwiseAnd(source);
  while (true) {
    if (source.isNext(ttCaret)) {
      source.expectPunctuation(ttCaret);
      Expression rhs = parseExpressionBitwiseAnd(source);
      result = OperatorBitwiseXorExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionBitwiseOr(TokenConsumer source) {
  Expression result = parseExpressionBitwiseXor(source);
  while (true) {
    if (source.isNext(ttVerticalBar)) {
      source.expectPunctuation(ttVerticalBar);
      Expression rhs = parseExpressionBitwiseXor(source);
      result = OperatorBitwiseOrExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression parseExpressionLogicalAnd(TokenConsumer source) {
  Expression result = parseExpressionBitwiseOr(source);
  while (true) {
    if (source.isNext(ttAmpersandAmpersand)) {
      source.expectPunctuation(ttAmpersandAmpersand);
      Expression rhs = parseExpressionBitwiseOr(source);
      result = OperatorLogicalAndExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}

Expression _parseExpression(TokenConsumer source) {
  Expression result = parseExpressionLogicalAnd(source);
  while (true) {
    if (source.isNext(ttVerticalBarVerticalBar)) {
      source.expectPunctuation(ttVerticalBarVerticalBar);
      Expression rhs = parseExpressionLogicalAnd(source);
      result = OperatorLogicalOrExpression(result, rhs);
      continue;
    }
    break;
  }
  return result;
}
parseExpression = _parseExpression;

// forward declaration
StatementFunction parseStatement;

StatementBlock parseBlock(TokenConsumer source) {
  source.expectPunctuation(ttOpenBrace);
  StatementList statements = [];
  while (!source.isNext(ttCloseBrace)) {
    append(statements, parseStatement(source));
  }
  source.expectPunctuation(ttCloseBrace);
  return StatementBlock(statements);
}

IfStatement parseIfStatement(TokenConsumer source) {
  source.expectIdentifier('if');
  source.expectPunctuation(ttOpenParen);
  Expression expression = parseExpression(source);
  source.expectPunctuation(ttCloseParen);
  StatementBlock block = parseBlock(source);
  ElseClauseNullable elseClause = null;
  if (source.isNextIdentifier('else')) {
    source.expectIdentifier('else');
    if (source.isNextIdentifier('if')) {
      elseClause = ElseIfClause(parseIfStatement(source));
    } else {
      elseClause = DefaultElseClause(parseBlock(source));
    }
  }
  return IfStatement(expression, block, elseClause);
}

DeclarationStatement parseDeclaration(TokenConsumer source) {
  String type = source.readIdentifier();
  String identifier = source.readIdentifier();
  if (source.isNext(ttEquals)) {
    source.expectPunctuation(ttEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return VariableDeclarationStatement(type, identifier, initializer);
  }
  if (source.isNext(ttOpenParen)) {
    source.expectPunctuation(ttOpenParen);
    StringListList parameters = [];
    while (!source.isNext(ttCloseParen)) {
      if (len(parameters) > 0) {
        source.expectPunctuation(ttComma);
      }
      append(parameters, [
        source.readIdentifier(),
        source.readIdentifier(),
      ]);
    }
    source.expectPunctuation(ttCloseParen);
    StatementBlock block = parseBlock(source);
    Subroutine subroutine = Subroutine(type, identifier, parameters, block);
    return SubroutineDeclarationStatement(subroutine);
  }
  if (source.isNext(ttSemicolon)) {
    source.expectPunctuation(ttSemicolon);
    Expression initialValue;
    return VariableDeclarationStatement(type, identifier, null);
  }
  throw(source.expected('"=", "(", or ";"'));
}

Statement _parseStatement(TokenConsumer source) {
  if (source.isNextIdentifier('enum')) {
    source.expectIdentifier('enum');
    String name = source.readIdentifier();
    source.expectPunctuation(ttOpenBrace);
    StringList values = [];
    while (source.isNext(ttIdentifier)) {
      append(values, source.readIdentifier());
    }
    source.expectPunctuation(ttCloseBrace);
    return EnumDeclaration(name, values);
  }
  if (source.isNextIdentifier('class')) {
    source.expectIdentifier('class');
    String className = source.readIdentifier();
    StringNullable superclassName = null;
    if (source.isNextIdentifier('extends')) {
      source.expectIdentifier('extends');
      superclassName = source.readIdentifier();
    }
    source.expectPunctuation(ttOpenBrace);
    DeclarationStatementList members = [];
    while (!source.isNext(ttCloseBrace)) {
      append(members, parseDeclaration(source));
    }
    source.expectPunctuation(ttCloseBrace);
    return ClassDeclaration(className, superclassName, members);
  }
  if (source.isNextIdentifier('if')) {
    return parseIfStatement(source);
  }
  if (source.isNextIdentifier('return')) {
    source.expectIdentifier('return');
    ExpressionNullable returnValue = null;
    if (!source.isNext(ttSemicolon)) {
      returnValue = parseExpression(source);
    }
    source.expectPunctuation(ttSemicolon);
    return ReturnStatement(returnValue);
  }
  if (source.isNextIdentifier('import')) {
    source.expectIdentifier('import');
    String path = source.readString();
    source.expectPunctuation(ttSemicolon);
    return ImportStatement(path);
  }
  if (source.isNextIdentifier('while')) {
    source.expectIdentifier('while');
    source.expectPunctuation(ttOpenParen);
    Expression expression = parseExpression(source);
    source.expectPunctuation(ttCloseParen);
    StatementBlock block = parseBlock(source);
    return WhileStatement(expression, block);
  }
  if (source.isNextIdentifier('for')) {
    source.expectIdentifier('for');
    source.expectPunctuation(ttOpenParen);
    String variable = source.readIdentifier();
    source.expectIdentifier('in');
    Expression expression = parseExpression(source);
    source.expectPunctuation(ttCloseParen);
    StatementBlock block = parseBlock(source);
    return ForStatement(variable, expression, block);
  }
  // TODO:
  // break
  // continue
  if (source.isNext2(ttIdentifier, ttIdentifier)) {
    return parseDeclaration(source);
  }
  Expression expression = parseExpression(source);
  if (source.isNext(ttSemicolon)) {
    source.expectPunctuation(ttSemicolon);
    return ExpressionStatement(expression);
  }
  // Expression followed by some operator: must be assignment.
  if (!expression.isLValue()) {
    throw(source.butFound('assignable lvalue expression', expression.toString()));
  }
  if (source.isNext(ttEquals)) {
    source.expectPunctuation(ttEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return StraightAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttPlusEquals)) {
    source.expectPunctuation(ttPlusEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return PlusAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttMinusEquals)) {
    source.expectPunctuation(ttMinusEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return MinusAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttAsteriskEquals)) {
    source.expectPunctuation(ttAsteriskEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return AsteriskAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttAsteriskEquals)) {
    source.expectPunctuation(ttAsteriskEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return AsteriskAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttSlashEquals)) {
    source.expectPunctuation(ttSlashEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return SlashAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttModulusEquals)) {
    source.expectPunctuation(ttModulusEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return ModulusAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttAmpersandEquals)) {
    source.expectPunctuation(ttAmpersandEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return BitwiseAndAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttCaretEquals)) {
    source.expectPunctuation(ttCaretEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return BitwiseXorAssignmentStatement(expression, initializer);
  }
  if (source.isNext(ttVerticalBarEquals)) {
    source.expectPunctuation(ttVerticalBarEquals);
    Expression initializer = parseExpression(source);
    source.expectPunctuation(ttSemicolon);
    return BitwiseOrAssignmentStatement(expression, initializer);
  }
  throw(source.expected('assignment operator (e.g. "=")'));
}
parseStatement = _parseStatement;

Library parseTokens(AnythingListList tokens, String name) {
  stderr('parsing...');
  TokenConsumer source = TokenConsumer(tokens);
  StatementList statements = [];
  while (!source.isNext(ttEof)) {
    append(statements, parseStatement(source));
  }
  return Library(statements, name);
}

Library parseString(String data, String filename) {
  return parseTokens(tokenize(scalarValues(data), filename), filename);
}

Library parseFile(String filename) {
  return parseTokens(tokenize(scalarValues(readFile(filename)), filename), filename);
}

CompiledLibrary processFile(String filename, CompilationEnvironment compilationEnvironment, Assembler assembler) {
  assert(compilationEnvironment.getLibraryState(filename) == lsUnknown, 'processFile has already processed this file');
  Library ast = parseFile(filename);
  compilationEnvironment.declareLibrary(filename);
  for (child in ast.children) {
    if (child is ImportStatement) {
      ls childLibraryState = compilationEnvironment.getLibraryState(cast(cast(child).path));
      if (childLibraryState == lsDeclared) {
        throw('xxxx'); // import loop detected (but ast needs to track token positions)
      } else if (childLibraryState == lsUnknown) {
        String libraryPath = cast(cast(child).path); // TODO: handle relative paths correctly
        compilationEnvironment.defineLibrary(libraryPath, processFile(libraryPath, compilationEnvironment, assembler));
      }
    } else {
      break;
    }
  }
  stderr(concat('compiling "', filename, '"...'));
  return ast.compileLibrary(compilationEnvironment, assembler);
}

String mainProgramFileName = 'temp.syd';
Assembler assembler = Assembler();
CompilationEnvironment compilationEnvironment = CompilationEnvironment(assembler);
CompiledLibrary program = processFile(mainProgramFileName, compilationEnvironment, assembler);
stderr('Compilation finished!');
stderr('Result:');
println(assembler.serialize());