/*
// NullFunction


// Null0Function
Null baz();

// NullInteger1Function
Null foo(Integer x) { }

// NullIntegerInteger0Function2Function
Null bar(Integer y, Integer0Function x) { }
*/

/*
Null throw(String t) {
  println('hi', t);
}

Integer x;
println(x);
*/
/*
IntegerList x = [3,2]:Integer;
append(x as AnythingList, "h");
println(x);
*/

/*
StringList b;
Null foo(String... s) {
  b = s;
}
foo('a', 'b');
append(b, 'c'); // crashes
println(b);
*/

/*
IntegerList b = [1,2,3];
for (a in b) {
  append(b, a); // crashes
}
print(b);
*/

//import 'a.syd'; // class Foo { Integer x; } Null bar(FooFunction a) { println(a().x); }
//import 'b.syd'; // class Foo { String s; } Null bar(FooFunction a) { println(a().s); }

//class Foo { Integer x; } Null bar(FooFunction a) { println(a().x); }
//class Foo { String s; } Null bar(FooFunction a) { println(a().s); }

// TODO
// - verify that we keep the stack pointer 16-byte aligned
// - something that runs each test in turn (and matches expectation)
// - static type checking ("xxxx")
// - heap allocation
//    - import GetProcessHeap, HeapAlloc, HeapFree from kernel32
// - string ref counting
// - len for varargs
// - vararg internal rtl functions
// - concat for strings, joinList for StringLists
// - lists, garbage collection
// - stringification
// - implement the real "println"
// - put initialized globals into .data section

import 'syd-tokenizer.syd';
import 'syd-ast.syd';
import 'syd-parser.syd';
import 'syd-compiler.syd';
import 'syd-assembler.syd';

stderr('syllad self-hosting compiler');
// syllad spec:
// intrinsics.txt + rtl.syd = built-in functions
// while loop
// for-in loops
// classical if-else
// classical variables, but with no 'var' or 'final' or 'const'
// enums (enum X {a b c}  ...  X state = Xa; ... state = Xb;   if(state == Xa) { ... })
// values are functions or true or false or null or int literal or list literal (e.g. [1, 2]) or string literal ('' or "", newlines ok, single-character escapes)
// types, or <t>, are:
// Anything, Integer, String, Boolean, <t>List, <t>Iterable, <t>Iterator, Null, <t> (enums/classes)
// operators: [], <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, <<

// WISHLIST
// P1 (blocking progress):
//   methods can't refer to themselves on child instances, e.g.:
//     class Node {
//       String label;
//       NodeList children;
//       Null walk() {
//         println(label);
//         for (child in children) {
//           child.walk(); // compiler fails here, even though Node.walk is defined already
//         }
//       }
//       Null constructor(String labelArg, NodeList childrenArg) {
//         label = labelArg;
//         children = childrenArg;
//       }
//     }
//     Node('a', [Node('b', [])]).walk();
//   simpler example with probably same cause: class A { Null test() { this.test(); } }
//   the language requires gc:
//     - closures can leak out of their stack frame:
//       AnythingFunction makeLoop() {
//         AnythingFunction myself;
//         Anything logic(AnythingFunction what) {
//           myself = what;
//           return myself == logic;
//         }
//         return logic;
//       }
//       AnythingFunction f = makeLoop();
//       println(f(f));
//     - objects can reference each other, but there's no way to dispose of an object
//     - lists are reference types (not copy-on-write value types) and one can form reference loops, but there's no way to dispose of a list
//   language changes that I think have been announced but not yet implemented:
//     - type declarations leak out of blocks (e.g. "if (true) { enum X { a } } X a;" does not fail)
//     - this should be true (but isn't): 2-3+4 == (2-3)+4
// P2 (making things much harder):
//   some errors with line numbers are... inaccurate
//   instance variables can be used to access variables in scope of class: Integer bar = 1; class Foo { Null constructor() { } } println(Foo().bar);
// P3 (nice-to-haves for which i've found workarounds):
//   performance
//   soundness in type system -- a variable being of type X should be a guarantee that it will have a value of type X
//     - returns are "not really type safe"
//     - functions without returns aren't statically checked
//     - toString returning non-string isn't checked for either
//     - shadow rules are weird: class A { } class B extends A { Null println() { } }
//   function types with signatures
//   string interpolation
//   new features in classes: abstract classes and methods
//   utf8 decoder (so that i can get scalarValues out of readFileBytes)
//   functions to have named arguments with default values
//   some way to call syscalls / OS functions
//   switch (especially if the compiler can report missing enum values)
//   no way to catch exceptions
//   try-finally
//   detailed language reference
//   [] could have its type inferred from context

CompiledLibrary processFile(String filename, CompilationEnvironment compilationEnvironment, Boolean isProgram) {
  assert(compilationEnvironment.getLibraryState(filename) == lsUnknown, 'processFile has already processed this file');
  Library ast = parseTokens(tokenize(scalarValues(readFile(filename)), filename), filename, isProgram);
  compilationEnvironment.declareLibrary(filename);
  for (child in ast.children) {
    if (child is ImportStatement) {
      ls childLibraryState = compilationEnvironment.getLibraryState(cast(cast(child).path));
      if (childLibraryState == lsDeclared) {
        throw(concat('Import loop at ', child.sourceLocation));
      } else if (childLibraryState == lsUnknown) {
        String libraryPath = cast(cast(child).path); // TODO: handle relative paths correctly
        compilationEnvironment.defineLibrary(libraryPath, processFile(libraryPath, compilationEnvironment, false));
      }
    } else {
      break;
    }
  }
  stderr(concat('compiling "', filename, '"...'));
  return ast.generateScopes(compilationEnvironment);
}

String mainProgramFileName = 'temp.syd';
CompilationEnvironment compilationEnvironment = CompilationEnvironment();
compilationEnvironment.setRuntimeLibrary(
  parseTokens(tokenize(scalarValues(readFile('syd-rtl.syd')), 'runtime library'), 'runtime library', false).generateScopes(compilationEnvironment)
);
CompiledLibrary program = processFile(mainProgramFileName, compilationEnvironment, true);
compilationEnvironment.defineLibrary(mainProgramFileName, program);
Assembler assembler = Assembler();
compilationEnvironment.compile(assembler);
stderr('Compilation finished!');
stderr('Result:');
println(assembler.serialize());
