import 'core.syd';

String hex8(Integer value) {
  return concat('0', padLeft(hex(value), 2, '0'), 'h');
}

String hex32(Integer value) {
  return concat('0', padLeft(hex(value), 8, '0'), 'h');
}

String hex64(Integer value) {
  return concat('0', padLeft(hex(value), 16, '0'), 'h');
}

String stringLiteral(String value) {
  StringList buffer = []:String;
  Boolean quoted = false;
  for (char in scalarValues(value)) {
    if (char == 0x22 && quoted) {
      append(buffer, '""');
    } else if (char < 0x20 || char > 0x7e || char == 0x22) {
      if (quoted) {
        append(buffer, '"');
        quoted = false;
      }
      if (len(buffer) > 0) {
        append(buffer, ', ');
      }
      append(buffer, concat(padLeft(hex(char), 2, '0'), 'h'));
    } else {
      if (!quoted) {
        if (len(buffer) > 0) {
          append(buffer, ', ');
        }
        append(buffer, '"');
        quoted = true;
      }
      append(buffer, chr(char));
    }
  }
  if (quoted) {
    append(buffer, '"');
  }
  return joinList(buffer);
}

String camelCase(String value) {
  StringList buffer = []:String;
  Boolean needUpper = false;
  for (char in scalarValues(value)) {
    if (char >= 0x41 && char <= 0x5A) { // A-Z
      if (needUpper) {
        append(buffer, chr(char));
      } else {
        append(buffer, chr(char + 0x20));
      }
    } else if (char >= 0x61 && char <= 0x7A) {
      if (needUpper) {
        append(buffer, chr(char - 0x20));
        needUpper = false;
      } else {
        append(buffer, chr(char));
      }
    } else {
      if ((char >= 0x30 && char <= 0x39) ||
          (char == 0x24)) {
        append(buffer, chr(char));
      }
      needUpper = true;
    }
  }
  return joinList(buffer);
}

enum ot { Imm32 Imm64 Indirect Label LabelOffset Register }

class Operand extends Object {
  String operand;
  String location;
  ot kind;

  Boolean isMemory() {
    return kind == otIndirect || kind == otLabelOffset;
  }

  Boolean isImmediate() {
    return kind == otImm32 || kind == otImm64 || kind == otLabel;
  }

  String toString() {
    return operand;
  }

  Null constructor(String operandArg, ot kindArg) {
    super.constructor();
    if (kindArg == otIndirect) {
      operand = concat('[', operandArg, ']');
      location = operandArg;
    } else if (kindArg == otLabel) {
      operand = operandArg;
      location = concat('offset ', operandArg);
    } else if (kindArg == otLabelOffset) {
      operand = concat('offset ', operandArg);
      // no location
    } else {
      operand = operandArg;
      // no location
    }
    kind = kindArg;
  }
}

Operand r8 = Operand('r8', otRegister);
Operand r9 = Operand('r9', otRegister);
Operand r10 = Operand('r10', otRegister);
Operand r11 = Operand('r11', otRegister);
Operand r12 = Operand('r12', otRegister);
Operand r13 = Operand('r13', otRegister);
Operand r14 = Operand('r14', otRegister);
Operand r15 = Operand('r15', otRegister);
Operand rax = Operand('rax', otRegister);
Operand rbx = Operand('rbx', otRegister);
Operand rcx = Operand('rcx', otRegister);
Operand rdx = Operand('rdx', otRegister);

class Assembler extends Object {
  Set includelibs = Set();
  StringList externs = []:String;
  StringList data = []:String;
  StringList labels = []:String;
  StringListList code = []:StringList;
  IntegerList indents = []:Integer;
  StringNullableList pendingComments = []:StringNullable;

  Integer lineLength = 64;

  Null addIncludeLib(String filename) {
    includelibs.add(concat('includelib ', filename));
  }

  Null addExternProc(String procname) {
    append(externs, concat('extern ', procname, ' : proc'));
  }

  Null addData(String label, StringList lines, StringNullableList comments) {
    assert(len(lines) > 0, 'addData got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = lines[index];
      StringNullable comment = comments[index];
      if (comment != null) {
        append(data, concat('  ', padRight(concat(padRight(prefix, 12, ' '), ' ', line), lineLength, ' '), ' ; ', comment));
      } else {
        append(data, concat('  ', padRight(label, 12, ' '), ' ', line));
      }
      index += 1;
      prefix = '';
    }
  }

  Null indent(Integer blockId, NullFunction generateAssembler) {
    indents[blockId] += 2;
    generateAssembler(this, blockId);
    indents[blockId] -= 2;
  }

  Null addCode(Integer blockId, String line, StringNullable comment) {
    String indentedLine = concat(stringTimes(' ', indents[blockId]), line);
    if (pendingComments[blockId] != null) {
      append(code[blockId], concat('  ', stringTimes(' ', indents[blockId]), '; ', pendingComments[blockId]));
      pendingComments[blockId] = null;
    }
    if (comment != null) {
      append(code[blockId], concat('  ', padRight(indentedLine, lineLength, ' '), ' ; ', comment));
    } else {
      append(code[blockId], concat('  ', indentedLine));
    }
  }

  Null addMov(Integer blockId, Operand destination, Operand source, String comment) {
    if (source.isMemory() && destination.isMemory()) {
      addCode(blockId, concat('mov r11, ', source.operand), comment);
      addCode(blockId, concat('mov ', destination.operand, ', r11'), concat('(indirect via r11 because mov can\'t do memory-to-memory)'));
    } else if (source.kind == otImm64) {
      addCode(blockId, concat('mov r11, ', source.operand), comment);
      addCode(blockId, concat('mov ', destination.operand, ', r11'), concat('(indirect via r11 because ', source.operand, ' could be a 64 bit value)'));
    } else if (source.kind == otImm32) {
      addCode(blockId, concat('mov qword ptr ', destination.operand, ', ', source.operand), comment);
    } else {
      addCode(blockId, concat('mov ', destination.operand, ', ', source.operand), comment);
    }
  }

  Null addCmp(Integer blockId, Operand a, Operand b, String comment) {
    if (a.isImmediate() && b.isImmediate()) {
      // TODO: should optimize call sites and make this an assert instead
      addCode(blockId, concat('mov r11, ', a.operand), comment);
      addCode(blockId, concat('cmp r11, ', b.operand), concat('(indirect via r11 because both operands are immediates)'));
    } else if (b.kind == otImm32) {
      addCode(blockId, concat('cmp qword ptr ', a.operand, ', ', b.operand), comment);
    } else if (b.kind == otImm64) {
      addCode(blockId, concat('mov r11, ', a.operand), comment);
      addCode(blockId, concat('cmp r11, ', b.operand), concat('(indirect via r11 because ', b.operand, ' could be a 64 bit value)'));
    } else if (a.isMemory() && b.isMemory()) {
      addCode(blockId, concat('mov r11, ', a.operand), comment);
      addCode(blockId, concat('cmp r11, ', b.operand), concat('(indirect via r11 because both operands are memory references)'));
    } else {
      addCode(blockId, concat('cmp ', a.operand, ', ', b.operand), comment);
    }
  }

  Null addLea(Integer blockId, Operand destination, Operand source, String comment) {
    assert(source.kind == otIndirect, concat('can only lea from a memory location, not a ', source.kind, ', when trying to add "lea ', destination, ', ', source, '"'));
    assert(destination.kind == otRegister, 'can only lea to a register');
    addCode(blockId, concat('lea ', destination.operand, ', ', source.operand), comment);
  }

  Null addPush(Integer blockId, Operand source, String comment) {
    if (source.kind == otLabel || source.kind == otLabelOffset) {
      addCode(blockId, concat('mov r11, ', source.operand), comment);
      addCode(blockId, concat('push r11'), concat('(indirect via r11 because "', source.operand, '" cannot be used with push)'));
    } else {
      addCode(blockId, concat('push ', source.operand), comment);
    }
  }

  Integer addLabel(String label, StringNullable comment) {
    append(labels, label);
    StringList subcode = []:String;
    if (comment != null && comment != label) {
      append(subcode, concat('; ', comment));
    }
    append(subcode, concat(label, ':'));
    append(code, subcode);
    append(indents, 0);
    append(pendingComments, null);
    assert(len(code) == len(labels), 'labels and code are out of sync');
    return len(code) - 1;
  }

  Null addComment(Integer blockId, String message) {
    append(code[blockId], concat('  ', stringTimes(' ', indents[blockId]), '; ', message));
    pendingComments[blockId] = null;
  }

  Null addPendingComment(Integer blockId, String message) {
    pendingComments[blockId] = message;
  }

  Null addBlankLine(Integer blockId) {
    if (len(code[blockId]) > 1) {
      append(code[blockId], '');
    }
  }

  String serialize() {
    StringList fullCode = []:String;
    Integer index = 0;
    while (index < len(code)) {
      append(fullCode, concat(
        join(code[index], '\n'),
        '\n\n',
      ));
      index += 1;
    }
    return concat(
      '_drectve segment info alias(".drectve")\n',
      '  db \' /ENTRY:main \'\n',
      '_drectve ends\n',
      'option casemap:none\n',
      '\n',
      '; includes\n',
      join((includelibs.values() as StringList), '\n'),
      '\n\n',
      '; externs\n',
      join(externs, '\n'),
      '\n\n',
      '.data\n',
      join(data, '\n'),
      '\n\n',
      '.code\n',
      '\n',
      'public main\n',
      joinList(fullCode),
      '\n',
      'end\n',
    );
  }

  Integer mainBlockId;

  Null constructor() {
    super.constructor();
    mainBlockId = addLabel('main', null);
  }
}
