import 'core.syd';

String hex8(Integer value) {
  return concat('0', padLeft(hex(value), 2, '0'), 'h');
}

String hex32(Integer value) {
  return concat('0', padLeft(hex(value), 8, '0'), 'h');
}

String hex64(Integer value) {
  return concat('0', padLeft(hex(value), 16, '0'), 'h');
}

String stringLiteral(String value) {
  assert(value != '', 'empty strings are not representable in assembler');
  StringList buffer = []:String;
  Boolean quoted = false;
  for (char in scalarValues(value)) {
    if (char == 0x22 && quoted) {
      append(buffer, '""');
    } else if (char < 0x20 || char > 0x7e || char == 0x22) {
      if (quoted) {
        append(buffer, '"');
        quoted = false;
      }
      if (len(buffer) > 0) {
        append(buffer, ', ');
      }
      append(buffer, concat(padLeft(hex(char), 2, '0'), 'h'));
    } else {
      if (!quoted) {
        if (len(buffer) > 0) {
          append(buffer, ', ');
        }
        append(buffer, '"');
        quoted = true;
      }
      append(buffer, chr(char));
    }
  }
  if (quoted) {
    append(buffer, '"');
  }
  return joinList(buffer);
}

String camelCase(String value) {
  StringList buffer = []:String;
  Boolean needUpper = false;
  for (char in scalarValues(value)) {
    if (char >= 0x41 && char <= 0x5A) { // A-Z
      if (needUpper) {
        append(buffer, chr(char));
      } else {
        append(buffer, chr(char + 0x20));
      }
    } else if (char >= 0x61 && char <= 0x7A) {
      if (needUpper) {
        append(buffer, chr(char - 0x20));
        needUpper = false;
      } else {
        append(buffer, chr(char));
      }
    } else if (char == 0x24) {
      append(buffer, chr(char));
      needUpper = false;
    } else {
      if (char >= 0x30 && char <= 0x39) {
        append(buffer, chr(char));
      }
      needUpper = true;
    }
  }
  return joinList(buffer);
}

enum ot { Imm32 Imm64 Indirect AddressOfLabel DereferencedPointerLabel Register }

class Operand extends Object {
  String debugName;
  String value;
  String destination;
  ot kind;

  Boolean isMemory() {
    return kind == otIndirect || kind == otDereferencedPointerLabel;
  }

  Boolean isImmediate() {
    return kind == otImm32 || kind == otImm64 || kind == otAddressOfLabel;
  }

  Boolean isImmediate64() {
    return kind == otImm64 || kind == otAddressOfLabel;
  }

  String toString() {
    return concat('"', debugName, '"');
  }

  Null constructor(String operandArg, ot kindArg) {
    super.constructor();
    kind = kindArg;
    debugName = operandArg;
    if (kindArg == otImm32 || kindArg == otImm64) {
      value = operandArg;
    } else if (kindArg == otAddressOfLabel) {
      value = concat('offset ', operandArg);
    } else if (kindArg == otIndirect) {
      value = concat('[', operandArg, ']');
      destination = value;
    } else if (kindArg == otDereferencedPointerLabel) {
      value = operandArg;
      destination = operandArg;
    } else {
      assert(kindArg == otRegister, 'Operand does not know about all ot* possibilities');
      value = operandArg;
      destination = operandArg;
    }
  }
}

// 64 BIT INTEGER REGISTERS
// non-volatile registers must be saved by CompiledStackFrameScope
Operand rax = Operand('rax', otRegister); // used as scratch register, input to opcodes like mul; redundant return value in calling convention (volatile)
Operand rbx = Operand('rbx', otRegister); // (nonvolatile)
Operand rcx = Operand('rcx', otRegister); // used in function calling convention for number of arguments (volatile)
Operand rdx = Operand('rdx', otRegister); // used in function calling convention for closure pointer (volatile)
Operand r8 = Operand('r8', otRegister); // used in function calling convention for type of "this" object (volatile)
Operand r9 = Operand('r9', otRegister); // used in function calling convention for pointer to "this" object (volatile)
Operand r10 = Operand('r10', otRegister); // scratch register used by syd-compiler.syd (volatile)
Operand r11 = Operand('r11', otRegister); // scratch register used by Assembler class below (volatile)
Operand r12 = Operand('r12', otRegister); // (nonvolatile)
Operand r13 = Operand('r13', otRegister); // (nonvolatile)
Operand r14 = Operand('r14', otRegister); // (nonvolatile)
Operand r15 = Operand('r15', otRegister); // return value pointer used by CompiledSubroutine (nonvolatile)

// Methods of Assembler other than addCode may mutate r11 without notice and without saving it.
class Assembler extends Object {
  Set includelibs = Set();
  StringList externs = []:String;
  StringList const = []:String;
  StringList data = []:String;
  StringList bss = []:String;
  StringList labels = []:String;
  StringListList code = []:StringList;
  IntegerList indents = []:Integer;
  StringNullableList pendingComments = []:StringNullable;

  Integer lineLength = 64;

  Null addIncludeLib(String filename) {
    includelibs.add(concat('includelib ', filename));
  }

  Null addExternProc(String procname) {
    append(externs, concat('extern ', procname, ' : proc'));
  }

  Null addConst(String label, StringList lines, StringNullableList comments) {
    assert(len(lines) > 0, 'addConst got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = concat('  ', padRight(prefix, 12, ' '), ' ', lines[index]);
      StringNullable comment = comments[index];
      if (comment != null) {
        line = concat(padRight(line, lineLength, ' '), ' ; ', comment);
      }
      append(const, line);
      index += 1;
      prefix = '';
    }
  }

  Null addData(String label, StringList lines, StringNullableList comments) {
    assert(len(lines) > 0, 'addData got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = concat('  ', padRight(prefix, 12, ' '), ' ', lines[index]);
      StringNullable comment = comments[index];
      if (comment != null) {
        line = concat(padRight(line, lineLength, ' '), ' ; ', comment);
      }
      append(const, line);
      index += 1;
      prefix = '';
    }
  }

  Null addBss(String label, Integer bytes, String comment) {
    String prefix;
    Integer count;
    if (bytes % 4 == 0) {
      prefix = 'dq';
      count = bytes / 4;
    } else {
      prefix = 'db';
      count = bytes;
    }
    append(bss,
      concat(
        padRight(
          concat('  ', label, ' ', prefix, ' ?', stringTimes(', ?', count - 1)),
          lineLength, ' ',
        ),
        ' ; ', comment,
      )
    );
  }

  Null indent(Integer blockId, NullFunction generateAssembler) {
    indents[blockId] += 2;
    generateAssembler(this, blockId);
    indents[blockId] -= 2;
  }

  Null addCode(Integer blockId, String line, StringNullable comment) {
    String indentedLine = concat(stringTimes(' ', indents[blockId]), line);
    if (pendingComments[blockId] != null) {
      append(code[blockId], concat('  ', stringTimes(' ', indents[blockId]), '; ', pendingComments[blockId]));
      pendingComments[blockId] = null;
    }
    if (comment != null) {
      append(code[blockId], concat(padRight(concat('  ', indentedLine), lineLength, ' '), ' ; ', comment));
    } else {
      append(code[blockId],                 concat('  ', indentedLine));
    }
  }

  Null addMov(Integer blockId, Operand destination, Operand source, String comment) {
    if (source.isMemory() && destination.isMemory()) {
      addCode(blockId, concat('mov r11, ', source.value), comment);
      addCode(blockId, concat('mov ', destination.destination, ', r11'), concat('(indirect via r11 because mov can\'t do memory-to-memory)'));
    } else if (source.isImmediate64()) {
      addCode(blockId, concat('mov r11, ', source.value), comment);
      addCode(blockId, concat('mov ', destination.destination, ', r11'), concat('(indirect via r11 because ', source, ' is an imm64)'));
    } else if (source.isImmediate()) {
      addCode(blockId, concat('mov qword ptr ', destination.destination, ', ', source.value), comment);
    } else {
      addCode(blockId, concat('mov ', destination.destination, ', ', source.value), comment);
    }
  }

  Null addCmp(Integer blockId, Operand a, Operand b, String aWhat, String bWhat) {
    // TODO: refactor to avoid so much code duplication
    if (a.isImmediate() && b.isImmediate()) {
      // TODO: should optimize call sites and make this an assert instead
      // call sites can either use STC/CLC or (preferred) actually skip the offending code
      addCode(blockId, concat('mov r11, ', a.value), concat('compare ', aWhat, '...'));
      addCode(blockId, concat('cmp r11, ', b.value), concat('...to ', bWhat));
    } else if (b.isImmediate64()) {
      addCode(blockId, concat('mov r11, ', a.value), concat('compare ', aWhat, '...'));
      addCode(blockId, concat('cmp r11, ', b.value), concat('...to ', bWhat));
    } else if (b.isImmediate()) {
      addCode(blockId, concat('cmp qword ptr ', a.value, ', ', b.value), concat('compare ', aWhat, ' to ', bWhat));
    } else if (a.isMemory() && b.isMemory()) {
      addCode(blockId, concat('mov r11, ', a.value), concat('compare ', aWhat, '...'));
      addCode(blockId, concat('cmp r11, ', b.value), concat('...to ', bWhat));
    } else {
      addCode(blockId, concat('cmp ', a.value, ', ', b.value), concat('compare ', aWhat, ' to ', bWhat));
    }
  }

  Null addZero(Integer blockId, Operand operand, String comment) {
    assert(operand.kind == otRegister, 'can only zero a register');
    addCode(blockId, concat('xor ', operand.destination, ', ', operand.destination), comment);
  }

  Null addLea(Integer blockId, Operand destination, Operand source, String comment) {
    assert(source.kind == otIndirect, concat('can only lea from a memory location, not a ', source.kind, ', when trying to add "lea ', destination, ', ', source, '"'));
    assert(destination.kind == otRegister, 'can only lea to a register');
    addCode(blockId, concat('lea ', destination.destination, ', ', source.value), comment);
  }

  Null addPush(Integer blockId, Operand source, String comment) {
    if (source.isImmediate64()) {
      addCode(blockId, concat('mov r11, ', source.value), comment);
      addCode(blockId, concat('push r11'), concat('(indirect via r11 because ', source, ' is an imm64)'));
    } else {
      addCode(blockId, concat('push ', source.value), comment);
    }
  }

  Null addOpcode(Integer blockId, String opcode, OperandList operands, String comment) {
    String encode(Operand operand) {
      return operand.value;
    }
    addCode(blockId, concat(opcode, ' ', join(map(operands, encode) as StringList, ', ')), comment);
  }

  Integer addLabel(String label, StringNullable comment) {
    append(labels, label);
    StringList subcode = []:String;
    if (comment != null && comment != label) {
      append(subcode, concat('; ', comment));
    }
    append(subcode, concat(label, ':'));
    append(code, subcode);
    append(indents, 0);
    append(pendingComments, null);
    assert(len(code) == len(labels), 'labels and code are out of sync');
    return len(code) - 1;
  }

  Null addComment(Integer blockId, String message) {
    append(code[blockId], concat('  ', stringTimes(' ', indents[blockId]), '; ', message));
    pendingComments[blockId] = null;
  }

  Null addPendingComment(Integer blockId, String message) {
    pendingComments[blockId] = message;
  }

  Null addBlankLine(Integer blockId) {
    if (len(code[blockId]) > 1) {
      append(code[blockId], '');
    }
  }

  String serialize() {
    StringList fullCode = []:String;
    Integer index = 0;
    while (index < len(code)) {
      append(fullCode, concat(
        join(code[index], '\n'),
        '\n\n',
      ));
      index += 1;
    }
    return concat(
      '_drectve segment info alias(".drectve")\n',
      '  db \' /ENTRY:main \'\n',
      '_drectve ends\n',
      'option casemap:none\n',
      '\n',
      '; includes\n',
      join((includelibs.values() as StringList), '\n'),
      '\n\n',
      '; externs\n',
      join(externs, '\n'),
      '\n\n',
      '.const\n',
      join(const, '\n'),
      '\n\n',
      '.data\n',
      join(data, '\n'),
      '\n\n',
      '_BSS segment\n',
      join(bss, '\n'),
      '\n\n',
      '.code\n',
      '\n',
      'public main\n',
      joinList(fullCode),
      '\n',
      'end\n',
    );
  }

  Integer mainBlockId;

  Null constructor() {
    super.constructor();
    mainBlockId = addLabel('main', null);
  }
}
