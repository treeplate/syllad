import 'core.syd';
import 'syd-operands.syd';

class LowLevelInstruction extends Object {
  StringNullable opcode;
  AnythingList operands;
  StringNullable comment;
  Integer indent;

  String eval(Integer lineLength) {
    if (opcode == null) {
      assert(len(operands) == 0, 'no opcode, but at least one operand');
      if (comment == null) {
        return '';
      }
      return concat(stringTimes(' ', indent), '  ; ', comment);
    }
    String rawCode = concat(opcode, ' ', join(map(operands, concat) as StringList, ', '));
    String indentedCode = concat('  ', stringTimes(' ', indent), rawCode);
    if (comment == null) {
      return indentedCode;
    }
    return concat(padRight(indentedCode, lineLength, ' '), ' ; ', comment);
  }
  
  String toString() {
    // for debug purposes (hence hard-coded line length)
    return concat(eval(64), ' ; from LowLevelInstruction.toString'); 
  }

  Null constructor(StringNullable opcodeArg, AnythingList operandsArg, StringNullable commentArg, Integer indentArg) {
    assert(opcodeArg != '', 'passed empty string to LowLevelInstruction');
    assert((len(operandsArg) == 0) || (opcodeArg != null), 'operands with no opcode');
    opcode = opcodeArg;
    operands = operandsArg;
    comment = commentArg;
    indent = indentArg;
  }
}

fwdclass Assembler extends Object;
fwdclass AssemblerBlock(Integer, Assembler) extends Object;

class AssemblerBlock extends Object {
  Integer lineLength;
  Assembler assembler;

  Integer currentIndent = 0;
  StringNullable pendingComment = null;
  LowLevelInstructionList lines = []:LowLevelInstruction;
  Boolean deadCode = false;

  Null indent(NullFunction generateAssembler) {
    currentIndent += 2;
    generateAssembler(this);
    currentIndent -= 2;
  }

  Null addCode(String opcode, WhateverList operands, StringNullable comment) {
    assert(!contains(charsOf(opcode), ':'), 'use addLabel to add a label');
    if (!deadCode) {
      if (pendingComment != null) {
        append(lines, LowLevelInstruction(null, [], pendingComment, currentIndent));
      }
      AnythingList newList = [];
      for (op in operands) {
        if (op is Operand) {
          append(newList, (op as Operand).snapshot());
        } else {
          append(newList, op);
        }
      }
      append(lines, LowLevelInstruction(opcode, newList, comment, currentIndent));
    }
    pendingComment = null;
    if (opcode == 'jmp') {
      deadCode = true;
    }
  }

  Null addLabel(String label, StringNullable comment) {
    assert(!contains(charsOf(label), ':'), 'addLabel adds the colon, so should not be given a label with a colon');
    pendingComment = null;
    append(lines, LowLevelInstruction(concat(label, ':'), [], comment, currentIndent));
    deadCode = false;
  }

  Null addComment(String message) {
    if (!deadCode) {
      if (pendingComment != null) {
        append(lines, LowLevelInstruction(null, [], pendingComment, currentIndent));
        pendingComment = null;
      }
      append(lines, LowLevelInstruction(null, [], message, currentIndent));
    }
  }

  Null addPendingComment(String message) {
    pendingComment = message;
  }

  Null addBlankLine() {
    if (len(lines) > 1) {
      append(lines, LowLevelInstruction(null, [], null, currentIndent));
    }
  }

  Null addBlock(AssemblerBlock block) {
    for (line in block.lines) {
      append(lines, line);
    }
  }

  AssemblerBlock createBlock() {
    return AssemblerBlock(lineLength, assembler);
  }

  Null constructor(Integer lineLengthArg, Assembler assemblerArg) {
    super.constructor();
    lineLength = lineLengthArg;
    assembler = assemblerArg;
  }
}

class Assembler extends Object {
  Set includelibs = Set();
  StringList externs = []:String;
  StringList const = []:String;
  StringList data = []:String;
  StringList bss = []:String;
  StringList code = []:String;

  Integer lineLength = 64;

  Null addIncludeLib(String filename) {
    includelibs.add(concat('includelib ', filename));
  }

  Null addExternProc(String procname) {
    append(externs, concat('extern ', procname, ' : proc'));
  }

  Null addConst(String label, StringList lines, StringNullableList comments) {
    assert(len(lines) > 0, 'addConst got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = concat('  ', padRight(prefix, 12, ' '), ' ', lines[index]);
      StringNullable comment = comments[index];
      if (comment != null) {
        line = concat(padRight(line, lineLength, ' '), ' ; ', comment);
      }
      append(const, line);
      index += 1;
      prefix = '';
    }
  }

  Null addData(String label, StringList lines, StringNullableList comments) {
    // TODO: should save these in a map and print them in some reasonable order (like alphabetically by name)
    assert(len(lines) > 0, 'addData got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = concat('  ', padRight(prefix, 12, ' '), ' ', lines[index]);
      StringNullable comment = comments[index];
      if (comment != null) {
        line = concat(padRight(line, lineLength, ' '), ' ; ', comment);
      }
      append(const, line);
      index += 1;
      prefix = '';
    }
  }

  Null addBss(String label, Integer bytes, String comment) {
    String prefix;
    Integer count;
    if (bytes % 4 == 0) {
      prefix = 'dq';
      count = bytes / 4;
    } else {
      prefix = 'db';
      count = bytes;
    }
    append(bss,
      concat(
        padRight(
          concat('  ', label, ' ', prefix, ' ?', stringTimes(', ?', count - 1)),
          lineLength, ' ',
        ),
        ' ; ', comment,
      )
    );
  }

  Null addLabeledBlock(String label, AssemblerBlock block, StringNullable comment, StringNullable annotation) {
    if (len(code) > 0) {
      append(code, '');
    }
    if (comment != null && comment != label) {
      append(code, concat('; ', comment));
    }
    if (annotation != null) {
      append(code, concat('dq ', annotation));
    }
    append(code, concat(label, ':'));
    for (line in block.lines) {
      append(code, line.eval(lineLength));
    }
  }

  AssemblerBlock createBlock() {
    return AssemblerBlock(lineLength, this);
  }

  String serialize() {
    return concat(
      '_drectve segment info alias(".drectve")\n',
      '  db \' /ENTRY:main \'\n',
      '_drectve ends\n',
      'option casemap:none\n',
      '\n',
      '; includes\n',
      join((includelibs.values() as StringList), '\n'),
      '\n\n',
      '; externs\n',
      join(externs, '\n'),
      '\n\n',
      '.const\n',
      join(const, '\n'),
      '\n\n',
      '.data\n',
      join(data, '\n'),
      '\n\n',
      '_BSS segment\n',
      join(bss, '\n'),
      '\n\n',
      '.code\n',
      '\n',
      'public main\n',
      join(code, '\n'),
      '\n',
      'end\n',
    );
  }
}
