import 'core.syd';

String hex8(Integer value) {
  return concat('0', padLeft(hex(value), 2, '0'), 'h');
}

String hex32(Integer value) {
  return concat('0', padLeft(hex(value), 8, '0'), 'h');
}

String hex64(Integer value) {
  return concat('0', padLeft(hex(value), 16, '0'), 'h');
}

String stringLiteral(String value) {
  StringList buffer = []:String;
  Boolean quoted = false;
  for (char in scalarValues(value)) {
    if (char == 0x22 && quoted) {
      append(buffer, '""');
    } else if (char < 0x20 || char > 0x7e || char == 0x22) {
      if (quoted) {
        append(buffer, '"');
        quoted = false;
      }
      if (len(buffer) > 0) {
        append(buffer, ', ');
      }
      append(buffer, concat(padLeft(hex(char), 2, '0'), 'h'));
    } else {
      if (!quoted) {
        if (len(buffer) > 0) {
          append(buffer, ', ');
        }
        append(buffer, '"');
        quoted = true;
      }
      append(buffer, chr(char));
    }
  }
  if (quoted) {
    append(buffer, '"');
  }
  return joinList(buffer);
}

enum ot { Imm32 Imm64 Indirect Label LabelOffset Register }

class Operand extends Object {
  String operand;
  String location;
  ot kind;

  Null constructor(String operandArg, ot kindArg) {
    super.constructor();
    if (kindArg == otIndirect) {
      operand = concat('[', operandArg, ']');
      location = operandArg;
    } else if (kindArg == otLabel) {
      operand = operandArg;
      location = concat('offset ', operandArg);
    } else if (kindArg == otLabelOffset) {
      operand = concat('offset ', operandArg);
      // no location
    } else {
      operand = operandArg;
      // no location
    }
    kind = kindArg;
  }

  String toString() {
    return operand;
  }
}

Operand r8 = Operand('r8', otRegister);
Operand r9 = Operand('r9', otRegister);
Operand r10 = Operand('r10', otRegister);
Operand r11 = Operand('r11', otRegister);
Operand rax = Operand('rax', otRegister);
Operand rbx = Operand('rbx', otRegister);
Operand rcx = Operand('rcx', otRegister);
Operand rdx = Operand('rdx', otRegister);

class Assembler extends Object {
  StringList includelibs = []:String;
  StringList externs = []:String;
  StringList data = []:String;
  StringList labels = []:String;
  StringListList code = []:StringList;

  Integer lineLength = 64;

  Null addIncludeLib(String filename) {
    append(includelibs, concat('includelib ', filename));
  }

  Null addExternProc(String procname) {
    append(externs, concat('extern ', procname, ' : proc'));
  }

  Null addData(String label, StringList lines, StringNullableList comments) {
    assert(len(lines) > 0, 'addData got no data');
    Integer index = 0;
    String prefix = label;
    while (index < len(lines)) {
      String line = lines[index];
      StringNullable comment = comments[index];
      if (comment != null) {
        append(data, concat('  ', padRight(concat(padRight(prefix, 12, ' '), ' ', line), lineLength, ' '), ' ; ', comment));
      } else {
        append(data, concat('  ', padRight(label, 12, ' '), ' ', line));
      }
      index += 1;
      prefix = '';
    }
  }

  Null addCode(Integer blockId, String line, StringNullable comment) {
    if (comment != null) {
      append(code[blockId], concat('  ', padRight(line, lineLength, ' '), ' ; ', comment));
    } else {
      append(code[blockId], concat('  ', line));
    }
  }

  Null addMov(Integer blockId, Operand destination, Operand source, String comment) {
    if (source.kind == otImm64) {
      addCode(blockId, concat('mov r11, ', source.operand), comment);
      addCode(blockId, concat('mov ', destination.operand, ', r11'), concat('(indirect via r11 because ', source.operand, ' could be a 64 bit value)'));
    } else if (source.kind == otImm32) {
      addCode(blockId, concat('mov dword ptr ', destination.operand, ', ', source.operand), comment);
    } else {
      addCode(blockId, concat('mov ', destination.operand, ', ', source.operand), comment);
    }
  }

  Null addLea(Integer blockId, Operand destination, Operand source, String comment) {
    assert(source.kind == otIndirect, concat('can only lea from a memory location, not a ', source.kind, ', when trying to add "lea ', destination, ', ', source, '"'));
    assert(destination.kind == otRegister, 'can only lea to a register');
    addCode(blockId, concat('lea ', destination.operand, ', ', source.operand), comment);
  }

  Null addPush(Integer blockId, Operand source, String comment) {
    if (source.kind == otLabelOffset) {
      addCode(blockId, concat('mov r11, ', source.operand), comment);
      addCode(blockId, concat('push r11'), concat('(indirect via r11 because "', source.operand, '" cannot be used with push)'));
    } else {
      addCode(blockId, concat('push ', source.operand), comment);
    }
  }

  Integer addLabel(String label, StringNullable comment) {
    append(labels, label);
    StringList subcode = []:String;
    if (comment != null && comment != label) {
      append(subcode, concat('; ', comment));
    }
    append(subcode, concat(label, ':'));
    append(code, subcode);
    assert(len(code) == len(labels), 'labels and code are out of sync');
    return len(code) - 1;
  }

  Null addComment(Integer blockId, String message) {
    append(code[blockId], concat('  ; ', message));
  }

  Null addBlankLine(Integer blockId) {
    if (len(code[blockId]) > 1) {
      append(code[blockId], '');
    }
  }

  String serialize() {
    StringList fullCode = []:String;
    Integer index = 0;
    while (index < len(code)) {
      append(fullCode, concat(
        join(code[index], '\n'),
        '\n\n',
      ));
      index += 1;
    }
    return concat(
      '_drectve segment info alias(".drectve")\n',
      '  db \' /ENTRY:main \'\n',
      '_drectve ends\n',
      'option casemap:none\n',
      '\n',
      '; includes\n',
      join(includelibs, '\n'),
      '\n\n',
      '; externs\n',
      join(externs, '\n'),
      '\n\n',
      '.data\n',
      join(data, '\n'),
      '\n\n',
      '.code\n',
      '\n',
      'public main\n',
      joinList(fullCode),
      '\n',
      'end\n',
    );
  }

  Integer mainBlockId;

  Null constructor() {
    super.constructor();
    mainBlockId = addLabel('main', null);
  }
}
