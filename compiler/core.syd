// Standard Library
//stderr('Syllad core library 1.0 loaded.');

Integer min(Integer a, Integer b) {
  if (a > b) {
    return b;
  }
  return a;
}

Integer max(Integer a, Integer b) {
  if (a < b) {
    return b;
  }
  return a;
}

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  StringList buffer = []:String;
  Integer newValue = value; // parameters are final
  if (newValue < 0) {
    newValue = -newValue;
  }
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    append(buffer, chr(0x30 + digit));
  }
  if (value < 0) {
    append(buffer, '-');
  }
  Integer index = len(buffer);
  StringList flippedBuffer = []:String;
  while (index > 0) {
    index -= 1;
    append(flippedBuffer, buffer[index]);
  }
  return joinList(flippedBuffer);
}

String padRight(String line, Integer length, String padding) {
  return concat(line, stringTimes(padding, (length - len(charsOf(line))) / len(charsOf(padding))));
}

AnythingList map(WhateverList items, AnythingFunction callback) {
  AnythingList result = [];
  Integer index = 0;
  while (index < len(items)) {
    append(result, callback(items[index]));
    index += 1;
  }
  return result;
}

Integer compareString(String a, String b) {
  Integer index = 0;
  IntegerList aChars = copy(scalarValues(a));
  IntegerList bChars = copy(scalarValues(b));
  while (true) {
    if (index >= len(aChars)) {
      if (index >= len(bChars)) {
        return 0;
      }
      return -1;
    }
    if (index >= len(bChars)) {
      return 1;
    }
    Integer result = aChars[index] - bChars[index];
    if (result != 0) {
      return result;
    }
    index += 1;
  }
}

Integer quickSortPartition(WhateverList list, Integer begin, Integer end, IntegerFunction comparator) {
  Whatever pivotValue = list[end - 1];
  Integer leftIndex = begin - 1;
  Integer rightIndex = begin;
  while (rightIndex < end - 1) {
    if (comparator(list[rightIndex], pivotValue) < 0) {
      leftIndex += 1;
      Whatever temp = list[leftIndex];
      list[leftIndex] = list[rightIndex];
      list[rightIndex] = temp;
    }
    rightIndex += 1;
  }
  Whatever temp = list[leftIndex + 1];
  list[leftIndex + 1] = list[rightIndex];
  list[rightIndex] = temp;
  return leftIndex + 1;
}

Null quickSortRange(WhateverList list, Integer begin, Integer end, IntegerFunction comparator) {
  assert(begin + 1 < end, 'quickSortRange called with less than two items');
  Integer pivot = quickSortPartition(list, begin, end, comparator);
  if (begin + 1 < pivot) {
    quickSortRange(list, begin, pivot, comparator);
  }
  if (pivot + 2 < end) {
    quickSortRange(list, pivot + 1, end, comparator);
  }
}

Null sortWithComparator(WhateverList list, IntegerFunction comparator) {
  if (len(list) > 1) {
    quickSortRange(list, 0, len(list), comparator);
  }
}

Boolean contains(WhateverList list, Anything item) {
  for (entry in list) {
    if (entry == item) {
      return true;
    }
  }
  return false;
}

// OBJECTS

Integer lastObjectId = 0;

class Object {
  Null abstract() {
    throw(concat('called abstract method on ', className));
  }

  Integer internalObjectId;

  Null constructor() {
    internalObjectId = lastObjectId;
    lastObjectId += 1;
  }

  String toString() {
    return concat('<', className, '@', internalObjectId, '>');
  }
}

// COLLECTIONS

// This is a port of the xor variant of djb2, from http://www.cse.yorku.ca/~oz/hash.html
// The original assumed 8-bit characters; this version uses scalar values which are 21 bits,
// whether this makes any sense or not is unclear.
Integer hashString(String data) {
  Integer result = 5381;
  for (c in scalarValues(data)) {
    result = ((result << 5) + result) ^ c;
  }
  return result;
}

Integer hashAnything(Anything data) {
  if (data is Object) {
    return (data as Object).internalObjectId;
  }
  return hashString(concat(data));
}

// Map has set, get, remove, keys, values
// an implementation of .containsKey would be identical to get(n) != null, so just use that
class Map extends Object {
  // outer list is indexed by hash mod length
  // it is a sparse list (hence nullable)
  // each entry is a list of the things at that that hash code
  // each thing in that list is a key/value pair
  AnythingListListNullableList table = []:AnythingListListNullable;
  Integer length = 0;

  Null constructor() { }

  // protected
  Null nonGrowingSet(Anything key, Anything value) {
    assert(len(table) > 0, 'Cannot set without growing in an empty Map.');
    Integer hashCode = hashAnything(key);
    Integer entryIndex = hashCode % len(table);
    AnythingListListNullableList table = table;
    AnythingListListNullable entry = table[entryIndex];
    if (entry == null) {
      table[entryIndex] = [[key, value]]:AnythingList;
      length += 1;
      return;
    }
    for (record in entry!) {
      if (record[0] == key) {
        record[1] = value;
        return;
      }
    }
    append(entry!, [key, value]);
    length += 1;
  }

  Null remove(Anything key) { // included for completeness #ignore_unused
    assert(len(table) > 0, 'Cannot remove from an empty Map.');
    Integer hashCode = hashAnything(key);
    Integer entryIndex = hashCode % len(table);
    AnythingListListNullable entry = table[entryIndex];
    assert(entry != null, 'Cannot remove something not in the map.');
    for (record in entry!) {
      if (record[0] == key) {
        length -= 1;
        if (len(entry!) > 1) {
          AnythingListList newRecord = []:AnythingList;
          for (item in entry!) {
            if (item[0] != key) {
              append(newRecord, item);
            }
          }
          table[entryIndex] = newRecord;
        } else {
          table[entryIndex] = null;
        }
        return;
      }
    }
    assert(false, 'Cannot remove something not in the set.');
  }

  // protected
  Null grow() {
    AnythingListListNullableList oldTable = table;
    AnythingListListNullableList newTable = []:AnythingListListNullable;
    Integer oldSize = len(oldTable);
    Integer newSize = oldSize * 2 + 1;
    Integer index = 0;
    while (index < newSize) {
      append(newTable, null);
      index += 1;
    }
    table = newTable;
    length = 0; // gets reset by nonGrowingSet
    for (entry in oldTable) {
      if (entry != null) {
        for (record in entry!) {
          nonGrowingSet(record[0], record[1]);
        }
      }
    }
  }

  Null set(Anything key, Anything value) {
    if (len(table) <= length /* *1.3 */) {
      grow();
    }
    nonGrowingSet(key, value);
  }

  AnythingNullable get(Anything key) {
    if (len(table) == 0) {
      return null;
    }
    Integer hashCode = hashAnything(key);
    AnythingListListNullable entry = table[hashCode % len(table)];
    if (entry == null) {
      return null;
    }
    for (record in entry!) {
      if (record[0] == key) {
        return record[1];
      }
    }
    return null;
  }

  AnythingList keys() {
    AnythingList result = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry!) {
          append(result, record[0]);
        }
      }
    }
    return result;
  }

  AnythingList values() {
    AnythingList result = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry!) {
          append(result, record[1]);
        }
      }
    }
    return result;
  }

  String toString() {
    StringList items = []:String;
    for (entry in table) {
      if (entry != null) {
        for (record in entry!) {
          if (len(items) > 0) {
            append(items, ', ');
          }
          append(items, concat(record[0], ': ', record[1]));
        }
      }
    }
    return concat(
      '{',
      joinList(items),
      '}',
    );
  }
}

class Set extends Object {
  AnythingListNullableList table = []:AnythingListNullable;
  Integer length = 0;

  // protected
  Null nonGrowingAdd(Anything key) {
    assert(len(table) > 0, 'Cannot set without growing in an empty Set.');
    Integer hashCode = hashAnything(key);
    Integer entryIndex = hashCode % len(table);
    AnythingListNullable entry = table[entryIndex];
    if (entry == null) {
      table[entryIndex] = [key];
      length += 1;
      return;
    }
    for (record in entry!) {
      if (record == key) {
        return;
      }
    }
    append(entry!, key);
    length += 1;
  }

  Null remove(Anything key) {
    assert(len(table) > 0, 'Cannot remove from an empty Set.');
    Integer hashCode = hashAnything(key);
    Integer entryIndex = hashCode % len(table);
    AnythingListNullable entry = table[entryIndex];
    assert(entry != null, 'Cannot remove something not in the set.');
    for (record in entry!) {
      if (record == key) {
        length -= 1;
        if (len(entry!) > 1) {
          AnythingList newRecord = []:Anything;
          for (item in entry!) {
            if (item != key) {
              append(newRecord, item);
            }
          }
          table[entryIndex] = newRecord;
        } else {
          table[entryIndex] = null;
        }
        return;
      }
    }
    assert(false, 'Cannot remove something not in the set.');
  }

  // protected
  Null grow() {
    AnythingListNullableList oldTable = table;
    AnythingListNullableList newTable = []:AnythingListNullable;
    Integer oldSize = len(oldTable);
    Integer newSize = oldSize * 2 + 1;
    Integer index = 0;
    while (index < newSize) {
      append(newTable, null);
      index += 1;
    }
    length = 0; // gets reset by nonGrowingAdd
    table = newTable;
    for (entry in oldTable) {
      if (entry != null) {
        for (record in entry!) {
          nonGrowingAdd(record);
        }
      }
    }
  }

  Boolean has(Anything key) {
    if (len(table) == 0) {
      return false;
    }
    Integer hashCode = hashAnything(key);
    AnythingListNullable entry = table[hashCode % len(table)];
    if (entry == null) {
      return false;
    }
    for (record in entry!) {
      if (record == key) {
        return true;
      }
    }
    return false;
  }

  Null add(Anything key) {
    if (has(key)) {
      return;
    }
    if (len(table) <= length /* *1.3 */) {
      grow();
    }
    nonGrowingAdd(key);
    assert(has(key), 'add did not add');
  }

  AnythingList values() {
    AnythingList result = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry!) {
          append(result, record);
        }
      }
    }
    return result;
  }

  String toString() {
    StringList items = []:String;
    for (entry in table) {
      if (entry != null) {
        for (record in entry!) {
          if (len(items) > 0) {
            append(items, ', ');
          }
          append(items, concat(record));
        }
      }
    }
    return concat(
      '{',
      joinList(items),
      '}',
    );
  }
}

Boolean listEquals(WhateverList list1, WhateverList list2) {
  if (len(list1) != len(list2)) {
    return false;
  }
  Integer index = 0;
  while (index < len(list1)) {
    if (list1[index] != list2[index]) {
      return false;
    }
    index += 1;
  }
  return true;
}