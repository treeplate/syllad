import 'core.syd';
import 'syd-types.syd';
import 'syd-operands.syd';
import 'syd-slots.syd';

class Operation extends Object {
  SlotContext scope; // used to determine if we're going to mutate things in another scope in the stack frame
  Null constructor(SlotContext scopeArg) {
    super.constructor();
    scope = scopeArg;
  }
}
class OperationRead extends Operation { }
class OperationWrite extends Operation { }

// Reference counting style.
// - rcNever means that the slot is not reference counted at all, regardless.
// - rcOnStack means that it is in a slot that would be a GC root (GarbageCollectable and Strings are reference counted).
// - rcOnHeap means that it is in a slot that would not be a GC root (only Strings are reference counted).
enum rc { Never OnStack OnHeap }

class DynamicSlotStory extends Object {
  Slot slot;

  OperandNullableList values = []:OperandNullable;
  OperandNullableList dynamicTypes = []:OperandNullable;
  Integer depth = -1;

  OperationList operations = []:Operation;
  Integer position = 0;

  Boolean valuePinned = false;

  Null pinValue() {
    assert(!valuePinned, concat('tried to pin slot value twice: ', slot));
    valuePinned = true;
  }

  Null unpinValue() {
    assert(valuePinned, concat('tried to unpin unpinned slot value: ', slot));
    valuePinned = false;
  }

  Boolean typePinned = false;

  Null pinType() {
    assert(!typePinned, concat('tried to pin slot type twice: ', slot));
    typePinned = true;
  }

  Null unpinType() {
    assert(typePinned, concat('tried to unpin unpinned slot type: ', slot));
    typePinned = false;
  }

  Boolean expired = false;

  Boolean stillAlive() {
    return !expired;
  }

  Null recomputeExpired() {
    expired = expired || ((position >= len(operations)) && depth <= 1);
  }

  Null willRead(SlotContext scope) {
    assert(position == 0, 'willRead called out of order');
    assert(depth == -1, 'willRead called on initalized slot');
    append(operations, OperationRead(scope));
  }

  Null willWrite(SlotContext scope) {
    assert(position == 0, 'willWrite called out of order');
    assert(depth == -1, 'willRead called on initalized slot');
    append(operations, OperationWrite(scope));
  }

  Boolean debugReadForDecrefScheduled = false;

  Null willReadForDecref(SlotContext scope) {
    assert(!debugReadForDecrefScheduled, 'Called willReadForDecref twice');
    assert(depth > -1, 'willReadForDecref called on uninitalized slot');
    append(operations, OperationRead(scope));
    debugReadForDecrefScheduled = true;
  }

  Null didRead(SlotContext scope) {
    assert(len(operations) > position, concat('unplanned read of ', slot, '; operations were ', operations));
    assert(operations[position] is OperationRead, concat('unplanned read of ', slot, ' at position ', position, '; operations were ', operations));
    assert(operations[position].scope == scope, concat('unplanned read of ', slot, ' at position ', position, ' (scope mismatch; expected, ', operations[position].scope, ' but was in ', scope, ')'));
    position += 1;
    recomputeExpired();
  }

  Null didWrite(SlotContext scope) {
    assert(len(operations) > position, concat('unplanned write of ', slot, '; operations were ', operations));
    assert(operations[position] is OperationWrite, concat('unplanned write of ', slot, ' at position ', position, '; operations were ', operations));
    assert(operations[position].scope == scope, concat('unplanned write of ', slot, ' at position ', position, ' (scope mismatch)'));
    position += 1;
    recomputeExpired();
  }

  // Whether the slot is going to be mutated in another scope
  // before we next do anything with it in this scope.
  Boolean needsToBeMutable(SlotContext scope) {
    /*

      Consider a case like this:
    
      |
      | init as imm64 0h
      | write imm
      | read
      | write imm
      |
      | <= entering scope (do not make mutable)
      |
      +-->--+
            | read
      +--<--+
      |
      | read
      |
      | <= entering scope (do make mutable)
      |
      +-->--+
            | read
            | write
            |
      +--<--+
      |
      | read
    
    */
    Integer index = position;
    while (index < len(operations)) {
      if (operations[index] is OperationWrite) {
        return true;
      }
      index += 1;
    }
    return false;
  }

  Boolean debugWriteScheduled() {
    Integer index = position;
    while (index < len(operations)) {
      if (operations[index] is OperationWrite) {
        return true;
      }
      index += 1;
    }
    return false;
  }

  Null initialize(Operand valueArg, Operand dynamicTypeArg) {
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth == -1, concat('cannot initialize ', slot, ' more than once (depth is ', depth, ')'));
    assert(len(values) == 0, 'cannot initialize more than once');
    assert(position == 0, 'initialize called out of order');
    append(values, valueArg);
    append(dynamicTypes, dynamicTypeArg);
    depth = 1;
    recomputeExpired();
  }

  Null enterNestedScope() {
    assert(stillAlive(), 'cannot enter nested scope with expired slot');
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth > -1, concat('entered nested scope before initializing ', slot));
    assert(depth > 0, concat('entered nested scope after finalizing ', slot));
    assert(len(values) >= depth, 'depth desync');
    if (len(values) == depth) {
      append(values, values[depth - 1]);
      append(dynamicTypes, dynamicTypes[depth - 1]);
    } else {
      values[depth] = values[depth - 1];
      dynamicTypes[depth] = dynamicTypes[depth - 1];
    }
    depth += 1;
  }

  Null updateValue(OperandNullable newValue) {
    assert(newValue != null || !stillAlive(), 'cannot discard living slot');
    assert(!valuePinned, concat('cannot move pinned slot ', slot));
    assert(values[depth - 1] != null, 'cannot update discarded slot');
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth > -1, 'use initialize() to initialize a slot');
    assert(depth > 0, 'cannot use finalized slot');
    assert(depth == 1 || values[depth - 2]!.isMutable() || !debugWriteScheduled(), concat('cannot update ', slot, '; would not be able to restore value after exit\n  currently: ', values[depth - 1], '/', dynamicTypes[depth - 1], '\n  depth=', depth, '\n  operations=', operations));
    values[depth - 1] = newValue;
  }

  Null updateDynamicType(OperandNullable newDynamicType) {
    assert(newDynamicType != null || !stillAlive(), 'cannot discard living slot');
    assert(!typePinned, concat('cannot move pinned slot ', slot));
    assert(dynamicTypes[depth - 1] != null, 'cannot update discarded slot');
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth > -1, 'use initialize() to initialize a slot');
    assert(depth > 0, 'cannot use finalized slot');
    assert(depth == 1 || dynamicTypes[depth - 2]!.isMutable() || !debugWriteScheduled(), concat('cannot update ', slot, '; would not be able to restore type after exit'));
    dynamicTypes[depth - 1] = newDynamicType;
  }

  Null exitNestedScope() {
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(!valuePinned && !typePinned, concat('cannot exit nested scope while pinned (slot: ', slot, ')'));
    assert(depth > -1, concat('cannot exit nested scope of uninitialized slot ', slot));
    assert(depth > 0, 'cannot use finalized slot');
    depth -= 1;
    recomputeExpired();
  }

  Operand value() {
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth > -1, 'use initialize() to initialize a slot');
    assert(depth > 0, 'cannot use finalized slot');
    assert(values[depth - 1] != null || !stillAlive(), 'living slot was discarded');
    assert(values[depth - 1] != null, concat('called value() on discarded slot ', slot));
    return values[depth - 1];
  }

  Operand dynamicType() {
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    assert(depth > -1, 'use initialize() to initialize a slot');
    assert(depth > 0, 'cannot use finalized slot');
    assert(dynamicTypes[depth - 1] != null || !stillAlive(), 'living slot was discarded');
    assert(dynamicTypes[depth - 1] != null, 'called dynamicType() on discarded slot');
    return dynamicTypes[depth - 1];
  }

  OperandNullable previousValue(Integer delta) {
    assert(delta > 0, 'invalid delta');
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    Integer target = depth - (1 + delta);
    assert(target >= -1, 'tried to reach too far into slot history');
    if (target == -1) {
      return null;
    }
    return values[target];
  }

  OperandNullable previousDynamicType(Integer delta) {
    assert(delta > 0, 'invalid delta');
    assert(len(values) == len(dynamicTypes), 'DynamicSlot desync');
    Integer target = depth - (1 + delta);
    assert(target >= -1, 'tried to reach too far into slot history');
    if (target == -1) {
      return null;
    }
    return dynamicTypes[target];
  }

  Null constructor(Slot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class DynamicSlot extends Slot {
  StringNullable name;
  SlotContext homeScope;
  Boolean referencedFromMultipleStackFrames = false;
  Map stories = Map(); // root SlotContext -> DynamicSlotStory

  Boolean initializeToRegisterScheduled = false;
  OperandNullable initialValue = null;
  OperandNullable initialDynamicType = null;

  DynamicSlotStory storyFor(SlotContext scope) {
    SlotContext root = scope.slotScope();
    DynamicSlotStoryNullable story = stories.get(root) as DynamicSlotStoryNullable;
    if (story == null) {
      assert(!initializeToRegisterScheduled, 'A slot on which willInitializeToRegister has been called should only be used from one stack frame');
      story = DynamicSlotStory(this);
      assert((initialValue == null) == (initialDynamicType == null), 'initialize inconsistency');
      if (initialValue != null) {
        story!.initialize(initialValue!, initialDynamicType!);
      }
      stories.set(root, story);
    }
    return story;
  }

  Null pinValue(SlotContext scope) {
    storyFor(scope).pinValue();
  }

  Null unpinValue(SlotContext scope) {
    storyFor(scope).unpinValue();
  }

  Null pinType(SlotContext scope) {
    storyFor(scope).pinType();
  }

  Null unpinType(SlotContext scope) {
    storyFor(scope).unpinType();
  }

  Boolean stillAlive(SlotContext scope) {
    return storyFor(scope).stillAlive();
  }

  Null willRead(SlotContext scope) {
    if (scope.slotScope() != homeScope.slotScope()) {
      referencedFromMultipleStackFrames = true;
    }
    storyFor(scope).willRead(scope);
  }

  Null willWrite(SlotContext scope) {
    if (scope.slotScope() != homeScope.slotScope()) {
      referencedFromMultipleStackFrames = true;
    }
    storyFor(scope).willWrite(scope);
  }

  rc referenceCountStyle;

  Null willReadForDecref(SlotContext scope) {
    assert(referenceCountStyle != rcNever, concat('No need to read for decref if the slot is not reference counted (', this, ')'));
    storyFor(scope).willReadForDecref(scope);
  }

  Null didRead(SlotContext scope) {
    storyFor(scope).didRead(scope);
  }

  Null didWrite(SlotContext scope) {
    storyFor(scope).didWrite(scope);
  }

  Boolean needsToBeMutable(SlotContext scope) {
    return storyFor(scope).needsToBeMutable(scope);
  }

  Boolean debugWriteScheduled(SlotContext scope) {
    return storyFor(scope).debugWriteScheduled();
  }

  Null willInitializeToRegister(SlotContext scope) {
    storyFor(scope); // we need to make sure we make the story this is for
    assert(stories.length <= 1, 'willInitialize should only be called from a slot that has only been used from one stack frame');
    assert(!initializeToRegisterScheduled, 'Called willInitialize twice');
    initializeToRegisterScheduled = true;
  }

  Null initialize(SlotContextNullable scope, Operand valueArg, Operand dynamicTypeArg) {
    assert(initializeToRegisterScheduled == (valueArg is Register64Operand), concat('initializeToRegisterScheduled (', initializeToRegisterScheduled, ') and initialize value argument (', valueArg, ') are inconsistent'));
    initialValue = valueArg;
    initialDynamicType = dynamicTypeArg;
    for (story in stories.values()) {
      (story as DynamicSlotStory).initialize(initialValue!, initialDynamicType!);
    }
  }

  Null enterNestedScope(SlotContext scope) {
    storyFor(scope).enterNestedScope();
  }

  Null updateValue(SlotContext scope, OperandNullable newValue) {
    storyFor(scope).updateValue(newValue);
  }

  Null updateDynamicType(SlotContext scope, OperandNullable newDynamicType) {
    storyFor(scope).updateDynamicType(newDynamicType);
  }

  Null exitNestedScope(SlotContext scope) {
    storyFor(scope).exitNestedScope();
  }

  Operand value(SlotContext scope) {
    return storyFor(scope).value();
  }

  Operand dynamicType(SlotContext scope) {
    return storyFor(scope).dynamicType();
  }

  Operand previousValue(SlotContext scope, Integer delta) {
    OperandNullable operand = storyFor(scope).previousValue(delta);
    if (operand != null) {
      return operand;
    }
    return initialValue!;
  }

  Operand previousDynamicType(SlotContext scope, Integer delta) {
    OperandNullable operand = storyFor(scope).previousDynamicType(delta);
    if (operand != null) {
      return operand;
    }
    return initialDynamicType!;
  }

  Boolean valuePinned(SlotContext scope) {
    return storyFor(scope).valuePinned;
  }

  Boolean typePinned(SlotContext scope) {
    return storyFor(scope).typePinned;
  }

  Integer depth(SlotContext scope) {
    return storyFor(scope).depth;
  }

  Boolean isMutable() {
    return true;
  }

  String toString() {
    return concat('<', className, ':', staticType, ' ("', debugName, '")>');
  }

  Null constructor(Type staticTypeArg, SlotContext homeScopeArg, rc referenceCountStyleArg, StringNullable nameArg, String debugNameArg) {
    assert(!(staticTypeArg.neverReferenceCounted() && referenceCountStyleArg != rcNever), concat('no point reference counting a type (', staticTypeArg.name, ') that cannot be reference counted'));
    super.constructor(staticTypeArg, debugNameArg);
    name = nameArg;
    homeScope = homeScopeArg;
    referenceCountStyle = referenceCountStyleArg;
  }
}