import 'core.syd';
import 'syd-utils.syd';

// Tokenizer

// TODO: add "as" as a separate token to be able to parse "foo as bar" as a statement (currently becomes a variable declaration)
// TODO: add a test for this

enum ts {
  Top
  Identifier 
  SingleQuoteString 
  SingleQuoteStringCR 
  SingleQuoteStringEscape 
  DoubleQuoteString 
  DoubleQuoteStringCR 
  DoubleQuoteStringEscape
  Zero
  Integer
  HexStart
  Hex

  Period
  PeriodPeriod

  Plus
  Minus
  Asterisk
  Slash 
  Modulus
  Equals
  Bang
  LessThan 
  GreaterThan 
  Ampersand
  AmpersandAmpersand
  Caret
  VerticalBar
  VerticalBarVerticalBar

  LineComment 
  BlockComment
  BlockCommentCR
  BlockCommentAsterisk
  CR 
}

enum tt {
  Identifier // String
  String // String
  Integer // Integer
  OpenBrace
  CloseBrace
  OpenBracket
  CloseBracket
  OpenParen
  CloseParen
  Period
  Ellipsis
  Comma
  Colon
  Semicolon

  Plus
  PlusEquals
  Minus
  MinusEquals
  Asterisk
  AsteriskEquals
  Slash
  SlashEquals
  Modulus
  ModulusEquals
  Equals
  EqualsEquals
  Bang
  BangEquals
  LessThan
  LessThanLessThan
  LessThanEquals
  GreaterThan
  GreaterThanGreaterThan
  GreaterThanEquals
  Ampersand
  AmpersandEquals
  AmpersandAmpersand
  AmpersandAmpersandEquals
  Caret
  CaretEquals
  VerticalBar
  VerticalBarEquals
  VerticalBarVerticalBar
  VerticalBarVerticalBarEquals
  Tilde

  Eof
}

class Token extends Object {
  tt type;
  SourceLocation sourceLocation;
  Anything data;

  Null constructor(tt typeArg, SourceLocation sourceLocationArg, Anything dataArg) {
    super.constructor();
    type = typeArg;
    sourceLocation = sourceLocationArg;
    data = dataArg;
  }

  //#override
  String toString() {
    if (type == tt.Identifier) {
      return concat('identifier "', data, '"');
    }
    if (type == tt.String) {
      return concat('string literal');
    }
    if (type == tt.Integer) {
      return concat('integer literal "', data, '"');
    }

    if (type == tt.OpenBrace) {
      return '"{"';
    }
    if (type == tt.CloseBrace) {
      return '"}"';
    }
    if (type == tt.OpenBracket) {
      return '"["';
    }
    if (type == tt.CloseBracket) {
      return '"]"';
    }
    if (type == tt.OpenParen) {
      return '"("';
    }
    if (type == tt.CloseParen) {
      return '")"';
    }
    if (type == tt.Period) {
      return '"."';
    }
    if (type == tt.Ellipsis) {
      return '"..."';
    }
    if (type == tt.Comma) {
      return '","';
    }
    if (type == tt.Colon) {
      return '":"';
    }
    if (type == tt.Semicolon) {
      return '";"';
    }

    if (type == tt.Plus) {
      return '"+"';
    }
    if (type == tt.PlusEquals) {
      return '"+="';
    }
    if (type == tt.Minus) {
      return '"-"';
    }
    if (type == tt.MinusEquals) {
      return '"-="';
    }
    if (type == tt.Asterisk) {
      return '"*"';
    }
    if (type == tt.AsteriskEquals) {
      return '"*="';
    }
    if (type == tt.Slash) {
      return '"/"';
    }
    if (type == tt.SlashEquals) {
      return '"/="';
    }
    if (type == tt.Modulus) {
      return '"%"';
    }
    if (type == tt.ModulusEquals) {
      return '"%="';
    }
    if (type == tt.Equals) {
      return '"="';
    }
    if (type == tt.EqualsEquals) {
      return '"=="';
    }
    if (type == tt.Bang) {
      return '"!"';
    }
    if (type == tt.BangEquals) {
      return '"!="';
    }
    if (type == tt.LessThan) {
      return '"<"';
    }
    if (type == tt.LessThanLessThan) {
      return '"<<"';
    }
    if (type == tt.LessThanEquals) {
      return '"<="';
    }
    if (type == tt.GreaterThan) {
      return '">"';
    }
    if (type == tt.GreaterThanGreaterThan) {
      return '">>"';
    }
    if (type == tt.GreaterThanEquals) {
      return '">="';
    }
    if (type == tt.Ampersand) {
      return '"&"';
    }
    if (type == tt.AmpersandEquals) {
      return '"&="';
    }
    if (type == tt.AmpersandAmpersand) {
      return '"&&"';
    }
    if (type == tt.AmpersandAmpersandEquals) {
      return '"&&="';
    }
    if (type == tt.Caret) {
      return '"^"';
    }
    if (type == tt.CaretEquals) {
      return '"^="';
    }
    if (type == tt.VerticalBar) {
      return '"|"';
    }
    if (type == tt.VerticalBarEquals) {
      return '"|="';
    }
    if (type == tt.VerticalBarVerticalBar) {
      return '"||"';
    }
    if (type == tt.VerticalBarVerticalBarEquals) {
      return '"||="';
    }
    if (type == tt.Tilde) {
      return '"~"';
    }

    if (type == tt.Eof) {
      return 'end of file';
    }

    assert(false, concat('don\t know how to describe token with type ', type));
    return concat(type);
  }
}

TokenList tokenize(IntegerIterable source, String filename, Boolean internal) {
  stderr(concat('tokenizing "', filename, '"...'));
  Integer lineNo = 1;
  Integer colNo = 0;
  Integer lastInterestingLineNo = -1;
  Integer lastInterestingColNo = -1;
  ts state = ts.Top;
  Anything buffer;
  TokenList tokens = []:Token;
  for (ch in source) {
    colNo += 1;
    while (true) {
      if (state == ts.Top) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) {
          state = ts.CR;
          break;
        } else if (ch == 0x20) { // space
          break;
        } else if (ch == 0x21) { // !
          state = ts.Bang;
          break;
        } else if (ch == 0x22) { // "
          state = ts.DoubleQuoteString;
          buffer = []:String;
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x25) { // %
          state = ts.Modulus;
          break;
        } else if (ch == 0x26) { // &
          state = ts.Ampersand;
          break;
        } else if (ch == 0x27) { // '
          state = ts.SingleQuoteString;
          buffer = []:String;
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x28) { // (
          append(tokens, Token(tt.OpenParen, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x29) { // )
          append(tokens, Token(tt.CloseParen, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x2a) { // *
          state = ts.Asterisk;
          break;
        } else if (ch == 0x2b) { // +
          state = ts.Plus;
          break;
        } else if (ch == 0x2c) { // ,
          append(tokens, Token(tt.Comma, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x2d) { // -
          state = ts.Minus;
          break;
        } else if (ch == 0x2e) { // .
          state = ts.Period;
          break;
        } else if (ch == 0x2f) { // /
          state = ts.Slash;
          break;
        } else if (ch == 0x30) { // 0
          state = ts.Zero;
          break;
        } else if (ch >= 0x31 && ch <= 0x39) { // 1-9
          state = ts.Integer;
          buffer = ch - 0x30;
          break;
        } else if (ch == 0x3a) { // :
          append(tokens, Token(tt.Colon, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x3b) { // ;
          append(tokens, Token(tt.Semicolon, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x3c) { // <
          state = ts.LessThan;
          break;
        } else if (ch == 0x3d) { // =
          state = ts.Equals;
          break;
        } else if (ch == 0x3e) { // >
          state = ts.GreaterThan;
          break;
        } else if ((ch >= 0x41 && ch <= 0x5a) || // A-Z
                   (ch >= 0x61 && ch <= 0x7a) || // a-z
                   (ch == 0x5f)) { // _
          state = ts.Identifier;
          buffer = [chr(ch)];
          break;
        } else if (ch == 0x5b) { // [
          append(tokens, Token(tt.OpenBracket, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x5d) { // ]
          append(tokens, Token(tt.CloseBracket, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x5e) { // ^
          state = ts.Caret;
          break;
        } else if (ch == 0x7b) { // {
          append(tokens, Token(tt.OpenBrace, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x7c) { // |
          state = ts.VerticalBar;
          break;
        } else if (ch == 0x7d) { // }
          append(tokens, Token(tt.CloseBrace, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x7e) { // ~
          append(tokens, Token(tt.Tilde, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else {
          throw(concat('unexpected character U+', padLeft(hex(ch), 4, "0"), ' at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
          break;
        }
      } else if (state == ts.Identifier) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x5a) || // A-Z
            (ch >= 0x61 && ch <= 0x7a) || // a-z
            (ch == 0x5f)) { // _
          append(cast(buffer), chr(ch));
          break;
        } else if (internal && ch == 0x23) { /* # */
          append(cast(buffer), chr(ch));
          append(tokens, Token(tt.Identifier, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Identifier, SourceLocation(lineNo, colNo - 1, filename), joinList(cast(buffer))));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.SingleQuoteString) {
        if (ch == 0x27) { // '
          append(tokens, Token(tt.String, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = ts.Top; 
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = ts.SingleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = ts.SingleQuoteStringCR;
          }
          break;
        }
      } else if (state == ts.SingleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = ts.SingleQuoteString;
        // no break, reprocess in ts.SingleQuoteString
      } else if (state == ts.SingleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = ts.SingleQuoteString;
          break;
        } else if (ch == 0x72) { // r
          append(cast(buffer), '\r');
          state = ts.SingleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = ts.SingleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = ts.SingleQuoteStringCR;
          }
          break;
        }
      } else if (state == ts.DoubleQuoteString) {
        if (ch == 0x22) { // "
          append(tokens, Token(tt.String, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = ts.Top;
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = ts.DoubleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = ts.DoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == ts.DoubleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = ts.DoubleQuoteString;
        // no break, reprocess in ts.DoubleQuoteString
      } else if (state == ts.DoubleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = ts.DoubleQuoteString;
          break;
        } else if (ch == 0x72) { // r
          append(cast(buffer), '\r');
          state = ts.DoubleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = ts.DoubleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = ts.DoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == ts.Zero) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          state = ts.Integer;
          buffer = 0;
          // no break, reprocess in ts.Integer
        } else if (ch == 0x58 || ch == 0x78) { // x, X
          state = ts.HexStart;
          break;
        } else {
          append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo - 1, filename), 0));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Integer) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 10 + ch - 0x30;
          break;
        } else {
          append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo - 1, filename), buffer));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.HexStart) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x46) || // A-F
            (ch >= 0x61 && ch <= 0x66)) { // a-f
          state = ts.Hex;
          buffer = 0;
          // no break, reprocess in ts.Hex
        } else {
          throw(concat('unexpected character ', padLeft(hex(ch), 4, "0"), ' in hex literal at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
        }
      } else if (state == ts.Hex) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 0x10 + ch - 0x30;
          break;
        } else if (ch >= 0x41 && ch <= 0x46) { // A-F
          buffer = (cast(buffer) * 0x10 + ch - 0x41) + 10;
          break;
        } else if (ch >= 0x61 && ch <= 0x66) { // a-f
          buffer = (cast(buffer) * 0x10 + ch - 0x61) + 10;
          break;
        } else {
          append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo - 1, filename), buffer));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }

      } else if (state == ts.Period) {
        if (ch == 0x2e) { // .
          state = ts.PeriodPeriod;
          break;
        } else {
          append(tokens, Token(tt.Period, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.PeriodPeriod) {
        if (ch == 0x2e) { // .
          append(tokens, Token(tt.Ellipsis, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          throw(concat('unexpected character U+', padLeft(hex(ch), 4, "0"), ' at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
        }

      } else if (state == ts.Plus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.PlusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Plus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Minus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.MinusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Minus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Asterisk) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.AsteriskEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Asterisk, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Slash) {
        if (ch == 0x2a) { // *
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          state = ts.BlockComment;
          break;
        } else if (ch == 0x2f) { // /
          state = ts.LineComment;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(tt.SlashEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Slash, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Modulus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.ModulusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Modulus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Equals) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.EqualsEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Equals, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Bang) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.BangEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Bang, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.LessThan) {
        if (ch == 0x3c) { // <
          append(tokens, Token(tt.LessThanLessThan, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(tt.LessThanEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.LessThan, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.GreaterThan) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.GreaterThanEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else if (ch == 0x3e) { // >
          append(tokens, Token(tt.GreaterThanGreaterThan, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.GreaterThan, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Ampersand) {
        if (ch == 0x26) { // &
          state = ts.AmpersandAmpersand;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(tt.AmpersandEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Ampersand, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.AmpersandAmpersand) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.AmpersandAmpersandEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.AmpersandAmpersand, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.Caret) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.CaretEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.Caret, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.VerticalBar) {
        if (ch == 0x7c) { // |
          state = ts.VerticalBarVerticalBar;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(tt.VerticalBarEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.VerticalBar, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.VerticalBarVerticalBar) {
        if (ch == 0x3d) { // =
          append(tokens, Token(tt.VerticalBarVerticalBarEquals, SourceLocation(lineNo, colNo, filename), null));
          state = ts.Top;
          break;
        } else {
          append(tokens, Token(tt.VerticalBarVerticalBar, SourceLocation(lineNo, colNo - 1, filename), null));
          state = ts.Top;
          // no break, reprocess in ts.Top
        }
      } else if (state == ts.LineComment) {
        if (ch == 0x0a) {
          state = ts.Top;
          // no break, reprocess in ts.Top
        } else if (ch == 0x0d) {
          state = ts.CR;
          break;
        } else {
          // Ignore until end of line.
          break;
        }
      } else if (state == ts.BlockComment) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) { // CR
          state = ts.BlockCommentCR;
          break;
        } else if (ch == 0x2a) { // *
          state = ts.BlockCommentAsterisk;
          break;
        } else {
          // Ignore until end of block.
          break;
        }
      } else if (state == ts.BlockCommentCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = ts.BlockComment;
        // no break, reprocess in ts.BlockComment
      } else if (state == ts.BlockCommentAsterisk) {
        if (ch == 0x2f) { // /
          state = ts.Top;
          break;
        } else {
          state = ts.BlockComment;
          // no break, reprocess in ts.BlockComment
        }
      } else if (state == ts.CR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = ts.Top;
        // no break, reprocess in ts.Top
      } else {
        throw(concat('unknown state ', state));
      }
    }
  }
  // Handle EOF
  if (state == ts.Top) {
    // no effect
  } else if (state == ts.Identifier) {
    append(tokens, Token(tt.Identifier, SourceLocation(lineNo, colNo, filename), joinList(buffer as WhateverList)));
  } else if (state == ts.SingleQuoteString) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.SingleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.SingleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.DoubleQuoteString) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.DoubleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.DoubleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.Zero) {
    append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo, filename), 0));
  } else if (state == ts.Integer) {
    append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo, filename), buffer));
  } else if (state == ts.HexStart) {
    throw(concat('incomplete hex literal at end of ', filename));
  } else if (state == ts.Hex) {
    append(tokens, Token(tt.Integer, SourceLocation(lineNo, colNo, filename), buffer));

  } else if (state == ts.Period) {
    append(tokens, Token(tt.Period, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.PeriodPeriod) {
    throw(concat('incomplete ellipsis at end of ', filename));

  } else if (state == ts.Plus) {
    append(tokens, Token(tt.Plus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Minus) {
    append(tokens, Token(tt.Minus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Asterisk) {
    append(tokens, Token(tt.Asterisk, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Slash) {
    append(tokens, Token(tt.Slash, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Modulus) {
    append(tokens, Token(tt.Modulus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Equals) {
    append(tokens, Token(tt.Equals, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Bang) {
    append(tokens, Token(tt.Bang, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.LessThan) {
    append(tokens, Token(tt.LessThan, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.GreaterThan) {
    append(tokens, Token(tt.GreaterThan, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Ampersand) {
    append(tokens, Token(tt.Ampersand, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.AmpersandAmpersand) {
    append(tokens, Token(tt.AmpersandAmpersand, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.Caret) {
    append(tokens, Token(tt.Caret, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.VerticalBar) {
    append(tokens, Token(tt.VerticalBar, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == ts.VerticalBarVerticalBar) {
    append(tokens, Token(tt.VerticalBarVerticalBar, SourceLocation(lineNo, colNo, filename), null));

  } else if (state == ts.LineComment) {
    // file terminated with line comment
  } else if (state == ts.BlockComment) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.BlockCommentCR) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.BlockCommentAsterisk) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == ts.CR) {
    // file terminated with newline
  } else {
    throw(concat('unknown state ', state));
  }
  append(tokens, Token(tt.Eof, SourceLocation(lineNo, colNo, filename), null));
  return tokens;
}

class TokenConsumer extends Object {
  TokenList tokens;
  Integer index;

  SourceLocation lastLocation() {
    return tokens[index - 1].sourceLocation;
  }

  Boolean isNext(tt tokenType) {
    return tokens[index].type == tokenType;
  }
  
  Boolean isNext2(tt tokenType1, tt tokenType2) {
    return index + 1 < len(tokens)
        && tokens[index    ].type == tokenType1
        && tokens[index + 1].type == tokenType2;
  }
  
  Boolean isNextIdentifier(String identifier) {
    Token token = tokens[index];
    return token.type == tt.Identifier && token.data == identifier;
  }
  
  String butFound(String what, String description) {
    return concat('Expected ', what, ' but found ', description, ' at ', tokens[index].sourceLocation);
  }
  
  String expected(String what) {
    return butFound(what, concat(tokens[index]));
  }

  String readIdentifier() {
    if (!isNext(tt.Identifier)) {
      throw(concat(expected('identifier')));
    }
    String result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  String readString() {
    if (!isNext(tt.String)) {
      throw(concat(expected('string literal')));
    }
    String result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  Integer readInteger() {
    if (!isNext(tt.Integer)) {
      throw(concat(expected('integer literal')));
    }
    Integer result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  Null expectIdentifier(String identifier) {
    if (!isNext(tt.Identifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    if (!isNextIdentifier(identifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    index = index + 1;
  }
  
  Null expectPunctuation(tt punctuation) {
    if (!isNext(punctuation)) {
      throw(concat(expected(concat(Token(punctuation, SourceLocation(-1, -1, ''), null)))));
    }
    index = index + 1;
  }
  
  Null constructor(TokenList tokensArg) {
    tokens = tokensArg;
    index = 0;
  }
}