import 'core.syd';
import 'syd-utils.syd';

// Tokenizer

enum ts {
  Top
  Identifier 
  SingleQuoteString 
  SingleQuoteStringCR 
  SingleQuoteStringEscape 
  DoubleQuoteString 
  DoubleQuoteStringCR 
  DoubleQuoteStringEscape
  Zero
  Integer
  HexStart
  Hex

  Period
  PeriodPeriod

  Plus
  Minus
  Asterisk
  Slash 
  Modulus
  Equals
  Bang
  LessThan 
  GreaterThan 
  Ampersand 
  Caret
  VerticalBar 

  LineComment 
  BlockComment
  BlockCommentCR
  BlockCommentAsterisk
  CR 
}

enum tt {
  Identifier // String
  String // String
  Integer // Integer
  OpenBrace
  CloseBrace
  OpenBracket
  CloseBracket
  OpenParen
  CloseParen
  Period
  Ellipsis
  Comma
  Colon
  Semicolon

  Plus
  PlusEquals
  Minus
  MinusEquals
  Asterisk
  AsteriskEquals
  Slash
  SlashEquals
  Modulus
  ModulusEquals
  Equals
  EqualsEquals
  Bang
  BangEquals
  LessThan
  LessThanLessThan
  LessThanEquals
  GreaterThan
  GreaterThanGreaterThan
  GreaterThanEquals
  Ampersand
  AmpersandEquals
  AmpersandAmpersand
  Caret
  CaretEquals
  VerticalBar
  VerticalBarEquals
  VerticalBarVerticalBar
  Tilde

  Eof
}

class Token extends Object {
  tt type;
  SourceLocation sourceLocation;
  Anything data;

  Null constructor(tt typeArg, SourceLocation sourceLocationArg, Anything dataArg) {
    super.constructor();
    type = typeArg;
    sourceLocation = sourceLocationArg;
    data = dataArg;
  }

  String toString() {
    if (type == ttIdentifier) {
      return concat('identifier "', data, '"');
    }
    if (type == ttString) {
      return concat('string literal');
    }
    if (type == ttInteger) {
      return concat('integer literal "', data, '"');
    }

    if (type == ttOpenBrace) {
      return '"{"';
    }
    if (type == ttCloseBrace) {
      return '"}"';
    }
    if (type == ttOpenBracket) {
      return '"["';
    }
    if (type == ttCloseBracket) {
      return '"]"';
    }
    if (type == ttOpenParen) {
      return '"("';
    }
    if (type == ttCloseParen) {
      return '")"';
    }
    if (type == ttPeriod) {
      return '"."';
    }
    if (type == ttEllipsis) {
      return '"..."';
    }
    if (type == ttComma) {
      return '","';
    }
    if (type == ttColon) {
      return '":"';
    }
    if (type == ttSemicolon) {
      return '";"';
    }

    if (type == ttPlus) {
      return '"+"';
    }
    if (type == ttPlusEquals) {
      return '"+="';
    }
    if (type == ttMinus) {
      return '"-"';
    }
    if (type == ttMinusEquals) {
      return '"-="';
    }
    if (type == ttAsterisk) {
      return '"*"';
    }
    if (type == ttAsteriskEquals) {
      return '"*="';
    }
    if (type == ttSlash) {
      return '"/"';
    }
    if (type == ttSlashEquals) {
      return '"/="';
    }
    if (type == ttModulus) {
      return '"%"';
    }
    if (type == ttModulusEquals) {
      return '"%="';
    }
    if (type == ttEquals) {
      return '"="';
    }
    if (type == ttEqualsEquals) {
      return '"=="';
    }
    if (type == ttBang) {
      return '"!"';
    }
    if (type == ttBangEquals) {
      return '"!="';
    }
    if (type == ttLessThan) {
      return '"<"';
    }
    if (type == ttLessThanLessThan) {
      return '"<<"';
    }
    if (type == ttLessThanEquals) {
      return '"<="';
    }
    if (type == ttGreaterThan) {
      return '">"';
    }
    if (type == ttGreaterThanGreaterThan) {
      return '">>"';
    }
    if (type == ttGreaterThanEquals) {
      return '">="';
    }
    if (type == ttAmpersand) {
      return '"&"';
    }
    if (type == ttAmpersandEquals) {
      return '"&="';
    }
    if (type == ttAmpersandAmpersand) {
      return '"&&"';
    }
    if (type == ttCaret) {
      return '"^"';
    }
    if (type == ttCaretEquals) {
      return '"^="';
    }
    if (type == ttVerticalBar) {
      return '"|"';
    }
    if (type == ttVerticalBarEquals) {
      return '"|="';
    }
    if (type == ttVerticalBarVerticalBar) {
      return '"||"';
    }
    if (type == ttTilde) {
      return '"~"';
    }

    if (type == ttEof) {
      return 'end of file';
    }

    assert(false, concat('don\t know how to describe token with type ', type));
    return concat(type);
  }
}

TokenList tokenize(IntegerIterable source, String filename, Boolean internal) {
  stderr(concat('tokenizing "', filename, '"...'));
  Integer lineNo = 1;
  Integer colNo = 0;
  Integer lastInterestingLineNo = -1;
  Integer lastInterestingColNo = -1;
  ts state = tsTop;
  Anything buffer;
  TokenList tokens = []:Token;
  for (ch in source) {
    colNo += 1;
    while (true) {
      if (state == tsTop) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) {
          state = tsCR;
          break;
        } else if (ch == 0x20) { // space
          break;
        } else if (ch == 0x21) { // !
          state = tsBang;
          break;
        } else if (ch == 0x22) { // "
          state = tsDoubleQuoteString;
          buffer = []:String;
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x25) { // %
          state = tsModulus;
          break;
        } else if (ch == 0x26) { // &
          state = tsAmpersand;
          break;
        } else if (ch == 0x27) { // '
          state = tsSingleQuoteString;
          buffer = []:String;
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x28) { // (
          append(tokens, Token(ttOpenParen, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x29) { // )
          append(tokens, Token(ttCloseParen, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x2a) { // *
          state = tsAsterisk;
          break;
        } else if (ch == 0x2b) { // +
          state = tsPlus;
          break;
        } else if (ch == 0x2c) { // ,
          append(tokens, Token(ttComma, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x2d) { // -
          state = tsMinus;
          break;
        } else if (ch == 0x2e) { // .
          state = tsPeriod;
          break;
        } else if (ch == 0x2f) { // /
          state = tsSlash;
          break;
        } else if (ch == 0x30) { // 0
          state = tsZero;
          break;
        } else if (ch >= 0x31 && ch <= 0x39) { // 1-9
          state = tsInteger;
          buffer = ch - 0x30;
          break;
        } else if (ch == 0x3a) { // :
          append(tokens, Token(ttColon, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x3b) { // ;
          append(tokens, Token(ttSemicolon, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x3c) { // <
          state = tsLessThan;
          break;
        } else if (ch == 0x3d) { // =
          state = tsEquals;
          break;
        } else if (ch == 0x3e) { // >
          state = tsGreaterThan;
          break;
        } else if ((ch >= 0x41 && ch <= 0x5a) || // A-Z
                   (ch >= 0x61 && ch <= 0x7a) || // a-z
                   (ch == 0x5f)) { // _
          state = tsIdentifier;
          buffer = [chr(ch)];
          break;
        } else if (ch == 0x5b) { // [
          append(tokens, Token(ttOpenBracket, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x5d) { // ]
          append(tokens, Token(ttCloseBracket, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x5e) { // ^
          state = tsCaret;
          break;
        } else if (ch == 0x7b) { // {
          append(tokens, Token(ttOpenBrace, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x7c) { // |
          state = tsVerticalBar;
          break;
        } else if (ch == 0x7d) { // }
          append(tokens, Token(ttCloseBrace, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else if (ch == 0x7e) { // ~
          append(tokens, Token(ttTilde, SourceLocation(lineNo, colNo, filename), null));
          break;
        } else {
          throw(concat('unexpected character U+', padLeft(hex(ch), 4, "0"), ' at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
          break;
        }
      } else if (state == tsIdentifier) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x5a) || // A-Z
            (ch >= 0x61 && ch <= 0x7a) || // a-z
            (ch == 0x5f)) { // _
          append(cast(buffer), chr(ch));
          break;
        } else if (internal && ch == 0x23) { /* # */
          append(cast(buffer), chr(ch));
          append(tokens, Token(ttIdentifier, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttIdentifier, SourceLocation(lineNo, colNo - 1, filename), joinList(cast(buffer))));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsSingleQuoteString) {
        if (ch == 0x27) { // '
          append(tokens, Token(ttString, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = tsTop; 
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = tsSingleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsSingleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsSingleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsSingleQuoteString;
        // no break, reprocess in tsSingleQuoteString
      } else if (state == tsSingleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = tsSingleQuoteString;
          break;
        } else if (ch == 0x72) { // r
          append(cast(buffer), '\r');
          state = tsSingleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = tsSingleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsSingleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsDoubleQuoteString) {
        if (ch == 0x22) { // "
          append(tokens, Token(ttString, SourceLocation(lineNo, colNo, filename), joinList(cast(buffer))));
          state = tsTop;
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = tsDoubleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsDoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsDoubleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsDoubleQuoteString;
        // no break, reprocess in tsDoubleQuoteString
      } else if (state == tsDoubleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = tsDoubleQuoteString;
          break;
        } else if (ch == 0x72) { // r
          append(cast(buffer), '\r');
          state = tsDoubleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = tsDoubleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsDoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsZero) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          state = tsInteger;
          buffer = 0;
          // no break, reprocess in tsInteger
        } else if (ch == 0x58 || ch == 0x78) { // x, X
          state = tsHexStart;
          break;
        } else {
          append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo - 1, filename), 0));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsInteger) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 10 + ch - 0x30;
          break;
        } else {
          append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo - 1, filename), buffer));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsHexStart) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x46) || // A-F
            (ch >= 0x61 && ch <= 0x66)) { // a-f
          state = tsHex;
          buffer = 0;
          // no break, reprocess in tsHex
        } else {
          throw(concat('unexpected character ', padLeft(hex(ch), 4, "0"), ' in hex literal at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
        }
      } else if (state == tsHex) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 0x10 + ch - 0x30;
          break;
        } else if (ch >= 0x41 && ch <= 0x46) { // A-F
          buffer = (cast(buffer) * 0x10 + ch - 0x41) + 10;
          break;
        } else if (ch >= 0x61 && ch <= 0x66) { // a-f
          buffer = (cast(buffer) * 0x10 + ch - 0x61) + 10;
          break;
        } else {
          append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo - 1, filename), buffer));
          state = tsTop;
          // no break, reprocess in tsTop
        }

      } else if (state == tsPeriod) {
        if (ch == 0x2e) { // .
          state = tsPeriodPeriod;
          break;
        } else {
          append(tokens, Token(ttPeriod, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsPeriodPeriod) {
        if (ch == 0x2e) { // .
          append(tokens, Token(ttEllipsis, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          throw(concat('unexpected character U+', padLeft(hex(ch), 4, "0"), ' at ', SourceLocation(lineNo, colNo, filename), ': ', chr(ch)));
        }

      } else if (state == tsPlus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttPlusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttPlus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsMinus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttMinusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttMinus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsAsterisk) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttAsteriskEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttAsterisk, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsSlash) {
        if (ch == 0x2a) { // *
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          state = tsBlockComment;
          break;
        } else if (ch == 0x2f) { // /
          state = tsLineComment;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(ttSlashEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttSlash, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsModulus) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttModulusEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttModulus, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsEquals) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttEqualsEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttEquals, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsBang) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttBangEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttBang, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsLessThan) {
        if (ch == 0x3c) { // <
          append(tokens, Token(ttLessThanLessThan, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(ttLessThanEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttLessThan, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsGreaterThan) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttGreaterThanEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else if (ch == 0x3e) { // >
          append(tokens, Token(ttGreaterThanGreaterThan, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttGreaterThan, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsAmpersand) {
        if (ch == 0x26) { // &
          append(tokens, Token(ttAmpersandAmpersand, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(ttAmpersandEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttAmpersand, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsCaret) {
        if (ch == 0x3d) { // =
          append(tokens, Token(ttCaretEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttCaret, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsVerticalBar) {
        if (ch == 0x7c) { // |
          append(tokens, Token(ttVerticalBarVerticalBar, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, Token(ttVerticalBarEquals, SourceLocation(lineNo, colNo, filename), null));
          state = tsTop;
          break;
        } else {
          append(tokens, Token(ttVerticalBar, SourceLocation(lineNo, colNo - 1, filename), null));
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsLineComment) {
        if (ch == 0x0a) {
          state = tsTop;
          // no break, reprocess in tsTop
        } else if (ch == 0x0d) {
          state = tsCR;
          break;
        } else {
          // Ignore until end of line.
          break;
        }
      } else if (state == tsBlockComment) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) { // CR
          state = tsBlockCommentCR;
          break;
        } else if (ch == 0x2a) { // *
          state = tsBlockCommentAsterisk;
          break;
        } else {
          // Ignore until end of block.
          break;
        }
      } else if (state == tsBlockCommentCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsBlockComment;
        // no break, reprocess in tsBlockComment
      } else if (state == tsBlockCommentAsterisk) {
        if (ch == 0x2f) { // /
          state = tsTop;
          break;
        } else {
          state = tsBlockComment;
          // no break, reprocess in tsBlockComment
        }
      } else if (state == tsCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsTop;
        // no break, reprocess in tsTop
      } else {
        throw(concat('unknown state ', state));
      }
    }
  }
  // Handle EOF
  if (state == tsTop) {
    // no effect
  } else if (state == tsIdentifier) {
    append(tokens, Token(ttIdentifier, SourceLocation(lineNo, colNo, filename), joinList(buffer as WhateverList)));
  } else if (state == tsSingleQuoteString) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsSingleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsSingleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsDoubleQuoteString) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsDoubleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsDoubleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsZero) {
    append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo, filename), 0));
  } else if (state == tsInteger) {
    append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo, filename), buffer));
  } else if (state == tsHexStart) {
    throw(concat('incomplete hex literal at end of ', filename));
  } else if (state == tsHex) {
    append(tokens, Token(ttInteger, SourceLocation(lineNo, colNo, filename), buffer));

  } else if (state == tsPeriod) {
    append(tokens, Token(ttPeriod, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsPeriodPeriod) {
    throw(concat('incomplete ellipsis at end of ', filename));

  } else if (state == tsPlus) {
    append(tokens, Token(ttPlus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsMinus) {
    append(tokens, Token(ttMinus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsAsterisk) {
    append(tokens, Token(ttAsterisk, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsSlash) {
    append(tokens, Token(ttSlash, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsModulus) {
    append(tokens, Token(ttModulus, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsEquals) {
    append(tokens, Token(ttEquals, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsBang) {
    append(tokens, Token(ttBang, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsLessThan) {
    append(tokens, Token(ttLessThan, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsGreaterThan) {
    append(tokens, Token(ttGreaterThan, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsAmpersand) {
    append(tokens, Token(ttAmpersand, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsCaret) {
    append(tokens, Token(ttCaret, SourceLocation(lineNo, colNo, filename), null));
  } else if (state == tsVerticalBar) {
    append(tokens, Token(ttVerticalBar, SourceLocation(lineNo, colNo, filename), null));

  } else if (state == tsLineComment) {
    // file terminated with line comment
  } else if (state == tsBlockComment) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsBlockCommentCR) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsBlockCommentAsterisk) {
    throw(concat('unterminated block comment at end of file started on ', SourceLocation(lastInterestingLineNo, lastInterestingColNo, filename)));
  } else if (state == tsCR) {
    // file terminated with newline
  } else {
    throw(concat('unknown state ', state));
  }
  append(tokens, Token(ttEof, SourceLocation(lineNo, colNo, filename), null));
  return tokens;
}

class TokenConsumer extends Object {
  TokenList tokens;
  Integer index;

  SourceLocation lastLocation() {
    return tokens[index - 1].sourceLocation;
  }

  Boolean isNext(tt tokenType) {
    return tokens[index].type == tokenType;
  }
  
  Boolean isNext2(tt tokenType1, tt tokenType2) {
    return index + 1 < len(tokens)
        && tokens[index    ].type == tokenType1
        && tokens[index + 1].type == tokenType2;
  }
  
  Boolean isNextIdentifier(String identifier) {
    Token token = tokens[index];
    return token.type == ttIdentifier && token.data == identifier;
  }
  
  String butFound(String what, String description) {
    return concat('Expected ', what, ' but found ', description, ' at ', tokens[index].sourceLocation);
  }
  
  String expected(String what) {
    return butFound(what, concat(tokens[index]));
  }

  String readIdentifier() {
    if (!isNext(ttIdentifier)) {
      throw(concat(expected('identifier')));
    }
    String result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  String readString() {
    if (!isNext(ttString)) {
      throw(concat(expected('string literal')));
    }
    String result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  Integer readInteger() {
    if (!isNext(ttInteger)) {
      throw(concat(expected('integer literal')));
    }
    Integer result = cast(tokens[index].data);
    index = index + 1;
    return result;
  }
  
  Null expectIdentifier(String identifier) {
    if (!isNext(ttIdentifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    if (!isNextIdentifier(identifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    index = index + 1;
  }
  
  Null expectPunctuation(tt punctuation) {
    if (!isNext(punctuation)) {
      throw(concat(expected(concat(Token(punctuation, SourceLocation(-1, -1, ''), null)))));
    }
    index = index + 1;
  }
  
  Null constructor(TokenList tokensArg) {
    tokens = tokensArg;
    index = 0;
  }
}