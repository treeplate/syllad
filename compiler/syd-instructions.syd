import 'syd-operands.syd';
import 'syd-assembler.syd';
import 'syd-slots.syd';
import 'syd-slot-manager.syd';
import 'syd-types.syd';

// ============================================================================
// INSTRUCTIONS
// ============================================================================

class Instruction extends Object {
  Null prepare(SlotContext scope) { }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.assertBlockIdentityMatches(block);
    abstract();
  }
}

class PendingCommentInstruction extends Instruction {
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addPendingComment(comment);
  }

  String toString() { 
    return concat('; ', comment);
  }

  Null constructor(String commentArg) {
    super.constructor();
    comment = commentArg;
  }
}

class CommentInstruction extends Instruction {
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addComment(comment);
  }

  String toString() { 
    return concat('; ', comment);
  }
  
  Null constructor(String commentArg) {
    super.constructor();
    comment = commentArg;
  }
}

class LabelInstruction extends Instruction {
  String label;
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addLabel(label, comment);
  }

  String toString() {
    return concat(label, ':   ; ', comment);
  }
  
  Null constructor(String labelArg, String commentArg) {
    super.constructor();
    label = labelArg;
    comment = commentArg;
  }
}

// be very careful when using this, since it does not
// call enterNestedScope/exitNestedScope and so slots
// do not get updated in different branches
class JumpInstruction extends Instruction {
  String target;
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addCode('jmp', [target]:Anything, comment);
  }

  Null constructor(String targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

class StoreCmpInstruction extends Instruction {
  Slot a;
  Slot b;
  Slot target;
  cc flag;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
    if (b != a) {
      b.willRead(scope, this);
    }
    if (target != a && target != b) {
      target.willWrite(scope, this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    // TODO: bit dubious to be reading the value directly rather than via slot manager's read()
    BooleanNullable hardcodedResult = compareOperands(a.value(manager.getScope()), flag, b.value(manager.getScope()));
    if (hardcodedResult == null) {
      Mop aOperand;
      if (a == b) {
        aOperand = manager.read(a, register, concat('we will be comparing ', a, ' with itself, so use a register'), this);
      } else {
        aOperand = manager.read(a, register | memory, concat('reading first value to compare (', a, ')'), this);
      }
      Mop bOperand;
      if (a == b) {
        bOperand = aOperand;
      } else if (aOperand.isMemory()) {
        bOperand = manager.read(b, register | immediate8 | immediate32, concat('reading second value to compare (', b, ')'), this);
      } else {
        bOperand = manager.read(b, register | memory | immediate8 | immediate32, concat('reading second value to compare (', b, ')'), this);
      }
      Mop targetOperand;
      if (target == a) {
        assert(false, 'not implemented: we should have used readForMutation in this case');
        targetOperand = aOperand;
      } else if (target == b) {
        assert(false, 'not implemented: we should have used readForMutation in this case');
        targetOperand = bOperand;
      } else {
        targetOperand = manager.write(target, register | memory, this);
      }
      block.addCode('xor', [targetOperand, targetOperand]:Anything, concat('clear ', target.debugName));
      block.addCode('cmp', [aOperand, bOperand]:Anything, concat('compare ', a.debugName, ' with ', b.debugName));
      block.addCode(concat('set', ccSuffix(flag)), [targetOperand.low8Bits()], concat('store result in ', target.debugName));
      aOperand.release();
      if (aOperand != bOperand) { 
        bOperand.release(); 
      }
      if (targetOperand != aOperand && targetOperand != bOperand) { 
        targetOperand.release(); 
      }
    } else {
      if (hardcodedResult!) {
        manager.hardcode(target, ImmediateIntegerOperand(0x01), concat(a.debugName, ' ', describeCC(flag), ' ', b.debugName, ' is true'), this);
      } else {
        manager.hardcode(target, ImmediateIntegerOperand(0x00), concat(a.debugName, ' ', describeCC(flag), ' ', b.debugName, ' is false'), this);
      }
      if (a != target) {
        manager.read(a, anywhere, 'record as read', this).release();
      }
      if (b != target && b != a) {
        manager.read(b, anywhere, 'record as read', this).release();
      }
    }
  }

  Null constructor(Slot aArg, Slot bArg, Slot targetArg, cc flagArg) { 
    super.constructor();
    a = aArg;
    b = bArg;
    target = targetArg;
    flag = flagArg;
  }
}

// Compares two slots and jumps to the label if the result matches the given check.
//
// The second slot can be left as null to compare against zero.
//
// Be very careful when using this, since it does not call enterNestedScope/exitNestedScope
// and so slots do not get updated in different branches.
class ConditionalJumpInstruction extends Instruction {
  Slot a;
  SlotNullable b;
  String label;
  String comment;
  cc check;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
    if (b != null) {
      b!.willRead(scope, this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Operand bValue;
    if (b == null) {
      bValue = ImmediateIntegerOperand(0x00);
    } else {
      bValue = b!.value(manager.getScope());
    }
    BooleanNullable hardcodedResult = compareOperands(a.value(manager.getScope()), check, bValue);
    if (hardcodedResult == null) {
      Mop aOperand = manager.read(a, register | memory, concat('reading first operand of cmp (', a.debugName, ') for a conditional jump'), this);
      if (b == null) {
        block.addCode('cmp', [aOperand, '0'], concat('compare ', a.debugName, ' to 0'));
      } else {
        Mop bOperand;
        if (aOperand.isMemory()) {
          bOperand = manager.read(b!, register | immediate8 | immediate32, concat('reading second operand of cmp (', b!.debugName, ') for a conditional jump'), this);
        } else {
          bOperand = manager.read(b!, register | memory | immediate8 | immediate32, concat('reading second operand of cmp (', b!.debugName, ') for a conditional jump'), this);
        }
        block.addCode('cmp', [aOperand, bOperand]:Anything, concat('compare ', a.debugName, ' to ', b!.debugName));
        bOperand.release();
      }
      aOperand.release();
      block.addCode(concat('j', ccSuffix(check)), [label], comment);
    } else {
      if (hardcodedResult!) {
        block.addCode('jmp', [label], comment);
      }
      manager.read(a, anywhere, 'record as read', this).release();
      if (b != a && b != null) {
        manager.read(b!, anywhere, 'record as read', this).release();
      }
    }
  }

  Null constructor(Slot aArg, SlotNullable bArg, cc checkArg, String labelArg, String commentArg) { 
    super.constructor();
    a = aArg;
    b = bArg;
    label = labelArg;
    check = checkArg;
    comment = commentArg;
  }
}

// Compares two slots and jumps to the label if their values are equal.
//
// The second slot can be left as null to compare against zero.
//
// Same as ConditionalJumpInstruction with the check set to ccEqual.
// See also SetSlotIfEqualInstruction and SetSlotIfTypesEqualInstruction.
//
// Be very careful when using this, since it does not call enterNestedScope/exitNestedScope
// and so slots do not get updated in different branches.
//
// Also, this doesn't compare types.
class JumpIfEqualInstruction extends ConditionalJumpInstruction {
  Null constructor(Slot aArg, SlotNullable bArg, String labelArg, String commentArg) {
    super.constructor(aArg, bArg, ccEqual, labelArg, commentArg);
  }
}

// Compares two slots and jumps to the label if their values are different.
//
// The second slot can be left as null to compare against zero.
//
// Same as ConditionalJumpInstruction with the check set to ccNotEqual.
// See also SetSlotIfEqualInstruction and SetSlotIfTypesEqualInstruction.
//
// Be very careful when using this, since it does not call enterNestedScope/exitNestedScope
// and so slots do not get updated in different branches.
//
// Also, this doesn't compare types.
class JumpIfNotEqualInstruction extends ConditionalJumpInstruction {
  Null constructor(Slot aArg, SlotNullable bArg, String labelArg, String commentArg) {
    super.constructor(aArg, bArg, ccNotEqual, labelArg, commentArg);
  }
}

// Compares the dynamic type of a slot with a static type, and jumps to the label if the result matches the given check.
//
// Be very careful when using this, since it does not call enterNestedScope/exitNestedScope
// and so slots do not get updated in different branches.
class ConditionalDynamicTypeJumpInstruction extends Instruction {
  Slot a;
  Type b;
  String label;
  String comment;
  cc check;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    BooleanNullable hardcodedResult = compareOperands(a.dynamicType(manager.getScope()), check, b.asOperand());
    if (hardcodedResult == null) {
      Mop aOperand = manager.readType(a, register | memory, concat('reading first operand of cmp (', a.debugName, ') for a conditional jump'), this);
      ImmediateOperand bOperand = b.asOperand();
      assert(bOperand.minBits() <= 32, 'Type.asOperand() is not an imm32');
      block.addCode('cmp', [aOperand, bOperand], concat('compare type of ', a.debugName, ' to ', b.name));
      aOperand.release();
      block.addCode(concat('j', ccSuffix(check)), [label], comment);
    } else {
      manager.readType(a, anywhere, 'record as read', this).release();
      if (hardcodedResult!) {
        block.addCode('jmp', [label], comment);
      }
    }
  }

  Null constructor(Slot aArg, Type bArg, cc checkArg, String labelArg, String commentArg) { 
    super.constructor();
    a = aArg;
    b = bArg;
    label = labelArg;
    check = checkArg;
    comment = commentArg;
  }
}

// Be very careful when using this, since it does not call enterNestedScope/exitNestedScope
// and so slots do not get updated in different branches.
class JumpIfDynamicTypeNotEqualStaticTypeInstruction extends ConditionalDynamicTypeJumpInstruction {
  Null constructor(Slot aArg, Type bArg, String labelArg, String commentArg) {
    super.constructor(aArg, bArg, ccNotEqual, labelArg, commentArg);
  }
}

class SyntheticNestedScopeExitInstruction extends Instruction {
  SlotContext scope; // must be the exiting scope

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.emitSyntheticNestedScopeExit(scope, true);
  }

  Null constructor(SlotContext scopeArg) {
    super.constructor();
    scope = scopeArg;
  }
}

class SyntheticNestedAllScopesExitInstruction extends Instruction {
  SlotContext scope; // doesn't really matter exactly which scope it is, we just grab the stack frame from it

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.emitSyntheticNestedScopeExit(scope.slotScope(), true);
  }

  Null constructor(SlotContext scopeArg) {
    super.constructor();
    scope = scopeArg;
  }
}

class IncrefInstruction extends Instruction {
  Slot slot;

  Null prepare(SlotContext scope) {
    slot.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop register = manager.read(slot, register, 'read slot into register for dereferencing', this);
    block.addCode('inc', [(register.operand as Register64Operand).dereference().withOffset(_gcBlockHeaderRefCount)], concat('increment reference count of ', slot.debugName));
    register.release();
  }

  Null constructor(Slot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class DecrefInstruction extends Instruction {
  Slot slot;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    if (slot is DynamicSlot) {
      manager.emitDecref(slot as DynamicSlot, false);
    }
  }

  Null constructor(Slot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class IncInstruction extends Instruction {
  Slot a;
  String comment;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop aOperand = manager.read(a, register | memory, concat('reading first operand of inc (', a.debugName, ')'), this);
    block.addCode('inc', [aOperand]:Anything, comment);
    aOperand.release();
  }

  Null constructor(Slot aArg, String commentArg) { 
    super.constructor();
    a = aArg;
    comment = commentArg;
  }
}

class DecInstruction extends Instruction {
  Slot a;
  String comment;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop aOperand = manager.read(a, register | memory, concat('reading first operand of dec (', a.debugName, ')'), this);
    block.addCode('dec', [aOperand]:Anything, comment);
    aOperand.release();
  }

  Null constructor(Slot aArg, String commentArg) { 
    super.constructor();
    a = aArg;
    comment = commentArg;
  }
}

// comment is for the jump instructions
class DecJccInstruction extends Instruction {
  Slot a;
  String label;
  String comment;
  cc check;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop aOperand = manager.read(a, register | memory, concat('reading first operand of dec (', a.debugName, ') for a conditional jump'), this);
    block.addCode('dec', [aOperand]:Anything, concat('decrement ', a.debugName));
    aOperand.release();
    block.addCode(concat('j', ccSuffix(check)), [label], comment);
  }

  Null constructor(Slot aArg, cc checkArg, String labelArg, String commentArg) { 
    super.constructor();
    a = aArg;
    label = labelArg;
    check = checkArg;
    comment = commentArg;
  }
}

class SetSlotIfEqualInstruction extends Instruction {
  Slot a;
  Slot b;
  Slot target;
  Type targetType;
  String comment;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
    b.willRead(scope, this);
    target.willWrite(scope, this); // value
    target.willWrite(scope, this); // type
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(a != b && a != target && b != target, 'SetSlotIfEqualInstruction does not yet support duplicate slots');
    Mop targetOperand = manager.write(target, register, this); // TODO: really this should take memory, but StackOperand needs to implement low8Bits first
    block.addCode('xor', [targetOperand, targetOperand], concat('zero ', target.debugName, ' to put the boolean in'));
    Mop operandA = manager.read(a, register | memory, concat('reading first operand of cmp (', a, ') for a SetSlotIfEqualInstruction'), this);
    Mop operandB;
    if (operandA.isMemory()) {
      operandB = manager.read(b, register | immediate8 | immediate32, concat('reading second operand of cmp (', b.debugName, ') for a SetSlotIfEqualInstruction'), this);
    } else {
      operandB = manager.read(b, register | memory | immediate8 | immediate32, concat('reading second operand of cmp (', b.debugName, ') for a SetSlotIfEqualInstruction'), this);
    }
    block.addCode('cmp', [operandA, operandB], comment);
    operandA.release();
    operandB.release();
    block.addCode('sete', [targetOperand.low8Bits()], concat('put result in ', target.debugName));
    targetOperand.release();
    Mop targetTypeOperand = manager.writeType(target, register | memory, this);
    emitMov(block, targetTypeOperand, targetType.asOperand(), concat(target.debugName, ' is a ', targetType));
    targetTypeOperand.release();
  }
  
  Null constructor(Slot aArg, Slot bArg, Slot targetArg, Type targetTypeArg, String commentArg) {
    super.constructor();
    a = aArg;
    b = bArg;
    target = targetArg;
    targetType = targetTypeArg;
    assert(targetType.isSubtypeOf(target.staticType), concat('cannot put a ', targetType, ' in a slot of type ', target.staticType));
    comment = commentArg;
  }
}
 
class SetSlotIfTypesEqualInstruction extends Instruction {
  Slot a;
  Slot b;
  Slot target;
  Type targetType;
  String comment;

  Null prepare(SlotContext scope) {
    a.willRead(scope, this);
    b.willRead(scope, this);
    target.willWrite(scope, this); // value
    target.willWrite(scope, this); // type
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(a != b && a != target && b != target, 'SetSlotIfTypesEqualInstruction does not yet support duplicate slots');
    Mop targetOperand = manager.write(target, register, this); // TODO: really this should take memory, but StackOperand needs to implement low8Bits first
    block.addCode('xor', [targetOperand, targetOperand], concat('zero ', target.debugName, ' to put the boolean in'));
    Mop operandA = manager.readType(a, register | memory, concat('reading type of ', a.debugName, ' for comparison with type of ', b.debugName), this);
    Mop operandB;
    if (operandA.isMemory()) {
      operandB = manager.readType(b, register | immediate8 | immediate32, concat('reading type of ', b.debugName), this);
    } else {
      operandB = manager.readType(b, register | memory | immediate8 | immediate32, concat('reading type of ', b.debugName), this);
    }
    block.addCode('cmp', [operandA, operandB], comment);
    operandA.release();
    operandB.release();
    block.addCode('sete', [targetOperand.low8Bits()], concat('put result in ', target.debugName));
    targetOperand.release();
    Mop targetTypeOperand = manager.writeType(target, register | memory, this);
    emitMov(block, targetTypeOperand, targetType.asOperand(), concat(target.debugName, ' is a ', targetType));
    targetTypeOperand.release();
  }
  
  Null constructor(Slot aArg, Slot bArg, Slot targetArg, Type targetTypeArg, String commentArg) {
    super.constructor();
    a = aArg;
    b = bArg;
    target = targetArg;
    targetType = targetTypeArg;
    assert(targetType.isSubtypeOf(target.staticType), concat('cannot put a ', targetType, ' in a slot of type ', target.staticType));
    comment = commentArg;
  }
}

class PushInstruction extends Instruction {
  Slot source;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop sourceOperand = manager.read(source, register | memory | immediate8 | immediate32, concat('reading ', source.debugName, ' for push'), this);
    block.addCode('push', [sourceOperand], comment);
    manager.recordPushes(1);
    sourceOperand.release();
  }

  Null constructor(Slot sourceArg, String commentArg) {
    super.constructor();
    source = sourceArg;
    comment = commentArg;
  }
}

class PushStaticTypeInstruction extends Instruction {
  Type type;
  String comment;

  Null prepare(SlotContext scope) {}

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Operand typeOperand = type.asOperand();
    block.addCode('push', [typeOperand], comment);
    manager.recordPushes(1);
  }

  Null constructor(Type typeArg, String commentArg) {
    super.constructor();
    type = typeArg;
    comment = commentArg;
  }
}

class PushTypeInstruction extends Instruction {
  Slot source;
  TypeRegistry typeRegistry;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop sourceOperand = manager.readType(source, register | memory | immediate8 | immediate32, concat('reading type of ', source.debugName), this);
    block.addCode('push', [sourceOperand], typeRegistry.withConstantTypeParenthetical(comment, sourceOperand.operand));
    manager.recordPushes(1);
    sourceOperand.release();
  }

  Null constructor(Slot sourceArg, TypeRegistry typeRegistryArg, String commentArg) {
    super.constructor();
    source = sourceArg;
    typeRegistry = typeRegistryArg;
    comment = commentArg;
  }
}

// Call a function using the syd calling convention.
// Arguments should be already positioned, including
// the pointer for the return value and type.
// Target should be the code address.
class CallInstruction extends Instruction {
  Slot target;
  String comment;

  Null prepare(SlotContext scope) {
    target.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.save(volatileRegister);
    // TODO: tell manager to restore global variables
    Mop targetOperand = manager.read(target, memory | nonvolatileRegister | immediate, concat('reading ', target.debugName, ' to call it'), this);
    assert(manager.stackMetrics.pushLevel % 2 == 0, concat('stack misaligned unexpectedly - ', manager.stackMetrics.pushLevel, ' pushes'));
    block.addCode('call', [targetOperand], comment);
    targetOperand.release();
    manager.releaseOperands(volatileRegister);
  }

  Null constructor(Slot targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

// Call a function using the syd calling convention.
// Arguments should be already positioned, including
// the pointer for the return value and type.
// The target should be a pointer to the code address,
// rather than the code address itself.
class CallDerefInstruction extends Instruction {
  Slot target;
  Integer offset;
  String comment;

  Null prepare(SlotContext scope) {
    target.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.save(volatileRegister &~ (r8.bit|r9.bit|rdx.bit|rcx.bit));
    // TODO: tell manager to restore global variables
    Mop targetOperand = manager.read(target, nonvolatileRegister, concat('reading ', target.debugName, ' to dereference it'), this);
    AddressComputationOperand codeOperand = AddressComputationOperand(targetOperand.operand as Register64Operand, null, 1, offset, 'qword');
    assert(manager.stackMetrics.pushLevel % 2 == 0, 'stack misaligned unexpectedly');
    block.addCode('call', [codeOperand], comment);
    targetOperand.release();
    manager.releaseOperands(volatileRegister &~ (r8.bit|r9.bit|rdx.bit|rcx.bit));
  }

  Null constructor(Slot targetArg, Integer offsetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    offset = offsetArg;
    comment = commentArg;
  }
}

// Call a system function. Parameters must be already set up;
// volatile registers used in this way must be specified in the
// usedRegisters property. The returnValue slot is configured
// to point to rax (which must not be locked).
class CallSystemInstruction extends Instruction {
  String library;
  String target;
  String comment;
  SlotNullable returnValue;

  Null prepare(SlotContext scope) {
    if (returnValue != null) {
      returnValue!.willWrite(scope, this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.assembler.addIncludeLib(library);
    block.assembler.addExternProc(target);
    if (returnValue != null) {
      manager.write(returnValue!, rax.bit, this); // Mop is released by releaseOperands below
      manager.save(volatileRegister - rax.bit);
    } else {
      manager.save(volatileRegister);
    }
    assert(manager.stackMetrics.pushLevel % 2 == 0, concat('stack misaligned unexpectedly (', manager.stackMetrics.pushLevel, ' pushes)'));
    block.addCode('call', [target], comment);
    manager.releaseOperands(volatileRegister);
  }

  Null constructor(String libraryArg, String targetArg, SlotNullable returnValueArg, String commentArg) {
    super.constructor();
    library = libraryArg;
    target = targetArg;
    comment = commentArg;
    returnValue = returnValueArg;
  }
}

class RecordPushesInstruction extends Instruction {
  Integer count;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.recordPushes(count);
  }

  Null constructor(Integer countArg) {
    super.constructor();
    count = countArg;
  }
}

class RecordPopsInstruction extends Instruction {
  Integer count;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.recordPops(count);
  }

  Null constructor(Integer countArg) {
    super.constructor();
    count = countArg;
  }
}

class Interrupt3Instruction extends Instruction {
  Null generateAssemblerBlock(AssemblerBlock block, SlotManager slotManager) {
    block.addCode('int', [3], 'call debugger');
  }
}

class ShiftInstruction extends Instruction {
  String opcode; // one of sal, shl, sar, shr
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(lhs != rhs && lhs != result && rhs != result, 'ShiftInstruction does not yet support duplicate slots');
    Mop count = manager.read(rhs, rcx.bit | immediate8, concat('read ', rhs, ' into imm8 or cl for', opcode), this); // this must be first, otherwise mutatedValue might use up rcx
    Mop mutatedValue = manager.readForMutation(lhs, result, register | memory, null, this);
    block.addCode(opcode, [mutatedValue, count.low8Bits()], comment); // low8Bits() ensures we use cl not rcx
    mutatedValue.release();
    count.release();
  }

  Null constructor(String opcodeArg, Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    opcode = opcodeArg;
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class UnsignedMultiplyInstruction extends Instruction {
  // TODO if both args are immediates, hard code the result
  // TODO if one is zero, move zero to targetArg without multiplying
  // TODO if either aArg or bArg are immediates representing 1, just move the other one to targetArg without multiplying
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop mutatedValue;
    Mop operand;
    manager.save(rdx.bit); // multiply's output is in rdx:rax (but we ignore rdx; OF will be 1 if we overflowed into rdx)
    if (lhs == rhs) {
      throw("not implemented"); // TODO
    } else if (lhs == result) {
      mutatedValue = manager.readForMutation(lhs, result, rax.bit, 'multiplicand must be in rax for mul instruction', this); // this must be first, otherwise operand might use up rax
      operand = manager.read(rhs, register | memory, concat('read operand of mul (', rhs.debugName, ') '), this);
    } else if (rhs == result) {
      mutatedValue = manager.readForMutation(rhs, result, rax.bit, null, this); // this must be first, otherwise operand might use up rax
      operand = manager.read(lhs, register | memory, concat('read operand of mul (', lhs.debugName, ') '), this); 
    } else {
      mutatedValue = manager.readForMutation(lhs, result, rax.bit, null, this); // this must be first, otherwise operand might use up rax
      operand = manager.read(rhs, register | memory, concat('read operand of mul (', rhs.debugName, ') '), this);
    }
    block.addCode('mul', [operand], comment); 
    manager.releaseOperands(rdx.bit);
    // TODO: throw if overflow (i.e. if OF flag set)
    mutatedValue.release();
    operand.release();
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class SignedMultiplyInstruction extends Instruction {
  // TODO if both args are immediates, hard code the result
  // TODO if one is zero, move zero to targetArg without multiplying
  // TODO if either aArg or bArg are immediates representing 1, just move the other one to targetArg without multiplying
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    MopList operands = []:Mop;
    IntegerNullable lhsValue = lhs.value(manager.getScope()).toInteger();
    IntegerNullable rhsValue = rhs.value(manager.getScope()).toInteger();
    if (lhsValue != null && rhsValue != null) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (lhs != rhs) {
        manager.read(rhs, anywhere, 'record as read', this).release();
      }
      manager.hardcode(result, ImmediateIntegerOperand(lhsValue * rhsValue), comment, this);
      return;
    } else if (lhsValue == 0) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (lhs != rhs) {
        manager.read(rhs, anywhere, 'record as read', this).release();
      }
      manager.hardcode(result, ImmediateIntegerOperand(0), comment, this);
      return;
    } else if (rhsValue == 0) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (lhs != rhs) {
        manager.read(rhs, anywhere, 'record as read', this).release();
      }
      manager.hardcode(result, ImmediateIntegerOperand(0), comment, this);
      return;
    } else if (lhsValue == 1) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (rhs == result) {
        manager.read(rhs, anywhere, 'record as read', this).release();
        manager.write(result, register | memory, this).release();
      } else {
        manager.readForMutation(rhs, result, register | memory, comment, this).release();
      }
      return;
    } else if (rhsValue == 1) {
      manager.read(rhs, anywhere, 'record as read', this).release();
      if (lhs == result) {
        manager.read(lhs, anywhere, 'record as read', this).release();
        manager.write(result, register | memory, this).release();
      } else {
        manager.readForMutation(lhs, result, register | memory, comment, this).release();
      }
      return;
    } else if (rhs == result) {
      // we'll use the two operand form
      if (rhs == lhs) {
        // a = a * a
        Mop op = manager.readForMutation(rhs, result, register, concat('read left and right hand side operands of imul (', rhs.debugName, '); will also become the result'), this);
        append(operands, op);
        append(operands, op);
      } else {
        // a = b * a
        append(operands, manager.readForMutation(rhs, result, register, concat('read right hand side operand of imul (', rhs.debugName, '), which is also the result'), this));
        append(operands, manager.read(lhs, register | memory, concat('read left hand side operand of imul (', lhs.debugName, ')'), this));
      }
    } else if (rhs == lhs) {
      // we'll use the two operand form
      assert(rhs != result, 'internal error');
      // a = b * b
      append(operands, manager.write(result, register, this));
      append(operands, manager.read(lhs, register, concat('read left and right hand side operands of imul (', lhs.debugName, ')'), this));
    } else {
      Mop op3 = manager.read(rhs, register | memory | immediate8 | immediate32, concat('read right hand side operand of imul (', rhs.debugName, ')'), this);
      if (op3.isImmediate()) {
        // we have to use the three operand form
        if (result == lhs) {
          // a = a * c
          Mop op = manager.readForMutation(lhs, result, register, concat('read left hand side operand of imul (', lhs.debugName, '), which is also the result'), this);
          append(operands, op);
          append(operands, op);
          append(operands, op3);
        } else {
          // a = b * c
          append(operands, manager.write(result, register, this));
          append(operands, manager.read(lhs, register, concat('read left hand side operand of imul (', lhs.debugName, ')'), this));
          append(operands, op3);
        }
      } else {
        // 2 operand form
        // a = a * c
        // a = b * c
        append(operands, manager.readForMutation(lhs, result, register, concat('read left hand side operand of imul (', lhs.debugName, '), which is also the result'), this));
        append(operands, op3);
      }
    }
    assert(len(operands) >= 2, 'one operand form would clobber rdx');
    block.addCode('imul', operands, concat(comment, ' (result in ', result.debugName, ')')); 
    Integer current = 0;
    while (current < len(operands)) {
      Mop op = operands[current];
      Boolean foundMatch = false;
      Integer inner = 0;
      while (inner < current) {
        if (operands[inner] == op) {
          foundMatch = true;
          break;
        }
        inner += 1;
      }
      if (!foundMatch) {
        op.release();
      }
      current += 1;
    }
    
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class IntegerRemainderInstruction extends Instruction {
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(lhs != rhs && lhs != result && rhs != result, 'IntegerRemainderInstruction does not yet support duplicate slots');
    // TODO: optimize power-of-two divisions to shifts
    manager.read(lhs, rax.bit, concat('put lhs of rdx division (', lhs, ') in rax'), this).release();
    manager.save(rax.bit);
    Mop resultOperand = manager.write(result, rdx.bit, this);
    block.addCode('cqo', [], 'zero-extend dividend (rax into rdx:rax)');
    Mop rhsOperand = manager.read(rhs, register | memory, concat('read visible operand of div (', rhs, ') '), this);
    block.addCode('idiv', [rhsOperand], concat(comment, ' (result, ', result.debugName, ', ends up in rdx)'));
    manager.releaseOperands(rax.bit);
    resultOperand.release();
    rhsOperand.release();
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class IntegerDivisionInstruction extends Instruction {
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    result.willWrite(scope, this);
    rhs.willRead(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(lhs != rhs && lhs != result && rhs != result, 'IntegerDivisionInstruction does not yet support duplicate slots');
    // TODO: optimize power-of-two divisions to shifts
    Mop dividendLow = manager.readForMutation(lhs, result, rax.bit, null, this); 
    manager.save(rdx.bit);
    block.addCode('cqo', [], 'zero-extend dividend');
    Mop rhsOperand = manager.read(rhs, register | memory, concat('read operand of div (', rhs.debugName, ') '), this);
    block.addCode('idiv', [rhsOperand], concat(comment, ' (result, ', result.debugName, ', is in rax)'));
    dividendLow.release();
    manager.releaseOperands(rdx.bit);
    rhsOperand.release();
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class BiOperandInstruction extends Instruction {
  String opcode;
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
    super.prepare(scope);
  }

  // TODO: if both aArg or bArg are immediates, hard code the result
  // TODO: for 'and', if one is zero, move the other to targetSlot
  // TODO: if anding with a literal 0xFFFFFFFF, instead of using `and`, just use the low 32 bit register (e.g. eax instead of rax)

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(lhs != rhs && rhs != result, concat('BiOperandInstruction does not yet support duplicate slots (except for lhs=result): \'', result.debugName, '\' = \'', lhs.debugName, '\' ', opcode, ' \'', rhs.debugName, '\''));
    Mop lhsOperand = manager.readForMutation(lhs, result, register | memory, null, this);
    Mop rhsOperand;
    if (lhsOperand.isMemory()) {
      rhsOperand = manager.read(rhs, register, concat('read second operand of ', opcode, ' (', rhs.debugName, ')'), this);
    } else {
      rhsOperand = manager.read(rhs, register | memory, concat('read second operand of ', opcode, ' (', rhs.debugName, ')'), this);
    }
    block.addCode(opcode, [lhsOperand, rhsOperand], comment);
    lhsOperand.release();
    rhsOperand.release();
  }

  Null constructor(String opcodeArg, Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    opcode = opcodeArg;
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class AddInstruction extends Instruction {
  // TODO: if both aArg and bArg are immediates, hard code the result
  // TODO: if one is zero, move the other to targetSlot

  // There are three slots but they can be the same as each other with five different possible combinations:
  //   a = b + c
  //   a = a + c
  //   a = a + a
  //   a = b + a
  //   a = b + b

  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    if (lhs != rhs) {
      rhs.willRead(scope, this);
    }
    result.willWrite(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    IntegerNullable lhsValue = lhs.value(manager.getScope()).toInteger();
    IntegerNullable rhsValue = rhs.value(manager.getScope()).toInteger();
    if (lhsValue != null && rhsValue != null) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (lhs != rhs) {
        manager.read(rhs, anywhere, 'record as read', this).release();
      }
      manager.hardcode(result, ImmediateIntegerOperand(lhsValue + rhsValue), comment, this);
    } else if (lhsValue == 0) {
      manager.read(lhs, anywhere, 'record as read', this).release();
      if (rhs == result) {
        manager.read(rhs, anywhere, 'record as read', this).release();
        manager.write(result, register | memory, this).release();
      } else {
        manager.readForMutation(rhs, result, register | memory, comment, this).release();
      }
    } else if (rhsValue == 0) {
      manager.read(rhs, anywhere, 'record as read', this).release();
      if (lhs == result) {
        manager.read(lhs, anywhere, 'record as read', this).release();
        manager.write(result, register | memory, this).release();
      } else {
        manager.readForMutation(lhs, result, register | memory, comment, this).release();
      }
    } else {
      Mop resultOperand;
      Mop otherOperand;
      if (lhs == result && rhs == result) {
        resultOperand = manager.readForMutation(result, result, register, null, this);
        otherOperand = resultOperand;
      } else if (rhs == result) {
        // we flip them over in this case since the order doesn't matter
        resultOperand = manager.readForMutation(rhs, result, register | memory, null, this);
        if (resultOperand.isMemory()) {
          otherOperand = manager.read(lhs, register | immediate8 | immediate32, concat('read first operand of + (', lhs.debugName, ')'), this);
        } else {
          otherOperand = manager.read(lhs, register | memory | immediate8 | immediate32, concat('read first operand of + (', lhs.debugName, ')'), this);
        }
      } else {
        resultOperand = manager.readForMutation(lhs, result, register | memory, null, this);
        if (resultOperand.isMemory()) {
          otherOperand = manager.read(rhs, register | immediate8 | immediate32, concat('read second operand of + (', rhs.debugName, ')'), this);
        } else {
          otherOperand = manager.read(rhs, register | memory | immediate8 | immediate32, concat('read second operand of + (', rhs.debugName, ')'), this);
        }
      }
      block.addCode('add', [resultOperand, otherOperand], concat(comment, ' (result in ', result.debugName, ')'));
      resultOperand.release();
      if (otherOperand != resultOperand) {
        otherOperand.release();
      }
    }
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class SubInstruction extends Instruction {
  Slot lhs;
  Slot rhs;
  Slot result;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    result.willWrite(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(lhs != rhs && rhs != result, 'SubInstruction does not support duplicate operands yet (except for lhs=result)');
    Mop lhsOperand = manager.readForMutation(lhs, result, register | memory, null, this);
    Mop rhsOperand;
    if (lhsOperand.isMemory()) {
      rhsOperand = manager.read(rhs, register | immediate, concat('read second operand of - (', rhs.debugName, ')'), this);
    } else {
      rhsOperand = manager.read(rhs, register | memory | immediate, concat('read second operand of - (', rhs.debugName, ')'), this);
    }
    block.addCode('sub', [lhsOperand, rhsOperand], comment);
    lhsOperand.release();
    rhsOperand.release();
  }

  Null constructor(Slot lhsArg, Slot rhsArg, Slot resultArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    result = resultArg;
    comment = commentArg;
  }
}

class MonoOperandInstruction extends Instruction {
  String opcode;
  Slot source;
  Slot target;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'MonoOperandInstruction does not yet support duplicate slots');
    Mop operand = manager.readForMutation(source, target, register | memory, null, this);
    block.addCode(opcode, [operand], comment);
    operand.release();
  }

  Null constructor(String opcodeArg, Slot sourceArg, Slot targetArg, String commentArg) {
    super.constructor();
    opcode = opcodeArg;
    source = sourceArg;
    target = targetArg;
    comment = commentArg;
  }
}

class MoveInstruction extends Instruction {
  Slot target;
  Slot source;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.readForMutation(source, target, memory | register, comment, this).release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, String commentArg) {
    assert(sourceArg != targetArg, 'redundant MoveInstruction');
    super.constructor();
    target = targetArg;
    source = sourceArg;
    comment = commentArg;
  }
}

// source.dynamicType -> target.dynamicType
class MoveTypeToTypeInstruction extends Instruction {
  Slot target;
  Slot source;
  TypeRegistry typeRegistry;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop sourceOperand = manager.readType(source, memory | register | immediate, 'internal error: this should not ever generate code', this);
    String fullComment = typeRegistry.withConstantTypeParenthetical(comment, sourceOperand.operand);
    sourceOperand.release();
    manager.readTypeForMutation(source, target, memory | register, fullComment, this).release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, TypeRegistry typeRegistryArg, String commentArg) {
    assert(sourceArg != targetArg, 'redundant MoveInstruction');
    super.constructor();
    target = targetArg;
    source = sourceArg;
    typeRegistry = typeRegistryArg;
    comment = commentArg;
  }
}

// source.dynamicType -> target.value
class MoveTypeToValueInstruction extends Instruction {
  Slot target;
  Slot source;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.readTypeToValueForMutation(source, target, memory | register, this).release();
  }

  Null constructor(Slot targetArg, Slot sourceArg) {
    assert(sourceArg != targetArg, 'redundant MoveInstruction');
    super.constructor();
    target = targetArg;
    source = sourceArg;
  }
}

class MoveValueToTypeInstruction extends Instruction {
  Slot target;
  Slot source;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.readValueToTypeForMutation(source, target, memory | register, this).release();
  }

  Null constructor(Slot targetArg, Slot sourceArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
  }
}

// source -> target.dynamicType
//
// This is used by "__as__" among other things.
class SetTypeInstruction extends Instruction {
  Slot target;
  Type source;

  Null prepare(SlotContext scope) {
    source.markConstructed();
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.hardcodeType(target, source.asOperand(), concat(target.debugName, ' is ', source.name), this);
  }

  Null constructor(Slot targetArg, Type sourceArg) {
    target = targetArg;
    source = sourceArg;
  }
}

class LeaInstruction extends Instruction {
  Slot target;
  Slot source;
  Integer offset;
  Boolean willRead;
  String comment;

  Null prepare(SlotContext scope) {
    if (willRead) {
      source.willRead(scope, this);
    } else {
      // this forces it into memory, but discards whatever current value is there
      source.willWrite(scope, this);
    }
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'LeaInstruction does not support duplicate slots');
    Integer allowedOperandKinds;
    if (offset != 0) {
      allowedOperandKinds = register;
    } else {
      allowedOperandKinds = memory;
    }
    Mop sourceOperand;
    if (willRead) {
      sourceOperand = manager.read(source, allowedOperandKinds, concat('get ', source.debugName, ' ready for lea'), this);
    } else {
      assert(offset == 0, 'cannot write to a memory location offset from a slot using LeaInstruction'); // (or is that ok?)
      sourceOperand = manager.write(source, allowedOperandKinds, this);
    }
    Mop targetOperand = manager.write(target, register, this);
    Operand computedSource;
    if (offset != 0) {
      computedSource = AddressComputationOperand(sourceOperand.operand as Register64Operand, null, 1, offset, 'qword');
    } else {
      computedSource = sourceOperand;
    }
    block.addCode('lea', [targetOperand, computedSource], comment);
    sourceOperand.release();
    targetOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Integer offsetArg, Boolean willReadArg, String commentArg) {
    assert(willReadArg || offsetArg == 0, 'cannot write to an offset from a slot using LeaInstruction');
    super.constructor();
    target = targetArg;
    source = sourceArg;
    offset = offsetArg;
    willRead = willReadArg;
    comment = commentArg;
  }
}

// copies source's type's memory location to target
class LeaTypeInstruction extends Instruction {
  Slot target;
  Slot source;
  Boolean willRead;
  String comment;

  Null prepare(SlotContext scope) {
    if (willRead) {
      source.willRead(scope, this);
    } else {
      // this forces it into memory, but discards whatever current value is there
      source.willWrite(scope, this);
    }
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'LeaTypeInstruction does not support duplicate slots');
    Mop sourceOperand;
    if (willRead) {
      sourceOperand = manager.readType(source, memory, concat('get ', source.debugName, '\'s type into memory for lea'), this);
    } else {
      sourceOperand = manager.writeType(source, memory, this);
    }
    Mop targetOperand = manager.write(target, register, this);
    block.addCode('lea', [targetOperand, sourceOperand], comment);
    sourceOperand.release();
    targetOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Boolean willReadArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    willRead = willReadArg;
    comment = commentArg;
  }
}

// Dereferences source slot, whose contents represent a pointer,
// and places the 64 bits at the pointed memory into the target slot.
class MoveDerefInstruction extends Instruction {
  Slot source;
  Slot target;
  Integer offset;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    if (source == target) {
      Mop operand = manager.readForMutation(source, target, register, concat('(this comment from ./compiler/', __FILE__, ':', __LINE__, ':', __COL__, ' should not be used)'), this);
      AddressComputationOperand sourceAddressComputationOperand = AddressComputationOperand(operand.operand as Register64Operand, null, 1, offset, 'qword');
      emitMov(block, operand, sourceAddressComputationOperand, comment);
      operand.release();
      return;
    }
    Mop sourceOperand = manager.read(source, register, concat('get ', source.debugName, ' into register to dereference it'), this);
    Mop targetOperand = manager.write(target, register, this);
    AddressComputationOperand sourceAddressComputationOperand = AddressComputationOperand(sourceOperand.operand as Register64Operand, null, 1, offset, 'qword');
    emitMov(block, targetOperand, sourceAddressComputationOperand, comment);
    targetOperand.release();
    sourceOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Integer offsetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    offset = offsetArg;
    comment = commentArg;
  }
}

// Dereferences source slot, whose contents represent a pointer,
// and places the 32 bits at the pointed memory into the target slot, clearing the other 32.
class MoveDwordDerefInstruction extends Instruction {
  Slot source;
  Slot target;
  SlotNullable temp;
  Integer offset;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    if (source == target) {
      temp!.willWrite(scope, this);
    }
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop sourceOperand;
    if (source == target) {
      sourceOperand = manager.readForMutation(source, temp!, register, concat('get ', source.debugName, ' into register to avoid memory-to-memory mov'), this);
    } else {
      sourceOperand = manager.read(source, register, concat('get ', source.debugName, ' into register to dereference it'), this);
    }
    Mop targetOperand = manager.write(target, register, this);
    block.addCode('xor', [targetOperand, targetOperand], 'clear target');
    AddressComputationOperand sourceAddressComputationOperand = AddressComputationOperand(sourceOperand.operand as Register64Operand, null, 1, offset, 'dword');
    emitMov(block, targetOperand.low32Bits(), sourceAddressComputationOperand, comment);
    targetOperand.release();
    sourceOperand.release();
  }

  // TODO: find a better API than this tempArg nonsense
  Null constructor(Slot targetArg, Slot sourceArg, SlotNullable tempArg, Integer offsetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    temp = tempArg;
    assert((temp == null) == (target != source), 'if the source and target are the same, a temporary slot must be provided; otherwise tempArg must be null');
    offset = offsetArg;
    comment = commentArg;
  }
}

// Dereferences target slot, whose contents represent a pointer,
// and places the source into the 64 bits at the target pointer.
// If the offset is non-zero, the pointer is adjusted by that amount.
class MoveToDerefInstruction extends Instruction {
  Slot source;
  Slot target;
  Integer offset;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'MoveToDerefInstruction does not support duplicate slots');
    Mop sourceOperand = manager.read(source, register | immediate8 | immediate32, concat('read second operand of mov (', source.debugName, ') for MoveToDerefInstruction'), this);
    Mop targetOperand = manager.read(target, register, concat('get ', target.debugName, ' into register to dereference it'), this);
    AddressComputationOperand targetAddressComputationOperand = AddressComputationOperand(targetOperand.operand as Register64Operand, null, 1, offset, 'qword');
    emitMov(block, targetAddressComputationOperand, sourceOperand, comment);
    targetOperand.release();
    sourceOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Integer offsetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    offset = offsetArg;
    comment = commentArg;
  }
}

// Dereferences target slot, whose contents represent a pointer,
// and places the type of source into the 64 bits at the target pointer.
// If the offset is non-zero, the pointer is adjusted by that amount.
class MoveTypeToDerefInstruction extends Instruction {
  Slot source;
  Slot target;
  Integer offset;
  TypeRegistry typeRegistry;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willRead(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'MoveTypeToDerefInstruction does not support duplicate slots');
    Mop sourceOperand = manager.readType(source, register | immediate8 | immediate32, concat('reading type of ', source.debugName), this);
    Mop targetOperand = manager.read(target, register, concat('get ', target.debugName, ' into register to dereference it'), this);
    AddressComputationOperand targetAddressComputationOperand = AddressComputationOperand(targetOperand.operand as Register64Operand, null, 1, offset, 'qword');
    emitMov(block, targetAddressComputationOperand, sourceOperand, typeRegistry.withConstantTypeParenthetical(comment, sourceOperand.operand));
    targetOperand.release();
    sourceOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Integer offsetArg, TypeRegistry typeRegistryArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    offset = offsetArg;
    typeRegistry = typeRegistryArg;
    comment = commentArg;
  }
}

// Dereferences source slot, whose contents represent a pointer,
// and places the 64 bits at the pointed memory into the target slot's dynamic type.
class MoveDerefToTypeInstruction extends Instruction {
  Slot source;
  Slot target;
  Integer offset;
  String comment;

  Null prepare(SlotContext scope) {
    source.willRead(scope, this);
    target.willWrite(scope, this);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    assert(source != target, 'MoveDerefToTypeInstruction does not support duplicate slots');
    Mop sourceOperand = manager.read(source, register, concat('read second operand of mov (', source.debugName, ') for MoveDerefToTypeInstruction'), this);
    Mop targetOperand = manager.writeType(target, register, this);
    AddressComputationOperand sourceAddressComputationOperand = AddressComputationOperand(sourceOperand.operand as Register64Operand, null, 1, offset, 'qword');
    emitMov(block, targetOperand, sourceAddressComputationOperand, comment);
    targetOperand.release();
    sourceOperand.release();
  }

  Null constructor(Slot targetArg, Slot sourceArg, Integer offsetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    offset = offsetArg;
    comment = commentArg;
  }
}

// Reads the slot into the specified kind of operand.
//
// See also PinSlotValueInstruction/UnpinSlotValueInstruction.
class MoveToSpecificOperandInstruction extends Instruction {
  Slot source;
  Integer target;
  Boolean willRead;
  String comment;

  Null prepare(SlotContext scope) {
    if (willRead) {
      source.willRead(scope, this);
    } else {
      source.willWrite(scope, this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop result;
    if (willRead) {
      result = manager.read(source, target, comment, this);
    } else {
      result = manager.write(source, target, this);
    }
    assert(result.operand.isOperandKind(target), concat('SlotManager.read gave invalid operand (', result, ') NOT ', describeOperandKinds(target), ' for ', source));
    result.release();
  }

  Null constructor(Integer targetArg, Slot sourceArg, Boolean willReadArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    willRead = willReadArg;
    comment = commentArg;
  }
}

// Reads the slot into the specified kind of operand.
//
// See also PinSlotTypeInstruction/UnpinSlotTypeInstruction.
class MoveTypeToSpecificOperandInstruction extends Instruction {
  Slot source;
  Integer target;
  Boolean willRead;
  String comment;

  Null prepare(SlotContext scope) {
    if (willRead) {
      source.willRead(scope, this);
    } else {
      source.willWrite(scope, this);
    }
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop result;
    if (willRead) {
      result = manager.readType(source, target, comment, this);
    } else {
      result = manager.writeType(source, target, this);
    }
    assert(result.operand.isOperandKind(target), concat('SlotManager.read gave invalid operand (', result, ') NOT ', describeOperandKinds(target), ' for ', source));
    result.release();
  }

  Null constructor(Integer targetArg, Slot sourceArg, Boolean willReadArg, String commentArg) {
    super.constructor();
    target = targetArg;
    source = sourceArg;
    willRead = willReadArg;
    comment = commentArg;
  }
}

// bt qword ptr [lhs], rhs
class BtDerefInstruction extends Instruction {
  Slot lhs;
  Slot rhs;
  String comment;

  Null prepare(SlotContext scope) {
    lhs.willRead(scope, this);
    rhs.willRead(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop lhsOperand = manager.read(lhs, register, concat('read first operand of BtDerefInstruction (', lhs.debugName, ') into register to dereference it'), this);
    AddressComputationOperand lhsDerefOperand = AddressComputationOperand(lhsOperand.operand as Register64Operand, null, 1, 0, 'qword');
    Mop rhsOperand = manager.read(rhs, register | immediate8, concat('read second operand of bt (', rhs.debugName, ')'), this);
    block.addCode('bt', [lhsDerefOperand, rhsOperand], comment);
    lhsOperand.release();
    rhsOperand.release();
  }

  Null constructor(Slot lhsArg, Slot rhsArg, String commentArg) {
    super.constructor();
    lhs = lhsArg;
    rhs = rhsArg;
    comment = commentArg;
  }
}

class JcInstruction extends Instruction {
  String target;
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addCode('jc', [target], comment);
  }

  Null constructor(String targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

class JncInstruction extends Instruction {
  String target;
  String comment;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addCode('jnc', [target], comment);
  }

  Null constructor(String targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

class SetcInstruction extends Instruction {
  Slot target;
  String comment;

  Null prepare(SlotContext scope) {
    target.willWrite(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    Mop targetOperand = manager.write(target, register, this); // TODO: really this should take memory, but StackOperand needs to implement low8Bits first
    block.addCode('setc', [targetOperand.low8Bits()], comment);
    targetOperand.release();
  }

  Null constructor(Slot targetArg, String commentArg) {
    super.constructor();
    target = targetArg;
    comment = commentArg;
  }
}

class PinSlotValueInstruction extends Instruction {
  DynamicSlot target;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    target.pinValue(manager.getScope());
  }

  Null constructor(DynamicSlot targetArg) {
    super.constructor();
    target = targetArg;
  }
}

class UnpinSlotValueInstruction extends Instruction {
  DynamicSlot target;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    if (target.stillAlive(manager.getScope()) || target.valuePinned(manager.getScope())) {
      target.unpinValue(manager.getScope());
    }
  }

  Null constructor(DynamicSlot targetArg) {
    super.constructor();
    target = targetArg;
  }
}

class PinSlotTypeInstruction extends Instruction {
  DynamicSlot target;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    target.pinType(manager.getScope());
  }

  Null constructor(DynamicSlot targetArg) {
    super.constructor();
    target = targetArg;
  }
}

class UnpinSlotTypeInstruction extends Instruction {
  DynamicSlot target;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    if (target.stillAlive(manager.getScope()) || target.typePinned(manager.getScope())) {
      target.unpinType(manager.getScope());
    }    
  }

  Null constructor(DynamicSlot targetArg) {
    super.constructor();
    target = targetArg;
  }
}

class PinRegisterSlotInstruction extends Instruction {
  RegisterSlot slot;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.pin(slot);
  }

  Null constructor(RegisterSlot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class TrackSlotInstruction extends Instruction {
  DynamicSlot slot;

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    manager.trackSlot(slot);
  }

  Null constructor(DynamicSlot slotArg) {
    super.constructor();
    slot = slotArg;
  }
}

class StringComparisonInstruction extends Instruction {
  Slot target;
  Slot a;
  Integer aOffset;
  Slot b;
  Integer bOffset;
  Slot length;
  String comment;

  Null prepare(SlotContext scope) {
    target.willWrite(scope, this);
    length.willRead(scope, this);
    a.willRead(scope, this);
    b.willRead(scope, this);
    super.prepare(scope);
  }

  Null generateAssemblerBlock(AssemblerBlock block, SlotManager manager) {
    block.addComment(comment);
    Mop targetOperand = manager.write(target, register &~ (rcx.bit | rdi.bit | rsi.bit), this);
    block.addCode('xor', [targetOperand, targetOperand]:Anything, concat('clear ', target.debugName));
    Mop lengthOperand = manager.read(length, rcx.bit, 'prepare length for rep instruction below', this);
    Mop aOperand = manager.read(a, rdi.bit, 'first string to compare', this);
    if (aOffset != 0) {
      Operand computedSource = AddressComputationOperand(aOperand.operand as Register64Operand, null, 1, aOffset, 'qword');
      block.addCode('lea', [aOperand, computedSource], 'offset to start of string comparison for first string');
    }
    Mop bOperand = manager.read(b, rsi.bit, 'seconds string to compare', this);
    if (bOffset != 0) {
      Operand computedSource = AddressComputationOperand(bOperand.operand as Register64Operand, null, 1, bOffset, 'qword');
      block.addCode('lea', [bOperand, computedSource], 'offset to start of string comparison for second string');
    }
    block.addCode('cld', [], 'configure repe cmpsb to increment');
    block.addCode('repe cmpsb', [], 'compare strings for rcx bytes, result in ZF (ZF=1 is a match)');
    block.addCode('setz', [targetOperand.low8Bits()], 'store result from ZF');
    aOperand.release();
    bOperand.release();
    lengthOperand.release();
    targetOperand.release();
  }

  Null constructor(Slot targetArg, Slot aArg, Integer aOffsetArg, Slot bArg, Integer bOffsetArg, Slot lengthArg, String commentArg) {
    super.constructor();
    target = targetArg;
    a = aArg;
    aOffset = aOffsetArg;
    b = bArg;
    bOffset = bOffsetArg;
    length = lengthArg;
    comment = commentArg;
  }
}