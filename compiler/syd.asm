_drectve segment info alias(".drectve")
  db ' /ENTRY:main '
_drectve ends
option casemap:none

; includes
includelib kernel32.lib

; externs
extern ExitProcess : proc
extern GetLastError : proc
extern GetProcessHeap : proc
extern HeapAlloc : proc
extern HeapFree : proc
extern GetStdHandle : proc
extern WriteFile : proc

.const
  typeTable    db 000h, 000h, 000h, 000h, 000h, 000h, 058h, 004h ; Type table
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 00ch ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 00ch, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 018h, 002h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 018h, 002h ; ...
               db 000h, 000h, 0b8h, 001h, 000h, 000h, 0b8h, 000h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 000h, 000h, 058h, 004h, 000h, 000h, 058h, 004h ; ...
               db 001h, 000h, 008h, 000h, 002h, 000h, 008h, 000h ; ...
               db 004h, 000h, 008h, 000h, 008h, 000h, 008h, 000h ; ...
               db 010h, 000h, 018h, 000h, 020h, 000h, 000h, 000h ; ...
               db 040h, 000h, 018h, 000h, 080h, 000h, 0b8h, 001h ; ...
               db 040h, 001h, 018h, 000h, 040h, 003h, 018h, 000h ; ...
               db 040h, 007h, 018h, 000h, 040h, 008h, 018h, 000h ; ...
               db 040h, 018h, 018h, 000h, 040h, 020h, 018h, 000h ; ...
               db 040h, 060h, 018h, 000h, 040h, 0e0h, 018h, 000h ; ...
               db 040h, 020h, 019h, 000h, 040h, 000h, 01ah, 000h ; ...
               db 040h, 000h, 01eh, 000h, 000h, 000h, 000h, 000h ; ...
   ; Columns: Null'36 Boolean'37 Integer'38 String'39 __ListData'3a __CodeAddress'3b __Object'3c StringList'3d
   ;          Object'3e Test'3f Subclass'40 BunnyA'41 BunnyB'42 CarrotRoot'43 CarrotBranchA'44 CarrotLeafA'45 CarrotBranchB'46
   ;          A'47 B'48 Anything'49 GarbageCollectable'4a WhateverReadOnlyList'4b AnythingFunction'4c WhateverIterable'4d WhateverList'4e WhateverIterator'4f
   ;          WhateverFunction'50 IntegerFunction'51
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 0   <sentinel>'0
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Whatever...)'1
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction(WhateverReadOnlyList)'2
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction()'3
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction(Integer)'4
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Integer, Integer)'5
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Anything)'6
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   __ObjectFunction()'7
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction()'8
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Boolean, String)'9
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(String)'a
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction(Integer, Integer, Integer)'b
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Integer)'c
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Integer, Integer, Integer)'d
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction(String)'e
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction(Integer)'f
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction(StringList, String)'10
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   GarbageCollectableFunction(Integer, Integer, Integer)'11
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   WhateverListFunction(Integer, Integer)'12
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(WhateverList)'13
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(WhateverList, Anything)'14
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   __ObjectFunction(Integer)'15
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction()'16
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   WhateverFunctionFunction(__Object, __CodeAddress, Integer)'17
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   WhateverFunction()'18
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   WhateverFunctionFunction(Anything, Integer)'19
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 1   IntegerFunction(Integer, Integer, Integer, Integer, Integer)'1a
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Integer, String)'1b
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction(Anything)'1c
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 1 0 0   StringIterator'1d
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction(Anything...)'1e
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 1 0 0   AnythingIterator'1f
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 1 0 1 : 1 0 0 0   AnythingList'20
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 1 0 1 : 0 0 0 0   AnythingReadOnlyList'21
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(Anything...)'22
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   ObjectFunction()'23
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   TestFunction()'24
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   SubclassFunction(String)'25
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   BunnyAFunction()'26
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunctionFunction()'27
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   BunnyBFunction()'28
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   CarrotRootFunction()'29
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   CarrotBranchAFunction()'2a
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   CarrotLeafAFunction()'2b
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   CarrotBranchBFunction()'2c
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction()Function()'2d
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   AFunction()'2e
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(IntegerFunction)'2f
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   BFunction()'30
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   StringFunction()Function()'31
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   IntegerFunction()Function()'32
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(IntegerFunction)Function()'33
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunctionFunction()Function()'34
   ; 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 1 0 : 0 0 1 0   NullFunction(String)Function()'35
   ; 1 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 0 0 0 0 : 0 0 0 0   Null'36
   ; 0 1 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 0 0 0 0 : 0 0 0 0   Boolean'37
   ; 0 0 1 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 0 0 0 0 : 0 0 0 0   Integer'38
   ; 0 0 0 1 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 0 0 0 0 : 0 0 0 0   String'39
   ; 0 0 0 0 1 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   __ListData'3a
   ; 0 0 0 0 0 1 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 0 0 0 0 0 : 0 0 0 0   __CodeAddress'3b
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   __Object'3c
   ; 0 0 0 0 0 0 0 1 : 0 0 0 0 0 0 0 0 : 0 0 0 1 1 1 0 1 : 1 0 0 0   StringList'3d
   ; 0 0 0 0 0 0 1 0 : 1 0 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   Object'3e
   ; 0 0 0 0 0 0 1 0 : 1 1 0 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   Test'3f
   ; 0 0 0 0 0 0 1 0 : 1 1 1 0 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   Subclass'40
   ; 0 0 0 0 0 0 1 0 : 0 0 0 1 0 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   BunnyA'41
   ; 0 0 0 0 0 0 1 0 : 0 0 0 1 1 0 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   BunnyB'42
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 1 0 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   CarrotRoot'43
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 1 1 0 : 0 0 0 1 1 0 0 0 : 0 0 0 0   CarrotBranchA'44
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 1 1 1 : 0 0 0 1 1 0 0 0 : 0 0 0 0   CarrotLeafA'45
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 1 0 0 : 1 0 0 1 1 0 0 0 : 0 0 0 0   CarrotBranchB'46
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 0 0 0 : 0 1 0 1 1 0 0 0 : 0 0 0 0   A'47
   ; 0 0 0 0 0 0 1 0 : 0 0 0 0 0 0 0 0 : 0 1 1 1 1 0 0 0 : 0 0 0 0   B'48

  iteratorTypeTable dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh ; Table mapping iterable types to iterator types
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 00000001fh, 00000001fh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 00000001dh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh
  listTypeTable dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh ; Table mapping iterable types to list types
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 000000020h, 000000020h, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 00000003dh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh, 0ffffffffh, 0ffffffffh, 0ffffffffh
               dd 0ffffffffh
  __Object$vmt dq 00000003ch                                     ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$__Object$__Object$annotation            ; pointer to class name
               dq __Object$vmt                                   ; pointer to parent VMT
               dq __Object$ddt                                   ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$__Object$__Object$constructor$setter, method$__Object$__Object$constructor$getter, method$__Object$constructor ; __Object.constructor
               dq 000000016h, method$__Object$__Object$toString$setter, method$__Object$__Object$toString$getter, method$__Object$toString ; __Object.toString
  __Object$ddt dq 0                                              ; Number of members used in dynamic dispatch
  CarrotRoot$vmt dq 000000043h                                   ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$CarrotRoot$CarrotRoot$annotation        ; pointer to class name
               dq __Object$vmt                                   ; pointer to parent VMT
               dq CarrotRoot$ddt                                 ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$CarrotRoot$CarrotRoot$constructor$setter, method$CarrotRoot$CarrotRoot$constructor$getter, method$__Object$constructor ; CarrotRoot.constructor
               dq 000000016h, method$CarrotRoot$CarrotRoot$toString$setter, method$CarrotRoot$CarrotRoot$toString$getter, method$__Object$toString ; CarrotRoot.toString
               dq 000000003h, method$CarrotRoot$CarrotRoot$foo$setter, method$CarrotRoot$CarrotRoot$foo$getter, method$CarrotRoot$foo ; CarrotRoot.foo
  CarrotRoot$ddt dq 0                                            ; Number of members used in dynamic dispatch
  CarrotBranchA$vmt dq 000000044h                                ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$CarrotBranchA$CarrotBranchA$annotation  ; pointer to class name
               dq CarrotRoot$vmt                                 ; pointer to parent VMT
               dq CarrotBranchA$ddt                              ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$CarrotBranchA$CarrotBranchA$constructor$setter, method$CarrotBranchA$CarrotBranchA$constructor$getter, method$__Object$constructor ; CarrotBranchA.constructor
               dq 000000016h, method$CarrotBranchA$CarrotBranchA$toString$setter, method$CarrotBranchA$CarrotBranchA$toString$getter, method$__Object$toString ; CarrotBranchA.toString
               dq 000000003h, method$CarrotBranchA$CarrotBranchA$foo$setter, method$CarrotBranchA$CarrotBranchA$foo$getter, method$CarrotRoot$foo ; CarrotBranchA.foo
               dq 000000003h, method$CarrotBranchA$CarrotBranchA$bar$setter, method$CarrotBranchA$CarrotBranchA$bar$getter, method$CarrotBranchA$bar ; CarrotBranchA.bar
  CarrotBranchA$ddt dq 0                                         ; Number of members used in dynamic dispatch
  CarrotLeafA$vmt dq 000000045h                                  ; type code
               dq 3                                              ; number of fields to allocate during construction
               dq method$CarrotLeafA$CarrotLeafA$annotation      ; pointer to class name
               dq CarrotBranchA$vmt                              ; pointer to parent VMT
               dq CarrotLeafA$ddt                                ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$CarrotLeafA$CarrotLeafA$constructor$setter, method$CarrotLeafA$CarrotLeafA$constructor$getter, method$CarrotLeafA$constructor ; CarrotLeafA.constructor
               dq 000000016h, method$CarrotLeafA$CarrotLeafA$toString$setter, method$CarrotLeafA$CarrotLeafA$toString$getter, method$__Object$toString ; CarrotLeafA.toString
               dq 000000003h, method$CarrotLeafA$CarrotLeafA$foo$setter, method$CarrotLeafA$CarrotLeafA$foo$getter, method$CarrotRoot$foo ; CarrotLeafA.foo
               dq -1, method$CarrotLeafA$CarrotLeafA$bar$setter, method$CarrotLeafA$CarrotLeafA$bar$getter, 0h ; CarrotLeafA.bar
               dq 000000003h, method$CarrotLeafA$CarrotLeafA$barImpl$setter, method$CarrotLeafA$CarrotLeafA$barImpl$getter, method$CarrotLeafA$barImpl ; CarrotLeafA.barImpl
  CarrotLeafA$ddt dq 0                                           ; Number of members used in dynamic dispatch
  CarrotBranchB$vmt dq 000000046h                                ; type code
               dq 3                                              ; number of fields to allocate during construction
               dq method$CarrotBranchB$CarrotBranchB$annotation  ; pointer to class name
               dq CarrotRoot$vmt                                 ; pointer to parent VMT
               dq CarrotBranchB$ddt                              ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$CarrotBranchB$CarrotBranchB$constructor$setter, method$CarrotBranchB$CarrotBranchB$constructor$getter, method$CarrotBranchB$constructor ; CarrotBranchB.constructor
               dq 000000016h, method$CarrotBranchB$CarrotBranchB$toString$setter, method$CarrotBranchB$CarrotBranchB$toString$getter, method$__Object$toString ; CarrotBranchB.toString
               dq -1, method$CarrotBranchB$CarrotBranchB$foo$setter, method$CarrotBranchB$CarrotBranchB$foo$getter, 0h ; CarrotBranchB.foo
               dq 000000003h, method$CarrotBranchB$CarrotBranchB$fooImpl$setter, method$CarrotBranchB$CarrotBranchB$fooImpl$getter, method$CarrotBranchB$fooImpl ; CarrotBranchB.fooImpl
               dq 000000003h, method$CarrotBranchB$CarrotBranchB$bar$setter, method$CarrotBranchB$CarrotBranchB$bar$getter, method$CarrotBranchB$bar ; CarrotBranchB.bar
  CarrotBranchB$ddt dq 0                                         ; Number of members used in dynamic dispatch
  A$vmt        dq 000000047h                                     ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$A$A$annotation                          ; pointer to class name
               dq __Object$vmt                                   ; pointer to parent VMT
               dq A$ddt                                          ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$A$A$constructor$setter, method$A$A$constructor$getter, method$__Object$constructor ; A.constructor
               dq 000000016h, method$A$A$toString$setter, method$A$A$toString$getter, method$__Object$toString ; A.toString
               dq 000000008h, method$A$A$foo$setter, method$A$A$foo$getter, method$A$foo ; A.foo
  A$ddt        dq 0                                              ; Number of members used in dynamic dispatch
  B$vmt        dq 000000048h                                     ; type code
               dq 3                                              ; number of fields to allocate during construction
               dq method$B$B$annotation                          ; pointer to class name
               dq A$vmt                                          ; pointer to parent VMT
               dq B$ddt                                          ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$B$B$constructor$setter, method$B$B$constructor$getter, method$__Object$constructor ; B.constructor
               dq 000000016h, method$B$B$toString$setter, method$B$B$toString$getter, method$__Object$toString ; B.toString
               dq -1, method$B$B$foo$setter, method$B$B$foo$getter, 0h ; B.foo
               dq 00000002fh, method$B$B$setFoo$setter, method$B$B$setFoo$getter, method$B$setFoo ; B.setFoo
  B$ddt        dq 0                                              ; Number of members used in dynamic dispatch
  BunnyA$vmt   dq 000000041h                                     ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$BunnyA$BunnyA$annotation                ; pointer to class name
               dq __Object$vmt                                   ; pointer to parent VMT
               dq BunnyA$ddt                                     ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$BunnyA$BunnyA$constructor$setter, method$BunnyA$BunnyA$constructor$getter, method$__Object$constructor ; BunnyA.constructor
               dq 000000016h, method$BunnyA$BunnyA$toString$setter, method$BunnyA$BunnyA$toString$getter, method$__Object$toString ; BunnyA.toString
               dq 000000003h, method$BunnyA$BunnyA$test$setter, method$BunnyA$BunnyA$test$getter, method$BunnyA$test ; BunnyA.test
  BunnyA$ddt   dq 0                                              ; Number of members used in dynamic dispatch
  BunnyB$vmt   dq 000000042h                                     ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$BunnyB$BunnyB$annotation                ; pointer to class name
               dq BunnyA$vmt                                     ; pointer to parent VMT
               dq BunnyB$ddt                                     ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$BunnyB$BunnyB$constructor$setter, method$BunnyB$BunnyB$constructor$getter, method$__Object$constructor ; BunnyB.constructor
               dq 000000016h, method$BunnyB$BunnyB$toString$setter, method$BunnyB$BunnyB$toString$getter, method$__Object$toString ; BunnyB.toString
               dq 000000003h, method$BunnyB$BunnyB$test$setter, method$BunnyB$BunnyB$test$getter, method$BunnyB$test ; BunnyB.test
               dq 000000027h, method$BunnyB$BunnyB$grab$setter, method$BunnyB$BunnyB$grab$getter, method$BunnyB$grab ; BunnyB.grab
  BunnyB$ddt   dq 0                                              ; Number of members used in dynamic dispatch
  Object$vmt   dq 00000003eh                                     ; type code
               dq 2                                              ; number of fields to allocate during construction
               dq method$Object$Object$annotation                ; pointer to class name
               dq __Object$vmt                                   ; pointer to parent VMT
               dq Object$ddt                                     ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$Object$Object$constructor$setter, method$Object$Object$constructor$getter, method$Object$constructor ; Object.constructor
               dq 000000016h, method$Object$Object$toString$setter, method$Object$Object$toString$getter, method$__Object$toString ; Object.toString
  Object$ddt   dq 0                                              ; Number of members used in dynamic dispatch
  Test$vmt     dq 00000003fh                                     ; type code
               dq 3                                              ; number of fields to allocate during construction
               dq method$Test$Test$annotation                    ; pointer to class name
               dq Object$vmt                                     ; pointer to parent VMT
               dq Test$ddt                                       ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 000000003h, method$Test$Test$constructor$setter, method$Test$Test$constructor$getter, method$Object$constructor ; Test.constructor
               dq 000000016h, method$Test$Test$toString$setter, method$Test$Test$toString$getter, method$__Object$toString ; Test.toString
               dq 00000000ah, method$Test$Test$mutateField$setter, method$Test$Test$mutateField$getter, method$Test$mutateField ; Test.mutateField
               dq 000000016h, method$Test$Test$method$setter, method$Test$Test$method$getter, method$Test$method ; Test.method
               dq -1, method$Test$Test$field$setter, method$Test$Test$field$getter, 0h ; Test.field
  Test$ddt     dq 2                                              ; Number of members used in dynamic dispatch
               dd 0, 000000098h                                  ; dynamic dispatch data for Test.method
               dd 1, 0000000b8h                                  ; dynamic dispatch data for Test.field
  Subclass$vmt dq 000000040h                                     ; type code
               dq 3                                              ; number of fields to allocate during construction
               dq method$Subclass$Subclass$annotation            ; pointer to class name
               dq Test$vmt                                       ; pointer to parent VMT
               dq Subclass$ddt                                   ; pointer to member lookup table for dynamic dispatch (to implement (foo as Whatever).bar)
               dq 00000000ah, method$Subclass$Subclass$constructor$setter, method$Subclass$Subclass$constructor$getter, method$Subclass$constructor ; Subclass.constructor
               dq 000000016h, method$Subclass$Subclass$toString$setter, method$Subclass$Subclass$toString$getter, method$__Object$toString ; Subclass.toString
               dq 00000000ah, method$Subclass$Subclass$mutateField$setter, method$Subclass$Subclass$mutateField$getter, method$Test$mutateField ; Subclass.mutateField
               dq 000000016h, method$Subclass$Subclass$method$setter, method$Subclass$Subclass$method$getter, method$Test$method ; Subclass.method
               dq -1, method$Subclass$Subclass$field$setter, method$Subclass$Subclass$field$getter, 0h ; Subclass.field
  Subclass$ddt dq 2                                              ; Number of members used in dynamic dispatch
               dd 0, 000000098h                                  ; dynamic dispatch data for Subclass.method
               dd 1, 0000000b8h                                  ; dynamic dispatch data for Subclass.field
  func$__error$annotation dq -01h                                ; String constant (reference count)
               dq 7                                              ; Length
               db "__error"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  func$len$annotation dq -01h                                    ; String constant (reference count)
               dq 3                                              ; Length
               db "len"                                          ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  func$__readFromAddress$annotation dq -01h                      ; String constant (reference count)
               dq 17                                             ; Length
               db "__readFromAddress"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$__writeToAddress$annotation dq -01h                       ; String constant (reference count)
               dq 16                                             ; Length
               db "__writeToAddress"                             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$__incref$annotation dq -01h                               ; String constant (reference count)
               dq 8                                              ; Length
               db "__incref"                                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  parameterCountCheckFailureMessage dq -01h                      ; String constant (reference count)
               dq 88                                             ; Length
               db "error: function call received the wrong number of parameters (expected %d, received %d)", 0ah ; line 3231 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  parameterTypeCheckFailureMessage dq -01h                       ; String constant (reference count)
               dq 71                                             ; Length
               db "error: type mismatch for function %s parameter %d, expected %s, got %s", 0ah ; line 3236 column 25 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  returnValueTypeCheckFailureMessage dq -01h                     ; String constant (reference count)
               dq 68                                             ; Length
               db "error: type mismatch for function return value, expected %s, got %s", 0ah ; line 3241 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  operandTypeCheckFailureMessage dq -01h                         ; String constant (reference count)
               dq 54                                             ; Length
               db "error: type mismatch for operand, expected %s, got %s", 0ah ; line 3246 column 25 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  assignmentTypeCheckFailureMessage dq -01h                      ; String constant (reference count)
               dq 57                                             ; Length
               db "error: type mismatch for assignment, expected %s, got %s", 0ah ; line 3251 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  subscriptTypeCheckFailureMessage dq -01h                       ; String constant (reference count)
               dq 42                                             ; Length
               db "error: subscript index must be %s, got %s", 0ah ; line 3256 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  subroutineCallTypeCheckFailureMessage dq -01h                  ; String constant (reference count)
               dq 53                                             ; Length
               db "error: function calls expect target to be %s, got %s", 0ah ; line 3266 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  asOperatorFailureMessage dq -01h                               ; String constant (reference count)
               dq 58                                             ; Length
               db "error: type mismatch for as operator, expected %s, got %s", 0ah ; line 3271 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  boundsFailureMessage dq -01h                                   ; String constant (reference count)
               dq 64                                             ; Length
               db "error: subscript index out of range (%d is not in range %d..%d)", 0ah ; line 3276 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  assignToMethodMessage dq -01h                                  ; String constant (reference count)
               dq 34                                             ; Length
               db "error: tried to assign to a method"           ; line 3281 column 25 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$__Object$__Object$annotation dq -01h                    ; String constant (reference count)
               dq 8                                              ; Length
               db "__Object"                                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$exit$annotation dq -01h                                   ; String constant (reference count)
               dq 4                                              ; Length
               db "exit"                                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  func$__getLastError$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "__getLastError"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$assert$annotation dq -01h                                 ; String constant (reference count)
               dq 6                                              ; Length
               db "assert"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$throw$annotation dq -01h                                  ; String constant (reference count)
               dq 5                                              ; Length
               db "throw"                                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  func$__getProcessHeap$annotation dq -01h                       ; String constant (reference count)
               dq 16                                             ; Length
               db "__getProcessHeap"                             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$__heapAlloc$annotation dq -01h                            ; String constant (reference count)
               dq 11                                             ; Length
               db "__heapAlloc"                                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  func$_alloc$annotation dq -01h                                 ; String constant (reference count)
               dq 6                                              ; Length
               db "_alloc"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string       dq -01h                                           ; String constant (reference count)
               dq 14                                             ; Length
               db "Out of memory."                               ; line 75 column 25 in file runtime library
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$__heapFree$annotation dq -01h                             ; String constant (reference count)
               dq 10                                             ; Length
               db "__heapFree"                                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  func$_free$annotation dq -01h                                  ; String constant (reference count)
               dq 5                                              ; Length
               db "_free"                                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  string$1     dq -01h                                           ; String constant (reference count)
               dq 36                                             ; Length
               db "failed to free pointer, error code: "         ; line 86 column 49 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  func$_moveBytes$annotation dq -01h                             ; String constant (reference count)
               dq 10                                             ; Length
               db "_moveBytes"                                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$2     dq -01h                                           ; String constant (reference count)
               dq 51                                             ; Length
               db "_moveBytes expects positive number of bytes to copy" ; line 94 column 74 in file runtime library
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$3     dq -01h                                           ; String constant (reference count)
               dq 61                                             ; Length
               db "internal error: zero extra bytes but fromCursor is before end" ; line 113 column 90 in file runtime library
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  string$4     dq -01h                                           ; String constant (reference count)
               dq 39                                             ; Length
               db "internal error: more than 7 extra bytes"      ; line 114 column 68 in file runtime library
               db 00h                                            ; padding to align to 8-byte boundary
  func$_fillQuadWords$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "_fillQuadWords"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$5     dq -01h                                           ; String constant (reference count)
               dq 55                                             ; Length
               db "_fillQuadWords expects positive number of bytes to fill" ; line 124 column 78 in file runtime library
               db 00h                                            ; padding to align to 8-byte boundary
  string$6     dq -01h                                           ; String constant (reference count)
               dq 68                                             ; Length
               db "_fillQuadWords expects number of bytes to fill to be a multiple of 8" ; line 125 column 96 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  func$_stringByteLength$annotation dq -01h                      ; String constant (reference count)
               dq 17                                             ; Length
               db "_stringByteLength"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$digitToStr$annotation dq -01h                             ; String constant (reference count)
               dq 10                                             ; Length
               db "digitToStr"                                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$7     dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "0"                                            ; line 146 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$8     dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "1"                                            ; line 149 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$9     dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "2"                                            ; line 152 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$10    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "3"                                            ; line 155 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$11    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "4"                                            ; line 158 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$12    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "5"                                            ; line 161 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$13    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "6"                                            ; line 164 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$14    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "7"                                            ; line 167 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$15    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "8"                                            ; line 170 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$16    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "9"                                            ; line 173 column 14 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$17    dq -01h                                           ; String constant (reference count)
               dq 56                                             ; Length
               db "Invalid digit passed to digitToStr (digit as exit code)", 0ah ; line 175 column 68 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$intToStr$annotation dq -01h                               ; String constant (reference count)
               dq 8                                              ; Length
               db "intToStr"                                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$18    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "-"                                            ; line 184 column 21 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$19    dq -01h                                           ; String constant (reference count)
               dq 0                                              ; Length
  func$join$annotation dq -01h                                   ; String constant (reference count)
               dq 4                                              ; Length
               db "join"                                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$20    dq -01h                                           ; String constant (reference count)
               dq 24                                             ; Length
               db "negative length detected"                     ; line 208 column 48 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$21    dq -01h                                           ; String constant (reference count)
               dq 38                                             ; Length
               db "absurd length detected (as exit code)", 0ah   ; line 210 column 52 in file runtime library
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$_blockListInit$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "_blockListInit"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$_growBlockList$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "_growBlockList"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$22    dq -01h                                           ; String constant (reference count)
               dq 43                                             ; Length
               db "_growBlockList called without _gcLocked set"  ; line 272 column 69 in file runtime library
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  func$_advanceToNextBlock$annotation dq -01h                    ; String constant (reference count)
               dq 19                                             ; Length
               db "_advanceToNextBlock"                          ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$23    dq -01h                                           ; String constant (reference count)
               dq 48                                             ; Length
               db "_advanceToNextBlock called without _gcLocked set" ; line 285 column 74 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$_constructor$annotation dq -01h                           ; String constant (reference count)
               dq 12                                             ; Length
               db "_constructor"                                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$24    dq -01h                                           ; String constant (reference count)
               dq 41                                             ; Length
               db "_constructor called without _gcLocked set"    ; line 306 column 67 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$25    dq -01h                                           ; String constant (reference count)
               dq 33                                             ; Length
               db "length cannot be bigger than size"            ; line 307 column 60 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$_mark$annotation dq -01h                                  ; String constant (reference count)
               dq 5                                              ; Length
               db "_mark"                                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  func$_garbageCollectorImplementation$annotation dq -01h        ; String constant (reference count)
               dq 31                                             ; Length
               db "_garbageCollectorImplementation"              ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$26    dq -01h                                           ; String constant (reference count)
               dq 26                                             ; Length
               db "Reference count underflow."                   ; line 350 column 61 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  func$_listConstructor$annotation dq -01h                       ; String constant (reference count)
               dq 16                                             ; Length
               db "_listConstructor"                             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  func$_growList$annotation dq -01h                              ; String constant (reference count)
               dq 9                                              ; Length
               db "_growList"                                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$append$annotation dq -01h                                 ; String constant (reference count)
               dq 6                                              ; Length
               db "append"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$_classAllocator$annotation dq -01h                        ; String constant (reference count)
               dq 15                                             ; Length
               db "_classAllocator"                              ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$29    dq -01h                                           ; String constant (reference count)
               dq 44                                             ; Length
               db "tried to construct class without a type code" ; line 550 column 70 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$30    dq -01h                                           ; String constant (reference count)
               dq 30                                             ; Length
               db "unexpectedly small field count"               ; line 552 column 58 in file runtime library
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$__Object$toString$annotation dq -01h                    ; String constant (reference count)
               dq 8                                              ; Length
               db "toString"                                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$31    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "<"                                            ; line 569 column 21 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$32    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db ">"                                            ; line 569 column 37 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$__Object$constructor$annotation dq -01h                 ; String constant (reference count)
               dq 11                                             ; Length
               db "constructor"                                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  func$_createMethodPointer$annotation dq -01h                   ; String constant (reference count)
               dq 20                                             ; Length
               db "_createMethodPointer"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  func$_dummy1$annotation dq -01h                                ; String constant (reference count)
               dq 7                                              ; Length
               db "_dummy1"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$33    dq -01h                                           ; String constant (reference count)
               dq 21                                             ; Length
               db "dummy function called"                        ; line 590 column 31 in file runtime library
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  func$_dynamicLookup$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "_dynamicLookup"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$34    dq -01h                                           ; String constant (reference count)
               dq 27                                             ; Length
               db "Cannot dynamic dispatch on "                  ; line 596 column 46 in file runtime library
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$35    dq -01h                                           ; String constant (reference count)
               dq 24                                             ; Length
               db " which is not an object."                     ; line 596 column 84 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$36    dq -01h                                           ; String constant (reference count)
               dq 40                                             ; Length
               db "No member with specified name found on """    ; line 610 column 57 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$37    dq -01h                                           ; String constant (reference count)
               dq 2                                              ; Length
               db 22h, "."                                       ; line 610 column 97 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  func$__getStdHandle$annotation dq -01h                         ; String constant (reference count)
               dq 14                                             ; Length
               db "__getStdHandle"                               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$__writeFile$annotation dq -01h                            ; String constant (reference count)
               dq 11                                             ; Length
               db "__writeFile"                                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  func$__writeToHandle$annotation dq -01h                        ; String constant (reference count)
               dq 15                                             ; Length
               db "__writeToHandle"                              ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  func$_stringify$annotation dq -01h                             ; String constant (reference count)
               dq 10                                             ; Length
               db "_stringify"                                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$44    dq -01h                                           ; String constant (reference count)
               dq 4                                              ; Length
               db "true"                                         ; line 693 column 19 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$45    dq -01h                                           ; String constant (reference count)
               dq 5                                              ; Length
               db "false"                                        ; line 695 column 18 in file runtime library
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  string$46    dq -01h                                           ; String constant (reference count)
               dq 4                                              ; Length
               db "null"                                         ; line 698 column 17 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$47    dq -01h                                           ; String constant (reference count)
               dq 18                                             ; Length
               db "<function (method "                           ; line 711 column 40 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$48    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "."                                            ; line 711 column 62 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$49    dq -01h                                           ; String constant (reference count)
               dq 2                                              ; Length
               db ")>"                                           ; line 711 column 94 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$50    dq -01h                                           ; String constant (reference count)
               dq 11                                             ; Length
               db "<function ("                                  ; line 714 column 31 in file runtime library
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$51    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "["                                            ; line 717 column 21 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$52    dq -01h                                           ; String constant (reference count)
               dq 2                                              ; Length
               db ", "                                           ; line 717 column 51 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$53    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "]"                                            ; line 717 column 57 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$54    dq -01h                                           ; String constant (reference count)
               dq 12                                             ; Length
               db "<__ListData>"                                 ; line 731 column 25 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$55    dq -01h                                           ; String constant (reference count)
               dq 28                                             ; Length
               db "value cannot be stringified", 0ah             ; line 733 column 40 in file runtime library
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  func$_concat$annotation dq -01h                                ; String constant (reference count)
               dq 7                                              ; Length
               db "_concat"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$56    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db " "                                            ; line 785 column 46 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$println$annotation dq -01h                                ; String constant (reference count)
               dq 7                                              ; Length
               db "println"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$57    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db 0ah                                            ; line 804 column 43 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  func$_stderr$annotation dq -01h                                ; String constant (reference count)
               dq 7                                              ; Length
               db "_stderr"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  func$_error$annotation dq -01h                                 ; String constant (reference count)
               dq 6                                              ; Length
               db "_error"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$58    dq -01h                                           ; String constant (reference count)
               dq 33                                             ; Length
               db "insufficient arguments to __error"            ; line 823 column 65 in file runtime library
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$Object$Object$annotation dq -01h                        ; String constant (reference count)
               dq 6                                              ; Length
               db "Object"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Test$Test$annotation dq -01h                            ; String constant (reference count)
               dq 4                                              ; Length
               db "Test"                                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$59    dq -01h                                           ; String constant (reference count)
               dq 5                                              ; Length
               db "FIELD"                                        ; line 20 column 24 in file temp.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$Test$method$annotation dq -01h                          ; String constant (reference count)
               dq 6                                              ; Length
               db "method"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$60    dq -01h                                           ; String constant (reference count)
               dq 6                                              ; Length
               db "METHOD"                                       ; line 22 column 19 in file temp.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Test$mutateField$annotation dq -01h                     ; String constant (reference count)
               dq 11                                             ; Length
               db "mutateField"                                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$Subclass$Subclass$annotation dq -01h                    ; String constant (reference count)
               dq 8                                              ; Length
               db "Subclass"                                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  string$61    dq -01h                                           ; String constant (reference count)
               dq 6                                              ; Length
               db "FIELD:"                                       ; line 36 column 16 in file temp.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$62    dq -01h                                           ; String constant (reference count)
               dq 7                                              ; Length
               db "METHOD:"                                      ; line 37 column 17 in file temp.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$63    dq -01h                                           ; String constant (reference count)
               dq 10                                             ; Length
               db "CLASSNAME:"                                   ; line 38 column 20 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$64    dq -01h                                           ; String constant (reference count)
               dq 6                                              ; Length
               db "CARROT"                                       ; line 45 column 25 in file temp.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$65    dq -01h                                           ; String constant (reference count)
               dq 29                                             ; Length
               db "FIELD (should now be CARROT):"                ; line 46 column 39 in file temp.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  string$66    dq -01h                                           ; String constant (reference count)
               dq 3                                              ; Length
               db "PEA"                                          ; line 48 column 34 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$67    dq -01h                                           ; String constant (reference count)
               dq 22                                             ; Length
               db "FIELD (should be PEA):"                       ; line 49 column 32 in file temp.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$68    dq -01h                                           ; String constant (reference count)
               dq 12                                             ; Length
               db "as Whatever:"                                 ; line 51 column 22 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$69    dq -01h                                           ; String constant (reference count)
               dq 14                                             ; Length
               db "METHOD caller:"                               ; line 52 column 24 in file temp.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  string$70    dq -01h                                           ; String constant (reference count)
               dq 4                                              ; Length
               db "FAIL"                                         ; line 58 column 22 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$annotation dq -01h                        ; String constant (reference count)
               dq 6                                              ; Length
               db "BunnyA"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$BunnyA$test$annotation dq -01h                          ; String constant (reference count)
               dq 4                                              ; Length
               db "test"                                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$71    dq -01h                                           ; String constant (reference count)
               dq 12                                             ; Length
               db "BunnyA::test"                                 ; line 62 column 27 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$annotation dq -01h                        ; String constant (reference count)
               dq 6                                              ; Length
               db "BunnyB"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$BunnyB$grab$annotation dq -01h                          ; String constant (reference count)
               dq 4                                              ; Length
               db "grab"                                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$72    dq -01h                                           ; String constant (reference count)
               dq 12                                             ; Length
               db "BunnyB::test"                                 ; line 72 column 27 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$73    dq -01h                                           ; String constant (reference count)
               dq 17                                             ; Length
               db "failure (Bunnies)"                            ; line 77 column 52 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$annotation dq -01h                ; String constant (reference count)
               dq 10                                             ; Length
               db "CarrotRoot"                                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$CarrotRoot$foo$annotation dq -01h                       ; String constant (reference count)
               dq 3                                              ; Length
               db "foo"                                          ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$74    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "a"                                            ; line 86 column 31 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$annotation dq -01h          ; String constant (reference count)
               dq 13                                             ; Length
               db "CarrotBranchA"                                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchA$bar$annotation dq -01h                    ; String constant (reference count)
               dq 3                                              ; Length
               db "bar"                                          ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$75    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "b"                                            ; line 92 column 31 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$annotation dq -01h              ; String constant (reference count)
               dq 11                                             ; Length
               db "CarrotLeafA"                                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$CarrotLeafA$barImpl$annotation dq -01h                  ; String constant (reference count)
               dq 7                                              ; Length
               db "barImpl"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$76    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "c"                                            ; line 100 column 31 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$annotation dq -01h          ; String constant (reference count)
               dq 13                                             ; Length
               db "CarrotBranchB"                                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchB$fooImpl$annotation dq -01h                ; String constant (reference count)
               dq 7                                              ; Length
               db "fooImpl"                                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$77    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "d"                                            ; line 112 column 31 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$78    dq -01h                                           ; String constant (reference count)
               dq 1                                              ; Length
               db "e"                                            ; line 116 column 31 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$79    dq -01h                                           ; String constant (reference count)
               dq 33                                             ; Length
               db "failure (??? strings in general?)"            ; line 124 column 56 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  string$80    dq -01h                                           ; String constant (reference count)
               dq 2                                              ; Length
               db "de"                                           ; line 130 column 21 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$81    dq -01h                                           ; String constant (reference count)
               dq 23                                             ; Length
               db "failure (CarrotBranchB)"                      ; line 130 column 48 in file temp.syd
               db 00h                                            ; padding to align to 8-byte boundary
  string$82    dq -01h                                           ; String constant (reference count)
               dq 2                                              ; Length
               db "ac"                                           ; line 136 column 21 in file temp.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  string$83    dq -01h                                           ; String constant (reference count)
               dq 21                                             ; Length
               db "failure (CarrotLeafA)"                        ; line 136 column 46 in file temp.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$A$A$annotation dq -01h                                  ; String constant (reference count)
               dq 1                                              ; Length
               db "A"                                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$B$B$annotation dq -01h                                  ; String constant (reference count)
               dq 1                                              ; Length
               db "B"                                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$B$setFoo$annotation dq -01h                             ; String constant (reference count)
               dq 6                                              ; Length
               db "setFoo"                                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  func$six$annotation dq -01h                                    ; String constant (reference count)
               dq 3                                              ; Length
               db "six"                                          ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  string$84    dq -01h                                           ; String constant (reference count)
               dq 4                                              ; Length
               db "ONE:"                                         ; line 153 column 14 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  string$85    dq -01h                                           ; String constant (reference count)
               dq 4                                              ; Length
               db "SIX:"                                         ; line 155 column 14 in file temp.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$__Object$__Object$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "__Object$constructor$getter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$__Object$__Object$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "__Object$constructor$setter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$__Object$__Object$toString$getter$annotation dq -01h    ; String constant (reference count)
               dq 24                                             ; Length
               db "__Object$toString$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$__Object$__Object$toString$setter$annotation dq -01h    ; String constant (reference count)
               dq 24                                             ; Length
               db "__Object$toString$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotRoot$constructor$getter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotRoot$constructor$setter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$toString$getter$annotation dq -01h ; String constant (reference count)
               dq 26                                             ; Length
               db "CarrotRoot$toString$getter"                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$toString$setter$annotation dq -01h ; String constant (reference count)
               dq 26                                             ; Length
               db "CarrotRoot$toString$setter"                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$foo$getter$annotation dq -01h     ; String constant (reference count)
               dq 21                                             ; Length
               db "CarrotRoot$foo$getter"                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotRoot$CarrotRoot$foo$setter$annotation dq -01h     ; String constant (reference count)
               dq 21                                             ; Length
               db "CarrotRoot$foo$setter"                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 32                                             ; Length
               db "CarrotBranchA$constructor$getter"             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 32                                             ; Length
               db "CarrotBranchA$constructor$setter"             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$bar$getter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchA$bar$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$bar$setter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchA$bar$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$toString$getter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotBranchA$toString$getter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$toString$setter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotBranchA$toString$setter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$foo$getter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchA$foo$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchA$CarrotBranchA$foo$setter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchA$foo$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 30                                             ; Length
               db "CarrotLeafA$constructor$getter"               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 30                                             ; Length
               db "CarrotLeafA$constructor$setter"               ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$bar$getter$annotation dq -01h   ; String constant (reference count)
               dq 22                                             ; Length
               db "CarrotLeafA$bar$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$bar$setter$annotation dq -01h   ; String constant (reference count)
               dq 22                                             ; Length
               db "CarrotLeafA$bar$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$toString$getter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "CarrotLeafA$toString$getter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$toString$setter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "CarrotLeafA$toString$setter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$foo$getter$annotation dq -01h   ; String constant (reference count)
               dq 22                                             ; Length
               db "CarrotLeafA$foo$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$foo$setter$annotation dq -01h   ; String constant (reference count)
               dq 22                                             ; Length
               db "CarrotLeafA$foo$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$barImpl$getter$annotation dq -01h ; String constant (reference count)
               dq 26                                             ; Length
               db "CarrotLeafA$barImpl$getter"                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$CarrotLeafA$CarrotLeafA$barImpl$setter$annotation dq -01h ; String constant (reference count)
               dq 26                                             ; Length
               db "CarrotLeafA$barImpl$setter"                   ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 32                                             ; Length
               db "CarrotBranchB$constructor$getter"             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 32                                             ; Length
               db "CarrotBranchB$constructor$setter"             ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$fooImpl$getter$annotation dq -01h ; String constant (reference count)
               dq 28                                             ; Length
               db "CarrotBranchB$fooImpl$getter"                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$fooImpl$setter$annotation dq -01h ; String constant (reference count)
               dq 28                                             ; Length
               db "CarrotBranchB$fooImpl$setter"                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$bar$getter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchB$bar$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$bar$setter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchB$bar$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$toString$getter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotBranchB$toString$getter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$toString$setter$annotation dq -01h ; String constant (reference count)
               dq 29                                             ; Length
               db "CarrotBranchB$toString$setter"                ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$foo$getter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchB$foo$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$CarrotBranchB$CarrotBranchB$foo$setter$annotation dq -01h ; String constant (reference count)
               dq 24                                             ; Length
               db "CarrotBranchB$foo$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$A$A$constructor$getter$annotation dq -01h               ; String constant (reference count)
               dq 20                                             ; Length
               db "A$constructor$getter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$A$A$constructor$setter$annotation dq -01h               ; String constant (reference count)
               dq 20                                             ; Length
               db "A$constructor$setter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$A$A$toString$getter$annotation dq -01h                  ; String constant (reference count)
               dq 17                                             ; Length
               db "A$toString$getter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$A$A$toString$setter$annotation dq -01h                  ; String constant (reference count)
               dq 17                                             ; Length
               db "A$toString$setter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$A$A$foo$getter$annotation dq -01h                       ; String constant (reference count)
               dq 12                                             ; Length
               db "A$foo$getter"                                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$A$A$foo$setter$annotation dq -01h                       ; String constant (reference count)
               dq 12                                             ; Length
               db "A$foo$setter"                                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$B$B$setFoo$getter$annotation dq -01h                    ; String constant (reference count)
               dq 15                                             ; Length
               db "B$setFoo$getter"                              ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$B$B$setFoo$setter$annotation dq -01h                    ; String constant (reference count)
               dq 15                                             ; Length
               db "B$setFoo$setter"                              ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$B$B$constructor$getter$annotation dq -01h               ; String constant (reference count)
               dq 20                                             ; Length
               db "B$constructor$getter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$B$B$constructor$setter$annotation dq -01h               ; String constant (reference count)
               dq 20                                             ; Length
               db "B$constructor$setter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$B$B$toString$getter$annotation dq -01h                  ; String constant (reference count)
               dq 17                                             ; Length
               db "B$toString$getter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$B$B$toString$setter$annotation dq -01h                  ; String constant (reference count)
               dq 17                                             ; Length
               db "B$toString$setter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$B$B$foo$getter$annotation dq -01h                       ; String constant (reference count)
               dq 12                                             ; Length
               db "B$foo$getter"                                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$B$B$foo$setter$annotation dq -01h                       ; String constant (reference count)
               dq 12                                             ; Length
               db "B$foo$setter"                                 ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$constructor$getter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "BunnyA$constructor$getter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$constructor$setter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "BunnyA$constructor$setter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$test$getter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyA$test$getter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$test$setter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyA$test$setter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$toString$getter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "BunnyA$toString$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$BunnyA$BunnyA$toString$setter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "BunnyA$toString$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$constructor$getter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "BunnyB$constructor$getter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$constructor$setter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "BunnyB$constructor$setter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$grab$getter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyB$grab$getter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$grab$setter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyB$grab$setter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$test$getter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyB$test$getter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$test$setter$annotation dq -01h            ; String constant (reference count)
               dq 18                                             ; Length
               db "BunnyB$test$setter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$toString$getter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "BunnyB$toString$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$BunnyB$BunnyB$toString$setter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "BunnyB$toString$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Object$Object$constructor$getter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "Object$constructor$getter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$Object$Object$constructor$setter$annotation dq -01h     ; String constant (reference count)
               dq 25                                             ; Length
               db "Object$constructor$setter"                    ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$Object$Object$toString$getter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "Object$toString$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Object$Object$toString$setter$annotation dq -01h        ; String constant (reference count)
               dq 22                                             ; Length
               db "Object$toString$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Test$Test$mutateField$getter$annotation dq -01h         ; String constant (reference count)
               dq 23                                             ; Length
               db "Test$mutateField$getter"                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$Test$Test$mutateField$setter$annotation dq -01h         ; String constant (reference count)
               dq 23                                             ; Length
               db "Test$mutateField$setter"                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$Test$Test$constructor$getter$annotation dq -01h         ; String constant (reference count)
               dq 23                                             ; Length
               db "Test$constructor$getter"                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$Test$Test$constructor$setter$annotation dq -01h         ; String constant (reference count)
               dq 23                                             ; Length
               db "Test$constructor$setter"                      ; line 2376 column 111 in file syd-compiler.syd
               db 00h                                            ; padding to align to 8-byte boundary
  method$Test$Test$method$getter$annotation dq -01h              ; String constant (reference count)
               dq 18                                             ; Length
               db "Test$method$getter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$Test$Test$method$setter$annotation dq -01h              ; String constant (reference count)
               dq 18                                             ; Length
               db "Test$method$setter"                           ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h                   ; padding to align to 8-byte boundary
  method$Test$Test$toString$getter$annotation dq -01h            ; String constant (reference count)
               dq 20                                             ; Length
               db "Test$toString$getter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$Test$Test$toString$setter$annotation dq -01h            ; String constant (reference count)
               dq 20                                             ; Length
               db "Test$toString$setter"                         ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h                             ; padding to align to 8-byte boundary
  method$Test$Test$field$getter$annotation dq -01h               ; String constant (reference count)
               dq 17                                             ; Length
               db "Test$field$getter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$Test$Test$field$setter$annotation dq -01h               ; String constant (reference count)
               dq 17                                             ; Length
               db "Test$field$setter"                            ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h              ; padding to align to 8-byte boundary
  method$Subclass$Subclass$mutateField$getter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "Subclass$mutateField$getter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$Subclass$Subclass$mutateField$setter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "Subclass$mutateField$setter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$Subclass$Subclass$constructor$getter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "Subclass$constructor$getter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$Subclass$Subclass$constructor$setter$annotation dq -01h ; String constant (reference count)
               dq 27                                             ; Length
               db "Subclass$constructor$setter"                  ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h                        ; padding to align to 8-byte boundary
  method$Subclass$Subclass$method$getter$annotation dq -01h      ; String constant (reference count)
               dq 22                                             ; Length
               db "Subclass$method$getter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Subclass$Subclass$method$setter$annotation dq -01h      ; String constant (reference count)
               dq 22                                             ; Length
               db "Subclass$method$setter"                       ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h                                       ; padding to align to 8-byte boundary
  method$Subclass$Subclass$toString$getter$annotation dq -01h    ; String constant (reference count)
               dq 24                                             ; Length
               db "Subclass$toString$getter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$Subclass$Subclass$toString$setter$annotation dq -01h    ; String constant (reference count)
               dq 24                                             ; Length
               db "Subclass$toString$setter"                     ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h         ; padding to align to 8-byte boundary
  method$Subclass$Subclass$field$getter$annotation dq -01h       ; String constant (reference count)
               dq 21                                             ; Length
               db "Subclass$field$getter"                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary
  method$Subclass$Subclass$field$setter$annotation dq -01h       ; String constant (reference count)
               dq 21                                             ; Length
               db "Subclass$field$setter"                        ; line 2376 column 111 in file syd-compiler.syd
               db 00h, 00h, 00h                                  ; padding to align to 8-byte boundary

.data
  func$__error$functionPointer dq 1                              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__error                                   ; code pointer
  func$len$functionPointer dq 1                                  ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$len                                       ; code pointer
  func$__readFromAddress$functionPointer dq 1                    ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__readFromAddress                         ; code pointer
  func$__writeToAddress$functionPointer dq 1                     ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__writeToAddress                          ; code pointer
  func$__incref$functionPointer dq 1                             ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__incref                                  ; code pointer
  method$__Object$__Object$functionPointer dq 1                  ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$__Object$__Object                       ; code pointer
  func$exit$functionPointer dq 1                                 ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$exit                                      ; code pointer
  func$__getLastError$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__getLastError                            ; code pointer
  func$assert$functionPointer dq 1                               ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$assert                                    ; code pointer
  func$throw$functionPointer dq 1                                ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$throw                                     ; code pointer
  func$__getProcessHeap$functionPointer dq 1                     ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__getProcessHeap                          ; code pointer
  func$__heapAlloc$functionPointer dq 1                          ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__heapAlloc                               ; code pointer
  func$_alloc$functionPointer dq 1                               ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_alloc                                    ; code pointer
  func$__heapFree$functionPointer dq 1                           ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__heapFree                                ; code pointer
  func$_free$functionPointer dq 1                                ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_free                                     ; code pointer
  func$_moveBytes$functionPointer dq 1                           ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_moveBytes                                ; code pointer
  func$_fillQuadWords$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_fillQuadWords                            ; code pointer
  func$_stringByteLength$functionPointer dq 1                    ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_stringByteLength                         ; code pointer
  func$digitToStr$functionPointer dq 1                           ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$digitToStr                                ; code pointer
  func$intToStr$functionPointer dq 1                             ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$intToStr                                  ; code pointer
  func$join$functionPointer dq 1                                 ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$join                                      ; code pointer
  func$_blockListInit$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_blockListInit                            ; code pointer
  func$_growBlockList$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_growBlockList                            ; code pointer
  func$_advanceToNextBlock$functionPointer dq 1                  ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_advanceToNextBlock                       ; code pointer
  func$_constructor$functionPointer dq 1                         ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_constructor                              ; code pointer
  func$_mark$functionPointer dq 1                                ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_mark                                     ; code pointer
  func$_garbageCollectorImplementation$functionPointer dq 1      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_garbageCollectorImplementation           ; code pointer
  func$_listConstructor$functionPointer dq 1                     ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_listConstructor                          ; code pointer
  func$_growList$functionPointer dq 1                            ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_growList                                 ; code pointer
  func$append$functionPointer dq 1                               ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$append                                    ; code pointer
  func$_classAllocator$functionPointer dq 1                      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_classAllocator                           ; code pointer
  func$_createMethodPointer$functionPointer dq 1                 ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_createMethodPointer                      ; code pointer
  func$_dummy1$functionPointer dq 1                              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_dummy1                                   ; code pointer
  func$_dynamicLookup$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_dynamicLookup                            ; code pointer
  func$__getStdHandle$functionPointer dq 1                       ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__getStdHandle                            ; code pointer
  func$__writeFile$functionPointer dq 1                          ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__writeFile                               ; code pointer
  func$__writeToHandle$functionPointer dq 1                      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$__writeToHandle                           ; code pointer
  func$_stringify$functionPointer dq 1                           ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_stringify                                ; code pointer
  func$_concat$functionPointer dq 1                              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_concat                                   ; code pointer
  func$println$functionPointer dq 1                              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$println                                   ; code pointer
  func$_stderr$functionPointer dq 1                              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_stderr                                   ; code pointer
  func$_error$functionPointer dq 1                               ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$_error                                    ; code pointer
  method$Object$Object$functionPointer dq 1                      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$Object$Object                           ; code pointer
  method$Test$Test$functionPointer dq 1                          ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$Test$Test                               ; code pointer
  method$Subclass$Subclass$functionPointer dq 1                  ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$Subclass$Subclass                       ; code pointer
  method$BunnyA$BunnyA$functionPointer dq 1                      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$BunnyA$BunnyA                           ; code pointer
  method$BunnyB$BunnyB$functionPointer dq 1                      ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$BunnyB$BunnyB                           ; code pointer
  method$CarrotRoot$CarrotRoot$functionPointer dq 1              ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$CarrotRoot$CarrotRoot                   ; code pointer
  method$CarrotBranchA$CarrotBranchA$functionPointer dq 1        ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$CarrotBranchA$CarrotBranchA             ; code pointer
  method$CarrotLeafA$CarrotLeafA$functionPointer dq 1            ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$CarrotLeafA$CarrotLeafA                 ; code pointer
  method$CarrotBranchB$CarrotBranchB$functionPointer dq 1        ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$CarrotBranchB$CarrotBranchB             ; code pointer
  method$A$A$functionPointer dq 1                                ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$A$A                                     ; code pointer
  method$B$B$functionPointer dq 1                                ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq method$B$B                                     ; code pointer
  func$six$functionPointer dq 1                                  ; reference count
               dq 2                                              ; number of fields in function pointer block
               dq 0                                              ; scratch space for garbage collector
               dq -1                                             ; block list entry pointer (invalid for function pointers as they are not in the block list)
               dq 54                                             ; type of receiver (Null)
               dq 0                                              ; pointer to receiver (null)
               dq 59                                             ; type of code pointer (Integer)
               dq func$six                                       ; code pointer

_BSS segment
  _blockEntrySizeType dq ?                                       ; dynamic type of _blockEntrySize variable
  _blockEntrySizeValue dq ?                                      ; _blockEntrySize variable
  _gcBlockHeaderRefCountType dq ?                                ; dynamic type of _gcBlockHeaderRefCount variable
  _gcBlockHeaderRefCountValue dq ?                               ; _gcBlockHeaderRefCount variable
  _gcBlockHeaderLengthType dq ?                                  ; dynamic type of _gcBlockHeaderLength variable
  _gcBlockHeaderLengthValue dq ?                                 ; _gcBlockHeaderLength variable
  _gcBlockHeaderScratchSpaceType dq ?                            ; dynamic type of _gcBlockHeaderScratchSpace variable
  _gcBlockHeaderScratchSpaceValue dq ?                           ; _gcBlockHeaderScratchSpace variable
  _gcBlockHeaderEntryPointerType dq ?                            ; dynamic type of _gcBlockHeaderEntryPointer variable
  _gcBlockHeaderEntryPointerValue dq ?                           ; _gcBlockHeaderEntryPointer variable
  _gcBlockDataType dq ?                                          ; dynamic type of _gcBlockData variable
  _gcBlockDataValue dq ?                                         ; _gcBlockData variable
  _vmtTypeCodeType dq ?                                          ; dynamic type of _vmtTypeCode variable
  _vmtTypeCodeValue dq ?                                         ; _vmtTypeCode variable
  _vmtFieldCountType dq ?                                        ; dynamic type of _vmtFieldCount variable
  _vmtFieldCountValue dq ?                                       ; _vmtFieldCount variable
  _vmtClassNameType dq ?                                         ; dynamic type of _vmtClassName variable
  _vmtClassNameValue dq ?                                        ; _vmtClassName variable
  _vmtDynamicDispatchTableType dq ?                              ; dynamic type of _vmtDynamicDispatchTable variable
  _vmtDynamicDispatchTableValue dq ?                             ; _vmtDynamicDispatchTable variable
  _subroutineReceiverTypeType dq ?                               ; dynamic type of _subroutineReceiverType variable
  _subroutineReceiverTypeValue dq ?                              ; _subroutineReceiverType variable
  _subroutineReceiverPointerType dq ?                            ; dynamic type of _subroutineReceiverPointer variable
  _subroutineReceiverPointerValue dq ?                           ; _subroutineReceiverPointer variable
  _subroutineCodeTypeType dq ?                                   ; dynamic type of _subroutineCodeType variable
  _subroutineCodeTypeValue dq ?                                  ; _subroutineCodeType variable
  _subroutineCodePointerType dq ?                                ; dynamic type of _subroutineCodePointer variable
  _subroutineCodePointerValue dq ?                               ; _subroutineCodePointer variable
  stderrType dq ?                                                ; dynamic type of stderr variable
  stderrValue dq ?                                               ; stderr variable
  _heapHandleType dq ?                                           ; dynamic type of _heapHandle variable
  _heapHandleValue dq ?                                          ; _heapHandle variable
  _blockCountType dq ?                                           ; dynamic type of _blockCount variable
  _blockCountValue dq ?                                          ; _blockCount variable
  _garbageCollectorType dq ?                                     ; dynamic type of _garbageCollector variable
  _garbageCollectorValue dq ?                                    ; _garbageCollector variable
  concatType dq ?                                                ; dynamic type of concat variable
  concatValue dq ?                                               ; concat variable
  _gcLockedType dq ?                                             ; dynamic type of _gcLocked variable
  _gcLockedValue dq ?                                            ; _gcLocked variable
  _blockListStartType dq ?                                       ; dynamic type of _blockListStart variable
  _blockListStartValue dq ?                                      ; _blockListStart variable
  _blockListEndType dq ?                                         ; dynamic type of _blockListEnd variable
  _blockListEndValue dq ?                                        ; _blockListEnd variable
  _blockListNextType dq ?                                        ; dynamic type of _blockListNext variable
  _blockListNextValue dq ?                                       ; _blockListNext variable
  _debugLiveBlocksType dq ?                                      ; dynamic type of _debugLiveBlocks variable
  _debugLiveBlocksValue dq ?                                     ; _debugLiveBlocks variable
  _currentTagType dq ?                                           ; dynamic type of _currentTag variable
  _currentTagValue dq ?                                          ; _currentTag variable
  __STD_OUTPUT_HANDLEType dq ?                                   ; dynamic type of __STD_OUTPUT_HANDLE variable
  __STD_OUTPUT_HANDLEValue dq ?                                  ; __STD_OUTPUT_HANDLE variable
  __STD_ERROR_HANDLEType dq ?                                    ; dynamic type of __STD_ERROR_HANDLE variable
  __STD_ERROR_HANDLEValue dq ?                                   ; __STD_ERROR_HANDLE variable
  _scratchType dq ?                                              ; dynamic type of _scratch variable
  _scratchValue dq ?                                             ; _scratch variable
  resultType dq ?                                                ; dynamic type of result variable
  resultValue dq ?                                               ; result variable

.code

public main
decrefString:
  ; Prolog
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 028h]                                ; set up frame pointer
  ; Body
  cmp qword ptr [rcx], 000h                                      ; compare value dereferenced to 0 (integer)
  jl decrefString$end                                            ; skip string decref block for string constants
  dec qword ptr [rcx]                                            ; decrement value dereferenced
  jnz decrefString$end                                           ; decrement reference count of value
  mov r10, rcx                                                   ; copy value of value to pointer
  ; Call _free with 1 arguments
  push r10                                                       ; value of argument #1 (value cast to integer)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_free                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  decrefString$end:                                              ; end of function
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  ret                                                            ; return from compiler-internal function

decrefMaybeGCOrString:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Body
  mov r10, rdx                                                   ; store value's type in testByte value slot
  mov qword ptr [rsp + 008h], rdx                                ; move value's type out of rdx
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that value is GarbageCollectable
  jnc decrefMaybeGCOrString$string                               ; valueskip GC decref block if the value is not GarbageCollectable
  dec qword ptr [rcx]                                            ; decref GarbageCollectable reference count of value
  jmp decrefMaybeGCOrString$end                                  ; return
  decrefMaybeGCOrString$string:                                  ; string decref
  cmp qword ptr [rsp + 008h], 039h                               ; compare type of value to String
  jne decrefMaybeGCOrString$end                                  ; skip string decref block if the value is not a String
  cmp qword ptr [rcx], 000h                                      ; compare value dereferenced to 0 (integer)
  jl decrefMaybeGCOrString$end                                   ; skip string decref block for string constants
  dec qword ptr [rcx]                                            ; decrement value dereferenced
  jnz decrefMaybeGCOrString$end                                  ; decrement reference count of value
  mov rdi, rcx                                                   ; copy value of value to pointer
  ; Call _free with 1 arguments
  push rdi                                                       ; value of argument #1 (value cast to integer)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r12, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_free                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  decrefMaybeGCOrString$end:                                     ; end of function
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from compiler-internal function

decrefMaybeString:
  ; Prolog
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 028h]                                ; set up frame pointer
  ; Body
  cmp rdx, 039h                                                  ; compare type of value to String
  jne decrefMaybeString$end                                      ; skip string decref block if the value is not a String
  cmp qword ptr [rcx], 000h                                      ; compare value dereferenced to 0 (integer)
  jl decrefMaybeString$end                                       ; skip string decref block for string constants
  dec qword ptr [rcx]                                            ; decrement value dereferenced
  jnz decrefMaybeString$end                                      ; decrement reference count of value
  mov r10, rcx                                                   ; copy value of value to pointer
  ; Call _free with 1 arguments
  push r10                                                       ; value of argument #1 (value cast to integer)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_free                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  decrefMaybeString$end:                                         ; end of function
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  ret                                                            ; return from compiler-internal function

decrefMaybeGC:
  ; Prolog
  push rbp                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  sub rsp, 010h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 028h]                                ; set up frame pointer
  ; Body
  mov r10, rdx                                                   ; store value's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that value is GarbageCollectable
  jnc decrefMaybeGC$end                                          ; valueskip GC decref block if the value is not GarbageCollectable
  dec qword ptr [rcx]                                            ; decref GarbageCollectable reference count of value
  decrefMaybeGC$end:                                             ; end of function
  ; Epilog
  add rsp, 010h                                                  ; free space for stack
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  ret                                                            ; return from compiler-internal function

main:
  ; runtime library
  ; ===============
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Line 5: Integer _blockEntrySize = 8;
  ; sentinel check of 8 type Integer expecting Integer
  mov qword ptr _blockEntrySizeValue, 008h                       ; value initialization of variable declaration for _blockEntrySize variable (8)
  mov qword ptr _blockEntrySizeType, 038h                        ; type initialization of variable declaration for _blockEntrySize variable (Integer'38)
  ; Line 6: Integer _gcBlockHeaderRefCount = 0 * 8;
  ; sentinel check of 0 type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr _gcBlockHeaderRefCountValue, 000h                ; value initialization of variable declaration for _gcBlockHeaderRefCount variable (* operator result)
  mov qword ptr _gcBlockHeaderRefCountType, 038h                 ; type initialization of variable declaration for _gcBlockHeaderRefCount variable (Integer'38)
  ; Line 7: Integer _gcBlockHeaderLength = 1 * 8;
  ; sentinel check of 1 type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr _gcBlockHeaderLengthValue, 008h                  ; value initialization of variable declaration for _gcBlockHeaderLength variable (* operator result)
  mov qword ptr _gcBlockHeaderLengthType, 038h                   ; type initialization of variable declaration for _gcBlockHeaderLength variable (Integer'38)
  ; Line 8: Integer _gcBlockHeaderScratchSpace = 2 * 8;
  ; sentinel check of 2 type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr _gcBlockHeaderScratchSpaceValue, 010h            ; value initialization of variable declaration for _gcBlockHeaderScratchSpace variable (* operator result)
  mov qword ptr _gcBlockHeaderScratchSpaceType, 038h             ; type initialization of variable declaration for _gcBlockHeaderScratchSpace variable (Integer'38)
  ; Line 9: Integer _gcBlockHeaderEntryPointer = 3 * 8;
  ; sentinel check of 3 type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr _gcBlockHeaderEntryPointerValue, 018h            ; value initialization of variable declaration for _gcBlockHeaderEntryPointer variable (* operator result)
  mov qword ptr _gcBlockHeaderEntryPointerType, 038h             ; type initialization of variable declaration for _gcBlockHeaderEntryPointer variable (Integer'38)
  ; Line 10: Integer _gcBlockData = 4 * 8;
  ; sentinel check of 4 type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr _gcBlockDataValue, 020h                          ; value initialization of variable declaration for _gcBlockData variable (* operator result)
  mov qword ptr _gcBlockDataType, 038h                           ; type initialization of variable declaration for _gcBlockData variable (Integer'38)
  ; Line 12: Integer _vmtTypeCode = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr _vmtTypeCodeValue, 000h                          ; value initialization of variable declaration for _vmtTypeCode variable (0)
  mov qword ptr _vmtTypeCodeType, 038h                           ; type initialization of variable declaration for _vmtTypeCode variable (Integer'38)
  ; Line 13: Integer _vmtFieldCount = 8;
  ; sentinel check of 8 type Integer expecting Integer
  mov qword ptr _vmtFieldCountValue, 008h                        ; value initialization of variable declaration for _vmtFieldCount variable (8)
  mov qword ptr _vmtFieldCountType, 038h                         ; type initialization of variable declaration for _vmtFieldCount variable (Integer'38)
  ; Line 14: Integer _vmtClassName = 16 /* 0x10 */;
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov qword ptr _vmtClassNameValue, 010h                         ; value initialization of variable declaration for _vmtClassName variable (16 /* 0x10 */)
  mov qword ptr _vmtClassNameType, 038h                          ; type initialization of variable declaration for _vmtClassName variable (Integer'38)
  ; Line 15: Integer _vmtParent = 24 /* 0x18 */;
  ; sentinel check of 24 /* 0x18 */ type Integer expecting Integer
  mov qword ptr [rsp + 018h], 018h                               ; value initialization of variable declaration for _vmtParent variable (24 /* 0x18 */)
  mov qword ptr [rsp + 010h], 038h                               ; type initialization of variable declaration for _vmtParent variable (Integer'38)
  ; Line 16: Integer _vmtDynamicDispatchTable = 32 /* 0x20 */;
  ; sentinel check of 32 /* 0x20 */ type Integer expecting Integer
  mov qword ptr _vmtDynamicDispatchTableValue, 020h              ; value initialization of variable declaration for _vmtDynamicDispatchTable variable (32 /* 0x20 */)
  mov qword ptr _vmtDynamicDispatchTableType, 038h               ; type initialization of variable declaration for _vmtDynamicDispatchTable variable (Integer'38)
  ; Line 17: Integer _vmtMethods = 40 /* 0x28 */;
  ; sentinel check of 40 /* 0x28 */ type Integer expecting Integer
  mov qword ptr [rsp + 018h], 028h                               ; value initialization of variable declaration for _vmtMethods variable (40 /* 0x28 */)
  mov qword ptr [rsp + 010h], 038h                               ; type initialization of variable declaration for _vmtMethods variable (Integer'38)
  ; Line 19: Integer _subroutineReceiverType = _gcBlockData + 0 * 16 /* 0x10 ...
  mov r15, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r10, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of 0 type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne runtimeLibrary$Gcblockdata$TypeMatch                       ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _gcBlockData's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  runtimeLibrary$Gcblockdata$TypeMatch:                          ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 018h], r10                                ; move copy of _gcBlockData's type out of r10
  mov r10, r15                                                   ; compute (copy of _gcBlockData) + (* operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _subroutineReceiverTypeValue, r10                ; value initialization of variable declaration for _subroutineReceiverType variable (+ operator result)
  mov qword ptr _subroutineReceiverTypeType, 038h                ; type initialization of variable declaration for _subroutineReceiverType variable (Integer'38)
  ; Line 20: Integer _subroutineReceiverPointer = _gcBlockData + 0 * 16 /* 0x...
  mov rsi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of 0 type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne runtimeLibrary$Gcblockdata$TypeMatch$1                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  runtimeLibrary$Gcblockdata$TypeMatch$1:                        ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 018h], rdi                                ; move copy of _gcBlockData's type out of rdi
  mov rdi, rsi                                                   ; compute (copy of _gcBlockData) + (* operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of + operator result to value of + operator result
  add r10, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _subroutineReceiverPointerValue, r10             ; value initialization of variable declaration for _subroutineReceiverPointer variable (+ operator result)
  mov qword ptr _subroutineReceiverPointerType, 038h             ; type initialization of variable declaration for _subroutineReceiverPointer variable (Integer'38)
  ; Line 21: Integer _subroutineCodeType = _gcBlockData + 1 * 16 /* 0x10 */;
  mov rsi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of 1 type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne runtimeLibrary$Gcblockdata$TypeMatch$2                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  runtimeLibrary$Gcblockdata$TypeMatch$2:                        ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 018h], rdi                                ; move copy of _gcBlockData's type out of rdi
  mov rdi, rsi                                                   ; assign value of copy of _gcBlockData to value of + operator result
  add rdi, 010h                                                  ; compute (copy of _gcBlockData) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _subroutineCodeTypeValue, rdi                    ; value initialization of variable declaration for _subroutineCodeType variable (+ operator result)
  mov qword ptr _subroutineCodeTypeType, 038h                    ; type initialization of variable declaration for _subroutineCodeType variable (Integer'38)
  ; Line 22: Integer _subroutineCodePointer = _gcBlockData + 1 * 16 /* 0x10 *...
  mov r14, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r15, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of 1 type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne runtimeLibrary$Gcblockdata$TypeMatch$3                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  runtimeLibrary$Gcblockdata$TypeMatch$3:                        ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 018h], r15                                ; move copy of _gcBlockData's type out of r15
  mov r15, r14                                                   ; assign value of copy of _gcBlockData to value of + operator result
  add r15, 010h                                                  ; compute (copy of _gcBlockData) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov rdi, r15                                                   ; assign value of + operator result to value of + operator result
  add rdi, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _subroutineCodePointerValue, rdi                 ; value initialization of variable declaration for _subroutineCodePointer variable (+ operator result)
  mov qword ptr _subroutineCodePointerType, 038h                 ; type initialization of variable declaration for _subroutineCodePointer variable (Integer'38)
  ; Line 52: Integer _heapHandle = __getProcessHeap();
  ; sentinel check of __getProcessHeap type IntegerFunction() expecting AnythingFunction
  ; Call __getProcessHeap with 0 arguments
  lea r10, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call func$__getProcessHeap                                     ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of __getProcessHeap return value type Integer expecting Integer
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of __getProcessHeap return value to <sentinel>
  jne runtimeLibrary$GetprocessheapReturnValue$TypeMatch         ; skip next block if __getProcessHeap return value is not sentinel
    ; Error handling block for __getProcessHeap return value
    ; Call __error with 1 arguments
    mov rax, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  runtimeLibrary$GetprocessheapReturnValue$TypeMatch:            ; after block
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (qword ptr _heapHandleValue, stack operand #1) is not allowed with mov
  mov qword ptr _heapHandleValue, r11                            ; value initialization of variable declaration for _heapHandle variable (__getProcessHeap return value)
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr _heapHandleType, stack operand #2) is not allowed with mov
  mov qword ptr _heapHandleType, r11                             ; type initialization of variable declaration for _heapHandle variable
  ; Line 56: Integer _blockCount = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr _blockCountValue, 000h                           ; value initialization of variable declaration for _blockCount variable (0)
  mov qword ptr _blockCountType, 038h                            ; type initialization of variable declaration for _blockCount variable (Integer'38)
  ; Line 253: Integer _gcLocked = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr _gcLockedValue, 000h                             ; value initialization of variable declaration for _gcLocked variable (0)
  mov qword ptr _gcLockedType, 038h                              ; type initialization of variable declaration for _gcLocked variable (Integer'38)
  ; Line 257: Integer _debugLiveBlocks = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr _debugLiveBlocksValue, 000h                      ; value initialization of variable declaration for _debugLiveBlocks variable (0)
  mov qword ptr _debugLiveBlocksType, 038h                       ; type initialization of variable declaration for _debugLiveBlocks variable (Integer'38)
  ; Line 269: _blockListInit(1024 /* 0x400 */);
  ; sentinel check of _blockListInit type NullFunction(Integer) expecting AnythingFunction
  ; Call _blockListInit with 1 arguments
  push 000000400h                                                ; value of argument #1 (1024 /* 0x400 */)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rbx, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_blockListInit                                       ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 337: Integer _currentTag = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr _currentTagValue, 000h                           ; value initialization of variable declaration for _currentTag variable (0)
  mov qword ptr _currentTagType, 038h                            ; type initialization of variable declaration for _currentTag variable (Integer'38)
  ; Line 372: _garbageCollector = _garbageCollectorImplementation;
  ; sentinel check of _garbageCollectorImplementation type NullFunction() expecting NullFunction
  mov r11, offset func$_garbageCollectorImplementation$functionPointer ; indirect through r11 because operand pair (qword ptr _garbageCollectorValue, offset func$_garbageCollectorImplementation$functionPointer) is not allowed with mov
  mov qword ptr _garbageCollectorValue, r11                      ; store value
  mov qword ptr _garbageCollectorType, 003h                      ; store type (NullFunction()'3)
  ; increment reference count for _garbageCollector variable if necessary
  mov r14, qword ptr _garbageCollectorType                       ; store _garbageCollector variable's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc runtimeLibrary$AfterGCIncref                               ; if not a GarbageCollectable, skip incref
    mov rbx, qword ptr _garbageCollectorValue                    ; read slot into register for dereferencing
    inc qword ptr [rbx]                                          ; increment reference count of _garbageCollector variable
    mov qword ptr _garbageCollectorValue, rbx                    ; restoring slot (_garbageCollector variable) to previous scope state for genuine block exit
  runtimeLibrary$AfterGCIncref:                                  ; after GarbageCollectable incref
  ; Line 679: Integer __STD_OUTPUT_HANDLE = -11 /* 0xb */;
  ; sentinel check of 11 /* 0xb */ type Integer expecting Integer
  mov r12, 00bh                                                  ; assign value of 11 /* 0xb */ to value of - unary operator result
  neg r12                                                        ; - unary operator
  ; sentinel check of - unary operator result type Integer expecting Integer
  mov qword ptr __STD_OUTPUT_HANDLEValue, r12                    ; value initialization of variable declaration for __STD_OUTPUT_HANDLE variable (- unary operator result)
  mov qword ptr __STD_OUTPUT_HANDLEType, 038h                    ; type initialization of variable declaration for __STD_OUTPUT_HANDLE variable (Integer'38)
  ; Line 680: Integer __STD_ERROR_HANDLE = -12 /* 0xc */;
  ; sentinel check of 12 /* 0xc */ type Integer expecting Integer
  mov r10, 00ch                                                  ; assign value of 12 /* 0xc */ to value of - unary operator result
  neg r10                                                        ; - unary operator
  ; sentinel check of - unary operator result type Integer expecting Integer
  mov qword ptr __STD_ERROR_HANDLEValue, r10                     ; value initialization of variable declaration for __STD_ERROR_HANDLE variable (- unary operator result)
  mov qword ptr __STD_ERROR_HANDLEType, 038h                     ; type initialization of variable declaration for __STD_ERROR_HANDLE variable (Integer'38)
  ; Line 681: Integer _scratch = _alloc(8);
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push 008h                                                      ; value of argument #1 (8)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r13, qword ptr [rsp + 028h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 028h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne runtimeLibrary$AllocReturnValue$TypeMatch                  ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  runtimeLibrary$AllocReturnValue$TypeMatch:                     ; after block
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (qword ptr _scratchValue, stack operand #1) is not allowed with mov
  mov qword ptr _scratchValue, r11                               ; value initialization of variable declaration for _scratch variable (_alloc return value)
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr _scratchType, stack operand #2) is not allowed with mov
  mov qword ptr _scratchType, r11                                ; type initialization of variable declaration for _scratch variable
  ; Line 778: concat = _concat;
  ; sentinel check of _concat type StringFunction(Anything...) expecting StringFunction
  mov r11, offset func$_concat$functionPointer                   ; indirect through r11 because operand pair (qword ptr concatValue, offset func$_concat$functionPointer) is not allowed with mov
  mov qword ptr concatValue, r11                                 ; store value
  mov qword ptr concatType, 01eh                                 ; store type (StringFunction(Anything...)'1e)
  ; increment reference count for concat variable if necessary
  mov rbx, qword ptr concatType                                  ; store concat variable's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc runtimeLibrary$AfterGCIncref$1                             ; if not a GarbageCollectable, skip incref
    mov r12, qword ptr concatValue                               ; read slot into register for dereferencing
    inc qword ptr [r12]                                          ; increment reference count of concat variable
    mov qword ptr concatValue, r12                               ; restoring slot (concat variable) to previous scope state for genuine block exit
  runtimeLibrary$AfterGCIncref$1:                                ; after GarbageCollectable incref
  ; Line 820: stderr = _stderr;
  ; sentinel check of _stderr type NullFunction(Anything...) expecting NullFunction
  mov r11, offset func$_stderr$functionPointer                   ; indirect through r11 because operand pair (qword ptr stderrValue, offset func$_stderr$functionPointer) is not allowed with mov
  mov qword ptr stderrValue, r11                                 ; store value
  mov qword ptr stderrType, 022h                                 ; store type (NullFunction(Anything...)'22)
  ; increment reference count for stderr variable if necessary
  mov r15, qword ptr stderrType                                  ; store stderr variable's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc runtimeLibrary$AfterGCIncref$2                             ; if not a GarbageCollectable, skip incref
    mov rsi, qword ptr stderrValue                               ; read slot into register for dereferencing
    inc qword ptr [rsi]                                          ; increment reference count of stderr variable
    mov qword ptr stderrValue, rsi                               ; restoring slot (stderr variable) to previous scope state for genuine block exit
  runtimeLibrary$AfterGCIncref$2:                                ; after GarbageCollectable incref
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers

  ; temp.syd
  ; ========
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0338h                                                 ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0378h]                               ; set up frame pointer
  ; Line 36: println('FIELD:', Test().field);
  ; sentinel check of Test type TestFunction() expecting AnythingFunction
  ; Call Test with 0 arguments
  lea rbx, qword ptr [rsp + 0320h]                               ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0320h]                               ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$Test$Test                                          ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rsi, qword ptr [rsp + 0320h]                               ; move "this" pointer to register to dereference a field
  mov rdi, qword ptr [rsi + 048h]                                ; make a copy of Test.field's value in case it changes before we use it
  mov r12, qword ptr [rsi + 040h]                                ; make a copy of Test.field's type in case it changes before we use it
  ; increment reference count for copy of Test.field if necessary
  cmp r12, 039h                                                  ; compare type of copy of Test.field to String
  jne tempSyd$AfterStringIncref                                  ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref                                     ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref                                ; skip incref for string constants
    tempSyd$StringIncref:                                        ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of Test.field
  tempSyd$AfterStringIncref:                                     ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push rdi                                                       ; value of argument #2 (copy of Test.field)
  push r12                                                       ; type of argument #2
  mov r10, offset string$61                                      ; reading string for push
  push r10                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rax, qword ptr [rsp + 0340h]                               ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 0338h]                               ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 37: println('METHOD:', Test().method());
  ; sentinel check of Test type TestFunction() expecting AnythingFunction
  ; Call Test with 0 arguments
  mov qword ptr [rsp + 0310h], rdi                               ; move copy of Test.field's value out of rdi
  lea rdi, qword ptr [rsp + 0320h]                               ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 0310h]                               ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$Test$Test                                          ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  mov qword ptr [rsp + 0300h], r12                               ; move copy of Test.field's type out of r12
  mov r12, qword ptr [rsp + 0320h]                               ; get Test return value into register to dereference it
  mov r13, qword ptr [r12 + 028h]                                ; get vmt
  add r13, 0a0h                                                  ; add offset for dereference (result in code address for Test.method)
  mov r13, qword ptr [r13]                                       ; get call method
  mov r14, 03bh                                                  ; store code of __CodeAddress value in code address for Test.method's type slot
  ; sentinel check of code address for Test.method type __CodeAddress expecting __CodeAddress
  cmp r14, 000h                                                  ; compare type of code address for Test.method to <sentinel>
  jne tempSyd$codeAddressForTEstMethod$TypeMatch                 ; skip next block if code address for Test.method is not sentinel
    ; Error handling block for code address for Test.method
    ; Call __error with 1 arguments
    mov r15, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 0330h]                             ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 0310h]                             ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$codeAddressForTEstMethod$TypeMatch:                    ; after block
  ; Call code address for Test.method with 0 arguments
  lea rax, qword ptr [rsp + 0320h]                               ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 0300h]                               ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r12                                                    ; internal argument 4: "this" pointer
  mov r8, qword ptr [rsp + 0338h]                                ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0338h], r8                                ; move Test return value's type out of r8
  mov qword ptr [rsp + 0320h], r9                                ; move Test return value's value out of r9
  call r13                                                       ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 0320h]                                   ; value of argument #2 (code address for Test.method return value)
  push qword ptr [rsp + 0300h]                                   ; type of argument #2
  mov rdi, offset string$62                                      ; reading string for push
  push rdi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r12, qword ptr [rsp + 0308h]                               ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 0308h]                               ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 38: println('CLASSNAME:', Test().className);
  ; sentinel check of Test type TestFunction() expecting AnythingFunction
  ; Call Test with 0 arguments
  lea r15, qword ptr [rsp + 02e8h]                               ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 02e8h]                               ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$Test$Test                                          ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 02e8h]                               ; move "this" pointer to register to dereference a field
  mov r10, qword ptr [rbx + 038h]                                ; make a copy of Test.className's value in case it changes before we use it
  mov rax, qword ptr [rbx + 030h]                                ; make a copy of Test.className's type in case it changes before we use it
  ; increment reference count for copy of Test.className if necessary
  cmp rax, 039h                                                  ; compare type of copy of Test.className to String
  jne tempSyd$AfterStringIncref$1                                ; if not a String, skip incref
    mov qword ptr [rsp + 02e8h], rsi                             ; move Test return value's value out of rsi
    mov rsi, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp rsi, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$1                                   ; if reference count is negative (constant strings), skip incref
    mov rsi, qword ptr [rsp + 02e8h]                             ; restoring slot (???) to previous scope state for synthetic block exit
    jmp tempSyd$AfterStringIncref$1                              ; skip incref for string constants
    tempSyd$StringIncref$1:                                      ; real String
      inc qword ptr [r10]                                        ; increment reference count of copy of Test.className
    mov rsi, qword ptr [rsp + 02e8h]                             ; restoring slot (Test return value) to previous scope state for genuine block exit
  tempSyd$AfterStringIncref$1:                                   ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push r10                                                       ; value of argument #2 (copy of Test.className)
  push rax                                                       ; type of argument #2
  mov r13, offset string$63                                      ; reading string for push
  push r13                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r14, qword ptr [rsp + 0308h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0300h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0320h], r10                               ; move copy of Test.className's value out of r10
  mov qword ptr [rsp + 0318h], rax                               ; move copy of Test.className's type out of rax
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 40: Test test = Test();
  ; sentinel check of Test type TestFunction() expecting AnythingFunction
  ; Call Test with 0 arguments
  lea r10, qword ptr [rsp + 02c0h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 02c0h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$Test$Test                                          ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of Test return value type Test expecting Test
  cmp qword ptr [rsp + 02b8h], 000h                              ; compare type of Test return value to <sentinel>
  jne tempSyd$testReturnValue$TypeMatch                          ; skip next block if Test return value is not sentinel
    ; Error handling block for Test return value
    ; Call __error with 1 arguments
    mov rax, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 02b8h], rsi                             ; move Test return value's value out of rsi
    lea rsi, qword ptr [rsp + 02c0h]                             ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 02b8h]                             ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 02a8h]                             ; restoring slot (Test return value) to previous scope state for genuine block exit
  tempSyd$testReturnValue$TypeMatch:                             ; after block
  mov r11, qword ptr [rsp + 02c0h]                               ; indirect through r11 because operand pair (stack operand #8, stack operand #13) is not allowed with mov
  mov qword ptr [rsp + 02e8h], r11                               ; value initialization of variable declaration for test variable (Test return value)
  mov r11, qword ptr [rsp + 02b8h]                               ; indirect through r11 because operand pair (stack operand #10, stack operand #14) is not allowed with mov
  mov qword ptr [rsp + 02d8h], r11                               ; type initialization of variable declaration for test variable
  ; increment reference count for test variable if necessary
  mov rdi, qword ptr [rsp + 02d8h]                               ; store test variable's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref                                      ; if not a GarbageCollectable, skip incref
    mov r14, qword ptr [rsp + 02e8h]                             ; read slot into register for dereferencing
    inc qword ptr [r14]                                          ; increment reference count of test variable
    mov qword ptr [rsp + 02e8h], r14                             ; restoring slot (test variable) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref:                                         ; after GarbageCollectable incref
  ; Line 41: println('FIELD:', test.field);
  mov r15, qword ptr [rsp + 02e8h]                               ; make a copy of test's value in case it changes before we use it
  mov qword ptr [rsp + 02b0h], rbx                               ; move Test return value's value out of rbx
  mov rbx, qword ptr [rsp + 02d8h]                               ; make a copy of test's type in case it changes before we use it
  ; increment reference count for copy of test if necessary
  mov r10, rbx                                                   ; store copy of test's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov qword ptr [rsp + 02a8h], rsi                               ; move Test return value's value out of rsi
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$1                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of test
  tempSyd$AfterGCIncref$1:                                       ; after GarbageCollectable incref
  mov r8, qword ptr [r15 + 048h]                                 ; make a copy of Test.field's value in case it changes before we use it
  mov rdx, qword ptr [r15 + 040h]                                ; make a copy of Test.field's type in case it changes before we use it
  ; increment reference count for copy of Test.field if necessary
  cmp rdx, 039h                                                  ; compare type of copy of Test.field to String
  jne tempSyd$AfterStringIncref$2                                ; if not a String, skip incref
    mov rcx, qword ptr [r8]                                      ; dereference string to get to reference count
    cmp rcx, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$2                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$2                              ; skip incref for string constants
    tempSyd$StringIncref$2:                                      ; real String
      inc qword ptr [r8]                                         ; increment reference count of copy of Test.field
  tempSyd$AfterStringIncref$2:                                   ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push r8                                                        ; value of argument #2 (copy of Test.field)
  push rdx                                                       ; type of argument #2
  mov r13, offset string$61                                      ; reading string for push
  push r13                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r14, qword ptr [rsp + 02c0h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 02c0h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 02e0h], r8                                ; move copy of Test.field's value out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov qword ptr [rsp + 02d8h], rdx                               ; move copy of Test.field's type out of rdx
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 42: println('METHOD:', test.method());
  mov qword ptr [rsp + 02a0h], r15                               ; move copy of test's value out of r15
  mov r15, qword ptr [rsp + 02e8h]                               ; make a copy of test's value in case it changes before we use it
  mov qword ptr [rsp + 0298h], rbx                               ; move copy of test's type out of rbx
  mov rbx, qword ptr [rsp + 02d8h]                               ; make a copy of test's type in case it changes before we use it
  ; increment reference count for copy of test if necessary
  mov r10, rbx                                                   ; store copy of test's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$2                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of test
  tempSyd$AfterGCIncref$2:                                       ; after GarbageCollectable incref
  mov r12, qword ptr [r15 + 028h]                                ; get vmt
  add r12, 0a0h                                                  ; add offset for dereference (result in code address for Test.method)
  mov r12, qword ptr [r12]                                       ; get call method
  mov r13, 03bh                                                  ; store code of __CodeAddress value in code address for Test.method's type slot
  ; sentinel check of code address for Test.method type __CodeAddress expecting __CodeAddress
  cmp r13, 000h                                                  ; compare type of code address for Test.method to <sentinel>
  jne tempSyd$codeAddressForTEstMethod$TypeMatch$1               ; skip next block if code address for Test.method is not sentinel
    ; Error handling block for code address for Test.method
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r9, qword ptr [rsp + 0290h]                              ; load address of return value's value
    push r9                                                      ; internal argument 6: pointer to return value slot's value
    lea r9, qword ptr [rsp + 0290h]                              ; load address of return value's type
    push r9                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$codeAddressForTEstMethod$TypeMatch$1:                  ; after block
  ; Call code address for Test.method with 0 arguments
  mov qword ptr [rsp + 0278h], r15                               ; move copy of test's value out of r15
  lea r15, qword ptr [rsp + 0280h]                               ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 0278h]                               ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, qword ptr [rsp + 02a8h]                                ; internal argument 4: "this" pointer
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 02a8h], r8                                ; move copy of test's type out of r8
  mov qword ptr [rsp + 0298h], r9                                ; move copy of test's value out of r9
  call r12                                                       ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 0280h]                                   ; value of argument #2 (code address for Test.method return value)
  push qword ptr [rsp + 0278h]                                   ; type of argument #2
  mov rax, offset string$62                                      ; reading string for push
  push rax                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rsi, qword ptr [rsp + 0280h]                               ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 0280h]                               ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 43: println('CLASSNAME:', test.className);
  mov rdi, qword ptr [rsp + 02e8h]                               ; make a copy of test's value in case it changes before we use it
  mov r12, qword ptr [rsp + 02d8h]                               ; make a copy of test's type in case it changes before we use it
  ; increment reference count for copy of test if necessary
  mov r13, r12                                                   ; store copy of test's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$3                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [rdi]                                          ; increment reference count of copy of test
  tempSyd$AfterGCIncref$3:                                       ; after GarbageCollectable incref
  mov rbx, qword ptr [rdi + 038h]                                ; make a copy of Test.className's value in case it changes before we use it
  mov r10, qword ptr [rdi + 030h]                                ; make a copy of Test.className's type in case it changes before we use it
  ; increment reference count for copy of Test.className if necessary
  cmp r10, 039h                                                  ; compare type of copy of Test.className to String
  jne tempSyd$AfterStringIncref$3                                ; if not a String, skip incref
    mov rsi, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp rsi, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$3                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$3                              ; skip incref for string constants
    tempSyd$StringIncref$3:                                      ; real String
      inc qword ptr [rbx]                                        ; increment reference count of copy of Test.className
  tempSyd$AfterStringIncref$3:                                   ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push rbx                                                       ; value of argument #2 (copy of Test.className)
  push r10                                                       ; type of argument #2
  mov qword ptr [rsp + 0270h], rdi                               ; move copy of test's value out of rdi
  mov rdi, offset string$63                                      ; reading string for push
  push rdi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  mov qword ptr [rsp + 0270h], r12                               ; move copy of test's type out of r12
  lea r12, qword ptr [rsp + 0278h]                               ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 0270h]                               ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0290h], r10                               ; move copy of Test.className's type out of r10
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 45: test.mutateField('CARROT');
  mov r13, qword ptr [rsp + 02e8h]                               ; make a copy of test's value in case it changes before we use it
  mov rax, qword ptr [rsp + 02d8h]                               ; make a copy of test's type in case it changes before we use it
  ; increment reference count for copy of test if necessary
  mov r14, rax                                                   ; store copy of test's type in testByte value slot
  mov qword ptr [rsp + 0258h], rax                               ; move copy of test's type out of rax
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 0248h], rbx                               ; move copy of Test.className's value out of rbx
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$4                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of test
  tempSyd$AfterGCIncref$4:                                       ; after GarbageCollectable incref
  mov r10, qword ptr [r13 + 028h]                                ; get vmt
  add r10, 080h                                                  ; add offset for dereference (result in code address for Test.mutateField)
  mov r10, qword ptr [r10]                                       ; get call method
  mov rsi, 03bh                                                  ; store code of __CodeAddress value in code address for Test.mutateField's type slot
  ; sentinel check of code address for Test.mutateField type __CodeAddress expecting __CodeAddress
  cmp rsi, 000h                                                  ; compare type of code address for Test.mutateField to <sentinel>
  jne tempSyd$codeAddressForTEstMutatefield$TypeMatch            ; skip next block if code address for Test.mutateField is not sentinel
    ; Error handling block for code address for Test.mutateField
    ; Call __error with 1 arguments
    mov rdi, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 0248h]                             ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0248h]                             ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0268h], r10                             ; move code address for Test.mutateField's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 0228h]                             ; restoring slot (code address for Test.mutateField) to previous scope state for genuine block exit
  tempSyd$codeAddressForTEstMutatefield$TypeMatch:               ; after block
  ; Call code address for Test.mutateField with 1 arguments
  mov qword ptr [rsp + 0238h], r13                               ; move copy of test's value out of r13
  mov r13, offset string$64                                      ; reading string for push
  push r13                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r14, qword ptr [rsp + 0240h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0240h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, qword ptr [rsp + 0278h]                                ; internal argument 4: "this" pointer
  mov r8, qword ptr [rsp + 0298h]                                ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0298h], r10                               ; move code address for Test.mutateField's value out of r10
  mov qword ptr [rsp + 0278h], r8                                ; move copy of test's type out of r8
  mov qword ptr [rsp + 0260h], r9                                ; move copy of test's value out of r9
  call qword ptr [rsp + 0298h]                                   ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 46: println('FIELD (should now be CARROT):', test.field);
  mov rax, qword ptr [rsp + 02e8h]                               ; make a copy of test's value in case it changes before we use it
  mov r15, qword ptr [rsp + 02d8h]                               ; make a copy of test's type in case it changes before we use it
  ; increment reference count for copy of test if necessary
  mov rbx, r15                                                   ; store copy of test's type in testByte value slot
  mov qword ptr [rsp + 0258h], rax                               ; move copy of test's value out of rax
  mov rax, rbx                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$5                                    ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 0258h]                             ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of copy of test
    mov qword ptr [rsp + 0258h], rdi                             ; restoring slot (copy of test) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref$5:                                       ; after GarbageCollectable incref
  mov r12, qword ptr [rsp + 0258h]                               ; move "this" pointer to register to dereference a field
  mov r13, qword ptr [r12 + 048h]                                ; make a copy of Test.field's value in case it changes before we use it
  mov r14, qword ptr [r12 + 040h]                                ; make a copy of Test.field's type in case it changes before we use it
  ; increment reference count for copy of Test.field if necessary
  cmp r14, 039h                                                  ; compare type of copy of Test.field to String
  jne tempSyd$AfterStringIncref$4                                ; if not a String, skip incref
    mov r9, qword ptr [r13]                                      ; dereference string to get to reference count
    cmp r9, 0                                                    ; compare string reference count to 0
    jns tempSyd$StringIncref$4                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$4                              ; skip incref for string constants
    tempSyd$StringIncref$4:                                      ; real String
      inc qword ptr [r13]                                        ; increment reference count of copy of Test.field
  tempSyd$AfterStringIncref$4:                                   ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push r13                                                       ; value of argument #2 (copy of Test.field)
  push r14                                                       ; type of argument #2
  mov qword ptr [rsp + 0268h], r15                               ; move copy of test's type out of r15
  mov r15, offset string$65                                      ; reading string for push
  push r15                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rbx, qword ptr [rsp + 0250h]                               ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0250h]                               ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 48: Subclass subclass = Subclass('PEA');
  ; sentinel check of Subclass type SubclassFunction(String) expecting AnythingFunction
  ; Call Subclass with 1 arguments
  mov rsi, offset string$66                                      ; reading string for push
  push rsi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rdi, qword ptr [rsp + 0228h]                               ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 0228h]                               ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call method$Subclass$Subclass                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of Subclass return value type Subclass expecting Subclass
  cmp qword ptr [rsp + 0210h], 000h                              ; compare type of Subclass return value to <sentinel>
  jne tempSyd$subclassReturnValue$TypeMatch                      ; skip next block if Subclass return value is not sentinel
    ; Error handling block for Subclass return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 0208h], r12                             ; move copy of test's value out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 0208h], r13                             ; move copy of Test.field's value out of r13
    lea r13, qword ptr [rsp + 0210h]                             ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0208h]                             ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 0208h]                             ; restoring slot (copy of test) to previous scope state for genuine block exit
    mov r13, qword ptr [rsp + 01f8h]                             ; restoring slot (copy of Test.field) to previous scope state for genuine block exit
  tempSyd$subclassReturnValue$TypeMatch:                         ; after block
  mov r11, qword ptr [rsp + 0218h]                               ; indirect through r11 because operand pair (stack operand #31, stack operand #34) is not allowed with mov
  mov qword ptr [rsp + 0230h], r11                               ; value initialization of variable declaration for subclass variable (Subclass return value)
  mov r11, qword ptr [rsp + 0210h]                               ; indirect through r11 because operand pair (stack operand #32, stack operand #35) is not allowed with mov
  mov qword ptr [rsp + 0228h], r11                               ; type initialization of variable declaration for subclass variable
  ; increment reference count for subclass variable if necessary
  mov qword ptr [rsp + 0208h], r14                               ; move copy of Test.field's type out of r14
  mov r14, qword ptr [rsp + 0228h]                               ; store subclass variable's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$6                                    ; if not a GarbageCollectable, skip incref
    mov r10, qword ptr [rsp + 0230h]                             ; read slot into register for dereferencing
    inc qword ptr [r10]                                          ; increment reference count of subclass variable
    mov qword ptr [rsp + 0230h], r10                             ; restoring slot (subclass variable) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref$6:                                       ; after GarbageCollectable incref
  ; Line 49: println('FIELD (should be PEA):', subclass.field);
  mov rsi, qword ptr [rsp + 0230h]                               ; make a copy of subclass's value in case it changes before we use it
  mov rdi, qword ptr [rsp + 0228h]                               ; make a copy of subclass's type in case it changes before we use it
  ; increment reference count for copy of subclass if necessary
  mov qword ptr [rsp + 0200h], r12                               ; move copy of test's value out of r12
  mov r12, rdi                                                   ; store copy of subclass's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov qword ptr [rsp + 01f8h], r13                               ; move copy of Test.field's value out of r13
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$7                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [rsi]                                          ; increment reference count of copy of subclass
  tempSyd$AfterGCIncref$7:                                       ; after GarbageCollectable incref
  mov r8, qword ptr [rsi + 048h]                                 ; make a copy of Subclass.field's value in case it changes before we use it
  mov rdx, qword ptr [rsi + 040h]                                ; make a copy of Subclass.field's type in case it changes before we use it
  ; increment reference count for copy of Subclass.field if necessary
  cmp rdx, 039h                                                  ; compare type of copy of Subclass.field to String
  jne tempSyd$AfterStringIncref$5                                ; if not a String, skip incref
    mov rcx, qword ptr [r8]                                      ; dereference string to get to reference count
    cmp rcx, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$5                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$5                              ; skip incref for string constants
    tempSyd$StringIncref$5:                                      ; real String
      inc qword ptr [r8]                                         ; increment reference count of copy of Subclass.field
  tempSyd$AfterStringIncref$5:                                   ; after String incref
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push r8                                                        ; value of argument #2 (copy of Subclass.field)
  push rdx                                                       ; type of argument #2
  mov rbx, offset string$67                                      ; reading string for push
  push rbx                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r10, qword ptr [rsp + 0210h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 0210h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 0230h], r8                                ; move copy of Subclass.field's value out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov qword ptr [rsp + 0228h], rdx                               ; move copy of Subclass.field's type out of rdx
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 51: println('as Whatever:');
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 1 arguments
  mov r12, offset string$68                                      ; reading string for push
  push r12                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rax, qword ptr [rsp + 0200h]                               ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 0200h]                               ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 52: println('METHOD caller:', subclass as Whatever.method as Whateve...
  mov r13, qword ptr [rsp + 0230h]                               ; make a copy of subclass's value in case it changes before we use it
  mov r14, qword ptr [rsp + 0228h]                               ; make a copy of subclass's type in case it changes before we use it
  ; increment reference count for copy of subclass if necessary
  mov r15, r14                                                   ; store copy of subclass's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$8                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of subclass
  tempSyd$AfterGCIncref$8:                                       ; after GarbageCollectable incref
  ; sentinel check of copy of subclass type Subclass expecting Whatever
  cmp r14, 000h                                                  ; compare type of copy of subclass to <sentinel>
  jne tempSyd$subclassAsWHatever$TypeMatch                       ; skip next block if copy of subclass is not sentinel
    ; Error handling block for subclass as Whatever
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 01f0h], rsi                             ; move copy of subclass's value out of rsi
    mov rsi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rsi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 01e0h], rdi                             ; move copy of subclass's type out of rdi
    lea rdi, qword ptr [rsp + 01f8h]                             ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 01e0h]                             ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 01f0h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 01d0h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
  tempSyd$subclassAsWHatever$TypeMatch:                          ; after block
  mov r12, r13                                                   ; copy value of copy of subclass for cast to Whatever
  mov qword ptr [rsp + 01f0h], r13                               ; move copy of subclass's value out of r13
  mov r13, r14                                                   ; copy type of copy of subclass for cast to Whatever
  ; Call _dynamicLookup with 2 arguments
  push 000h                                                      ; value of argument #2 (0 (integer))
  push 038h                                                      ; type of argument #2 (Integer'38)
  push r12                                                       ; value of argument #1 (cast of copy of subclass to Whatever)
  push r13                                                       ; type of argument #1
  mov qword ptr [rsp + 01f0h], r14                               ; move copy of subclass's type out of r14
  lea r14, qword ptr [rsp + 0208h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 01f0h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$_dynamicLookup                                       ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Call _dynamicLookup return value with 0 arguments
  mov r15, qword ptr [rsp + 01e8h]                               ; get _dynamicLookup return value into register to dereference it
  mov rax, qword ptr [r15 + 028h]                                ; read receiver pointer
  mov rbx, qword ptr [r15 + 020h]                                ; read receiver type
  lea r10, qword ptr [rsp + 01e8h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 01c8h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rax                                                    ; internal argument 4: "this" pointer
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r15 + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _dynamicLookup return value return value type Whatever expecting Whatever
  cmp qword ptr [rsp + 01c0h], 000h                              ; compare type of _dynamicLookup return value return value to <sentinel>
  jne tempSyd$subclassAsWHateverMethodAsWHatever$TypeMatch       ; skip next block if _dynamicLookup return value return value is not sentinel
    ; Error handling block for subclass as Whatever.method as Whatever
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 01c8h], rsi                             ; move copy of subclass's value out of rsi
    mov rsi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rsi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 01c0h], rdi                             ; move copy of subclass's type out of rdi
    lea rdi, qword ptr [rsp + 01c8h]                             ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 01c0h]                             ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 01c8h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 01b0h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
  tempSyd$subclassAsWHateverMethodAsWHatever$TypeMatch:          ; after block
  mov r12, qword ptr [rsp + 01e8h]                               ; copy value of _dynamicLookup return value return value for cast to Whatever
  mov r13, qword ptr [rsp + 01c0h]                               ; copy type of _dynamicLookup return value return value for cast to Whatever
  ; sentinel check of cast of _dynamicLookup return value return value to Whatever type Whatever expecting AnythingFunction
  cmp r13, 000h                                                  ; compare type of cast of _dynamicLookup return value return value to Whatever to <sentinel>
  jne tempSyd$castOfDynamiclookupReturnValueReturnValueToWHatever$TypeMatch ; skip next block if cast of _dynamicLookup return value return value to Whatever is not sentinel
    ; Error handling block for cast of _dynamicLookup return value return value to Whatever
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 01d8h]                             ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 01d0h]                             ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$castOfDynamiclookupReturnValueReturnValueToWHatever$TypeMatch:  ; after block
  ; Call cast of _dynamicLookup return value return value to Whatever with 0 arguments
  mov rax, qword ptr [r12 + 028h]                                ; read receiver pointer
  mov rbx, qword ptr [r12 + 020h]                                ; read receiver type
  lea r10, qword ptr [rsp + 01c8h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 01c0h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rax                                                    ; internal argument 4: "this" pointer
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r12 + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 01c8h]                                   ; value of argument #2 (cast of _dynamicLookup return value return value to Whatever return value)
  push qword ptr [rsp + 01c0h]                                   ; type of argument #2
  mov r12, offset string$69                                      ; reading string for push
  push r12                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r13, qword ptr [rsp + 01d0h]                               ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 01d0h]                               ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 53: println('FIELD:', subclass as Whatever.field);
  mov r14, qword ptr [rsp + 0230h]                               ; make a copy of subclass's value in case it changes before we use it
  mov r15, qword ptr [rsp + 0228h]                               ; make a copy of subclass's type in case it changes before we use it
  ; increment reference count for copy of subclass if necessary
  mov rax, r15                                                   ; store copy of subclass's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$9                                    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r14]                                          ; increment reference count of copy of subclass
  tempSyd$AfterGCIncref$9:                                       ; after GarbageCollectable incref
  ; sentinel check of copy of subclass type Subclass expecting Whatever
  cmp r15, 000h                                                  ; compare type of copy of subclass to <sentinel>
  jne tempSyd$subclassAsWHatever$TypeMatch$1                     ; skip next block if copy of subclass is not sentinel
    ; Error handling block for subclass as Whatever
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 01b0h], rsi                             ; move copy of subclass's value out of rsi
    mov rsi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rsi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 01b0h], rdi                             ; move copy of subclass's type out of rdi
    lea rdi, qword ptr [rsp + 01b8h]                             ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 01b0h]                             ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 01b0h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 01a0h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
  tempSyd$subclassAsWHatever$TypeMatch$1:                        ; after block
  mov r12, r14                                                   ; copy value of copy of subclass for cast to Whatever
  mov r13, r15                                                   ; copy type of copy of subclass for cast to Whatever
  ; Call _dynamicLookup with 2 arguments
  push 001h                                                      ; value of argument #2 (1 (integer))
  push 038h                                                      ; type of argument #2 (Integer'38)
  push r12                                                       ; value of argument #1 (cast of copy of subclass to Whatever)
  push r13                                                       ; type of argument #1
  mov qword ptr [rsp + 01c8h], r14                               ; move copy of subclass's value out of r14
  lea r14, qword ptr [rsp + 01d0h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 01c8h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$_dynamicLookup                                       ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Call _dynamicLookup return value with 0 arguments
  mov qword ptr [rsp + 0198h], r15                               ; move copy of subclass's type out of r15
  mov r15, qword ptr [rsp + 01b0h]                               ; get _dynamicLookup return value into register to dereference it
  mov rax, qword ptr [r15 + 028h]                                ; read receiver pointer
  mov rbx, qword ptr [r15 + 020h]                                ; read receiver type
  lea r10, qword ptr [rsp + 01b0h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 0198h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rax                                                    ; internal argument 4: "this" pointer
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r15 + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 01b0h]                                   ; value of argument #2 (_dynamicLookup return value return value)
  push qword ptr [rsp + 0198h]                                   ; type of argument #2
  mov r12, offset string$61                                      ; reading string for push
  push r12                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r13, qword ptr [rsp + 01c0h]                               ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 01b0h]                               ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 58: String result = 'FAIL';
  ; sentinel check of string type String expecting String
  mov r11, offset string$70                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$70) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; value initialization of variable declaration for result variable (string)
  mov qword ptr resultType, 039h                                 ; type initialization of variable declaration for result variable (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne tempSyd$AfterStringIncref$6                                ; if not a String, skip incref
    mov rax, qword ptr resultValue                               ; get result variable into register to dereference it
    mov rbx, qword ptr [rax]                                     ; dereference string to get to reference count
    cmp rbx, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$6                                   ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, rax                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp tempSyd$AfterStringIncref$6                              ; skip incref for string constants
    tempSyd$StringIncref$6:                                      ; real String
      inc qword ptr [rax]                                        ; increment reference count of result variable
    mov qword ptr resultValue, rax                               ; restoring slot (result variable) to previous scope state for genuine block exit
  tempSyd$AfterStringIncref$6:                                   ; after String incref
  ; Line 76: BunnyB().grab()();
  ; sentinel check of BunnyB type BunnyBFunction() expecting AnythingFunction
  ; Call BunnyB with 0 arguments
  mov qword ptr [rsp + 0188h], rdi                               ; move copy of subclass's type out of rdi
  lea rdi, qword ptr [rsp + 01a0h]                               ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 0188h]                               ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$BunnyB$BunnyB                                      ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r12, qword ptr [rsp + 01a0h]                               ; get BunnyB return value into register to dereference it
  mov r13, qword ptr [r12 + 028h]                                ; get vmt
  add r13, 0a0h                                                  ; add offset for dereference (result in code address for BunnyB.grab)
  mov r13, qword ptr [r13]                                       ; get call method
  mov r14, 03bh                                                  ; store code of __CodeAddress value in code address for BunnyB.grab's type slot
  ; sentinel check of code address for BunnyB.grab type __CodeAddress expecting __CodeAddress
  cmp r14, 000h                                                  ; compare type of code address for BunnyB.grab to <sentinel>
  jne tempSyd$codeAddressForBUnnybGrab$TypeMatch                 ; skip next block if code address for BunnyB.grab is not sentinel
    ; Error handling block for code address for BunnyB.grab
    ; Call __error with 1 arguments
    mov r15, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 01b0h]                             ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0190h]                             ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$codeAddressForBUnnybGrab$TypeMatch:                    ; after block
  ; Call code address for BunnyB.grab with 0 arguments
  lea rbx, qword ptr [rsp + 01a0h]                               ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0180h]                               ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r12                                                    ; internal argument 4: "this" pointer
  mov r8, qword ptr [rsp + 01b0h]                                ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 01b0h], r8                                ; move BunnyB return value's type out of r8
  mov qword ptr [rsp + 01a0h], r9                                ; move BunnyB return value's value out of r9
  call r13                                                       ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of code address for BunnyB.grab return value type NullFunction expecting AnythingFunction
  cmp qword ptr [rsp + 0178h], 000h                              ; compare type of code address for BunnyB.grab return value to <sentinel>
  jne tempSyd$codeAddressForBUnnybGrabReturnValue$TypeMatch      ; skip next block if code address for BunnyB.grab return value is not sentinel
    ; Error handling block for code address for BunnyB.grab return value
    ; Call __error with 1 arguments
    mov r10, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 0170h], rsi                             ; move copy of subclass's value out of rsi
    lea rsi, qword ptr [rsp + 0178h]                             ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0170h]                             ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 0160h]                             ; restoring slot (copy of subclass) to previous scope state for genuine block exit
  tempSyd$codeAddressForBUnnybGrabReturnValue$TypeMatch:         ; after block
  ; Call code address for BunnyB.grab return value with 0 arguments
  mov rdi, qword ptr [rsp + 01a0h]                               ; get code address for BunnyB.grab return value into register to dereference it
  mov r12, qword ptr [rdi + 028h]                                ; read receiver pointer
  mov r13, qword ptr [rdi + 020h]                                ; read receiver type
  lea r14, qword ptr [rsp + 01a0h]                               ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0170h]                               ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r12                                                    ; internal argument 4: "this" pointer
  mov r8, r13                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 77: assert(result == 'BunnyB::test', 'failure (Bunnies)');
  mov r15, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov rax, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp rax, 039h                                                  ; compare type of copy of result to String
  jne tempSyd$AfterStringIncref$7                                ; if not a String, skip incref
    mov rbx, qword ptr [r15]                                     ; dereference string to get to reference count
    cmp rbx, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$7                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$7                              ; skip incref for string constants
    tempSyd$StringIncref$7:                                      ; real String
      inc qword ptr [r15]                                        ; increment reference count of copy of result
  tempSyd$AfterStringIncref$7:                                   ; after String incref
  xor r10, r10                                                   ; zero value result of == (testing copy of result and string) to put the boolean in
  mov qword ptr [rsp + 01a0h], rsi                               ; move copy of subclass's value out of rsi
  mov rsi, offset string$72                                      ; reading second operand of cmp (string) for a SetSlotIfEqualInstruction
  cmp r15, rsi                                                   ; values equal?
  sete r10b                                                      ; put result in value result of == (testing copy of result and string)
  mov rdi, 037h                                                  ; value result of == (testing copy of result and string) is a Boolean'37
  xor r12, r12                                                   ; zero type result of == (testing copy of result and string) to put the boolean in
  cmp rax, 039h                                                  ; types equal?
  sete r12b                                                      ; put result in type result of == (testing copy of result and string)
  mov r13, 037h                                                  ; type result of == (testing copy of result and string) is a Boolean'37
  mov r14, r10                                                   ; assign value of value result of == (testing copy of result and string) to value of == operator result
  and r14, r12                                                   ; && type temp and value temp
  cmp r14, 000h                                                  ; compare == operator result to false
  jne tempSyd$stringCompareEnd                                   ; skip string compare if values definitely equal by pointer comparison
    mov qword ptr [rsp + 0178h], 000h                            ; move == operator result's type into a mutable location
    cmp rax, 039h                                                ; compare type of copy of result to String
    je tempSyd$aIsString                                         ; verify that copy of result is a string before string compare
    jmp tempSyd$stringCompareEnd                                 ; skip string compare; not a string
    tempSyd$aIsString:                                           ; continue string comparison
    mov r9, qword ptr [r15 + 008h]                               ; read length of copy of result
    mov r8, offset string$72                                     ; get string into register to dereference it
    mov rdx, qword ptr [r8 + 008h]                               ; read length of string
    cmp r9, rdx                                                  ; compare length of copy of result to length of string
    je tempSyd$abEqualLength                                     ; verify that copy of result and string have the same length
    jmp tempSyd$stringCompareEnd                                 ; skip string compare; strings do not have the same length
    tempSyd$abEqualLength:                                       ; continue string comparison
    ; verify that copy of result and string are string-equal
    xor r14, r14                                                 ; clear == operator result
    mov rcx, r9                                                  ; prepare length for rep instruction below
    mov rdi, r15                                                 ; first string to compare
    lea rdi, qword ptr [rdi + 010h]                              ; offset to start of string comparison for first string
    mov rsi, offset string$72                                    ; seconds string to compare
    lea rsi, qword ptr [rsi + 010h]                              ; offset to start of string comparison for second string
    cld                                                          ; configure repe cmpsb to increment
    repe cmpsb                                                   ; compare strings for rcx bytes, result in ZF (ZF=1 is a match)
    setz r14b                                                    ; store result from ZF
    mov r15, rdi                                                 ; restoring slot (copy of result) to previous scope state for genuine block exit
  tempSyd$stringCompareEnd:                                      ; after string comparison block
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$73                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r14                                                       ; value of argument #1 (== operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r10, qword ptr [rsp + 0198h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 0190h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 01b0h], rax                               ; move copy of result's type out of rax
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 82: result = '';
  ; sentinel check of string type String expecting String
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, offset string$19                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$19) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov qword ptr resultType, 039h                                 ; store type (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne tempSyd$AfterStringIncref$8                                ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov rdi, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp rdi, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$8                                   ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp tempSyd$AfterStringIncref$8                              ; skip incref for string constants
    tempSyd$StringIncref$8:                                      ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
    mov qword ptr resultValue, r14                               ; restoring slot (result variable) to previous scope state for genuine block exit
  tempSyd$AfterStringIncref$8:                                   ; after String incref
  ; Line 124: assert(result == '', 'failure (??? strings in general?)');
  mov rsi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov qword ptr [rsp + 0178h], r15                               ; move copy of result's value out of r15
  mov r15, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r15, 039h                                                  ; compare type of copy of result to String
  jne tempSyd$AfterStringIncref$9                                ; if not a String, skip incref
    mov rax, qword ptr [rsi]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$9                                   ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$9                              ; skip incref for string constants
    tempSyd$StringIncref$9:                                      ; real String
      inc qword ptr [rsi]                                        ; increment reference count of copy of result
  tempSyd$AfterStringIncref$9:                                   ; after String incref
  xor rbx, rbx                                                   ; zero value result of == (testing copy of result and string) to put the boolean in
  mov r10, offset string$19                                      ; reading second operand of cmp (string) for a SetSlotIfEqualInstruction
  cmp rsi, r10                                                   ; values equal?
  sete bl                                                        ; put result in value result of == (testing copy of result and string)
  mov r12, 037h                                                  ; value result of == (testing copy of result and string) is a Boolean'37
  xor r13, r13                                                   ; zero type result of == (testing copy of result and string) to put the boolean in
  cmp r15, 039h                                                  ; types equal?
  sete r13b                                                      ; put result in type result of == (testing copy of result and string)
  mov r9, 037h                                                   ; type result of == (testing copy of result and string) is a Boolean'37
  mov r8, rbx                                                    ; assign value of value result of == (testing copy of result and string) to value of == operator result
  and r8, r13                                                    ; && type temp and value temp
  cmp r8, 000h                                                   ; compare == operator result to false
  jne tempSyd$stringCompareEnd$1                                 ; skip string compare if values definitely equal by pointer comparison
    mov qword ptr [rsp + 0168h], 000h                            ; move == operator result's type into a mutable location
    cmp r15, 039h                                                ; compare type of copy of result to String
    je tempSyd$aIsString$1                                       ; verify that copy of result is a string before string compare
    jmp tempSyd$stringCompareEnd$1                               ; skip string compare; not a string
    tempSyd$aIsString$1:                                         ; continue string comparison
    mov rdx, qword ptr [rsi + 008h]                              ; read length of copy of result
    mov rcx, offset string$19                                    ; get string into register to dereference it
    mov r14, qword ptr [rcx + 008h]                              ; read length of string
    cmp rdx, r14                                                 ; compare length of copy of result to length of string
    je tempSyd$abEqualLength$1                                   ; verify that copy of result and string have the same length
    jmp tempSyd$stringCompareEnd$1                               ; skip string compare; strings do not have the same length
    tempSyd$abEqualLength$1:                                     ; continue string comparison
    ; verify that copy of result and string are string-equal
    xor r8, r8                                                   ; clear == operator result
    mov rcx, rdx                                                 ; prepare length for rep instruction below
    mov rdi, rsi                                                 ; first string to compare
    lea rdi, qword ptr [rdi + 010h]                              ; offset to start of string comparison for first string
    mov rsi, offset string$19                                    ; seconds string to compare
    lea rsi, qword ptr [rsi + 010h]                              ; offset to start of string comparison for second string
    cld                                                          ; configure repe cmpsb to increment
    repe cmpsb                                                   ; compare strings for rcx bytes, result in ZF (ZF=1 is a match)
    setz r8b                                                     ; store result from ZF
    mov rsi, rdi                                                 ; restoring slot (copy of result) to previous scope state for genuine block exit
  tempSyd$stringCompareEnd$1:                                    ; after string comparison block
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$79                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r8                                                        ; value of argument #1 (== operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r10, qword ptr [rsp + 0188h]                               ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 0180h]                               ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 126: result = '';
  ; sentinel check of string type String expecting String
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, offset string$19                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$19) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov qword ptr resultType, 039h                                 ; store type (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne tempSyd$AfterStringIncref$10                               ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov rdi, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp rdi, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$10                                  ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp tempSyd$AfterStringIncref$10                             ; skip incref for string constants
    tempSyd$StringIncref$10:                                     ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
    mov qword ptr resultValue, r14                               ; restoring slot (result variable) to previous scope state for genuine block exit
  tempSyd$AfterStringIncref$10:                                  ; after String incref
  ; Line 127: CarrotBranchB x = CarrotBranchB();
  ; sentinel check of CarrotBranchB type CarrotBranchBFunction() expecting AnythingFunction
  ; Call CarrotBranchB with 0 arguments
  lea rax, qword ptr [rsp + 0148h]                               ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 0148h]                               ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$CarrotBranchB$CarrotBranchB                        ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of CarrotBranchB return value type CarrotBranchB expecting CarrotBranchB
  cmp qword ptr [rsp + 0140h], 000h                              ; compare type of CarrotBranchB return value to <sentinel>
  jne tempSyd$carrotbranchbReturnValue$TypeMatch                 ; skip next block if CarrotBranchB return value is not sentinel
    ; Error handling block for CarrotBranchB return value
    ; Call __error with 1 arguments
    mov rbx, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 0140h]                             ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 0140h]                             ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$carrotbranchbReturnValue$TypeMatch:                    ; after block
  mov r11, qword ptr [rsp + 0148h]                               ; indirect through r11 because operand pair (stack operand #56, stack operand #60) is not allowed with mov
  mov qword ptr [rsp + 0168h], r11                               ; value initialization of variable declaration for x variable (CarrotBranchB return value)
  mov r11, qword ptr [rsp + 0140h]                               ; indirect through r11 because operand pair (stack operand #58, stack operand #61) is not allowed with mov
  mov qword ptr [rsp + 0158h], r11                               ; type initialization of variable declaration for x variable
  ; increment reference count for x variable if necessary
  mov r12, qword ptr [rsp + 0158h]                               ; store x variable's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$10                                   ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 0168h]                             ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of x variable
    mov qword ptr [rsp + 0168h], rdi                             ; restoring slot (x variable) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref$10:                                      ; after GarbageCollectable incref
  ; Line 128: x.foo();
  mov qword ptr [rsp + 0130h], rsi                               ; move copy of result's value out of rsi
  mov rsi, qword ptr [rsp + 0168h]                               ; make a copy of x's value in case it changes before we use it
  mov qword ptr [rsp + 0128h], r15                               ; move copy of result's type out of r15
  mov r15, qword ptr [rsp + 0158h]                               ; make a copy of x's type in case it changes before we use it
  ; increment reference count for copy of x if necessary
  mov rbx, r15                                                   ; store copy of x's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$11                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [rsi]                                          ; increment reference count of copy of x
  tempSyd$AfterGCIncref$11:                                      ; after GarbageCollectable incref
  mov r8, qword ptr [rsi + 048h]                                 ; make a copy of CarrotBranchB.foo's value in case it changes before we use it
  mov rdx, qword ptr [rsi + 040h]                                ; make a copy of CarrotBranchB.foo's type in case it changes before we use it
  ; sentinel check of copy of CarrotBranchB.foo type NullFunction expecting AnythingFunction
  cmp rdx, 000h                                                  ; compare type of copy of CarrotBranchB.foo to <sentinel>
  jne tempSyd$copyOfCArrotbranchbFoo$TypeMatch                   ; skip next block if copy of CarrotBranchB.foo is not sentinel
    ; Error handling block for copy of CarrotBranchB.foo
    ; Call __error with 1 arguments
    mov rcx, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rcx                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 0130h]                             ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0130h]                             ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 0150h], r8                              ; move copy of CarrotBranchB.foo's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov qword ptr [rsp + 0148h], rdx                             ; move copy of CarrotBranchB.foo's type out of rdx
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rdx, qword ptr [rsp + 0108h]                             ; restoring slot (copy of CarrotBranchB.foo) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 0110h]                              ; restoring slot (copy of CarrotBranchB.foo) to previous scope state for genuine block exit
  tempSyd$copyOfCArrotbranchbFoo$TypeMatch:                      ; after block
  ; Call copy of CarrotBranchB.foo with 0 arguments
  mov r13, qword ptr [r8 + 028h]                                 ; read receiver pointer
  mov r14, qword ptr [r8 + 020h]                                 ; read receiver type
  lea rdi, qword ptr [rsp + 0120h]                               ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 0120h]                               ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r13                                                    ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 0140h], r8                                ; move copy of CarrotBranchB.foo's value out of r8
  mov r8, r14                                                    ; internal argument 3: "this" pointer type
  mov qword ptr [rsp + 0138h], rdx                               ; move copy of CarrotBranchB.foo's type out of rdx
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0130h], rsi                               ; move copy of x's value out of rsi
  mov rsi, qword ptr [rsp + 0140h]                               ; reading copy of CarrotBranchB.foo to dereference it
  call qword ptr [rsi + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 129: x.bar();
  mov qword ptr [rsp + 0120h], r15                               ; move copy of x's type out of r15
  mov r15, qword ptr [rsp + 0168h]                               ; make a copy of x's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 0158h]                               ; make a copy of x's type in case it changes before we use it
  ; increment reference count for copy of x if necessary
  mov rax, rbx                                                   ; store copy of x's type in testByte value slot
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$12                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of x
  tempSyd$AfterGCIncref$12:                                      ; after GarbageCollectable incref
  mov r13, qword ptr [r15 + 028h]                                ; get vmt
  add r13, 0c0h                                                  ; add offset for dereference (result in code address for CarrotBranchB.bar)
  mov r13, qword ptr [r13]                                       ; get call method
  mov r14, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotBranchB.bar's type slot
  ; sentinel check of code address for CarrotBranchB.bar type __CodeAddress expecting __CodeAddress
  cmp r14, 000h                                                  ; compare type of code address for CarrotBranchB.bar to <sentinel>
  jne tempSyd$codeAddressForCArrotbranchbBar$TypeMatch           ; skip next block if code address for CarrotBranchB.bar is not sentinel
    ; Error handling block for code address for CarrotBranchB.bar
    ; Call __error with 1 arguments
    mov rdi, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r9, qword ptr [rsp + 0128h]                              ; load address of return value's value
    push r9                                                      ; internal argument 6: pointer to return value slot's value
    lea r9, qword ptr [rsp + 0128h]                              ; load address of return value's type
    push r9                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$codeAddressForCArrotbranchbBar$TypeMatch:              ; after block
  ; Call code address for CarrotBranchB.bar with 0 arguments
  lea rsi, qword ptr [rsp + 0118h]                               ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 0118h]                               ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r15                                                    ; internal argument 4: "this" pointer
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0138h], r8                                ; move copy of x's type out of r8
  mov qword ptr [rsp + 0128h], r9                                ; move copy of x's value out of r9
  call r13                                                       ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 130: assert(result == 'de', 'failure (CarrotBranchB)');
  mov r15, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov rbx, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp rbx, 039h                                                  ; compare type of copy of result to String
  jne tempSyd$AfterStringIncref$11                               ; if not a String, skip incref
    mov rax, qword ptr [r15]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$11                                  ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$11                             ; skip incref for string constants
    tempSyd$StringIncref$11:                                     ; real String
      inc qword ptr [r15]                                        ; increment reference count of copy of result
  tempSyd$AfterStringIncref$11:                                  ; after String incref
  xor r10, r10                                                   ; zero value result of == (testing copy of result and string) to put the boolean in
  mov r12, offset string$80                                      ; reading second operand of cmp (string) for a SetSlotIfEqualInstruction
  cmp r15, r12                                                   ; values equal?
  sete r10b                                                      ; put result in value result of == (testing copy of result and string)
  mov r13, 037h                                                  ; value result of == (testing copy of result and string) is a Boolean'37
  xor r14, r14                                                   ; zero type result of == (testing copy of result and string) to put the boolean in
  cmp rbx, 039h                                                  ; types equal?
  sete r14b                                                      ; put result in type result of == (testing copy of result and string)
  mov rdi, 037h                                                  ; type result of == (testing copy of result and string) is a Boolean'37
  mov rsi, r10                                                   ; assign value of value result of == (testing copy of result and string) to value of == operator result
  and rsi, r14                                                   ; && type temp and value temp
  cmp rsi, 000h                                                  ; compare == operator result to false
  jne tempSyd$stringCompareEnd$2                                 ; skip string compare if values definitely equal by pointer comparison
    mov qword ptr [rsp + 0118h], 000h                            ; move == operator result's type into a mutable location
    cmp rbx, 039h                                                ; compare type of copy of result to String
    je tempSyd$aIsString$2                                       ; verify that copy of result is a string before string compare
    jmp tempSyd$stringCompareEnd$2                               ; skip string compare; not a string
    tempSyd$aIsString$2:                                         ; continue string comparison
    mov r9, qword ptr [r15 + 008h]                               ; read length of copy of result
    mov r8, offset string$80                                     ; get string into register to dereference it
    mov rdx, qword ptr [r8 + 008h]                               ; read length of string
    cmp r9, rdx                                                  ; compare length of copy of result to length of string
    je tempSyd$abEqualLength$2                                   ; verify that copy of result and string have the same length
    jmp tempSyd$stringCompareEnd$2                               ; skip string compare; strings do not have the same length
    tempSyd$abEqualLength$2:                                     ; continue string comparison
    ; verify that copy of result and string are string-equal
    mov qword ptr [rsp + 0110h], r15                             ; move copy of result's value out of r15
    xor r15, r15                                                 ; clear == operator result
    mov rcx, r9                                                  ; prepare length for rep instruction below
    mov rdi, qword ptr [rsp + 0110h]                             ; first string to compare
    lea rdi, qword ptr [rdi + 010h]                              ; offset to start of string comparison for first string
    mov rsi, offset string$80                                    ; seconds string to compare
    lea rsi, qword ptr [rsi + 010h]                              ; offset to start of string comparison for second string
    cld                                                          ; configure repe cmpsb to increment
    repe cmpsb                                                   ; compare strings for rcx bytes, result in ZF (ZF=1 is a match)
    setz r15b                                                    ; store result from ZF
    mov rsi, r15                                                 ; restoring slot (== operator result) to previous scope state for genuine block exit
    mov r15, rdi                                                 ; restoring slot (copy of result) to previous scope state for genuine block exit
  tempSyd$stringCompareEnd$2:                                    ; after string comparison block
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r10, offset string$81                                      ; reading string for push
  push r10                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rsi                                                       ; value of argument #1 (== operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r12, qword ptr [rsp + 0138h]                               ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 0138h]                               ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 132: result = '';
  ; sentinel check of string type String expecting String
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, offset string$19                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$19) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov qword ptr resultType, 039h                                 ; store type (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne tempSyd$AfterStringIncref$12                               ; if not a String, skip incref
    mov qword ptr [rsp + 0118h], r15                             ; move copy of result's value out of r15
    mov r15, qword ptr resultValue                               ; get result variable into register to dereference it
    mov rdi, qword ptr [r15]                                     ; dereference string to get to reference count
    cmp rdi, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$12                                  ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r15                               ; restoring slot (???) to previous scope state for synthetic block exit
    mov r15, qword ptr [rsp + 0118h]                             ; restoring slot (???) to previous scope state for synthetic block exit
    jmp tempSyd$AfterStringIncref$12                             ; skip incref for string constants
    tempSyd$StringIncref$12:                                     ; real String
      inc qword ptr [r15]                                        ; increment reference count of result variable
    mov qword ptr resultValue, r15                               ; restoring slot (result variable) to previous scope state for genuine block exit
    mov r15, qword ptr [rsp + 0118h]                             ; restoring slot (copy of result) to previous scope state for genuine block exit
  tempSyd$AfterStringIncref$12:                                  ; after String incref
  ; Line 133: CarrotBranchA y = CarrotLeafA();
  ; sentinel check of CarrotLeafA type CarrotLeafAFunction() expecting AnythingFunction
  ; Call CarrotLeafA with 0 arguments
  lea rax, qword ptr [rsp + 0f0h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 0e8h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$CarrotLeafA$CarrotLeafA                            ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of CarrotLeafA return value type CarrotLeafA expecting CarrotBranchA
  cmp qword ptr [rsp + 0e0h], 000h                               ; compare type of CarrotLeafA return value to <sentinel>
  jne tempSyd$carrotleafaReturnValue$TypeMatch                   ; skip next block if CarrotLeafA return value is not sentinel
    ; Error handling block for CarrotLeafA return value
    ; Call __error with 1 arguments
    mov r10, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 0e8h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0e8h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$carrotleafaReturnValue$TypeMatch:                      ; after block
  mov r11, qword ptr [rsp + 0f0h]                                ; indirect through r11 because operand pair (stack operand #66, stack operand #71) is not allowed with mov
  mov qword ptr [rsp + 0118h], r11                               ; value initialization of variable declaration for y variable (CarrotLeafA return value)
  mov r11, qword ptr [rsp + 0e0h]                                ; indirect through r11 because operand pair (stack operand #67, stack operand #73) is not allowed with mov
  mov qword ptr [rsp + 0110h], r11                               ; type initialization of variable declaration for y variable
  ; increment reference count for y variable if necessary
  mov r13, qword ptr [rsp + 0110h]                               ; store y variable's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 0d8h], r15                                ; move copy of result's value out of r15
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$13                                   ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 0118h]                             ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of y variable
    mov qword ptr [rsp + 0118h], rdi                             ; restoring slot (y variable) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref$13:                                      ; after GarbageCollectable incref
  ; Line 134: y.foo();
  mov rsi, qword ptr [rsp + 0118h]                               ; make a copy of y's value in case it changes before we use it
  mov qword ptr [rsp + 0d0h], rbx                                ; move copy of result's type out of rbx
  mov rbx, qword ptr [rsp + 0110h]                               ; make a copy of y's type in case it changes before we use it
  ; increment reference count for copy of y if necessary
  mov r10, rbx                                                   ; store copy of y's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$14                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [rsi]                                          ; increment reference count of copy of y
  tempSyd$AfterGCIncref$14:                                      ; after GarbageCollectable incref
  mov r8, qword ptr [rsi + 028h]                                 ; get vmt
  add r8, 080h                                                   ; add offset for dereference (result in code address for CarrotBranchA.foo)
  mov r8, qword ptr [r8]                                         ; get call method
  mov rdx, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotBranchA.foo's type slot
  ; sentinel check of code address for CarrotBranchA.foo type __CodeAddress expecting __CodeAddress
  cmp rdx, 000h                                                  ; compare type of code address for CarrotBranchA.foo to <sentinel>
  jne tempSyd$codeAddressForCArrotbranchaFoo$TypeMatch           ; skip next block if code address for CarrotBranchA.foo is not sentinel
    ; Error handling block for code address for CarrotBranchA.foo
    ; Call __error with 1 arguments
    mov rcx, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rcx                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0d8h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0d8h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 0f8h], r8                               ; move code address for CarrotBranchA.foo's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov qword ptr [rsp + 0f0h], rdx                              ; move code address for CarrotBranchA.foo's type out of rdx
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rdx, qword ptr [rsp + 0b0h]                              ; restoring slot (code address for CarrotBranchA.foo) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 0b8h]                               ; restoring slot (code address for CarrotBranchA.foo) to previous scope state for genuine block exit
  tempSyd$codeAddressForCArrotbranchaFoo$TypeMatch:              ; after block
  ; Call code address for CarrotBranchA.foo with 0 arguments
  lea r14, qword ptr [rsp + 0c8h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0c8h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rsi                                                    ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 0e8h], r8                                 ; move code address for CarrotBranchA.foo's value out of r8
  mov r8, rbx                                                    ; internal argument 3: "this" pointer type
  mov qword ptr [rsp + 0e0h], rdx                                ; move code address for CarrotBranchA.foo's type out of rdx
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0d8h], r8                                 ; move copy of y's type out of r8
  mov qword ptr [rsp + 0d0h], r9                                 ; move copy of y's value out of r9
  call qword ptr [rsp + 0e8h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 135: y.bar();
  mov r15, qword ptr [rsp + 0118h]                               ; make a copy of y's value in case it changes before we use it
  mov rdi, qword ptr [rsp + 0110h]                               ; make a copy of y's type in case it changes before we use it
  ; increment reference count for copy of y if necessary
  mov rsi, rdi                                                   ; store copy of y's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$15                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of y
  tempSyd$AfterGCIncref$15:                                      ; after GarbageCollectable incref
  mov r12, qword ptr [r15 + 028h]                                ; get vmt
  add r12, 098h                                                  ; add offset for dereference (result in temporary for AmbiguousMemberIdentifierEntity.forRead)
  mov r12, qword ptr [r12]                                       ; get getter method for bar
  ; Call temporary for AmbiguousMemberIdentifierEntity.forRead with 0 arguments
  lea r13, qword ptr [rsp + 0c8h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 0c8h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r15                                                    ; internal argument 4: "this" pointer
  mov r8, rdi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0e8h], r8                                 ; move copy of y's type out of r8
  mov qword ptr [rsp + 0e0h], r9                                 ; move copy of y's value out of r9
  call r12                                                       ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of temporary for AmbiguousMemberIdentifierEntity.forRead return value type NullFunction() expecting AnythingFunction
  cmp qword ptr [rsp + 0c0h], 000h                               ; compare type of temporary for AmbiguousMemberIdentifierEntity.forRead return value to <sentinel>
  jne tempSyd$temporaryForAMbiguousmemberidentifierentityForreadReturnValue$TypeMatch ; skip next block if temporary for AmbiguousMemberIdentifierEntity.forRead return value is not sentinel
    ; Error handling block for temporary for AmbiguousMemberIdentifierEntity.forRead return value
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$temporaryForAMbiguousmemberidentifierentityForreadReturnValue$TypeMatch:  ; after block
  ; Call temporary for AmbiguousMemberIdentifierEntity.forRead return value with 0 arguments
  mov rdi, qword ptr [rsp + 0c8h]                                ; get temporary for AmbiguousMemberIdentifierEntity.forRead return value into register to dereference it
  mov rsi, qword ptr [rdi + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rdi + 020h]                                ; read receiver type
  lea rbx, qword ptr [rsp + 0c8h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0a0h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rsi                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 136: assert(result == 'ac', 'failure (CarrotLeafA)');
  mov r10, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne tempSyd$AfterStringIncref$13                               ; if not a String, skip incref
    mov r13, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$13                                  ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$13                             ; skip incref for string constants
    tempSyd$StringIncref$13:                                     ; real String
      inc qword ptr [r10]                                        ; increment reference count of copy of result
  tempSyd$AfterStringIncref$13:                                  ; after String incref
  xor r14, r14                                                   ; zero value result of == (testing copy of result and string) to put the boolean in
  mov r15, offset string$82                                      ; reading second operand of cmp (string) for a SetSlotIfEqualInstruction
  cmp r10, r15                                                   ; values equal?
  sete r14b                                                      ; put result in value result of == (testing copy of result and string)
  mov rdi, 037h                                                  ; value result of == (testing copy of result and string) is a Boolean'37
  xor rsi, rsi                                                   ; zero type result of == (testing copy of result and string) to put the boolean in
  cmp r12, 039h                                                  ; types equal?
  sete sil                                                       ; put result in type result of == (testing copy of result and string)
  mov rax, 037h                                                  ; type result of == (testing copy of result and string) is a Boolean'37
  mov rbx, r14                                                   ; assign value of value result of == (testing copy of result and string) to value of == operator result
  and rbx, rsi                                                   ; && type temp and value temp
  cmp rbx, 000h                                                  ; compare == operator result to false
  jne tempSyd$stringCompareEnd$3                                 ; skip string compare if values definitely equal by pointer comparison
    mov qword ptr [rsp + 0c8h], 000h                             ; move == operator result's type into a mutable location
    cmp r12, 039h                                                ; compare type of copy of result to String
    je tempSyd$aIsString$3                                       ; verify that copy of result is a string before string compare
    jmp tempSyd$stringCompareEnd$3                               ; skip string compare; not a string
    tempSyd$aIsString$3:                                         ; continue string comparison
    mov r9, qword ptr [r10 + 008h]                               ; read length of copy of result
    mov r8, offset string$82                                     ; get string into register to dereference it
    mov rdx, qword ptr [r8 + 008h]                               ; read length of string
    cmp r9, rdx                                                  ; compare length of copy of result to length of string
    je tempSyd$abEqualLength$3                                   ; verify that copy of result and string have the same length
    jmp tempSyd$stringCompareEnd$3                               ; skip string compare; strings do not have the same length
    tempSyd$abEqualLength$3:                                     ; continue string comparison
    ; verify that copy of result and string are string-equal
    xor rbx, rbx                                                 ; clear == operator result
    mov rcx, r9                                                  ; prepare length for rep instruction below
    mov rdi, r10                                                 ; first string to compare
    lea rdi, qword ptr [rdi + 010h]                              ; offset to start of string comparison for first string
    mov rsi, offset string$82                                    ; seconds string to compare
    lea rsi, qword ptr [rsi + 010h]                              ; offset to start of string comparison for second string
    cld                                                          ; configure repe cmpsb to increment
    repe cmpsb                                                   ; compare strings for rcx bytes, result in ZF (ZF=1 is a match)
    setz bl                                                      ; store result from ZF
    mov r10, rdi                                                 ; restoring slot (copy of result) to previous scope state for genuine block exit
  tempSyd$stringCompareEnd$3:                                    ; after string comparison block
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r13, offset string$83                                      ; reading string for push
  push r13                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rbx                                                       ; value of argument #1 (== operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r14, qword ptr [rsp + 0e8h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0e8h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0e8h], r10                                ; move copy of result's value out of r10
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 152: B b = B();
  ; sentinel check of B type BFunction() expecting AnythingFunction
  ; Call B with 0 arguments
  lea rbx, qword ptr [rsp + 090h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 088h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call method$B$B                                                ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of B return value type B expecting B
  cmp qword ptr [rsp + 080h], 000h                               ; compare type of B return value to <sentinel>
  jne tempSyd$bReturnValue$TypeMatch                             ; skip next block if B return value is not sentinel
    ; Error handling block for B return value
    ; Call __error with 1 arguments
    mov rdi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 088h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 088h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$bReturnValue$TypeMatch:                                ; after block
  mov r11, qword ptr [rsp + 090h]                                ; indirect through r11 because operand pair (stack operand #76, stack operand #83) is not allowed with mov
  mov qword ptr [rsp + 0c8h], r11                                ; value initialization of variable declaration for b variable (B return value)
  mov r11, qword ptr [rsp + 080h]                                ; indirect through r11 because operand pair (stack operand #77, stack operand #85) is not allowed with mov
  mov qword ptr [rsp + 0c0h], r11                                ; type initialization of variable declaration for b variable
  ; increment reference count for b variable if necessary
  mov r10, qword ptr [rsp + 0c0h]                                ; store b variable's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov qword ptr [rsp + 078h], r12                                ; move copy of result's type out of r12
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$16                                   ; if not a GarbageCollectable, skip incref
    mov r14, qword ptr [rsp + 0c8h]                              ; read slot into register for dereferencing
    inc qword ptr [r14]                                          ; increment reference count of b variable
    mov qword ptr [rsp + 0c8h], r14                              ; restoring slot (b variable) to previous scope state for genuine block exit
  tempSyd$AfterGCIncref$16:                                      ; after GarbageCollectable incref
  ; Line 153: println('ONE:', b.foo());
  mov r15, qword ptr [rsp + 0c8h]                                ; make a copy of b's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 0c0h]                                ; make a copy of b's type in case it changes before we use it
  ; increment reference count for copy of b if necessary
  mov rdi, rbx                                                   ; store copy of b's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$17                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of b
  tempSyd$AfterGCIncref$17:                                      ; after GarbageCollectable incref
  mov r8, qword ptr [r15 + 048h]                                 ; make a copy of B.foo's value in case it changes before we use it
  mov rdx, qword ptr [r15 + 040h]                                ; make a copy of B.foo's type in case it changes before we use it
  ; increment reference count for copy of B.foo if necessary
  mov rcx, rdx                                                   ; store copy of B.foo's type in testByte value slot
  mov qword ptr [rsp + 070h], rdx                                ; move copy of B.foo's type out of rdx
  mov rax, rcx                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$18                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r8]                                           ; increment reference count of copy of B.foo
  tempSyd$AfterGCIncref$18:                                      ; after GarbageCollectable incref
  cmp qword ptr [rsp + 070h], 039h                               ; compare type of copy of B.foo to String
  jne tempSyd$AfterStringIncref$14                               ; if not a String, skip incref
    mov r13, qword ptr [r8]                                      ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns tempSyd$StringIncref$14                                  ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$14                             ; skip incref for string constants
    tempSyd$StringIncref$14:                                     ; real String
      inc qword ptr [r8]                                         ; increment reference count of copy of B.foo
  tempSyd$AfterStringIncref$14:                                  ; after String incref
  ; sentinel check of copy of B.foo type Whatever expecting AnythingFunction
  cmp qword ptr [rsp + 070h], 000h                               ; compare type of copy of B.foo to <sentinel>
  jne tempSyd$copyOfBFoo$TypeMatch                               ; skip next block if copy of B.foo is not sentinel
    ; Error handling block for copy of B.foo
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 070h], r15                              ; move copy of b's value out of r15
    lea r15, qword ptr [rsp + 078h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 090h], r8                               ; move copy of B.foo's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r15, qword ptr [rsp + 060h]                              ; restoring slot (copy of b) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 050h]                               ; restoring slot (copy of B.foo) to previous scope state for genuine block exit
  tempSyd$copyOfBFoo$TypeMatch:                                  ; after block
  ; Call copy of B.foo with 0 arguments
  mov qword ptr [rsp + 068h], rbx                                ; move copy of b's type out of rbx
  mov rbx, qword ptr [r8 + 028h]                                 ; read receiver pointer
  mov rdi, qword ptr [r8 + 020h]                                 ; read receiver type
  lea rsi, qword ptr [rsp + 060h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 060h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rbx                                                    ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 080h], r8                                 ; move copy of B.foo's value out of r8
  mov r8, rdi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  mov r12, qword ptr [rsp + 080h]                                ; reading copy of B.foo to dereference it
  call qword ptr [r12 + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 060h]                                    ; value of argument #2 (copy of B.foo return value)
  push qword ptr [rsp + 060h]                                    ; type of argument #2
  mov r13, offset string$84                                      ; reading string for push
  push r13                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r14, qword ptr [rsp + 070h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 070h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 154: b.setFoo(six);
  mov qword ptr [rsp + 050h], r15                                ; move copy of b's value out of r15
  mov r15, qword ptr [rsp + 0c8h]                                ; make a copy of b's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 0c0h]                                ; make a copy of b's type in case it changes before we use it
  ; increment reference count for copy of b if necessary
  mov rdi, rbx                                                   ; store copy of b's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 048h], r12                                ; move copy of B.foo's value out of r12
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$19                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r15]                                          ; increment reference count of copy of b
  tempSyd$AfterGCIncref$19:                                      ; after GarbageCollectable incref
  mov r10, qword ptr [r15 + 028h]                                ; get vmt
  add r10, 0a0h                                                  ; add offset for dereference (result in code address for B.setFoo)
  mov r10, qword ptr [r10]                                       ; get call method
  mov r13, 03bh                                                  ; store code of __CodeAddress value in code address for B.setFoo's type slot
  ; sentinel check of code address for B.setFoo type __CodeAddress expecting __CodeAddress
  cmp r13, 000h                                                  ; compare type of code address for B.setFoo to <sentinel>
  jne tempSyd$codeAddressForBSetfoo$TypeMatch                    ; skip next block if code address for B.setFoo is not sentinel
    ; Error handling block for code address for B.setFoo
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r9, qword ptr [rsp + 050h]                               ; load address of return value's value
    push r9                                                      ; internal argument 6: pointer to return value slot's value
    lea r9, qword ptr [rsp + 050h]                               ; load address of return value's type
    push r9                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 070h], r10                              ; move code address for B.setFoo's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 030h]                              ; restoring slot (code address for B.setFoo) to previous scope state for genuine block exit
  tempSyd$codeAddressForBSetfoo$TypeMatch:                       ; after block
  ; Call code address for B.setFoo with 1 arguments
  mov qword ptr [rsp + 040h], r15                                ; move copy of b's value out of r15
  mov r15, offset func$six$functionPointer                       ; reading six for push
  push r15                                                       ; value of argument #1 (six)
  push 008h                                                      ; type of argument #1 (IntegerFunction()'8)
  mov qword ptr [rsp + 040h], rbx                                ; move copy of b's type out of rbx
  lea rbx, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 040h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, qword ptr [rsp + 080h]                                 ; internal argument 4: "this" pointer
  mov r8, qword ptr [rsp + 070h]                                 ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 080h], r10                                ; move code address for B.setFoo's value out of r10
  mov qword ptr [rsp + 070h], r8                                 ; move copy of b's type out of r8
  mov qword ptr [rsp + 060h], r9                                 ; move copy of b's value out of r9
  call qword ptr [rsp + 080h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 155: println('SIX:', b.foo());
  mov rdi, qword ptr [rsp + 0c8h]                                ; make a copy of b's value in case it changes before we use it
  mov rax, qword ptr [rsp + 0c0h]                                ; make a copy of b's type in case it changes before we use it
  ; increment reference count for copy of b if necessary
  mov rsi, rax                                                   ; store copy of b's type in testByte value slot
  mov qword ptr [rsp + 040h], rax                                ; move copy of b's type out of rax
  mov rax, rsi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$20                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [rdi]                                          ; increment reference count of copy of b
  tempSyd$AfterGCIncref$20:                                      ; after GarbageCollectable incref
  mov r13, qword ptr [rdi + 048h]                                ; make a copy of B.foo's value in case it changes before we use it
  mov r14, qword ptr [rdi + 040h]                                ; make a copy of B.foo's type in case it changes before we use it
  ; increment reference count for copy of B.foo if necessary
  mov r15, r14                                                   ; store copy of B.foo's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc tempSyd$AfterGCIncref$21                                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of B.foo
  tempSyd$AfterGCIncref$21:                                      ; after GarbageCollectable incref
  cmp r14, 039h                                                  ; compare type of copy of B.foo to String
  jne tempSyd$AfterStringIncref$15                               ; if not a String, skip incref
    mov r8, qword ptr [r13]                                      ; dereference string to get to reference count
    cmp r8, 0                                                    ; compare string reference count to 0
    jns tempSyd$StringIncref$15                                  ; if reference count is negative (constant strings), skip incref
    jmp tempSyd$AfterStringIncref$15                             ; skip incref for string constants
    tempSyd$StringIncref$15:                                     ; real String
      inc qword ptr [r13]                                        ; increment reference count of copy of B.foo
  tempSyd$AfterStringIncref$15:                                  ; after String incref
  ; sentinel check of copy of B.foo type Whatever expecting AnythingFunction
  cmp r14, 000h                                                  ; compare type of copy of B.foo to <sentinel>
  jne tempSyd$copyOfBFoo$TypeMatch$1                             ; skip next block if copy of B.foo is not sentinel
    ; Error handling block for copy of B.foo
    ; Call __error with 1 arguments
    mov rdx, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rdx                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rcx, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rcx                                                     ; internal argument 6: pointer to return value slot's value
    lea rcx, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rcx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  tempSyd$copyOfBFoo$TypeMatch$1:                                ; after block
  ; Call copy of B.foo with 0 arguments
  mov qword ptr [rsp + 038h], rdi                                ; move copy of b's value out of rdi
  mov rdi, qword ptr [r13 + 028h]                                ; read receiver pointer
  mov rsi, qword ptr [r13 + 020h]                                ; read receiver type
  lea r12, qword ptr [rsp + 028h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rdi                                                    ; internal argument 4: "this" pointer
  mov r8, rsi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r13 + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of println type NullFunction(Anything...) expecting AnythingFunction
  ; Call println with 2 arguments
  push qword ptr [rsp + 028h]                                    ; value of argument #2 (copy of B.foo return value)
  push qword ptr [rsp + 020h]                                    ; type of argument #2
  mov qword ptr [rsp + 020h], r14                                ; move copy of B.foo's type out of r14
  mov r14, offset string$85                                      ; reading string for push
  push r14                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r15, qword ptr [rsp + 028h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 028h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$println                                              ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Terminate application - call exit(0)
  ; Call exit with 1 arguments
  push 000h                                                      ; value of argument #1 (0 (integer))
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 018h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Decrement reference count for copy of b (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 060h]                                ; arg #2: copy of b's type
  mov rcx, qword ptr [rsp + 058h]                                ; arg #1: copy of b's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for code address for Test.method return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0290h]                               ; arg #2: code address for Test.method return value's type
  mov rcx, qword ptr [rsp + 02a0h]                               ; arg #1: code address for Test.method return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for Test return value (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0338h]                               ; arg #2: Test return value's type
  mov rcx, qword ptr [rsp + 02c8h]                               ; arg #1: Test return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Test.className (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 02e8h]                               ; arg #2: copy of Test.className's type
  mov rcx, qword ptr [rsp + 02f0h]                               ; arg #1: copy of Test.className's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of subclass (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01f0h]                               ; arg #2: copy of subclass's type
  mov rcx, qword ptr [rsp + 0210h]                               ; arg #1: copy of subclass's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for CarrotLeafA return value (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0100h]                               ; arg #2: CarrotLeafA return value's type
  mov rcx, qword ptr [rsp + 0110h]                               ; arg #1: CarrotLeafA return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Test.className (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0260h]                               ; arg #2: copy of Test.className's type
  mov rcx, qword ptr [rsp + 0268h]                               ; arg #1: copy of Test.className's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Subclass.field (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01f8h]                               ; arg #2: copy of Subclass.field's type
  mov rcx, qword ptr [rsp + 0200h]                               ; arg #1: copy of Subclass.field's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for code address for Test.method return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0318h]                               ; arg #2: code address for Test.method return value's type
  mov rcx, qword ptr [rsp + 0340h]                               ; arg #1: code address for Test.method return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of y (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0d8h]                                ; arg #2: copy of y's type
  mov rcx, qword ptr [rsp + 0d0h]                                ; arg #1: copy of y's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0f0h]                                ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 0f8h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for Subclass return value (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0230h]                               ; arg #2: Subclass return value's type
  mov rcx, qword ptr [rsp + 0238h]                               ; arg #1: Subclass return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Test.field (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 02a8h]                               ; arg #2: copy of Test.field's type
  mov rcx, qword ptr [rsp + 02b0h]                               ; arg #1: copy of Test.field's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 098h]                                ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 0b8h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of B.foo (static type: Whatever) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 090h]                                ; arg #2: copy of B.foo's type
  mov rcx, qword ptr [rsp + 068h]                                ; arg #1: copy of B.foo's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of b (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 050h]                                ; arg #2: copy of b's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of b's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of subclass (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01b8h]                               ; arg #2: copy of subclass's type
  mov rcx, qword ptr [rsp + 01c8h]                               ; arg #1: copy of subclass's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for y variable (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0130h]                               ; arg #2: y variable's type
  mov rcx, qword ptr [rsp + 0138h]                               ; arg #1: y variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for B return value (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0a0h]                                ; arg #2: B return value's type
  mov rcx, qword ptr [rsp + 0b0h]                                ; arg #1: B return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of B.foo (static type: Whatever) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of B.foo's type
  mov rcx, r13                                                   ; arg #1: copy of B.foo's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for Test return value (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 02d8h]                               ; arg #2: Test return value's type
  mov rcx, qword ptr [rsp + 02e0h]                               ; arg #1: Test return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0180h]                               ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 0198h]                               ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for subclass variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0248h]                               ; arg #2: subclass variable's type
  mov rcx, qword ptr [rsp + 0250h]                               ; arg #1: subclass variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of test (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0278h]                               ; arg #2: copy of test's type
  mov rcx, qword ptr [rsp + 0220h]                               ; arg #1: copy of test's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for CarrotBranchB return value (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0160h]                               ; arg #2: CarrotBranchB return value's type
  mov rcx, qword ptr [rsp + 0168h]                               ; arg #1: CarrotBranchB return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Test.field (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0320h]                               ; arg #2: copy of Test.field's type
  mov rcx, qword ptr [rsp + 0330h]                               ; arg #1: copy of Test.field's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of y (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0c8h]                                ; arg #2: copy of y's type
  mov rcx, qword ptr [rsp + 0c0h]                                ; arg #1: copy of y's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for BunnyB return value (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01a0h]                               ; arg #2: BunnyB return value's type
  mov rcx, qword ptr [rsp + 0190h]                               ; arg #1: BunnyB return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of x (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0128h]                               ; arg #2: copy of x's type
  mov rcx, qword ptr [rsp + 0118h]                               ; arg #1: copy of x's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for Test return value (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0300h]                               ; arg #2: Test return value's type
  mov rcx, qword ptr [rsp + 02d0h]                               ; arg #1: Test return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for cast of _dynamicLookup return value return value to Whatever return value (static type: Anything'49) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01d8h]                               ; arg #2: cast of _dynamicLookup return value return value to Whatever return value's type
  mov rcx, qword ptr [rsp + 01e8h]                               ; arg #1: cast of _dynamicLookup return value return value to Whatever return value's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0148h]                               ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 0150h]                               ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of B.foo return value (static type: Anything'49) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 078h]                                ; arg #2: copy of B.foo return value's type
  mov rcx, qword ptr [rsp + 080h]                                ; arg #1: copy of B.foo return value's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for b variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0e0h]                                ; arg #2: b variable's type
  mov rcx, qword ptr [rsp + 0e8h]                                ; arg #1: b variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for test variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 02f8h]                               ; arg #2: test variable's type
  mov rcx, qword ptr [rsp + 0308h]                               ; arg #1: test variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for x variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0178h]                               ; arg #2: x variable's type
  mov rcx, qword ptr [rsp + 0188h]                               ; arg #1: x variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of test (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0258h]                               ; arg #2: copy of test's type
  mov rcx, qword ptr [rsp + 0240h]                               ; arg #1: copy of test's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _dynamicLookup return value return value (static type: Whatever) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01e0h]                               ; arg #2: _dynamicLookup return value return value's type
  mov rcx, qword ptr [rsp + 0208h]                               ; arg #1: _dynamicLookup return value return value's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of test (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0270h]                               ; arg #2: copy of test's type
  mov rcx, qword ptr [rsp + 0280h]                               ; arg #1: copy of test's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of B.foo return value (static type: Anything'49) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 038h]                                ; arg #2: copy of B.foo return value's type
  mov rcx, qword ptr [rsp + 048h]                                ; arg #1: copy of B.foo return value's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of subclass (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01a8h]                               ; arg #2: copy of subclass's type
  mov rcx, qword ptr [rsp + 01c0h]                               ; arg #1: copy of subclass's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of Test.field (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0228h]                               ; arg #2: copy of Test.field's type
  mov rcx, qword ptr [rsp + 0218h]                               ; arg #1: copy of Test.field's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of test (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 02b8h]                               ; arg #2: copy of test's type
  mov rcx, qword ptr [rsp + 02c0h]                               ; arg #1: copy of test's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of test (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0298h]                               ; arg #2: copy of test's type
  mov rcx, qword ptr [rsp + 0288h]                               ; arg #1: copy of test's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for Test return value (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0328h]                               ; arg #2: Test return value's type
  mov rcx, qword ptr [rsp + 0310h]                               ; arg #1: Test return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of b (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 088h]                                ; arg #2: copy of b's type
  mov rcx, qword ptr [rsp + 070h]                                ; arg #1: copy of b's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of x (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0140h]                               ; arg #2: copy of x's type
  mov rcx, qword ptr [rsp + 0120h]                               ; arg #1: copy of x's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _dynamicLookup return value return value (static type: Whatever) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 01b0h]                               ; arg #2: _dynamicLookup return value return value's type
  mov rcx, qword ptr [rsp + 01d0h]                               ; arg #1: _dynamicLookup return value return value's value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Epilog
  add rsp, 0338h                                                 ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers

  ; End of global scope
  ret                                                            ; exit application

; __error
dq func$__error$annotation
func$__error:
  jmp func$_error                                                ; trampoline to error intrinsic

; len
dq func$len$annotation
func$len:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of len to 1 (integer)
  je func$len$parameterCountCheck$continuation                   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$len$parameterCountCheck$continuation:                     ; end of parameter count check
  ; Check type of parameter 0, list (expecting WhateverReadOnlyList)
  ; type check of list type WhateverReadOnlyList expecting WhateverReadOnlyList
  mov rbx, qword ptr [rbp + 038h]                                ; store list's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 005h                                       ; check that list is WhateverReadOnlyList
  jc func$len$list$TypeMatch                                     ; skip next block if the type matches
    ; Error handling block for list
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$len$list$TypeMatch:                                       ; after block
  mov r14, qword ptr [rbp + 040h]                                ; get list into register to dereference it
  mov r15, qword ptr [r14 + 038h]                                ; list data is the second field in its block
  mov r10, qword ptr [r15 + 008h]                                ; list length is a field in the list data
  ; sentinel check of length of list type Integer expecting Integer
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of len into register to dereference it
  mov qword ptr [rsi], r10                                       ; len return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of len into register to dereference it
  mov qword ptr [rdi], 038h                                      ; type of len return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __readFromAddress
dq func$__readFromAddress$annotation
func$__readFromAddress:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of __readFromAddress to 1 (integer)
  je func$__readFromAddress$parameterCountCheck$continuation     ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__readFromAddress$parameterCountCheck$continuation:       ; end of parameter count check
  ; Check type of parameter 0, address (expecting Integer)
  ; type check of address type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store address's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that address is Integer
  jc func$__readFromAddress$address$TypeMatch                    ; skip next block if the type matches
    ; Error handling block for address
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__readFromAddress$address$TypeMatch:                      ; after block
  ; Implicit return from __readFromAddress
  ; type check of null type Null expecting Integer
  mov r14, 036h                                                  ; store null's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that __readFromAddress return value is Integer
  jc func$__readFromAddress$ReadfromaddressReturnValue$TypeMatch ; skip next block if the type matches
    ; Error handling block for __readFromAddress return value
    ; Call __error with 1 arguments
    mov rbx, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__readFromAddress$ReadfromaddressReturnValue$TypeMatch:   ; after block
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of __readFromAddress into register to dereference it
  mov qword ptr [rdi], 000h                                      ; __readFromAddress return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of __readFromAddress into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of __readFromAddress return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __writeToAddress
dq func$__writeToAddress$annotation
func$__writeToAddress:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of __writeToAddress to 2 (integer)
  je func$__writeToAddress$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToAddress$parameterCountCheck$continuation:        ; end of parameter count check
  ; Check type of parameter 0, address (expecting Integer)
  ; type check of address type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store address's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that address is Integer
  jc func$__writeToAddress$address$TypeMatch                     ; skip next block if the type matches
    ; Error handling block for address
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToAddress$address$TypeMatch:                       ; after block
  ; Check type of parameter 1, value (expecting Integer)
  ; type check of value type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store value's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that value is Integer
  jc func$__writeToAddress$value$TypeMatch                       ; skip next block if the type matches
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToAddress$value$TypeMatch:                         ; after block
  ; Implicit return from __writeToAddress
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of __writeToAddress into register to dereference it
  mov qword ptr [r13], 000h                                      ; __writeToAddress return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of __writeToAddress into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of __writeToAddress return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __incref
dq func$__incref$annotation
func$__incref:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of __incref to 1 (integer)
  je func$__incref$parameterCountCheck$continuation              ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__incref$parameterCountCheck$continuation:                ; end of parameter count check
  ; Check type of parameter 0, value (expecting Anything)
  ; type check of value type Anything expecting Anything
  mov rbx, qword ptr [rbp + 038h]                                ; store value's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that value is Anything
  jc func$__incref$value$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__incref$value$TypeMatch:                                 ; after block
  ; Implicit return from __incref
  ; sentinel check of null type Null expecting Null
  mov r10, qword ptr [rbp + 030h]                                ; get pointer to return value of __incref into register to dereference it
  mov qword ptr [r10], 000h                                      ; __incref return value
  mov rbx, qword ptr [rbp + 028h]                                ; get pointer to return value type of __incref into register to dereference it
  mov qword ptr [rbx], 036h                                      ; type of __incref return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __Object
dq method$__Object$__Object$annotation
method$__Object$__Object:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset __Object$vmt                                   ; reading vmt pointer for __Object for push
  push r10                                                       ; value of argument #1 (vmt pointer for __Object)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of __Object's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for __Object.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for __Object.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of '__Object.constructor' method for use with "jmp" below
  ; sentinel check of _classAllocator return value type __Object expecting __Object
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of _classAllocator return value to <sentinel>
  jne method$__Object$__Object$OBjectReturnValue$TypeMatch       ; skip next block if _classAllocator return value is not sentinel
    ; Error handling block for __Object return value
    ; Call __error with 1 arguments
    mov r12, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$__Object$OBjectReturnValue$TypeMatch:          ; after block
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of __Object into register to dereference it
  mov qword ptr [r14], rbx                                       ; __Object return value
  mov r15, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of __Object into register to dereference it
  mov qword ptr [r10], r15                                       ; type of __Object return value
  ; increment reference count for _classAllocator return value if necessary
  mov rax, r15                                                   ; store _classAllocator return value's type in testByte value slot
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$__Object$__Object$AfterGCIncref                     ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], rdi                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$__Object$__Object$AfterGCIncref:                        ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r15                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, r15                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; exit
dq func$exit$annotation
func$exit:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of exit to 1 (integer)
  je func$exit$parameterCountCheck$continuation                  ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$exit$parameterCountCheck$continuation:                    ; end of parameter count check
  ; Check type of parameter 0, exitCode (expecting Integer)
  ; type check of exitCode type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store exitCode's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that exitCode is Integer
  jc func$exit$exitcode$TypeMatch                                ; skip next block if the type matches
    ; Error handling block for exitCode
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$exit$exitcode$TypeMatch:                                  ; after block
  ; Calling ExitProcess
  mov rcx, qword ptr [rbp + 040h]                                ; argument #1
  sub rsp, 020h                                                  ; allocate shadow space
  call ExitProcess                                               ; calls ExitProcess from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of ExitProcess system call type Integer expecting Integer
  mov r10, qword ptr [rbp + 030h]                                ; get pointer to return value of exit into register to dereference it
  mov qword ptr [r10], rax                                       ; exit return value
  mov rbx, qword ptr [rbp + 028h]                                ; get pointer to return value type of exit into register to dereference it
  mov qword ptr [rbx], 038h                                      ; type of exit return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __getLastError
dq func$__getLastError$annotation
func$__getLastError:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __getLastError to 0 (integer)
  je func$__getLastError$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__getLastError$parameterCountCheck$continuation:          ; end of parameter count check
  ; Calling GetLastError
  sub rsp, 020h                                                  ; allocate shadow space
  call GetLastError                                              ; calls GetLastError from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of GetLastError system call type Integer expecting Integer
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of __getLastError into register to dereference it
  mov qword ptr [rdi], rax                                       ; __getLastError return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of __getLastError into register to dereference it
  mov qword ptr [r12], 038h                                      ; type of __getLastError return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; assert
dq func$assert$annotation
func$assert:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of assert to 2 (integer)
  je func$assert$parameterCountCheck$continuation                ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$assert$parameterCountCheck$continuation:                  ; end of parameter count check
  ; Check type of parameter 0, condition (expecting Boolean)
  ; type check of condition type Boolean expecting Boolean
  mov rbx, qword ptr [rbp + 038h]                                ; store condition's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 001h                                       ; check that condition is Boolean
  jc func$assert$condition$TypeMatch                             ; skip next block if the type matches
    ; Error handling block for condition
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$assert$condition$TypeMatch:                               ; after block
  ; Check type of parameter 1, message (expecting String)
  ; type check of message type String expecting String
  mov r14, qword ptr [rbp + 048h]                                ; store message's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that message is String
  jc func$assert$message$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for message
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$assert$message$TypeMatch:                                 ; after block
  ; Line 36: if (!condition) { ...
  ; sentinel check of condition type Boolean expecting Boolean
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of condition to <sentinel>
  jne func$assert$condition$TypeMatch$1                          ; skip next block if condition is not sentinel
    ; Error handling block for condition
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$assert$condition$TypeMatch$1:                             ; after block
  xor r13, r13                                                   ; zero ! unary operator result to put the boolean in
  cmp qword ptr [rbp + 040h], 000h                               ; ! unary operator
  sete r13b                                                      ; put result in ! unary operator result
  mov r14, 037h                                                  ; ! unary operator result is a Boolean'37
  ; sentinel check of ! unary operator result type Boolean expecting Boolean
  cmp r13, 000h                                                  ; compare ! unary operator result to false
  je func$assert$if$continuation                                 ; !condition
    ; Line 37: stderr(message);
    mov r10, qword ptr stderrValue                               ; make a copy of stderr's value in case it changes before we use it
    mov rbx, qword ptr stderrType                                ; make a copy of stderr's type in case it changes before we use it
    ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
    cmp rbx, 000h                                                ; compare type of copy of stderr to <sentinel>
    jne func$assert$assert$if$copyOfStderr$TypeMatch             ; skip next block if copy of stderr is not sentinel
      ; Error handling block for copy of stderr
      ; Call __error with 1 arguments
      mov rsi, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of stderr's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of stderr) to previous scope state for genuine block exit
    func$assert$assert$if$copyOfStderr$TypeMatch:                ; after block
    ; Call copy of stderr with 1 arguments
    mov r12, qword ptr [r10 + 028h]                              ; read receiver pointer
    mov r13, qword ptr [r10 + 020h]                              ; read receiver type
    push qword ptr [rbp + 050h]                                  ; value of argument #1 (message)
    push qword ptr [rbp + 048h]                                  ; type of argument #1
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r12                                                  ; internal argument 4: "this" pointer
    mov r8, r13                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], r10                              ; move copy of stderr's value out of r10
    mov r15, qword ptr [rsp + 040h]                              ; reading copy of stderr to dereference it
    call qword ptr [r15 + 038h]                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 38: exit(1);
    ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
    ; Call exit with 1 arguments
    push 001h                                                    ; value of argument #1 (1)
    push 038h                                                    ; type of argument #1 (Integer'38)
    lea rbx, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$exit                                               ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$assert$if$continuation:                                   ; end of if
  ; Implicit return from assert
  ; sentinel check of null type Null expecting Null
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of assert into register to dereference it
  mov qword ptr [r12], 000h                                      ; assert return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of assert into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of assert return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; throw
dq func$throw$annotation
func$throw:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of throw to 1 (integer)
  je func$throw$parameterCountCheck$continuation                 ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$throw$parameterCountCheck$continuation:                   ; end of parameter count check
  ; Check type of parameter 0, message (expecting String)
  ; type check of message type String expecting String
  mov rbx, qword ptr [rbp + 038h]                                ; store message's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that message is String
  jc func$throw$message$TypeMatch                                ; skip next block if the type matches
    ; Error handling block for message
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$throw$message$TypeMatch:                                  ; after block
  ; Line 43: stderr(message);
  mov r14, qword ptr stderrValue                                 ; make a copy of stderr's value in case it changes before we use it
  mov r15, qword ptr stderrType                                  ; make a copy of stderr's type in case it changes before we use it
  ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
  cmp r15, 000h                                                  ; compare type of copy of stderr to <sentinel>
  jne func$throw$copyOfStderr$TypeMatch                          ; skip next block if copy of stderr is not sentinel
    ; Error handling block for copy of stderr
    ; Call __error with 1 arguments
    mov r10, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$throw$copyOfStderr$TypeMatch:                             ; after block
  ; Call copy of stderr with 1 arguments
  mov rax, qword ptr [r14 + 028h]                                ; read receiver pointer
  mov rsi, qword ptr [r14 + 020h]                                ; read receiver type
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (message)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rdi, qword ptr [rsp + 018h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 018h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rax                                                    ; internal argument 4: "this" pointer
  mov r8, rsi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r14 + 038h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 44: exit(1);
  ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
  ; Call exit with 1 arguments
  push 001h                                                      ; value of argument #1 (1)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r14, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from throw
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of throw into register to dereference it
  mov qword ptr [rbx], 000h                                      ; throw return value
  mov rax, qword ptr [rbp + 028h]                                ; get pointer to return value type of throw into register to dereference it
  mov qword ptr [rax], 036h                                      ; type of throw return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __getProcessHeap
dq func$__getProcessHeap$annotation
func$__getProcessHeap:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __getProcessHeap to 0 (integer)
  je func$__getProcessHeap$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__getProcessHeap$parameterCountCheck$continuation:        ; end of parameter count check
  ; Calling GetProcessHeap
  sub rsp, 020h                                                  ; allocate shadow space
  call GetProcessHeap                                            ; calls GetProcessHeap from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of GetProcessHeap system call type Integer expecting Integer
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of __getProcessHeap into register to dereference it
  mov qword ptr [rdi], rax                                       ; __getProcessHeap return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of __getProcessHeap into register to dereference it
  mov qword ptr [r12], 038h                                      ; type of __getProcessHeap return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __heapAlloc
dq func$__heapAlloc$annotation
func$__heapAlloc:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of __heapAlloc to 3 (integer)
  je func$__heapAlloc$parameterCountCheck$continuation           ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapAlloc$parameterCountCheck$continuation:             ; end of parameter count check
  ; Check type of parameter 0, hHeap (expecting Integer)
  ; type check of hHeap type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store hHeap's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that hHeap is Integer
  jc func$__heapAlloc$hheap$TypeMatch                            ; skip next block if the type matches
    ; Error handling block for hHeap
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapAlloc$hheap$TypeMatch:                              ; after block
  ; Check type of parameter 1, dwFlags (expecting Integer)
  ; type check of dwFlags type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store dwFlags's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that dwFlags is Integer
  jc func$__heapAlloc$dwflags$TypeMatch                          ; skip next block if the type matches
    ; Error handling block for dwFlags
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapAlloc$dwflags$TypeMatch:                            ; after block
  ; Check type of parameter 2, dwBytes (expecting Integer)
  ; type check of dwBytes type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store dwBytes's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that dwBytes is Integer
  jc func$__heapAlloc$dwbytes$TypeMatch                          ; skip next block if the type matches
    ; Error handling block for dwBytes
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapAlloc$dwbytes$TypeMatch:                            ; after block
  ; Calling HeapAlloc
  mov r8, qword ptr [rbp + 060h]                                 ; argument #3
  mov rdx, qword ptr [rbp + 050h]                                ; argument #2
  mov rcx, qword ptr [rbp + 040h]                                ; argument #1
  sub rsp, 020h                                                  ; allocate shadow space
  call HeapAlloc                                                 ; calls HeapAlloc from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of HeapAlloc system call type Integer expecting Integer
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of __heapAlloc into register to dereference it
  mov qword ptr [rsi], rax                                       ; __heapAlloc return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of __heapAlloc into register to dereference it
  mov qword ptr [rdi], 038h                                      ; type of __heapAlloc return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _alloc
dq func$_alloc$annotation
func$_alloc:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 048h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 088h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _alloc to 1 (integer)
  je func$_alloc$parameterCountCheck$continuation                ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$parameterCountCheck$continuation:                  ; end of parameter count check
  ; Check type of parameter 0, size (expecting Integer)
  ; type check of size type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store size's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that size is Integer
  jc func$_alloc$size$TypeMatch                                  ; skip next block if the type matches
    ; Error handling block for size
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$size$TypeMatch:                                    ; after block
  ; Line 64: Integer pointer = __heapAlloc(_heapHandle, 0, size);
  mov r14, qword ptr _heapHandleValue                            ; make a copy of _heapHandle's value in case it changes before we use it
  mov r15, qword ptr _heapHandleType                             ; make a copy of _heapHandle's type in case it changes before we use it
  ; sentinel check of __heapAlloc type IntegerFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call __heapAlloc with 3 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #3 (size)
  push qword ptr [rbp + 038h]                                    ; type of argument #3
  push 000h                                                      ; value of argument #2 (0)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push r14                                                       ; value of argument #1 (copy of _heapHandle)
  push r15                                                       ; type of argument #1
  lea rax, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$__heapAlloc                                          ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of __heapAlloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of __heapAlloc return value to <sentinel>
  jne func$_alloc$HeapallocReturnValue$TypeMatch                 ; skip next block if __heapAlloc return value is not sentinel
    ; Error handling block for __heapAlloc return value
    ; Call __error with 1 arguments
    mov rsi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$HeapallocReturnValue$TypeMatch:                    ; after block
  mov r11, qword ptr [rsp + 028h]                                ; indirect through r11 because operand pair (stack operand #1, stack operand #3) is not allowed with mov
  mov qword ptr [rsp + 038h], r11                                ; value initialization of variable declaration for pointer variable (__heapAlloc return value)
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (stack operand #2, stack operand #4) is not allowed with mov
  mov qword ptr [rsp + 030h], r11                                ; type initialization of variable declaration for pointer variable
  ; Line 65: if (pointer > 0) { ...
  mov r12, qword ptr [rsp + 038h]                                ; make a copy of pointer's value in case it changes before we use it
  mov r13, qword ptr [rsp + 030h]                                ; make a copy of pointer's type in case it changes before we use it
  ; sentinel check of copy of pointer type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of pointer to <sentinel>
  jne func$_alloc$pointer$TypeMatch                              ; skip next block if copy of pointer is not sentinel
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$pointer$TypeMatch:                                 ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor rax, rax                                                   ; clear > operator result
  cmp r12, 000h                                                  ; compare copy of pointer with 0
  setg al                                                        ; store result in > operator result
  ; sentinel check of > operator result type Boolean expecting Boolean
  cmp rax, 000h                                                  ; compare > operator result to false
  je func$_alloc$if$continuation                                 ; pointer > 0
    ; Line 66: _blockCount += 1;
    mov r12, qword ptr _blockCountValue                          ; make a copy of _blockCount's value in case it changes before we use it
    mov r13, qword ptr _blockCountType                           ; make a copy of _blockCount's type in case it changes before we use it
    ; sentinel check of copy of _blockCount type Integer expecting Integer
    cmp r13, 000h                                                ; compare type of copy of _blockCount to <sentinel>
    jne func$_alloc$Alloc$if$copyOfBlockcount$TypeMatch          ; skip next block if copy of _blockCount is not sentinel
      ; Error handling block for copy of _blockCount
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 038h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 038h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_alloc$Alloc$if$copyOfBlockcount$TypeMatch:             ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov rax, r12                                                 ; assign value of copy of _blockCount to value of += operator result
    mov rsi, 001h                                                ; read second operand of add (1)
    add rax, rsi                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr _blockCountValue, rax                          ; store value
    mov qword ptr _blockCountType, 038h                          ; store type (Integer'38)
    ; Line 67: return pointer;
    mov r13, qword ptr [rsp + 038h]                              ; make a copy of pointer's value in case it changes before we use it
    mov r14, qword ptr [rsp + 030h]                              ; make a copy of pointer's type in case it changes before we use it
    ; sentinel check of copy of pointer type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of pointer to <sentinel>
    jne func$_alloc$Alloc$if$AllocReturnValue$TypeMatch          ; skip next block if copy of pointer is not sentinel
      ; Error handling block for _alloc return value
      ; Call __error with 1 arguments
      mov r15, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 038h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 038h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 058h], rax                            ; move += operator result's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 018h]                            ; restoring slot (+= operator result) to previous scope state for genuine block exit
    func$_alloc$Alloc$if$AllocReturnValue$TypeMatch:             ; after block
    mov rbx, qword ptr [rbp + 030h]                              ; get pointer to return value of _alloc into register to dereference it
    mov qword ptr [rbx], r13                                     ; _alloc return value
    mov qword ptr [rsp + 028h], rax                              ; move += operator result's value out of rax
    mov rax, qword ptr [rbp + 028h]                              ; get pointer to return value type of _alloc into register to dereference it
    mov qword ptr [rax], r14                                     ; type of _alloc return value
    jmp func$_alloc$epilog                                       ; return
  func$_alloc$if$continuation:                                   ; end of if
  ; Line 69: _garbageCollector();
  mov rsi, qword ptr _garbageCollectorValue                      ; make a copy of _garbageCollector's value in case it changes before we use it
  mov rdi, qword ptr _garbageCollectorType                       ; make a copy of _garbageCollector's type in case it changes before we use it
  ; sentinel check of copy of _garbageCollector type NullFunction expecting AnythingFunction
  cmp rdi, 000h                                                  ; compare type of copy of _garbageCollector to <sentinel>
  jne func$_alloc$copyOfGarbagecollector$TypeMatch               ; skip next block if copy of _garbageCollector is not sentinel
    ; Error handling block for copy of _garbageCollector
    ; Call __error with 1 arguments
    mov r12, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$copyOfGarbagecollector$TypeMatch:                  ; after block
  ; Call copy of _garbageCollector with 0 arguments
  mov r14, qword ptr [rsi + 028h]                                ; read receiver pointer
  mov r15, qword ptr [rsi + 020h]                                ; read receiver type
  lea r10, qword ptr [rsp + 020h]                                ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r14                                                    ; internal argument 4: "this" pointer
  mov r8, r15                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [rsi + 038h]                                    ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 70: pointer = __heapAlloc(_heapHandle, 0, size);
  mov rbx, qword ptr _heapHandleValue                            ; make a copy of _heapHandle's value in case it changes before we use it
  mov rax, qword ptr _heapHandleType                             ; make a copy of _heapHandle's type in case it changes before we use it
  ; sentinel check of __heapAlloc type IntegerFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call __heapAlloc with 3 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #3 (size)
  push qword ptr [rbp + 038h]                                    ; type of argument #3
  push 000h                                                      ; value of argument #2 (0)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push rbx                                                       ; value of argument #1 (copy of _heapHandle)
  push rax                                                       ; type of argument #1
  lea r12, qword ptr [rsp + 050h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 050h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$__heapAlloc                                          ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of __heapAlloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 018h], 000h                               ; compare type of __heapAlloc return value to <sentinel>
  jne func$_alloc$HeapallocReturnValue$TypeMatch$1               ; skip next block if __heapAlloc return value is not sentinel
    ; Error handling block for __heapAlloc return value
    ; Call __error with 1 arguments
    mov r13, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$HeapallocReturnValue$TypeMatch$1:                  ; after block
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (stack operand #1, stack operand #4) is not allowed with mov
  mov qword ptr [rsp + 038h], r11                                ; store value
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (stack operand #2, stack operand #5) is not allowed with mov
  mov qword ptr [rsp + 030h], r11                                ; store type
  ; Line 71: if (pointer > 0) { ...
  mov r15, qword ptr [rsp + 038h]                                ; make a copy of pointer's value in case it changes before we use it
  mov r10, qword ptr [rsp + 030h]                                ; make a copy of pointer's type in case it changes before we use it
  ; sentinel check of copy of pointer type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of pointer to <sentinel>
  jne func$_alloc$pointer$TypeMatch$1                            ; skip next block if copy of pointer is not sentinel
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], r10                              ; move copy of pointer's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 000h]                              ; restoring slot (copy of pointer) to previous scope state for genuine block exit
  func$_alloc$pointer$TypeMatch$1:                               ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r12, r12                                                   ; clear > operator result
  cmp r15, 000h                                                  ; compare copy of pointer with 0
  setg r12b                                                      ; store result in > operator result
  ; sentinel check of > operator result type Boolean expecting Boolean
  cmp r12, 000h                                                  ; compare > operator result to false
  je func$_alloc$if$continuation$1                               ; pointer > 0
    ; Line 72: _blockCount += 1;
    mov r15, qword ptr _blockCountValue                          ; make a copy of _blockCount's value in case it changes before we use it
    mov r10, qword ptr _blockCountType                           ; make a copy of _blockCount's type in case it changes before we use it
    ; sentinel check of copy of _blockCount type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of _blockCount to <sentinel>
    jne func$_alloc$Alloc$if$1$copyOfBlockcount$TypeMatch        ; skip next block if copy of _blockCount is not sentinel
      ; Error handling block for copy of _blockCount
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of _blockCount's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of _blockCount) to previous scope state for genuine block exit
    func$_alloc$Alloc$if$1$copyOfBlockcount$TypeMatch:           ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov r12, r15                                                 ; assign value of copy of _blockCount to value of += operator result
    mov r13, 001h                                                ; read second operand of add (1)
    add r12, r13                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr _blockCountValue, r12                          ; store value
    mov qword ptr _blockCountType, 038h                          ; store type (Integer'38)
    ; Line 73: return pointer;
    mov r10, qword ptr [rsp + 038h]                              ; make a copy of pointer's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 030h]                              ; make a copy of pointer's type in case it changes before we use it
    ; sentinel check of copy of pointer type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of pointer to <sentinel>
    jne func$_alloc$Alloc$if$1$AllocReturnValue$TypeMatch        ; skip next block if copy of pointer is not sentinel
      ; Error handling block for _alloc return value
      ; Call __error with 1 arguments
      mov rax, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of pointer's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of pointer) to previous scope state for genuine block exit
    func$_alloc$Alloc$if$1$AllocReturnValue$TypeMatch:           ; after block
    mov rdi, qword ptr [rbp + 030h]                              ; get pointer to return value of _alloc into register to dereference it
    mov qword ptr [rdi], r10                                     ; _alloc return value
    mov qword ptr [rsp + 010h], r12                              ; move += operator result's value out of r12
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of _alloc into register to dereference it
    mov qword ptr [r12], rbx                                     ; type of _alloc return value
    jmp func$_alloc$epilog                                       ; return
  func$_alloc$if$continuation$1:                                 ; end of if
  ; Line 75: stderr('Out of memory.');
  mov r13, qword ptr stderrValue                                 ; make a copy of stderr's value in case it changes before we use it
  mov r14, qword ptr stderrType                                  ; make a copy of stderr's type in case it changes before we use it
  ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
  cmp r14, 000h                                                  ; compare type of copy of stderr to <sentinel>
  jne func$_alloc$copyOfStderr$TypeMatch                         ; skip next block if copy of stderr is not sentinel
    ; Error handling block for copy of stderr
    ; Call __error with 1 arguments
    mov r15, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$copyOfStderr$TypeMatch:                            ; after block
  ; Call copy of stderr with 1 arguments
  mov rbx, qword ptr [r13 + 028h]                                ; read receiver pointer
  mov rax, qword ptr [r13 + 020h]                                ; read receiver type
  mov rsi, offset string                                         ; reading string for push
  push rsi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea rdi, qword ptr [rsp + 018h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 018h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rbx                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r13 + 038h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 76: exit(1);
  ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
  ; Call exit with 1 arguments
  push 001h                                                      ; value of argument #1 (1)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r14, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _alloc
  ; type check of null type Null expecting Integer
  mov r15, 036h                                                  ; store null's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that _alloc return value is Integer
  jc func$_alloc$AllocReturnValue$TypeMatch                      ; skip next block if the type matches
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov rsi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_alloc$AllocReturnValue$TypeMatch:                        ; after block
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of _alloc into register to dereference it
  mov qword ptr [r12], 000h                                      ; _alloc return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of _alloc into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of _alloc return value (Null'36)
  func$_alloc$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 048h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __heapFree
dq func$__heapFree$annotation
func$__heapFree:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of __heapFree to 3 (integer)
  je func$__heapFree$parameterCountCheck$continuation            ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapFree$parameterCountCheck$continuation:              ; end of parameter count check
  ; Check type of parameter 0, hHeap (expecting Integer)
  ; type check of hHeap type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store hHeap's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that hHeap is Integer
  jc func$__heapFree$hheap$TypeMatch                             ; skip next block if the type matches
    ; Error handling block for hHeap
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapFree$hheap$TypeMatch:                               ; after block
  ; Check type of parameter 1, dwFlags (expecting Integer)
  ; type check of dwFlags type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store dwFlags's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that dwFlags is Integer
  jc func$__heapFree$dwflags$TypeMatch                           ; skip next block if the type matches
    ; Error handling block for dwFlags
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapFree$dwflags$TypeMatch:                             ; after block
  ; Check type of parameter 2, lpMem (expecting Integer)
  ; type check of lpMem type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store lpMem's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that lpMem is Integer
  jc func$__heapFree$lpmem$TypeMatch                             ; skip next block if the type matches
    ; Error handling block for lpMem
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__heapFree$lpmem$TypeMatch:                               ; after block
  ; Calling HeapFree
  mov r8, qword ptr [rbp + 060h]                                 ; argument #3
  mov rdx, qword ptr [rbp + 050h]                                ; argument #2
  mov rcx, qword ptr [rbp + 040h]                                ; argument #1
  sub rsp, 020h                                                  ; allocate shadow space
  call HeapFree                                                  ; calls HeapFree from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of HeapFree system call type Integer expecting Integer
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of __heapFree into register to dereference it
  mov qword ptr [rsi], rax                                       ; __heapFree return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of __heapFree into register to dereference it
  mov qword ptr [rdi], 038h                                      ; type of __heapFree return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _free
dq func$_free$annotation
func$_free:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _free to 1 (integer)
  je func$_free$parameterCountCheck$continuation                 ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_free$parameterCountCheck$continuation:                   ; end of parameter count check
  ; Check type of parameter 0, pointer (expecting Integer)
  ; type check of pointer type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store pointer's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that pointer is Integer
  jc func$_free$pointer$TypeMatch                                ; skip next block if the type matches
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_free$pointer$TypeMatch:                                  ; after block
  ; Line 84: _blockCount -= 1;
  mov r14, qword ptr _blockCountValue                            ; make a copy of _blockCount's value in case it changes before we use it
  mov r15, qword ptr _blockCountType                             ; make a copy of _blockCount's type in case it changes before we use it
  ; sentinel check of copy of _blockCount type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _blockCount to <sentinel>
  jne func$_free$copyOfBlockcount$TypeMatch                      ; skip next block if copy of _blockCount is not sentinel
    ; Error handling block for copy of _blockCount
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_free$copyOfBlockcount$TypeMatch:                         ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of _blockCount to value of -= operator result
  mov r12, 001h                                                  ; read second operand of sub (1)
  sub rdi, r12                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _blockCountValue, rdi                            ; store value
  mov qword ptr _blockCountType, 038h                            ; store type (Integer'38)
  ; Line 85: if (__heapFree(_heapHandle, 0, pointer) == 0) { ...
  mov r15, qword ptr _heapHandleValue                            ; make a copy of _heapHandle's value in case it changes before we use it
  mov r10, qword ptr _heapHandleType                             ; make a copy of _heapHandle's type in case it changes before we use it
  ; sentinel check of __heapFree type IntegerFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call __heapFree with 3 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #3 (pointer)
  push qword ptr [rbp + 038h]                                    ; type of argument #3
  push 000h                                                      ; value of argument #2 (0)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push r15                                                       ; value of argument #1 (copy of _heapHandle)
  push r10                                                       ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$__heapFree                                           ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  mov qword ptr [rsp + 018h], rdi                                ; move -= operator result's value out of rdi
  xor rdi, rdi                                                   ; zero value result of == (testing __heapFree return value and 0) to put the boolean in
  cmp qword ptr [rsp + 028h], 000h                               ; values equal?
  sete dil                                                       ; put result in value result of == (testing __heapFree return value and 0)
  mov r12, 037h                                                  ; value result of == (testing __heapFree return value and 0) is a Boolean'37
  xor r13, r13                                                   ; zero type result of == (testing __heapFree return value and 0) to put the boolean in
  cmp qword ptr [rsp + 020h], 038h                               ; types equal?
  sete r13b                                                      ; put result in type result of == (testing __heapFree return value and 0)
  mov r14, 037h                                                  ; type result of == (testing __heapFree return value and 0) is a Boolean'37
  mov r15, rdi                                                   ; assign value of value result of == (testing __heapFree return value and 0) to value of == operator result
  and r15, r13                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r15, 000h                                                  ; compare == operator result to false
  je func$_free$if$continuation                                  ; __heapFree(_heapHandle, 0, pointer) == 0
    ; Line 86: stderr('failed to free pointer, error code: ', __getLastError())...
    mov rax, qword ptr stderrValue                               ; make a copy of stderr's value in case it changes before we use it
    mov rsi, qword ptr stderrType                                ; make a copy of stderr's type in case it changes before we use it
    ; sentinel check of __getLastError type IntegerFunction() expecting AnythingFunction
    ; Call __getLastError with 0 arguments
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 000h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], rax                              ; move copy of stderr's value out of rax
    call func$__getLastError                                     ; jump to subroutine
    add rsp, 030h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
    cmp rsi, 000h                                                ; compare type of copy of stderr to <sentinel>
    jne func$_free$Free$if$copyOfStderr$TypeMatch                ; skip next block if copy of stderr is not sentinel
      ; Error handling block for copy of stderr
      ; Call __error with 1 arguments
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 018h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 018h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_free$Free$if$copyOfStderr$TypeMatch:                   ; after block
    ; Call copy of stderr with 2 arguments
    mov r10, qword ptr [rsp + 010h]                              ; get copy of stderr into register to dereference it
    mov rbx, qword ptr [r10 + 028h]                              ; read receiver pointer
    mov rax, qword ptr [r10 + 020h]                              ; read receiver type
    push qword ptr [rsp + 028h]                                  ; value of argument #2 (__getLastError return value)
    push qword ptr [rsp + 028h]                                  ; type of argument #2
    mov qword ptr [rsp + 038h], rsi                              ; move copy of stderr's type out of rsi
    mov rsi, offset string$1                                     ; reading string for push
    push rsi                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, rbx                                                  ; internal argument 4: "this" pointer
    mov r8, rax                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of stderr's value out of r10
    mov r12, qword ptr [rsp + 058h]                              ; reading copy of stderr to dereference it
    call qword ptr [r12 + 038h]                                  ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 87: exit(1);
    ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
    ; Call exit with 1 arguments
    push 001h                                                    ; value of argument #1 (1)
    push 038h                                                    ; type of argument #1 (Integer'38)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$exit                                               ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_free$if$continuation:                                    ; end of if
  ; Implicit return from _free
  ; sentinel check of null type Null expecting Null
  mov rax, qword ptr [rbp + 030h]                                ; get pointer to return value of _free into register to dereference it
  mov qword ptr [rax], 000h                                      ; _free return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of _free into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of _free return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _moveBytes
dq func$_moveBytes$annotation
func$_moveBytes:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0a8h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0e8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of _moveBytes to 3 (integer)
  je func$_moveBytes$parameterCountCheck$continuation            ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$parameterCountCheck$continuation:              ; end of parameter count check
  ; Check type of parameter 0, from (expecting Integer)
  ; type check of from type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store from's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that from is Integer
  jc func$_moveBytes$from$TypeMatch                              ; skip next block if the type matches
    ; Error handling block for from
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$from$TypeMatch:                                ; after block
  ; Check type of parameter 1, to (expecting Integer)
  ; type check of to type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store to's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that to is Integer
  jc func$_moveBytes$to$TypeMatch                                ; skip next block if the type matches
    ; Error handling block for to
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$to$TypeMatch:                                  ; after block
  ; Check type of parameter 2, length (expecting Integer)
  ; type check of length type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store length's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that length is Integer
  jc func$_moveBytes$length$TypeMatch                            ; skip next block if the type matches
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$length$TypeMatch:                              ; after block
  ; Line 94: assert(length > 0, '_moveBytes expects positive number of bytes ...
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 058h], 000h                               ; compare type of length to <sentinel>
  jne func$_moveBytes$length$TypeMatch$1                         ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$length$TypeMatch$1:                            ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor rax, rax                                                   ; clear > operator result
  cmp qword ptr [rbp + 060h], 000h                               ; compare length with 0
  setg al                                                        ; store result in > operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r14, offset string$2                                       ; reading string for push
  push r14                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rax                                                       ; value of argument #1 (> operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r15, qword ptr [rsp + 0b0h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 0b0h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 95: Integer fromCursor = from;
  ; sentinel check of from type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of from to <sentinel>
  jne func$_moveBytes$from$TypeMatch$1                           ; skip next block if from is not sentinel
    mov qword ptr [rsp + 090h], 000h                             ; move fromCursor variable's value into a mutable location
    mov qword ptr [rsp + 088h], 000h                             ; move fromCursor variable's type into a mutable location
    ; Error handling block for from
    ; Call __error with 1 arguments
    mov r10, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 090h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 090h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$from$TypeMatch$1:                              ; after block
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (stack operand #1, qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rsp + 090h], r11                                ; value initialization of variable declaration for fromCursor variable (from)
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (stack operand #2, qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rsp + 088h], r11                                ; type initialization of variable declaration for fromCursor variable
  ; Line 96: Integer toCursor = to;
  ; sentinel check of to type Integer expecting Integer
  cmp qword ptr [rbp + 048h], 000h                               ; compare type of to to <sentinel>
  jne func$_moveBytes$to$TypeMatch$1                             ; skip next block if to is not sentinel
    mov qword ptr [rsp + 080h], 000h                             ; move toCursor variable's value into a mutable location
    mov qword ptr [rsp + 078h], 000h                             ; move toCursor variable's type into a mutable location
    ; Error handling block for to
    ; Call __error with 1 arguments
    mov rsi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 080h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 080h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$to$TypeMatch$1:                                ; after block
  mov r11, qword ptr [rbp + 050h]                                ; indirect through r11 because operand pair (stack operand #3, qword ptr [rbp + 050h]) is not allowed with mov
  mov qword ptr [rsp + 080h], r11                                ; value initialization of variable declaration for toCursor variable (to)
  mov r11, qword ptr [rbp + 048h]                                ; indirect through r11 because operand pair (stack operand #4, qword ptr [rbp + 048h]) is not allowed with mov
  mov qword ptr [rsp + 078h], r11                                ; type initialization of variable declaration for toCursor variable
  ; Line 97: Integer end = from + length / 8 * 8;
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 058h], 000h                               ; compare type of length to <sentinel>
  jne func$_moveBytes$length$TypeMatch$2                         ; skip next block if length is not sentinel
    mov qword ptr [rsp + 070h], 000h                             ; move end variable's value into a mutable location
    mov qword ptr [rsp + 068h], 000h                             ; move end variable's type into a mutable location
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$length$TypeMatch$2:                            ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov rax, qword ptr [rbp + 060h]                                ; assign value of length to value of / operator result
  cqo                                                            ; zero-extend dividend
  mov r15, 008h                                                  ; read operand of div (8) 
  idiv r15                                                       ; compute (length) / (8) (result, / operator result, is in rax)
  ; sentinel check of / operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  imul r12, rax, 008h                                            ; compute (/ operator result) * (8) (result in * operator result)
  ; sentinel check of from type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of from to <sentinel>
  jne func$_moveBytes$from$TypeMatch$2                           ; skip next block if from is not sentinel
    ; Error handling block for from
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$from$TypeMatch$2:                              ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov r10, qword ptr [rbp + 040h]                                ; assign value of from to value of + operator result
  add r10, r12                                                   ; compute (from) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 070h], r10                                ; value initialization of variable declaration for end variable (+ operator result)
  mov qword ptr [rsp + 068h], 038h                               ; type initialization of variable declaration for end variable (Integer'38)
  func$_moveBytes$while$top:                                     ; top of while
    mov rdi, qword ptr [rsp + 090h]                              ; make a copy of fromCursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 088h]                              ; make a copy of fromCursor's type in case it changes before we use it
    mov r13, qword ptr [rsp + 070h]                              ; make a copy of end's value in case it changes before we use it
    mov r14, qword ptr [rsp + 068h]                              ; make a copy of end's type in case it changes before we use it
    ; sentinel check of copy of fromCursor type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of fromCursor to <sentinel>
    jne func$_moveBytes$while$fromcursor$TypeMatch               ; skip next block if copy of fromCursor is not sentinel
      ; Error handling block for fromCursor
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 070h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 070h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_moveBytes$while$fromcursor$TypeMatch:                  ; after block
    ; sentinel check of copy of end type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of end to <sentinel>
    jne func$_moveBytes$while$end$TypeMatch                      ; skip next block if copy of end is not sentinel
      ; Error handling block for end
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_moveBytes$while$end$TypeMatch:                         ; after block
    xor rsi, rsi                                                 ; clear < operator result
    cmp rdi, r13                                                 ; compare copy of fromCursor with copy of end
    setl sil                                                     ; store result in < operator result
    cmp rsi, 000h                                                ; compare < operator result to false
    jne func$_moveBytes$while$body                               ; while condition
    jmp func$_moveBytes$while$bottom                             ; break out of while
    func$_moveBytes$while$body:                                  ; start of while
    ; Line 102: Integer value = __readFromAddress(fromCursor);
    mov rdi, qword ptr [rsp + 090h]                              ; make a copy of fromCursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 088h]                              ; make a copy of fromCursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov rax, qword ptr [rdi]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of fromCursor type Integer expecting Integer
    mov qword ptr [rsp + 060h], rax                              ; value initialization of variable declaration for value variable (dereferenced copy of fromCursor)
    mov qword ptr [rsp + 058h], 038h                             ; type initialization of variable declaration for value variable (Integer'38)
    ; Line 103: __writeToAddress(toCursor, value);
    mov rbx, qword ptr [rsp + 080h]                              ; make a copy of toCursor's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 078h]                              ; make a copy of toCursor's type in case it changes before we use it
    mov rdi, qword ptr [rsp + 060h]                              ; make a copy of value's value in case it changes before we use it
    mov r12, qword ptr [rsp + 058h]                              ; make a copy of value's type in case it changes before we use it
    ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
    ; Call __writeToAddress with 2 arguments
    mov qword ptr [rbx], rdi                                     ; __writeToAddress
    ; Line 104: fromCursor += 8;
    mov rax, qword ptr [rsp + 090h]                              ; make a copy of fromCursor's value in case it changes before we use it
    mov r15, qword ptr [rsp + 088h]                              ; make a copy of fromCursor's type in case it changes before we use it
    ; sentinel check of copy of fromCursor type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of fromCursor to <sentinel>
    jne func$_moveBytes$while$copyOfFromcursor$TypeMatch         ; skip next block if copy of fromCursor is not sentinel
      ; Error handling block for copy of fromCursor
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 090h], rax                            ; move copy of fromCursor's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 050h]                            ; restoring slot (copy of fromCursor) to previous scope state for genuine block exit
    func$_moveBytes$while$copyOfFromcursor$TypeMatch:            ; after block
    ; sentinel check of 8 type Integer expecting Integer
    mov r12, rax                                                 ; assign value of copy of fromCursor to value of += operator result
    mov r13, 008h                                                ; read second operand of add (8)
    add r12, r13                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 090h], r12                              ; store value
    mov qword ptr [rsp + 088h], 038h                             ; store type (Integer'38)
    ; Line 105: toCursor += 8;
    mov r15, qword ptr [rsp + 080h]                              ; make a copy of toCursor's value in case it changes before we use it
    mov r10, qword ptr [rsp + 078h]                              ; make a copy of toCursor's type in case it changes before we use it
    ; sentinel check of copy of toCursor type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of toCursor to <sentinel>
    jne func$_moveBytes$while$copyOfTocursor$TypeMatch           ; skip next block if copy of toCursor is not sentinel
      ; Error handling block for copy of toCursor
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 070h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 090h], r10                            ; move copy of toCursor's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 050h]                            ; restoring slot (copy of toCursor) to previous scope state for genuine block exit
    func$_moveBytes$while$copyOfTocursor$TypeMatch:              ; after block
    ; sentinel check of 8 type Integer expecting Integer
    mov r13, r15                                                 ; assign value of copy of toCursor to value of += operator result
    mov r14, 008h                                                ; read second operand of add (8)
    add r13, r14                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 080h], r13                              ; store value
    mov qword ptr [rsp + 078h], 038h                             ; store type (Integer'38)
    jmp func$_moveBytes$while$top                                ; return to top of while
  func$_moveBytes$while$bottom:                                  ; bottom of while
  ; Line 107: end = from + length;
  ; sentinel check of from type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of from to <sentinel>
  jne func$_moveBytes$from$TypeMatch$3                           ; skip next block if from is not sentinel
    ; Error handling block for from
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$from$TypeMatch$3:                              ; after block
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 058h], 000h                               ; compare type of length to <sentinel>
  jne func$_moveBytes$length$TypeMatch$3                         ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_moveBytes$length$TypeMatch$3:                            ; after block
  mov qword ptr [rsp + 060h], r12                                ; move += operator result's value out of r12
  mov r12, qword ptr [rbp + 040h]                                ; assign value of from to value of + operator result
  add r12, qword ptr [rbp + 060h]                                ; compute (from) + (length) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 070h], r12                                ; store value
  mov qword ptr [rsp + 068h], 038h                               ; store type (Integer'38)
  ; Line 109: if (fromCursor < end) { ...
  mov rax, qword ptr [rsp + 090h]                                ; make a copy of fromCursor's value in case it changes before we use it
  mov r15, qword ptr [rsp + 088h]                                ; make a copy of fromCursor's type in case it changes before we use it
  mov r10, qword ptr [rsp + 070h]                                ; make a copy of end's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 068h]                                ; make a copy of end's type in case it changes before we use it
  ; sentinel check of copy of fromCursor type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of fromCursor to <sentinel>
  jne func$_moveBytes$fromcursor$TypeMatch                       ; skip next block if copy of fromCursor is not sentinel
    ; Error handling block for fromCursor
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], r10                              ; move copy of end's value out of r10
    mov qword ptr [rsp + 078h], rax                              ; move copy of fromCursor's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 038h]                              ; restoring slot (copy of fromCursor) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 040h]                              ; restoring slot (copy of end) to previous scope state for genuine block exit
  func$_moveBytes$fromcursor$TypeMatch:                          ; after block
  ; sentinel check of copy of end type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of end to <sentinel>
  jne func$_moveBytes$end$TypeMatch                              ; skip next block if copy of end is not sentinel
    ; Error handling block for end
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 050h], r12                              ; move + operator result's value out of r12
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 078h], r10                              ; move copy of end's value out of r10
    mov qword ptr [rsp + 070h], rax                              ; move copy of fromCursor's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 030h]                              ; restoring slot (copy of fromCursor) to previous scope state for genuine block exit
    mov r12, qword ptr [rsp + 050h]                              ; restoring slot (+ operator result) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 038h]                              ; restoring slot (copy of end) to previous scope state for genuine block exit
  func$_moveBytes$end$TypeMatch:                                 ; after block
  xor r14, r14                                                   ; clear < operator result
  cmp rax, r10                                                   ; compare copy of fromCursor with copy of end
  setl r14b                                                      ; store result in < operator result
  ; sentinel check of < operator result type Boolean expecting Boolean
  cmp r14, 000h                                                  ; compare < operator result to false
  je func$_moveBytes$if$continuation                             ; fromCursor < end
    ; Line 110: Integer newValue = __readFromAddress(fromCursor);
    mov r10, qword ptr [rsp + 090h]                              ; make a copy of fromCursor's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 088h]                              ; make a copy of fromCursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov qword ptr [rsp + 040h], r12                              ; move + operator result's value out of r12
    mov r12, qword ptr [r10]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of fromCursor type Integer expecting Integer
    mov qword ptr [rsp + 050h], r12                              ; value initialization of variable declaration for newValue variable (dereferenced copy of fromCursor)
    mov qword ptr [rsp + 048h], 038h                             ; type initialization of variable declaration for newValue variable (Integer'38)
    ; Line 111: Integer oldValue = __readFromAddress(toCursor);
    mov rax, qword ptr [rsp + 080h]                              ; make a copy of toCursor's value in case it changes before we use it
    mov r15, qword ptr [rsp + 078h]                              ; make a copy of toCursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov rsi, qword ptr [rax]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of toCursor type Integer expecting Integer
    mov qword ptr [rsp + 038h], rsi                              ; value initialization of variable declaration for oldValue variable (dereferenced copy of toCursor)
    mov qword ptr [rsp + 030h], 038h                             ; type initialization of variable declaration for oldValue variable (Integer'38)
    ; Line 112: Integer extraBytes = end - fromCursor;
    mov r13, qword ptr [rsp + 070h]                              ; make a copy of end's value in case it changes before we use it
    mov r14, qword ptr [rsp + 068h]                              ; make a copy of end's type in case it changes before we use it
    mov rax, qword ptr [rsp + 090h]                              ; make a copy of fromCursor's value in case it changes before we use it
    mov r15, qword ptr [rsp + 088h]                              ; make a copy of fromCursor's type in case it changes before we use it
    ; sentinel check of copy of end type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of end to <sentinel>
    jne func$_moveBytes$Movebytes$if$end$TypeMatch               ; skip next block if copy of end is not sentinel
      mov qword ptr [rsp + 028h], 000h                           ; move extraBytes variable's value into a mutable location
      mov qword ptr [rsp + 020h], 000h                           ; move extraBytes variable's type into a mutable location
      ; Error handling block for end
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], rax                            ; move copy of fromCursor's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 008h]                            ; restoring slot (copy of fromCursor) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$end$TypeMatch:                  ; after block
    ; sentinel check of copy of fromCursor type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of fromCursor to <sentinel>
    jne func$_moveBytes$Movebytes$if$fromcursor$TypeMatch        ; skip next block if copy of fromCursor is not sentinel
      ; Error handling block for fromCursor
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], rax                            ; move copy of fromCursor's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 008h]                            ; restoring slot (copy of fromCursor) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$fromcursor$TypeMatch:           ; after block
    mov r12, r13                                                 ; assign value of copy of end to value of - operator result
    sub r12, rax                                                 ; compute (copy of end) - (copy of fromCursor)
    ; sentinel check of - operator result type Integer expecting Integer
    mov qword ptr [rsp + 028h], r12                              ; value initialization of variable declaration for extraBytes variable (- operator result)
    mov qword ptr [rsp + 020h], 038h                             ; type initialization of variable declaration for extraBytes variable (Integer'38)
    ; Line 113: assert(extraBytes > 0, 'internal error: zero extra bytes but fro...
    mov rax, qword ptr [rsp + 028h]                              ; make a copy of extraBytes's value in case it changes before we use it
    mov r15, qword ptr [rsp + 020h]                              ; make a copy of extraBytes's type in case it changes before we use it
    ; sentinel check of copy of extraBytes type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of extraBytes to <sentinel>
    jne func$_moveBytes$Movebytes$if$extrabytes$TypeMatch        ; skip next block if copy of extraBytes is not sentinel
      ; Error handling block for extraBytes
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], rax                            ; move copy of extraBytes's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 008h]                            ; restoring slot (copy of extraBytes) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$extrabytes$TypeMatch:           ; after block
    ; sentinel check of 0 type Integer expecting Integer
    xor r12, r12                                                 ; clear > operator result
    cmp rax, 000h                                                ; compare copy of extraBytes with 0
    setg r12b                                                    ; store result in > operator result
    ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
    ; Call assert with 2 arguments
    mov rax, offset string$3                                     ; reading string for push
    push rax                                                     ; value of argument #2 (string)
    push 039h                                                    ; type of argument #2 (String'39)
    push r12                                                     ; value of argument #1 (> operator result)
    push 037h                                                    ; type of argument #1 (Boolean'37)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$assert                                             ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 114: assert(extraBytes < 8, 'internal error: more than 7 extra bytes'...
    mov r10, qword ptr [rsp + 028h]                              ; make a copy of extraBytes's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 020h]                              ; make a copy of extraBytes's type in case it changes before we use it
    ; sentinel check of copy of extraBytes type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of extraBytes to <sentinel>
    jne func$_moveBytes$Movebytes$if$extrabytes$TypeMatch$1      ; skip next block if copy of extraBytes is not sentinel
      ; Error handling block for extraBytes
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], r10                            ; move copy of extraBytes's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 008h]                            ; restoring slot (copy of extraBytes) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$extrabytes$TypeMatch$1:         ; after block
    ; sentinel check of 8 type Integer expecting Integer
    xor r14, r14                                                 ; clear < operator result
    cmp r10, 008h                                                ; compare copy of extraBytes with 8
    setl r14b                                                    ; store result in < operator result
    ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
    ; Call assert with 2 arguments
    mov r10, offset string$4                                     ; reading string for push
    push r10                                                     ; value of argument #2 (string)
    push 039h                                                    ; type of argument #2 (String'39)
    push r14                                                     ; value of argument #1 (< operator result)
    push 037h                                                    ; type of argument #1 (Boolean'37)
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$assert                                             ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 115: Integer mask = -1 << extraBytes * 8;
    mov rsi, qword ptr [rsp + 028h]                              ; make a copy of extraBytes's value in case it changes before we use it
    mov rdi, qword ptr [rsp + 020h]                              ; make a copy of extraBytes's type in case it changes before we use it
    ; sentinel check of copy of extraBytes type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of extraBytes to <sentinel>
    jne func$_moveBytes$Movebytes$if$extrabytes$TypeMatch$2      ; skip next block if copy of extraBytes is not sentinel
      mov qword ptr [rsp + 028h], 000h                           ; move mask variable's value into a mutable location
      mov qword ptr [rsp + 020h], 000h                           ; move mask variable's type into a mutable location
      ; Error handling block for extraBytes
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 028h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 028h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_moveBytes$Movebytes$if$extrabytes$TypeMatch$2:         ; after block
    ; sentinel check of 8 type Integer expecting Integer
    imul r15, rsi, 008h                                          ; compute (copy of extraBytes) * (8) (result in * operator result)
    ; sentinel check of -1 type Integer expecting Integer
    ; sentinel check of * operator result type Integer expecting Integer
    mov rcx, r15                                                 ; read <DynamicSlot:Integer'38 ("* operator result")> into imm8 or cl forshl
    mov r12, -001h                                               ; assign value of -1 to value of << operator result
    shl r12, cl                                                  ; compute (-1) << (* operator result)
    ; sentinel check of << operator result type Integer expecting Integer
    mov qword ptr [rsp + 028h], r12                              ; value initialization of variable declaration for mask variable (<< operator result)
    mov qword ptr [rsp + 020h], 038h                             ; type initialization of variable declaration for mask variable (Integer'38)
    ; Line 116: Integer finalValue = newValue & ~mask | oldValue & mask;
    mov rax, qword ptr [rsp + 050h]                              ; make a copy of newValue's value in case it changes before we use it
    mov r15, qword ptr [rsp + 048h]                              ; make a copy of newValue's type in case it changes before we use it
    mov r10, qword ptr [rsp + 028h]                              ; make a copy of mask's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 020h]                              ; make a copy of mask's type in case it changes before we use it
    ; sentinel check of copy of mask type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of mask to <sentinel>
    jne func$_moveBytes$Movebytes$if$mask$TypeMatch              ; skip next block if copy of mask is not sentinel
      mov qword ptr [rsp + 050h], 000h                           ; move finalValue variable's value into a mutable location
      mov qword ptr [rsp + 048h], 000h                           ; move finalValue variable's type into a mutable location
      ; Error handling block for mask
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], r10                            ; move copy of mask's value out of r10
      mov qword ptr [rsp + 040h], rax                            ; move copy of newValue's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 000h]                            ; restoring slot (copy of newValue) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 008h]                            ; restoring slot (copy of mask) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$mask$TypeMatch:                 ; after block
    mov r12, r10                                                 ; assign value of copy of mask to value of ~ unary operator result
    not r12                                                      ; ~ unary operator
    ; sentinel check of copy of newValue type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of newValue to <sentinel>
    jne func$_moveBytes$Movebytes$if$newvalue$TypeMatch          ; skip next block if copy of newValue is not sentinel
      ; Error handling block for newValue
      ; Call __error with 1 arguments
      mov r13, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 028h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 028h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], rax                            ; move copy of newValue's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 008h]                            ; restoring slot (copy of newValue) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$newvalue$TypeMatch:             ; after block
    ; sentinel check of ~ unary operator result type Integer expecting Integer
    mov r10, rax                                                 ; assign value of copy of newValue to value of & operator result
    and r10, r12                                                 ; compute (copy of newValue) & (~ unary operator result)
    mov rbx, qword ptr [rsp + 038h]                              ; make a copy of oldValue's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 030h]                              ; make a copy of oldValue's type in case it changes before we use it
    mov rdi, qword ptr [rsp + 028h]                              ; make a copy of mask's value in case it changes before we use it
    mov r12, qword ptr [rsp + 020h]                              ; make a copy of mask's type in case it changes before we use it
    ; sentinel check of copy of oldValue type Integer expecting Integer
    cmp rsi, 000h                                                ; compare type of copy of oldValue to <sentinel>
    jne func$_moveBytes$Movebytes$if$oldvalue$TypeMatch          ; skip next block if copy of oldValue is not sentinel
      ; Error handling block for oldValue
      ; Call __error with 1 arguments
      mov r13, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 068h], r10                            ; move & operator result's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 028h]                            ; restoring slot (& operator result) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$oldvalue$TypeMatch:             ; after block
    ; sentinel check of copy of mask type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of mask to <sentinel>
    jne func$_moveBytes$Movebytes$if$mask$TypeMatch$1            ; skip next block if copy of mask is not sentinel
      ; Error handling block for mask
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 068h], r10                            ; move & operator result's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 028h]                            ; restoring slot (& operator result) to previous scope state for genuine block exit
    func$_moveBytes$Movebytes$if$mask$TypeMatch$1:               ; after block
    mov qword ptr [rsp + 038h], r10                              ; move & operator result's value out of r10
    mov r10, rbx                                                 ; assign value of copy of oldValue to value of & operator result
    and r10, rdi                                                 ; compute (copy of oldValue) & (copy of mask)
    ; sentinel check of & operator result type Integer expecting Integer
    ; sentinel check of & operator result type Integer expecting Integer
    mov r13, qword ptr [rsp + 038h]                              ; assign value of & operator result to value of | operator result
    or r13, r10                                                  ; compute (& operator result) | (& operator result)
    ; sentinel check of | operator result type Integer expecting Integer
    mov qword ptr [rsp + 050h], r13                              ; value initialization of variable declaration for finalValue variable (| operator result)
    mov qword ptr [rsp + 048h], 038h                             ; type initialization of variable declaration for finalValue variable (Integer'38)
    ; Line 117: __writeToAddress(toCursor, finalValue);
    mov r15, qword ptr [rsp + 080h]                              ; make a copy of toCursor's value in case it changes before we use it
    mov r10, qword ptr [rsp + 078h]                              ; make a copy of toCursor's type in case it changes before we use it
    mov rbx, qword ptr [rsp + 050h]                              ; make a copy of finalValue's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 048h]                              ; make a copy of finalValue's type in case it changes before we use it
    ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
    ; Call __writeToAddress with 2 arguments
    mov qword ptr [r15], rbx                                     ; __writeToAddress
    mov r12, qword ptr [rsp + 040h]                              ; restoring slot (+ operator result) to previous scope state for genuine block exit
  func$_moveBytes$if$continuation:                               ; end of if
  ; Implicit return from _moveBytes
  ; sentinel check of null type Null expecting Null
  mov rax, qword ptr [rbp + 030h]                                ; get pointer to return value of _moveBytes into register to dereference it
  mov qword ptr [rax], 000h                                      ; _moveBytes return value
  mov r15, qword ptr [rbp + 028h]                                ; get pointer to return value type of _moveBytes into register to dereference it
  mov qword ptr [r15], 036h                                      ; type of _moveBytes return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0a8h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _fillQuadWords
dq func$_fillQuadWords$annotation
func$_fillQuadWords:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 048h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 088h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of _fillQuadWords to 3 (integer)
  je func$_fillQuadWords$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$parameterCountCheck$continuation:          ; end of parameter count check
  ; Check type of parameter 0, destination (expecting Integer)
  ; type check of destination type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store destination's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that destination is Integer
  jc func$_fillQuadWords$destination$TypeMatch                   ; skip next block if the type matches
    ; Error handling block for destination
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$destination$TypeMatch:                     ; after block
  ; Check type of parameter 1, length (expecting Integer)
  ; type check of length type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store length's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that length is Integer
  jc func$_fillQuadWords$length$TypeMatch                        ; skip next block if the type matches
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$length$TypeMatch:                          ; after block
  ; Check type of parameter 2, value (expecting Integer)
  ; type check of value type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store value's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that value is Integer
  jc func$_fillQuadWords$value$TypeMatch                         ; skip next block if the type matches
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$value$TypeMatch:                           ; after block
  ; Line 124: assert(length > 0, '_fillQuadWords expects positive number of by...
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 048h], 000h                               ; compare type of length to <sentinel>
  jne func$_fillQuadWords$length$TypeMatch$1                     ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$length$TypeMatch$1:                        ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor rax, rax                                                   ; clear > operator result
  cmp qword ptr [rbp + 050h], 000h                               ; compare length with 0
  setg al                                                        ; store result in > operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r14, offset string$5                                       ; reading string for push
  push r14                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rax                                                       ; value of argument #1 (> operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r15, qword ptr [rsp + 050h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 050h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 125: assert(length % 8 == 0, '_fillQuadWords expects number of bytes ...
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 048h], 000h                               ; compare type of length to <sentinel>
  jne func$_fillQuadWords$length$TypeMatch$2                     ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$length$TypeMatch$2:                        ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov rax, qword ptr [rbp + 050h]                                ; put lhs of rdx division (<ParameterSlot:Integer'38 ("length")>) in rax
  cqo                                                            ; zero-extend dividend (rax into rdx:rax)
  mov r12, 008h                                                  ; read visible operand of div (<ImmediateIntegerSlot:Integer'38 ("8")>) 
  idiv r12                                                       ; compute (length) % (8) (result, % operator result, ends up in rdx)
  xor r13, r13                                                   ; zero value result of == (testing % operator result and 0) to put the boolean in
  cmp rdx, 000h                                                  ; values equal?
  sete r13b                                                      ; put result in value result of == (testing % operator result and 0)
  mov r14, 037h                                                  ; value result of == (testing % operator result and 0) is a Boolean'37
  xor r15, r15                                                   ; zero type result of == (testing % operator result and 0) to put the boolean in
  mov r10, 038h                                                  ; reading type of % operator result for comparison with type of 0
  cmp r10, 038h                                                  ; types equal?
  sete r15b                                                      ; put result in type result of == (testing % operator result and 0)
  mov rbx, 037h                                                  ; type result of == (testing % operator result and 0) is a Boolean'37
  mov rsi, r13                                                   ; assign value of value result of == (testing % operator result and 0) to value of == operator result
  and rsi, r15                                                   ; && type temp and value temp
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rax, offset string$6                                       ; reading string for push
  push rax                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rsi                                                       ; value of argument #1 (== operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r12, qword ptr [rsp + 050h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 050h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 126: Integer cursor = destination;
  ; sentinel check of destination type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of destination to <sentinel>
  jne func$_fillQuadWords$destination$TypeMatch$1                ; skip next block if destination is not sentinel
    mov qword ptr [rsp + 030h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 028h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for destination
    ; Call __error with 1 arguments
    mov r13, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$destination$TypeMatch$1:                   ; after block
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (stack operand #1, qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rsp + 030h], r11                                ; value initialization of variable declaration for cursor variable (destination)
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (stack operand #2, qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rsp + 028h], r11                                ; type initialization of variable declaration for cursor variable
  ; Line 127: Integer end = destination + length;
  ; sentinel check of destination type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of destination to <sentinel>
  jne func$_fillQuadWords$destination$TypeMatch$2                ; skip next block if destination is not sentinel
    mov qword ptr [rsp + 020h], 000h                             ; move end variable's value into a mutable location
    mov qword ptr [rsp + 018h], 000h                             ; move end variable's type into a mutable location
    ; Error handling block for destination
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$destination$TypeMatch$2:                   ; after block
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 048h], 000h                               ; compare type of length to <sentinel>
  jne func$_fillQuadWords$length$TypeMatch$3                     ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_fillQuadWords$length$TypeMatch$3:                        ; after block
  mov rdi, qword ptr [rbp + 040h]                                ; assign value of destination to value of + operator result
  add rdi, qword ptr [rbp + 050h]                                ; compute (destination) + (length) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 020h], rdi                                ; value initialization of variable declaration for end variable (+ operator result)
  mov qword ptr [rsp + 018h], 038h                               ; type initialization of variable declaration for end variable (Integer'38)
  func$_fillQuadWords$while$top:                                 ; top of while
    mov r13, qword ptr [rsp + 030h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r14, qword ptr [rsp + 028h]                              ; make a copy of cursor's type in case it changes before we use it
    mov r15, qword ptr [rsp + 020h]                              ; make a copy of end's value in case it changes before we use it
    mov r10, qword ptr [rsp + 018h]                              ; make a copy of end's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_fillQuadWords$while$cursor$TypeMatch               ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of end's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of end) to previous scope state for genuine block exit
    func$_fillQuadWords$while$cursor$TypeMatch:                  ; after block
    ; sentinel check of copy of end type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of end to <sentinel>
    jne func$_fillQuadWords$while$end$TypeMatch                  ; skip next block if copy of end is not sentinel
      ; Error handling block for end
      ; Call __error with 1 arguments
      mov rdi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of end's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of end) to previous scope state for genuine block exit
    func$_fillQuadWords$while$end$TypeMatch:                     ; after block
    xor r12, r12                                                 ; clear < operator result
    cmp r13, r15                                                 ; compare copy of cursor with copy of end
    setl r12b                                                    ; store result in < operator result
    cmp r12, 000h                                                ; compare < operator result to false
    jne func$_fillQuadWords$while$body                           ; while condition
    jmp func$_fillQuadWords$while$bottom                         ; break out of while
    func$_fillQuadWords$while$body:                              ; start of while
    ; Line 129: __writeToAddress(cursor, value);
    mov r13, qword ptr [rsp + 030h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r14, qword ptr [rsp + 028h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
    ; Call __writeToAddress with 2 arguments
    mov rbx, qword ptr [rbp + 060h]                              ; read second operand of mov (value) for MoveToDerefInstruction
    mov qword ptr [r13], rbx                                     ; __writeToAddress
    ; Line 130: cursor += 8;
    mov rsi, qword ptr [rsp + 030h]                              ; make a copy of cursor's value in case it changes before we use it
    mov rdi, qword ptr [rsp + 028h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_fillQuadWords$while$copyOfCursor$TypeMatch         ; skip next block if copy of cursor is not sentinel
      ; Error handling block for copy of cursor
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 020h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 020h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_fillQuadWords$while$copyOfCursor$TypeMatch:            ; after block
    ; sentinel check of 8 type Integer expecting Integer
    mov r15, rsi                                                 ; assign value of copy of cursor to value of += operator result
    mov r10, 008h                                                ; read second operand of add (8)
    add r15, r10                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 030h], r15                              ; store value
    mov qword ptr [rsp + 028h], 038h                             ; store type (Integer'38)
    jmp func$_fillQuadWords$while$top                            ; return to top of while
  func$_fillQuadWords$while$bottom:                              ; bottom of while
  ; Implicit return from _fillQuadWords
  ; sentinel check of null type Null expecting Null
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of _fillQuadWords into register to dereference it
  mov qword ptr [r12], 000h                                      ; _fillQuadWords return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of _fillQuadWords into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of _fillQuadWords return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 048h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _stringByteLength
dq func$_stringByteLength$annotation
func$_stringByteLength:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _stringByteLength to 1 (integer)
  je func$_stringByteLength$parameterCountCheck$continuation     ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_stringByteLength$parameterCountCheck$continuation:       ; end of parameter count check
  ; Check type of parameter 0, data (expecting String)
  ; type check of data type String expecting String
  mov rbx, qword ptr [rbp + 038h]                                ; store data's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that data is String
  jc func$_stringByteLength$data$TypeMatch                       ; skip next block if the type matches
    ; Error handling block for data
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_stringByteLength$data$TypeMatch:                         ; after block
  ; Line 140: Integer pointer = data __as__ Integer;
  mov r14, qword ptr [rbp + 040h]                                ; force cast of data to Integer
  ; sentinel check of force cast of data to Integer type Integer expecting Integer
  mov qword ptr [rsp + 018h], r14                                ; value initialization of variable declaration for pointer variable (force cast of data to Integer)
  mov qword ptr [rsp + 010h], 038h                               ; type initialization of variable declaration for pointer variable (Integer'38)
  ; Line 141: return __readFromAddress(pointer + 8);
  mov rbx, qword ptr [rsp + 018h]                                ; make a copy of pointer's value in case it changes before we use it
  mov rax, qword ptr [rsp + 010h]                                ; make a copy of pointer's type in case it changes before we use it
  ; sentinel check of copy of pointer type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of pointer to <sentinel>
  jne func$_stringByteLength$pointer$TypeMatch                   ; skip next block if copy of pointer is not sentinel
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], rax                              ; move copy of pointer's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 008h]                              ; restoring slot (copy of pointer) to previous scope state for genuine block exit
  func$_stringByteLength$pointer$TypeMatch:                      ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov r14, rbx                                                   ; assign value of copy of pointer to value of + operator result
  add r14, 008h                                                  ; compute (copy of pointer) + (8) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rbx, qword ptr [r14]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of _stringByteLength into register to dereference it
  mov qword ptr [rdi], rbx                                       ; _stringByteLength return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of _stringByteLength into register to dereference it
  mov qword ptr [r12], 038h                                      ; type of _stringByteLength return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; digitToStr
dq func$digitToStr$annotation
func$digitToStr:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of digitToStr to 1 (integer)
  je func$digitToStr$parameterCountCheck$continuation            ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$digitToStr$parameterCountCheck$continuation:              ; end of parameter count check
  ; Check type of parameter 0, digit (expecting Integer)
  ; type check of digit type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store digit's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that digit is Integer
  jc func$digitToStr$digit$TypeMatch                             ; skip next block if the type matches
    ; Error handling block for digit
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$digitToStr$digit$TypeMatch:                               ; after block
  ; Line 145: if (digit == 0) { ...
  xor r14, r14                                                   ; zero value result of == (testing digit and 0) to put the boolean in
  cmp qword ptr [rbp + 040h], 000h                               ; values equal?
  sete r14b                                                      ; put result in value result of == (testing digit and 0)
  mov r15, 037h                                                  ; value result of == (testing digit and 0) is a Boolean'37
  xor r10, r10                                                   ; zero type result of == (testing digit and 0) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r10b                                                      ; put result in type result of == (testing digit and 0)
  mov rbx, 037h                                                  ; type result of == (testing digit and 0) is a Boolean'37
  mov rax, r14                                                   ; assign value of value result of == (testing digit and 0) to value of == operator result
  and rax, r10                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rax, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation                             ; digit == 0
    ; Line 146: return '0';
    ; sentinel check of string type String expecting String
    mov r14, offset string$7                                     ; read second operand of mov (string) for MoveToDerefInstruction
    mov r15, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r15], r14                                     ; digitToStr return value
    mov r10, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r10], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation:                               ; end of if
  ; Line 148: if (digit == 1) { ...
  xor rbx, rbx                                                   ; zero value result of == (testing digit and 1) to put the boolean in
  cmp qword ptr [rbp + 040h], 001h                               ; values equal?
  sete bl                                                        ; put result in value result of == (testing digit and 1)
  mov rax, 037h                                                  ; value result of == (testing digit and 1) is a Boolean'37
  xor rsi, rsi                                                   ; zero type result of == (testing digit and 1) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete sil                                                       ; put result in type result of == (testing digit and 1)
  mov rdi, 037h                                                  ; type result of == (testing digit and 1) is a Boolean'37
  mov r12, rbx                                                   ; assign value of value result of == (testing digit and 1) to value of == operator result
  and r12, rsi                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r12, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$1                           ; digit == 1
    ; Line 149: return '1';
    ; sentinel check of string type String expecting String
    mov r10, offset string$8                                     ; read second operand of mov (string) for MoveToDerefInstruction
    mov rbx, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [rbx], r10                                     ; digitToStr return value
    mov rax, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [rax], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$1:                             ; end of if
  ; Line 151: if (digit == 2) { ...
  xor rsi, rsi                                                   ; zero value result of == (testing digit and 2) to put the boolean in
  cmp qword ptr [rbp + 040h], 002h                               ; values equal?
  sete sil                                                       ; put result in value result of == (testing digit and 2)
  mov rdi, 037h                                                  ; value result of == (testing digit and 2) is a Boolean'37
  xor r12, r12                                                   ; zero type result of == (testing digit and 2) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r12b                                                      ; put result in type result of == (testing digit and 2)
  mov r13, 037h                                                  ; type result of == (testing digit and 2) is a Boolean'37
  mov r14, rsi                                                   ; assign value of value result of == (testing digit and 2) to value of == operator result
  and r14, r12                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r14, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$2                           ; digit == 2
    ; Line 152: return '2';
    ; sentinel check of string type String expecting String
    mov rax, offset string$9                                     ; read second operand of mov (string) for MoveToDerefInstruction
    mov rsi, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [rsi], rax                                     ; digitToStr return value
    mov rdi, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [rdi], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$2:                             ; end of if
  ; Line 154: if (digit == 3) { ...
  xor r12, r12                                                   ; zero value result of == (testing digit and 3) to put the boolean in
  cmp qword ptr [rbp + 040h], 003h                               ; values equal?
  sete r12b                                                      ; put result in value result of == (testing digit and 3)
  mov r13, 037h                                                  ; value result of == (testing digit and 3) is a Boolean'37
  xor r14, r14                                                   ; zero type result of == (testing digit and 3) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r14b                                                      ; put result in type result of == (testing digit and 3)
  mov r15, 037h                                                  ; type result of == (testing digit and 3) is a Boolean'37
  mov r10, r12                                                   ; assign value of value result of == (testing digit and 3) to value of == operator result
  and r10, r14                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r10, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$3                           ; digit == 3
    ; Line 155: return '3';
    ; sentinel check of string type String expecting String
    mov rdi, offset string$10                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r12, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r12], rdi                                     ; digitToStr return value
    mov r13, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r13], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$3:                             ; end of if
  ; Line 157: if (digit == 4) { ...
  xor r14, r14                                                   ; zero value result of == (testing digit and 4) to put the boolean in
  cmp qword ptr [rbp + 040h], 004h                               ; values equal?
  sete r14b                                                      ; put result in value result of == (testing digit and 4)
  mov r15, 037h                                                  ; value result of == (testing digit and 4) is a Boolean'37
  xor r10, r10                                                   ; zero type result of == (testing digit and 4) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r10b                                                      ; put result in type result of == (testing digit and 4)
  mov rbx, 037h                                                  ; type result of == (testing digit and 4) is a Boolean'37
  mov rax, r14                                                   ; assign value of value result of == (testing digit and 4) to value of == operator result
  and rax, r10                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rax, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$4                           ; digit == 4
    ; Line 158: return '4';
    ; sentinel check of string type String expecting String
    mov r13, offset string$11                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r14, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r14], r13                                     ; digitToStr return value
    mov r15, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r15], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$4:                             ; end of if
  ; Line 160: if (digit == 5) { ...
  xor r10, r10                                                   ; zero value result of == (testing digit and 5) to put the boolean in
  cmp qword ptr [rbp + 040h], 005h                               ; values equal?
  sete r10b                                                      ; put result in value result of == (testing digit and 5)
  mov rbx, 037h                                                  ; value result of == (testing digit and 5) is a Boolean'37
  xor rax, rax                                                   ; zero type result of == (testing digit and 5) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete al                                                        ; put result in type result of == (testing digit and 5)
  mov rsi, 037h                                                  ; type result of == (testing digit and 5) is a Boolean'37
  mov rdi, r10                                                   ; assign value of value result of == (testing digit and 5) to value of == operator result
  and rdi, rax                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rdi, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$5                           ; digit == 5
    ; Line 161: return '5';
    ; sentinel check of string type String expecting String
    mov r15, offset string$12                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r10, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r10], r15                                     ; digitToStr return value
    mov rbx, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [rbx], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$5:                             ; end of if
  ; Line 163: if (digit == 6) { ...
  xor rax, rax                                                   ; zero value result of == (testing digit and 6) to put the boolean in
  cmp qword ptr [rbp + 040h], 006h                               ; values equal?
  sete al                                                        ; put result in value result of == (testing digit and 6)
  mov rsi, 037h                                                  ; value result of == (testing digit and 6) is a Boolean'37
  xor rdi, rdi                                                   ; zero type result of == (testing digit and 6) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete dil                                                       ; put result in type result of == (testing digit and 6)
  mov r12, 037h                                                  ; type result of == (testing digit and 6) is a Boolean'37
  mov r13, rax                                                   ; assign value of value result of == (testing digit and 6) to value of == operator result
  and r13, rdi                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r13, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$6                           ; digit == 6
    ; Line 164: return '6';
    ; sentinel check of string type String expecting String
    mov rbx, offset string$13                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov rax, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [rax], rbx                                     ; digitToStr return value
    mov rsi, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [rsi], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$6:                             ; end of if
  ; Line 166: if (digit == 7) { ...
  xor rdi, rdi                                                   ; zero value result of == (testing digit and 7) to put the boolean in
  cmp qword ptr [rbp + 040h], 007h                               ; values equal?
  sete dil                                                       ; put result in value result of == (testing digit and 7)
  mov r12, 037h                                                  ; value result of == (testing digit and 7) is a Boolean'37
  xor r13, r13                                                   ; zero type result of == (testing digit and 7) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r13b                                                      ; put result in type result of == (testing digit and 7)
  mov r14, 037h                                                  ; type result of == (testing digit and 7) is a Boolean'37
  mov r15, rdi                                                   ; assign value of value result of == (testing digit and 7) to value of == operator result
  and r15, r13                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r15, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$7                           ; digit == 7
    ; Line 167: return '7';
    ; sentinel check of string type String expecting String
    mov rsi, offset string$14                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov rdi, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [rdi], rsi                                     ; digitToStr return value
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r12], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$7:                             ; end of if
  ; Line 169: if (digit == 8) { ...
  xor r13, r13                                                   ; zero value result of == (testing digit and 8) to put the boolean in
  cmp qword ptr [rbp + 040h], 008h                               ; values equal?
  sete r13b                                                      ; put result in value result of == (testing digit and 8)
  mov r14, 037h                                                  ; value result of == (testing digit and 8) is a Boolean'37
  xor r15, r15                                                   ; zero type result of == (testing digit and 8) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r15b                                                      ; put result in type result of == (testing digit and 8)
  mov r10, 037h                                                  ; type result of == (testing digit and 8) is a Boolean'37
  mov rbx, r13                                                   ; assign value of value result of == (testing digit and 8) to value of == operator result
  and rbx, r15                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$8                           ; digit == 8
    ; Line 170: return '8';
    ; sentinel check of string type String expecting String
    mov r12, offset string$15                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r13, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r13], r12                                     ; digitToStr return value
    mov r14, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r14], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$8:                             ; end of if
  ; Line 172: if (digit == 9) { ...
  xor r15, r15                                                   ; zero value result of == (testing digit and 9) to put the boolean in
  cmp qword ptr [rbp + 040h], 009h                               ; values equal?
  sete r15b                                                      ; put result in value result of == (testing digit and 9)
  mov r10, 037h                                                  ; value result of == (testing digit and 9) is a Boolean'37
  xor rbx, rbx                                                   ; zero type result of == (testing digit and 9) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete bl                                                        ; put result in type result of == (testing digit and 9)
  mov rax, 037h                                                  ; type result of == (testing digit and 9) is a Boolean'37
  mov rsi, r15                                                   ; assign value of value result of == (testing digit and 9) to value of == operator result
  and rsi, rbx                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rsi, 000h                                                  ; compare == operator result to false
  je func$digitToStr$if$continuation$9                           ; digit == 9
    ; Line 173: return '9';
    ; sentinel check of string type String expecting String
    mov r14, offset string$16                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r15, qword ptr [rbp + 030h]                              ; get pointer to return value of digitToStr into register to dereference it
    mov qword ptr [r15], r14                                     ; digitToStr return value
    mov r10, qword ptr [rbp + 028h]                              ; get pointer to return value type of digitToStr into register to dereference it
    mov qword ptr [r10], 039h                                    ; type of digitToStr return value (String'39)
    jmp func$digitToStr$epilog                                   ; return
  func$digitToStr$if$continuation$9:                             ; end of if
  ; Line 175: stderr('Invalid digit passed to digitToStr (digit as exit code)\...
  mov rbx, qword ptr stderrValue                                 ; make a copy of stderr's value in case it changes before we use it
  mov rax, qword ptr stderrType                                  ; make a copy of stderr's type in case it changes before we use it
  ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
  cmp rax, 000h                                                  ; compare type of copy of stderr to <sentinel>
  jne func$digitToStr$copyOfStderr$TypeMatch                     ; skip next block if copy of stderr is not sentinel
    ; Error handling block for copy of stderr
    ; Call __error with 1 arguments
    mov rsi, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], rax                              ; move copy of stderr's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of stderr) to previous scope state for genuine block exit
  func$digitToStr$copyOfStderr$TypeMatch:                        ; after block
  ; Call copy of stderr with 1 arguments
  mov r12, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov r13, qword ptr [rbx + 020h]                                ; read receiver type
  mov r14, offset string$17                                      ; reading string for push
  push r14                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r15, qword ptr [rsp + 020h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r12                                                    ; internal argument 4: "this" pointer
  mov r8, r13                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 040h], rax                                ; move copy of stderr's type out of rax
  call qword ptr [rbx + 038h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 176: exit(digit);
  ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
  ; Call exit with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (digit)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rax, qword ptr [rsp + 020h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 020h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from digitToStr
  ; type check of null type Null expecting String
  mov rsi, 036h                                                  ; store null's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that digitToStr return value is String
  jc func$digitToStr$digittostrReturnValue$TypeMatch             ; skip next block if the type matches
    ; Error handling block for digitToStr return value
    ; Call __error with 1 arguments
    mov r13, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$digitToStr$digittostrReturnValue$TypeMatch:               ; after block
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of digitToStr into register to dereference it
  mov qword ptr [r15], 000h                                      ; digitToStr return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of digitToStr into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of digitToStr return value (Null'36)
  func$digitToStr$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; intToStr
dq func$intToStr$annotation
func$intToStr:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 098h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0d8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of intToStr to 1 (integer)
  je func$intToStr$parameterCountCheck$continuation              ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$intToStr$parameterCountCheck$continuation:                ; end of parameter count check
  ; Check type of parameter 0, value (expecting Integer)
  ; type check of value type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store value's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that value is Integer
  jc func$intToStr$value$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 098h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 098h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$intToStr$value$TypeMatch:                                 ; after block
  ; Line 180: if (value == 0) { ...
  xor r14, r14                                                   ; zero value result of == (testing value and 0) to put the boolean in
  cmp qword ptr [rbp + 040h], 000h                               ; values equal?
  sete r14b                                                      ; put result in value result of == (testing value and 0)
  mov r15, 037h                                                  ; value result of == (testing value and 0) is a Boolean'37
  xor r10, r10                                                   ; zero type result of == (testing value and 0) to put the boolean in
  cmp qword ptr [rbp + 038h], 038h                               ; types equal?
  sete r10b                                                      ; put result in type result of == (testing value and 0)
  mov rbx, 037h                                                  ; type result of == (testing value and 0) is a Boolean'37
  mov rax, r14                                                   ; assign value of value result of == (testing value and 0) to value of == operator result
  and rax, r10                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rax, 000h                                                  ; compare == operator result to false
  je func$intToStr$if$continuation                               ; value == 0
    ; Line 181: return '0';
    ; sentinel check of string type String expecting String
    mov r14, offset string$7                                     ; read second operand of mov (string) for MoveToDerefInstruction
    mov r15, qword ptr [rbp + 030h]                              ; get pointer to return value of intToStr into register to dereference it
    mov qword ptr [r15], r14                                     ; intToStr return value
    mov r10, qword ptr [rbp + 028h]                              ; get pointer to return value type of intToStr into register to dereference it
    mov qword ptr [r10], 039h                                    ; type of intToStr return value (String'39)
    jmp func$intToStr$epilog                                     ; return
  func$intToStr$if$continuation:                                 ; end of if
  ; Line 183: if (value < 0) { ...
  ; sentinel check of value type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of value to <sentinel>
  jne func$intToStr$value$TypeMatch$1                            ; skip next block if value is not sentinel
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$intToStr$value$TypeMatch$1:                               ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r12, r12                                                   ; clear < operator result
  cmp qword ptr [rbp + 040h], 000h                               ; compare value with 0
  setl r12b                                                      ; store result in < operator result
  ; sentinel check of < operator result type Boolean expecting Boolean
  cmp r12, 000h                                                  ; compare < operator result to false
  je func$intToStr$if$continuation$1                             ; value < 0
    ; Line 184: return concat('-', intToStr(-value));
    mov r15, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov r10, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    ; sentinel check of value type Integer expecting Integer
    cmp qword ptr [rbp + 038h], 000h                             ; compare type of value to <sentinel>
    jne func$intToStr$inttostr$if$1$value$TypeMatch              ; skip next block if value is not sentinel
      ; Error handling block for value
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 098h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 098h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0b8h], r10                            ; move copy of concat's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 078h]                            ; restoring slot (copy of concat) to previous scope state for genuine block exit
    func$intToStr$inttostr$if$1$value$TypeMatch:                 ; after block
    mov rsi, qword ptr [rbp + 040h]                              ; assign value of value to value of - unary operator result
    neg rsi                                                      ; - unary operator
    ; sentinel check of intToStr type StringFunction(Integer) expecting AnythingFunction
    ; Call intToStr with 1 arguments
    push rsi                                                     ; value of argument #1 (- unary operator result)
    push 038h                                                    ; type of argument #1 (Integer'38)
    lea r13, qword ptr [rsp + 098h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 098h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0b8h], r10                              ; move copy of concat's type out of r10
    call func$intToStr                                           ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp qword ptr [rsp + 078h], 000h                             ; compare type of copy of concat to <sentinel>
    jne func$intToStr$inttostr$if$1$copyOfConcat$TypeMatch       ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 078h], r15                            ; move copy of concat's value out of r15
      lea r15, qword ptr [rsp + 080h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 078h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r15, qword ptr [rsp + 068h]                            ; restoring slot (copy of concat) to previous scope state for genuine block exit
    func$intToStr$inttostr$if$1$copyOfConcat$TypeMatch:          ; after block
    ; Call copy of concat with 2 arguments
    mov r10, qword ptr [r15 + 028h]                              ; read receiver pointer
    mov rbx, qword ptr [r15 + 020h]                              ; read receiver type
    push qword ptr [rsp + 088h]                                  ; value of argument #2 (intToStr return value)
    push qword ptr [rsp + 088h]                                  ; type of argument #2
    mov rax, offset string$18                                    ; reading string for push
    push rax                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 090h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 090h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r10                                                  ; internal argument 4: "this" pointer
    mov r8, rbx                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call qword ptr [r15 + 038h]                                  ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat return value type String expecting String
    cmp qword ptr [rsp + 068h], 000h                             ; compare type of copy of concat return value to <sentinel>
    jne func$intToStr$inttostr$if$1$inttostrReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
      ; Error handling block for intToStr return value
      ; Call __error with 1 arguments
      mov rdi, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 088h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 078h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$intToStr$inttostr$if$1$inttostrReturnValue$TypeMatch:   ; after block
    mov r13, qword ptr [rsp + 070h]                              ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
    mov r14, qword ptr [rbp + 030h]                              ; get pointer to return value of intToStr into register to dereference it
    mov qword ptr [r14], r13                                     ; intToStr return value
    mov r15, qword ptr [rsp + 068h]                              ; reading type of copy of concat return value
    mov r10, qword ptr [rbp + 028h]                              ; get pointer to return value type of intToStr into register to dereference it
    mov qword ptr [r10], r15                                     ; type of intToStr return value
    ; increment reference count for copy of concat return value if necessary
    cmp r15, 039h                                                ; compare type of copy of concat return value to String
    jne func$intToStr$inttostr$if$1$AfterStringIncref            ; if not a String, skip incref
      mov rbx, qword ptr [r13]                                   ; dereference string to get to reference count
      cmp rbx, 0                                                 ; compare string reference count to 0
      jns func$intToStr$inttostr$if$1$StringIncref               ; if reference count is negative (constant strings), skip incref
      jmp func$intToStr$inttostr$if$1$AfterStringIncref          ; skip incref for string constants
      func$intToStr$inttostr$if$1$StringIncref:                  ; real String
        inc qword ptr [r13]                                      ; increment reference count of copy of concat return value
    func$intToStr$inttostr$if$1$AfterStringIncref:               ; after String incref
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r15                                                 ; arg #2: copy of concat return value's type
    mov rcx, r13                                                 ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for intToStr return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0a0h]                              ; arg #2: intToStr return value's type
    mov rcx, qword ptr [rsp + 0a8h]                              ; arg #1: intToStr return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$intToStr$epilog                                     ; return
  func$intToStr$if$continuation$1:                               ; end of if
  ; Line 186: String buffer = '';
  ; sentinel check of string type String expecting String
  mov r11, offset string$19                                      ; indirect through r11 because operand pair (stack operand #3, offset string$19) is not allowed with mov
  mov qword ptr [rsp + 078h], r11                                ; value initialization of variable declaration for buffer variable (string)
  mov qword ptr [rsp + 070h], 039h                               ; type initialization of variable declaration for buffer variable (String'39)
  ; increment reference count for buffer variable if necessary
  cmp qword ptr [rsp + 070h], 039h                               ; compare type of buffer variable to String
  jne func$intToStr$AfterStringIncref                            ; if not a String, skip incref
    mov rdi, qword ptr [rsp + 078h]                              ; get buffer variable into register to dereference it
    mov r12, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r12, 0                                                   ; compare string reference count to 0
    jns func$intToStr$StringIncref                               ; if reference count is negative (constant strings), skip incref
    mov qword ptr [rsp + 078h], rdi                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$intToStr$AfterStringIncref                          ; skip incref for string constants
    func$intToStr$StringIncref:                                  ; real String
      inc qword ptr [rdi]                                        ; increment reference count of buffer variable
    mov qword ptr [rsp + 078h], rdi                              ; restoring slot (buffer variable) to previous scope state for genuine block exit
  func$intToStr$AfterStringIncref:                               ; after String incref
  ; Line 187: Integer newValue = value;
  ; sentinel check of value type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of value to <sentinel>
  jne func$intToStr$value$TypeMatch$2                            ; skip next block if value is not sentinel
    mov qword ptr [rsp + 068h], 000h                             ; move newValue variable's value into a mutable location
    mov qword ptr [rsp + 060h], 000h                             ; move newValue variable's type into a mutable location
    ; Error handling block for value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 058h], r13                              ; move copy of concat return value's value out of r13
    mov r13, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$intToStr$value$TypeMatch$2:                               ; after block
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (stack operand #5, qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rsp + 068h], r11                                ; value initialization of variable declaration for newValue variable (value)
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (stack operand #6, qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rsp + 060h], r11                                ; type initialization of variable declaration for newValue variable
  func$intToStr$while$top:                                       ; top of while
    mov qword ptr [rsp + 050h], r15                              ; move copy of concat return value's type out of r15
    mov r15, qword ptr [rsp + 068h]                              ; make a copy of newValue's value in case it changes before we use it
    mov r10, qword ptr [rsp + 060h]                              ; make a copy of newValue's type in case it changes before we use it
    ; sentinel check of copy of newValue type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of newValue to <sentinel>
    jne func$intToStr$while$newvalue$TypeMatch                   ; skip next block if copy of newValue is not sentinel
      ; Error handling block for newValue
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 058h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 058h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 078h], r10                            ; move copy of newValue's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 038h]                            ; restoring slot (copy of newValue) to previous scope state for genuine block exit
    func$intToStr$while$newvalue$TypeMatch:                      ; after block
    ; sentinel check of 0 type Integer expecting Integer
    xor r12, r12                                                 ; clear > operator result
    cmp r15, 000h                                                ; compare copy of newValue with 0
    setg r12b                                                    ; store result in > operator result
    cmp r12, 000h                                                ; compare > operator result to false
    jne func$intToStr$while$body                                 ; while condition
    jmp func$intToStr$while$bottom                               ; break out of while
    func$intToStr$while$body:                                    ; start of while
    ; Line 189: Integer digit = newValue % 10 /* 0xa */;
    mov r13, qword ptr [rsp + 068h]                              ; make a copy of newValue's value in case it changes before we use it
    mov r14, qword ptr [rsp + 060h]                              ; make a copy of newValue's type in case it changes before we use it
    ; sentinel check of copy of newValue type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of newValue to <sentinel>
    jne func$intToStr$while$newvalue$TypeMatch$1                 ; skip next block if copy of newValue is not sentinel
      mov qword ptr [rsp + 048h], 000h                           ; move digit variable's value into a mutable location
      mov qword ptr [rsp + 040h], 000h                           ; move digit variable's type into a mutable location
      ; Error handling block for newValue
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$intToStr$while$newvalue$TypeMatch$1:                    ; after block
    ; sentinel check of 10 /* 0xa */ type Integer expecting Integer
    mov rax, r13                                                 ; put lhs of rdx division (<DynamicSlot:Integer'38 ("copy of newValue")>) in rax
    cqo                                                          ; zero-extend dividend (rax into rdx:rax)
    mov rsi, 00ah                                                ; read visible operand of div (<ImmediateIntegerSlot:Integer'38 ("10 /* 0xa */")>) 
    idiv rsi                                                     ; compute (copy of newValue) % (10 /* 0xa */) (result, % operator result, ends up in rdx)
    ; sentinel check of % operator result type Integer expecting Integer
    mov qword ptr [rsp + 048h], rdx                              ; value initialization of variable declaration for digit variable (% operator result)
    mov qword ptr [rsp + 040h], 038h                             ; type initialization of variable declaration for digit variable (Integer'38)
    ; Line 190: newValue = newValue / 10 /* 0xa */;
    mov r13, qword ptr [rsp + 068h]                              ; make a copy of newValue's value in case it changes before we use it
    mov r14, qword ptr [rsp + 060h]                              ; make a copy of newValue's type in case it changes before we use it
    ; sentinel check of copy of newValue type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of newValue to <sentinel>
    jne func$intToStr$while$newvalue$TypeMatch$2                 ; skip next block if copy of newValue is not sentinel
      ; Error handling block for newValue
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$intToStr$while$newvalue$TypeMatch$2:                    ; after block
    ; sentinel check of 10 /* 0xa */ type Integer expecting Integer
    mov rax, r13                                                 ; assign value of copy of newValue to value of / operator result
    cqo                                                          ; zero-extend dividend
    mov rsi, 00ah                                                ; read operand of div (10 /* 0xa */) 
    idiv rsi                                                     ; compute (copy of newValue) / (10 /* 0xa */) (result, / operator result, is in rax)
    ; sentinel check of / operator result type Integer expecting Integer
    mov qword ptr [rsp + 068h], rax                              ; store value
    mov qword ptr [rsp + 060h], 038h                             ; store type (Integer'38)
    ; Line 191: buffer = concat(digitToStr(digit), buffer);
    mov r13, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov r14, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    mov r15, qword ptr [rsp + 048h]                              ; make a copy of digit's value in case it changes before we use it
    mov r10, qword ptr [rsp + 040h]                              ; make a copy of digit's type in case it changes before we use it
    ; sentinel check of digitToStr type StringFunction(Integer) expecting AnythingFunction
    ; Call digitToStr with 1 arguments
    push r15                                                     ; value of argument #1 (copy of digit)
    push r10                                                     ; type of argument #1
    lea rsi, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], rax                              ; move / operator result's value out of rax
    call func$digitToStr                                         ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rdi, qword ptr [rsp + 078h]                              ; make a copy of buffer's value in case it changes before we use it
    mov r12, qword ptr [rsp + 070h]                              ; make a copy of buffer's type in case it changes before we use it
    ; increment reference count for copy of buffer if necessary
    cmp r12, 039h                                                ; compare type of copy of buffer to String
    jne func$intToStr$while$AfterStringIncref                    ; if not a String, skip incref
      mov qword ptr [rsp + 020h], r13                            ; move copy of concat's value out of r13
      mov r13, qword ptr [rdi]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$intToStr$while$StringIncref                       ; if reference count is negative (constant strings), skip incref
      mov r13, qword ptr [rsp + 020h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$intToStr$while$AfterStringIncref                  ; skip incref for string constants
      func$intToStr$while$StringIncref:                          ; real String
        inc qword ptr [rdi]                                      ; increment reference count of copy of buffer
      mov r13, qword ptr [rsp + 020h]                            ; restoring slot (copy of concat) to previous scope state for genuine block exit
    func$intToStr$while$AfterStringIncref:                       ; after String incref
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp r14, 000h                                                ; compare type of copy of concat to <sentinel>
    jne func$intToStr$while$copyOfConcat$TypeMatch               ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 020h], r14                            ; move copy of concat's type out of r14
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 028h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 028h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r14, qword ptr [rsp + 020h]                            ; restoring slot (copy of concat) to previous scope state for genuine block exit
    func$intToStr$while$copyOfConcat$TypeMatch:                  ; after block
    ; Call copy of concat with 2 arguments
    mov r10, qword ptr [r13 + 028h]                              ; read receiver pointer
    mov rbx, qword ptr [r13 + 020h]                              ; read receiver type
    push rdi                                                     ; value of argument #2 (copy of buffer)
    push r12                                                     ; type of argument #2
    push qword ptr [rsp + 048h]                                  ; value of argument #1 (digitToStr return value)
    push qword ptr [rsp + 048h]                                  ; type of argument #1
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r10                                                  ; internal argument 4: "this" pointer
    mov r8, rbx                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call qword ptr [r13 + 038h]                                  ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat return value type String expecting String
    cmp qword ptr [rsp + 018h], 000h                             ; compare type of copy of concat return value to <sentinel>
    jne func$intToStr$while$copyOfConcatReturnValue$TypeMatch    ; skip next block if copy of concat return value is not sentinel
      ; Error handling block for copy of concat return value
      ; Call __error with 1 arguments
      mov rsi, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 018h], rdi                            ; move copy of buffer's value out of rdi
      lea rdi, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 018h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rdi, qword ptr [rsp + 008h]                            ; restoring slot (copy of buffer) to previous scope state for genuine block exit
    func$intToStr$while$copyOfConcatReturnValue$TypeMatch:       ; after block
    ; Decrement reference count for buffer variable (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 090h]                              ; arg #2: buffer variable's type
    mov rcx, qword ptr [rsp + 098h]                              ; arg #1: buffer variable's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    mov r11, qword ptr [rsp + 020h]                              ; indirect through r11 because operand pair (stack operand #3, stack operand #14) is not allowed with mov
    mov qword ptr [rsp + 078h], r11                              ; store value
    mov r11, qword ptr [rsp + 018h]                              ; indirect through r11 because operand pair (stack operand #4, stack operand #15) is not allowed with mov
    mov qword ptr [rsp + 070h], r11                              ; store type
    ; increment reference count for buffer variable if necessary
    cmp qword ptr [rsp + 070h], 039h                             ; compare type of buffer variable to String
    jne func$intToStr$while$AfterStringIncref$1                  ; if not a String, skip incref
      mov qword ptr [rsp + 010h], r12                            ; move copy of buffer's type out of r12
      mov r12, qword ptr [rsp + 078h]                            ; get buffer variable into register to dereference it
      mov r13, qword ptr [r12]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$intToStr$while$StringIncref$1                     ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 078h], r12                            ; restoring slot (???) to previous scope state for synthetic block exit
      mov r12, qword ptr [rsp + 010h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$intToStr$while$AfterStringIncref$1                ; skip incref for string constants
      func$intToStr$while$StringIncref$1:                        ; real String
        inc qword ptr [r12]                                      ; increment reference count of buffer variable
      mov qword ptr [rsp + 078h], r12                            ; restoring slot (buffer variable) to previous scope state for genuine block exit
      mov r12, qword ptr [rsp + 010h]                            ; restoring slot (copy of buffer) to previous scope state for genuine block exit
    func$intToStr$while$AfterStringIncref$1:                     ; after String incref
    ; Decrement reference count for copy of buffer (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r12                                                 ; arg #2: copy of buffer's type
    mov rcx, rdi                                                 ; arg #1: copy of buffer's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 038h]                              ; arg #2: copy of concat return value's type
    mov rcx, qword ptr [rsp + 040h]                              ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for digitToStr return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 050h]                              ; arg #2: digitToStr return value's type
    mov rcx, qword ptr [rsp + 058h]                              ; arg #1: digitToStr return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$intToStr$while$top                                  ; return to top of while
  func$intToStr$while$bottom:                                    ; bottom of while
  ; Line 193: return buffer;
  mov r14, qword ptr [rsp + 078h]                                ; make a copy of buffer's value in case it changes before we use it
  mov r15, qword ptr [rsp + 070h]                                ; make a copy of buffer's type in case it changes before we use it
  ; increment reference count for copy of buffer if necessary
  cmp r15, 039h                                                  ; compare type of copy of buffer to String
  jne func$intToStr$AfterStringIncref$1                          ; if not a String, skip incref
    mov r10, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r10, 0                                                   ; compare string reference count to 0
    jns func$intToStr$StringIncref$1                             ; if reference count is negative (constant strings), skip incref
    jmp func$intToStr$AfterStringIncref$1                        ; skip incref for string constants
    func$intToStr$StringIncref$1:                                ; real String
      inc qword ptr [r14]                                        ; increment reference count of copy of buffer
  func$intToStr$AfterStringIncref$1:                             ; after String incref
  ; sentinel check of copy of buffer type String expecting String
  cmp r15, 000h                                                  ; compare type of copy of buffer to <sentinel>
  jne func$intToStr$inttostrReturnValue$TypeMatch                ; skip next block if copy of buffer is not sentinel
    ; Error handling block for intToStr return value
    ; Call __error with 1 arguments
    mov rbx, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 078h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 078h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$intToStr$inttostrReturnValue$TypeMatch:                   ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of intToStr into register to dereference it
  mov qword ptr [rsi], r14                                       ; intToStr return value
  mov qword ptr [rsp + 068h], rdi                                ; move copy of buffer's value out of rdi
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of intToStr into register to dereference it
  mov qword ptr [rdi], r15                                       ; type of intToStr return value
  ; increment reference count for copy of buffer if necessary
  cmp r15, 039h                                                  ; compare type of copy of buffer to String
  jne func$intToStr$AfterStringIncref$2                          ; if not a String, skip incref
    mov qword ptr [rsp + 060h], r12                              ; move copy of buffer's type out of r12
    mov r12, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r12, 0                                                   ; compare string reference count to 0
    jns func$intToStr$StringIncref$2                             ; if reference count is negative (constant strings), skip incref
    jmp func$intToStr$AfterStringIncref$2                        ; skip incref for string constants
    func$intToStr$StringIncref$2:                                ; real String
      inc qword ptr [r14]                                        ; increment reference count of copy of buffer
  func$intToStr$AfterStringIncref$2:                             ; after String incref
  ; Decrement reference count for buffer variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 090h]                                ; arg #2: buffer variable's type
  mov rcx, qword ptr [rsp + 098h]                                ; arg #1: buffer variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of buffer (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r15                                                   ; arg #2: copy of buffer's type
  mov rcx, r14                                                   ; arg #1: copy of buffer's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  func$intToStr$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 098h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; join
dq func$join$annotation
func$join:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0f8h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0138h]                               ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of join to 2 (integer)
  je func$join$parameterCountCheck$continuation                  ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0f0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0f0h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$parameterCountCheck$continuation:                    ; end of parameter count check
  ; Check type of parameter 0, items (expecting StringList)
  ; type check of items type StringList expecting StringList
  mov rbx, qword ptr [rbp + 038h]                                ; store items's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 007h                                       ; check that items is StringList
  jc func$join$items$TypeMatch                                   ; skip next block if the type matches
    ; Error handling block for items
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0f0h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0f0h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$items$TypeMatch:                                     ; after block
  ; Check type of parameter 1, joiner (expecting String)
  ; type check of joiner type String expecting String
  mov r14, qword ptr [rbp + 048h]                                ; store joiner's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that joiner is String
  jc func$join$joiner$TypeMatch                                  ; skip next block if the type matches
    ; Error handling block for joiner
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 0f0h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0f0h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$joiner$TypeMatch:                                    ; after block
  ; Line 197: if (len(items) == 0) { ...
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (items)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea r13, qword ptr [rsp + 0f0h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 0f0h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  xor r14, r14                                                   ; zero value result of == (testing len return value and 0) to put the boolean in
  cmp qword ptr [rsp + 0e0h], 000h                               ; values equal?
  sete r14b                                                      ; put result in value result of == (testing len return value and 0)
  mov rax, 037h                                                  ; value result of == (testing len return value and 0) is a Boolean'37
  xor r15, r15                                                   ; zero type result of == (testing len return value and 0) to put the boolean in
  cmp qword ptr [rsp + 0d8h], 038h                               ; types equal?
  sete r15b                                                      ; put result in type result of == (testing len return value and 0)
  mov r10, 037h                                                  ; type result of == (testing len return value and 0) is a Boolean'37
  mov rbx, r14                                                   ; assign value of value result of == (testing len return value and 0) to value of == operator result
  and rbx, r15                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare == operator result to false
  je func$join$if$continuation                                   ; len(items) == 0
    ; Line 198: return '';
    ; sentinel check of string type String expecting String
    mov r14, offset string$19                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov rax, qword ptr [rbp + 030h]                              ; get pointer to return value of join into register to dereference it
    mov qword ptr [rax], r14                                     ; join return value
    mov r15, qword ptr [rbp + 028h]                              ; get pointer to return value type of join into register to dereference it
    mov qword ptr [r15], 039h                                    ; type of join return value (String'39)
    jmp func$join$epilog                                         ; return
  func$join$if$continuation:                                     ; end of if
  ; Line 200: Integer length = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0e0h], 000h                               ; value initialization of variable declaration for length variable (0)
  mov qword ptr [rsp + 0d8h], 038h                               ; type initialization of variable declaration for length variable (Integer'38)
  ; Line 201: Integer index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0d0h], 000h                               ; value initialization of variable declaration for index variable (0)
  mov qword ptr [rsp + 0c8h], 038h                               ; type initialization of variable declaration for index variable (Integer'38)
  func$join$while$top:                                           ; top of while
    mov r12, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov r13, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    push qword ptr [rbp + 040h]                                  ; value of argument #1 (items)
    push qword ptr [rbp + 038h]                                  ; type of argument #1
    lea r15, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0d0h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$len                                                ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r13, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$index$TypeMatch                          ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0c0h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0c0h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$index$TypeMatch:                             ; after block
    ; sentinel check of len return value type Integer expecting Integer
    cmp qword ptr [rsp + 0b8h], 000h                             ; compare type of len return value to <sentinel>
    jne func$join$while$lenItems$TypeMatch                       ; skip next block if len return value is not sentinel
      ; Error handling block for len(items)
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 0c0h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 0c0h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$lenItems$TypeMatch:                          ; after block
    xor r13, r13                                                 ; clear < operator result
    cmp r12, qword ptr [rsp + 0c0h]                              ; compare copy of index with len return value
    setl r13b                                                    ; store result in < operator result
    cmp r13, 000h                                                ; compare < operator result to false
    jne func$join$while$body                                     ; while condition
    jmp func$join$while$bottom                                   ; break out of while
    func$join$while$body:                                        ; start of while
    ; Line 203: length += _stringByteLength(items[index]);
    mov r12, qword ptr [rsp + 0e0h]                              ; make a copy of length's value in case it changes before we use it
    mov r14, qword ptr [rsp + 0d8h]                              ; make a copy of length's type in case it changes before we use it
    ; sentinel check of items type StringList expecting WhateverReadOnlyList
    cmp qword ptr [rbp + 038h], 000h                             ; compare type of items to <sentinel>
    jne func$join$while$items$TypeMatch                          ; skip next block if items is not sentinel
      ; Error handling block for items
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$items$TypeMatch:                             ; after block
    mov r10, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$copyOfIndex$TypeMatch                    ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov rsi, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 0d0h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0f0h], r10                            ; move copy of index's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0b0h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$join$while$copyOfIndex$TypeMatch:                       ; after block
    mov r13, qword ptr [rbp + 040h]                              ; get items into register to dereference it
    mov qword ptr [rsp + 0c0h], r12                              ; move copy of length's value out of r12
    mov r12, qword ptr [r13 + 038h]                              ; list data is the second field in its block
    mov qword ptr [rsp + 0b8h], r14                              ; move copy of length's type out of r14
    mov r14, qword ptr [r12 + 008h]                              ; read length from the list data block's metadata
    lea rax, qword ptr [r12 + 020h]                              ; compute address of 0th entry in list data block
    cmp r10, r14                                                 ; compare copy of index to length of list
    jge func$join$while$subscript$boundsError                    ; index out of range (too high)
    cmp r10, 000h                                                ; compare copy of index to 0 (integer)
    jge func$join$while$subscript$inBounds                       ; index not out of range (not negative)
    func$join$while$subscript$boundsError:                       ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov r15, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push r15                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0b8h], r10                            ; move copy of index's value out of r10
      lea r10, qword ptr [rsp + 0c0h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0b8h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0d8h], rax                            ; move base address of list's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 098h]                            ; restoring slot (base address of list) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 0a8h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$join$while$subscript$inBounds:                          ; valid index
    mov qword ptr [rsp + 0b0h], rbx                              ; move copy of index's type out of rbx
    mov rbx, r10                                                 ; assign value of copy of index to value of index into list * 16
    shl rbx, 004h                                                ; multiply by 8*2
    mov rsi, rax                                                 ; assign value of base address of list to value of pointer to items[copy of index]
    add rsi, rbx                                                 ; compute address of specified list entry (result in pointer to items[copy of index])
    mov rdi, qword ptr [rsi + 008h]                              ; value of items[copy of index]
    mov r13, qword ptr [rsi]                                     ; type of items[copy of index]
    ; increment reference count for copy of items[copy of index] if necessary
    cmp r13, 039h                                                ; compare type of copy of items[copy of index] to String
    jne func$join$while$AfterStringIncref                        ; if not a String, skip incref
      mov r12, qword ptr [rdi]                                   ; dereference string to get to reference count
      cmp r12, 0                                                 ; compare string reference count to 0
      jns func$join$while$StringIncref                           ; if reference count is negative (constant strings), skip incref
      jmp func$join$while$AfterStringIncref                      ; skip incref for string constants
      func$join$while$StringIncref:                              ; real String
        inc qword ptr [rdi]                                      ; increment reference count of copy of items[copy of index]
    func$join$while$AfterStringIncref:                           ; after String incref
    ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
    ; Call _stringByteLength with 1 arguments
    push rdi                                                     ; value of argument #1 (copy of items[copy of index])
    push r13                                                     ; type of argument #1
    lea r15, qword ptr [rsp + 0c0h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0c0h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$_stringByteLength                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of length type Integer expecting Integer
    cmp qword ptr [rsp + 0b8h], 000h                             ; compare type of copy of length to <sentinel>
    jne func$join$while$copyOfLength$TypeMatch                   ; skip next block if copy of length is not sentinel
      ; Error handling block for copy of length
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0b0h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0b0h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$copyOfLength$TypeMatch:                      ; after block
    ; sentinel check of _stringByteLength return value type Integer expecting Integer
    cmp qword ptr [rsp + 0a8h], 000h                             ; compare type of _stringByteLength return value to <sentinel>
    jne func$join$while$StringbytelengthReturnValue$TypeMatch    ; skip next block if _stringByteLength return value is not sentinel
      ; Error handling block for _stringByteLength return value
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0a8h], rdi                            ; move copy of items[copy of index]'s value out of rdi
      lea rdi, qword ptr [rsp + 0b0h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 0a8h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rdi, qword ptr [rsp + 098h]                            ; restoring slot (copy of items[copy of index]) to previous scope state for genuine block exit
    func$join$while$StringbytelengthReturnValue$TypeMatch:       ; after block
    mov qword ptr [rsp + 0a0h], r13                              ; move copy of items[copy of index]'s type out of r13
    mov r13, qword ptr [rsp + 0c0h]                              ; assign value of copy of length to value of += operator result
    add r13, qword ptr [rsp + 0b0h]                              ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0e0h], r13                              ; store value
    mov qword ptr [rsp + 0d8h], 038h                             ; store type (Integer'38)
    ; Line 204: index += 1;
    mov rax, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov r15, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$copyOfIndex$TypeMatch$1                  ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0d0h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0f0h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0b0h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$join$while$copyOfIndex$TypeMatch$1:                     ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov qword ptr [rsp + 0c0h], r13                              ; move += operator result's value out of r13
    mov r13, rax                                                 ; assign value of copy of index to value of += operator result
    mov r12, 001h                                                ; read second operand of add (1)
    add r13, r12                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0d0h], r13                              ; store value
    mov qword ptr [rsp + 0c8h], 038h                             ; store type (Integer'38)
    ; Decrement reference count for copy of items[copy of index] (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0c0h]                              ; arg #2: copy of items[copy of index]'s type
    mov rcx, rdi                                                 ; arg #1: copy of items[copy of index]'s value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$join$while$top                                      ; return to top of while
  func$join$while$bottom:                                        ; bottom of while
  ; Line 206: Integer joinerLength = _stringByteLength(joiner);
  ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
  ; Call _stringByteLength with 1 arguments
  push qword ptr [rbp + 050h]                                    ; value of argument #1 (joiner)
  push qword ptr [rbp + 048h]                                    ; type of argument #1
  lea rbx, qword ptr [rsp + 0b8h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0b0h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_stringByteLength                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _stringByteLength return value type Integer expecting Integer
  cmp qword ptr [rsp + 098h], 000h                               ; compare type of _stringByteLength return value to <sentinel>
  jne func$join$StringbytelengthReturnValue$TypeMatch            ; skip next block if _stringByteLength return value is not sentinel
    ; Error handling block for _stringByteLength return value
    ; Call __error with 1 arguments
    mov rsi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 098h], rdi                              ; move copy of items[copy of index]'s value out of rdi
    lea rdi, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$StringbytelengthReturnValue$TypeMatch:               ; after block
  mov r11, qword ptr [rsp + 0a8h]                                ; indirect through r11 because operand pair (stack operand #6, stack operand #8) is not allowed with mov
  mov qword ptr [rsp + 0b8h], r11                                ; value initialization of variable declaration for joinerLength variable (_stringByteLength return value)
  mov r11, qword ptr [rsp + 098h]                                ; indirect through r11 because operand pair (stack operand #7, stack operand #10) is not allowed with mov
  mov qword ptr [rsp + 0b0h], r11                                ; type initialization of variable declaration for joinerLength variable
  ; Line 207: length += joinerLength * len(items) - 1;
  mov qword ptr [rsp + 0a8h], r13                                ; move += operator result's value out of r13
  mov r13, qword ptr [rsp + 0e0h]                                ; make a copy of length's value in case it changes before we use it
  mov r12, qword ptr [rsp + 0d8h]                                ; make a copy of length's type in case it changes before we use it
  mov r14, qword ptr [rsp + 0b8h]                                ; make a copy of joinerLength's value in case it changes before we use it
  mov rax, qword ptr [rsp + 0b0h]                                ; make a copy of joinerLength's type in case it changes before we use it
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (items)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rbx, qword ptr [rsp + 0a8h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 0a8h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0c0h], rax                                ; move copy of joinerLength's type out of rax
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of len return value type Integer expecting Integer
  cmp qword ptr [rsp + 090h], 000h                               ; compare type of len return value to <sentinel>
  jne func$join$lenItems$TypeMatch                               ; skip next block if len return value is not sentinel
    ; Error handling block for len(items)
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 088h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 088h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$lenItems$TypeMatch:                                  ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov qword ptr [rsp + 078h], r14                                ; move copy of joinerLength's value out of r14
  mov r14, qword ptr [rsp + 098h]                                ; assign value of len return value to value of - operator result
  sub r14, 001h                                                  ; compute (len return value) - (1)
  ; sentinel check of copy of joinerLength type Integer expecting Integer
  cmp qword ptr [rsp + 080h], 000h                               ; compare type of copy of joinerLength to <sentinel>
  jne func$join$joinerlength$TypeMatch                           ; skip next block if copy of joinerLength is not sentinel
    ; Error handling block for joinerLength
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$joinerlength$TypeMatch:                              ; after block
  ; sentinel check of - operator result type Integer expecting Integer
  mov rsi, qword ptr [rsp + 078h]                                ; read left hand side operand of imul (copy of joinerLength), which is also the result
  imul rsi, r14                                                  ; compute (copy of joinerLength) * (- operator result) (result in * operator result)
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$join$copyOfLength$TypeMatch                           ; skip next block if copy of length is not sentinel
    ; Error handling block for copy of length
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 0a0h], r13                              ; move copy of length's value out of r13
    lea r13, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 098h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 090h]                              ; restoring slot (copy of length) to previous scope state for genuine block exit
  func$join$copyOfLength$TypeMatch:                              ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov rax, r13                                                   ; assign value of copy of length to value of += operator result
  add rax, rsi                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr [rsp + 0e0h], rax                                ; store value
  mov qword ptr [rsp + 0d8h], 038h                               ; store type (Integer'38)
  ; Line 208: assert(length >= 0, 'negative length detected');
  mov rbx, qword ptr [rsp + 0e0h]                                ; make a copy of length's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 0d8h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$join$length$TypeMatch                                 ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0c0h], rax                              ; move += operator result's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 080h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$join$length$TypeMatch:                                    ; after block
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 098h], rax                                ; move += operator result's value out of rax
  xor rax, rax                                                   ; clear >= operator result
  cmp rbx, 000h                                                  ; compare copy of length with 0
  setge al                                                       ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$20                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rax                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rsi, qword ptr [rsp + 0b0h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 0a8h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 209: if (length >= 2147483648 /* 0x80000000 */) { ...
  mov rdi, qword ptr [rsp + 0e0h]                                ; make a copy of length's value in case it changes before we use it
  mov r13, qword ptr [rsp + 0d8h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$join$length$TypeMatch$1                               ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 098h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$length$TypeMatch$1:                                  ; after block
  ; sentinel check of 2147483648 /* 0x80000000 */ type Integer expecting Integer
  mov r10, 080000000h                                            ; reading second value to compare (<ImmediateIntegerSlot:Integer'38 ("2147483648 /* 0x80000000 */")>)
  xor rbx, rbx                                                   ; clear >= operator result
  cmp rdi, r10                                                   ; compare copy of length with 2147483648 /* 0x80000000 */
  setge bl                                                       ; store result in >= operator result
  ; sentinel check of >= operator result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare >= operator result to false
  je func$join$if$continuation$1                                 ; length >= 2147483648 /* 0x80000000 */
    ; Line 210: stderr('absurd length detected (as exit code)\n');
    mov r13, qword ptr stderrValue                               ; make a copy of stderr's value in case it changes before we use it
    mov r12, qword ptr stderrType                                ; make a copy of stderr's type in case it changes before we use it
    ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
    cmp r12, 000h                                                ; compare type of copy of stderr to <sentinel>
    jne func$join$join$if$1$copyOfStderr$TypeMatch               ; skip next block if copy of stderr is not sentinel
      ; Error handling block for copy of stderr
      ; Call __error with 1 arguments
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 0a0h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 098h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$join$if$1$copyOfStderr$TypeMatch:                  ; after block
    ; Call copy of stderr with 1 arguments
    mov r15, qword ptr [r13 + 028h]                              ; read receiver pointer
    mov r10, qword ptr [r13 + 020h]                              ; read receiver type
    mov rbx, offset string$21                                    ; reading string for push
    push rbx                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r15                                                  ; internal argument 4: "this" pointer
    mov r8, r10                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call qword ptr [r13 + 038h]                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 211: exit(length);
    mov rdi, qword ptr [rsp + 0e0h]                              ; make a copy of length's value in case it changes before we use it
    mov r13, qword ptr [rsp + 0d8h]                              ; make a copy of length's type in case it changes before we use it
    ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
    ; Call exit with 1 arguments
    push rdi                                                     ; value of argument #1 (copy of length)
    push r13                                                     ; type of argument #1
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$exit                                               ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$if$continuation$1:                                   ; end of if
  ; Line 213: Integer resultPointer = _alloc(16 /* 0x10 */ + length);
  mov r15, qword ptr [rsp + 0e0h]                                ; make a copy of length's value in case it changes before we use it
  mov r10, qword ptr [rsp + 0d8h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$join$length$TypeMatch$2                               ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 088h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 088h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0a8h], r10                              ; move copy of length's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 068h]                              ; restoring slot (copy of length) to previous scope state for genuine block exit
  func$join$length$TypeMatch$2:                                  ; after block
  mov r12, 010h                                                  ; assign value of 16 /* 0x10 */ to value of + operator result
  add r12, r15                                                   ; compute (16 /* 0x10 */) + (copy of length) (result in + operator result)
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push r12                                                       ; value of argument #1 (+ operator result)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r15, qword ptr [rsp + 088h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 088h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 070h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne func$join$AllocReturnValue$TypeMatch                       ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov r10, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 078h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 078h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$join$AllocReturnValue$TypeMatch:                          ; after block
  mov r11, qword ptr [rsp + 078h]                                ; indirect through r11 because operand pair (stack operand #11, stack operand #14) is not allowed with mov
  mov qword ptr [rsp + 090h], r11                                ; value initialization of variable declaration for resultPointer variable (_alloc return value)
  mov r11, qword ptr [rsp + 070h]                                ; indirect through r11 because operand pair (stack operand #13, stack operand #15) is not allowed with mov
  mov qword ptr [rsp + 080h], r11                                ; type initialization of variable declaration for resultPointer variable
  ; Line 214: __writeToAddress(resultPointer, 0);
  mov rsi, qword ptr [rsp + 090h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rdi, qword ptr [rsp + 080h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rsi], 000h                                      ; __writeToAddress
  ; Line 215: __writeToAddress(resultPointer + 8, length);
  mov r14, qword ptr [rsp + 090h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rax, qword ptr [rsp + 080h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$join$resultpointer$TypeMatch                          ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 088h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 088h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0a8h], rax                              ; move copy of resultPointer's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 068h]                              ; restoring slot (copy of resultPointer) to previous scope state for genuine block exit
  func$join$resultpointer$TypeMatch:                             ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of resultPointer to value of + operator result
  add rdi, 008h                                                  ; compute (copy of resultPointer) + (8) (result in + operator result)
  mov r13, qword ptr [rsp + 0e0h]                                ; make a copy of length's value in case it changes before we use it
  mov r12, qword ptr [rsp + 0d8h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rdi], r13                                       ; __writeToAddress
  ; Line 216: Integer cursor = resultPointer + 16 /* 0x10 */;
  mov r15, qword ptr [rsp + 090h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r10, qword ptr [rsp + 080h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$join$resultpointer$TypeMatch$1                        ; skip next block if copy of resultPointer is not sentinel
    mov qword ptr [rsp + 078h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 070h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 078h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 078h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 098h], r10                              ; move copy of resultPointer's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 058h]                              ; restoring slot (copy of resultPointer) to previous scope state for genuine block exit
  func$join$resultpointer$TypeMatch$1:                           ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov r12, r15                                                   ; assign value of copy of resultPointer to value of + operator result
  add r12, 010h                                                  ; compute (copy of resultPointer) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 078h], r12                                ; value initialization of variable declaration for cursor variable (+ operator result)
  mov qword ptr [rsp + 070h], 038h                               ; type initialization of variable declaration for cursor variable (Integer'38)
  ; Line 217: index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0d0h], 000h                               ; store value
  mov qword ptr [rsp + 0c8h], 038h                               ; store type (Integer'38)
  func$join$while$top$1:                                         ; top of while
    mov rbx, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    push qword ptr [rbp + 040h]                                  ; value of argument #1 (items)
    push qword ptr [rbp + 038h]                                  ; type of argument #1
    lea r12, qword ptr [rsp + 078h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 078h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$len                                                ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of index type Integer expecting Integer
    cmp rsi, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$index$TypeMatch$1                        ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 068h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$index$TypeMatch$1:                           ; after block
    ; sentinel check of len return value type Integer expecting Integer
    cmp qword ptr [rsp + 060h], 000h                             ; compare type of len return value to <sentinel>
    jne func$join$while$lenItems$TypeMatch$1                     ; skip next block if len return value is not sentinel
      ; Error handling block for len(items)
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 068h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$lenItems$TypeMatch$1:                        ; after block
    xor rsi, rsi                                                 ; clear < operator result
    cmp rbx, qword ptr [rsp + 068h]                              ; compare copy of index with len return value
    setl sil                                                     ; store result in < operator result
    cmp rsi, 000h                                                ; compare < operator result to false
    jne func$join$while$body$1                                   ; while condition
    jmp func$join$while$bottom$1                                 ; break out of while
    func$join$while$body$1:                                      ; start of while
    ; Line 219: String segment = items[index];
    ; sentinel check of items type StringList expecting WhateverReadOnlyList
    cmp qword ptr [rbp + 038h], 000h                             ; compare type of items to <sentinel>
    jne func$join$while$items$TypeMatch$1                        ; skip next block if items is not sentinel
      mov qword ptr [rsp + 068h], 000h                           ; move segment variable's value into a mutable location
      mov qword ptr [rsp + 060h], 000h                           ; move segment variable's type into a mutable location
      ; Error handling block for items
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 068h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$items$TypeMatch$1:                           ; after block
    mov r13, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov r12, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$copyOfIndex$TypeMatch$2                  ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r14, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 068h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$copyOfIndex$TypeMatch$2:                     ; after block
    mov r15, qword ptr [rbp + 040h]                              ; get items into register to dereference it
    mov r10, qword ptr [r15 + 038h]                              ; list data is the second field in its block
    mov rsi, qword ptr [r10 + 008h]                              ; read length from the list data block's metadata
    lea rbx, qword ptr [r10 + 020h]                              ; compute address of 0th entry in list data block
    cmp r13, rsi                                                 ; compare copy of index to length of list
    jge func$join$while$subscript$boundsError$1                  ; index out of range (too high)
    cmp r13, 000h                                                ; compare copy of index to 0 (integer)
    jge func$join$while$subscript$inBounds$1                     ; index not out of range (not negative)
    func$join$while$subscript$boundsError$1:                     ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov rdi, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push rdi                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 060h], r13                            ; move copy of index's value out of r13
      lea r13, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 060h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r13, qword ptr [rsp + 050h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$join$while$subscript$inBounds$1:                        ; valid index
    mov qword ptr [rsp + 058h], r12                              ; move copy of index's type out of r12
    mov r12, r13                                                 ; assign value of copy of index to value of index into list * 16
    shl r12, 004h                                                ; multiply by 8*2
    mov r14, rbx                                                 ; assign value of base address of list to value of pointer to items[copy of index]
    add r14, r12                                                 ; compute address of specified list entry (result in pointer to items[copy of index])
    mov rax, qword ptr [r14 + 008h]                              ; value of items[copy of index]
    mov r15, qword ptr [r14]                                     ; type of items[copy of index]
    ; increment reference count for copy of items[copy of index] if necessary
    cmp r15, 039h                                                ; compare type of copy of items[copy of index] to String
    jne func$join$while$AfterStringIncref$1                      ; if not a String, skip incref
      mov r10, qword ptr [rax]                                   ; dereference string to get to reference count
      cmp r10, 0                                                 ; compare string reference count to 0
      jns func$join$while$StringIncref$1                         ; if reference count is negative (constant strings), skip incref
      jmp func$join$while$AfterStringIncref$1                    ; skip incref for string constants
      func$join$while$StringIncref$1:                            ; real String
        inc qword ptr [rax]                                      ; increment reference count of copy of items[copy of index]
    func$join$while$AfterStringIncref$1:                         ; after String incref
    ; sentinel check of copy of items[copy of index] type String expecting String
    cmp r15, 000h                                                ; compare type of copy of items[copy of index] to <sentinel>
    jne func$join$while$copyOfItemsCopyOfIndex$TypeMatch         ; skip next block if copy of items[copy of index] is not sentinel
      ; Error handling block for copy of items[copy of index]
      ; Call __error with 1 arguments
      mov rsi, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 068h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 088h], rax                            ; move copy of items[copy of index]'s value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 048h]                            ; restoring slot (copy of items[copy of index]) to previous scope state for genuine block exit
    func$join$while$copyOfItemsCopyOfIndex$TypeMatch:            ; after block
    mov qword ptr [rsp + 068h], rax                              ; value initialization of variable declaration for segment variable (copy of items[copy of index])
    mov qword ptr [rsp + 060h], r15                              ; type initialization of variable declaration for segment variable
    ; increment reference count for segment variable if necessary
    cmp qword ptr [rsp + 060h], 039h                             ; compare type of segment variable to String
    jne func$join$while$AfterStringIncref$2                      ; if not a String, skip incref
      mov rdi, qword ptr [rsp + 068h]                            ; get segment variable into register to dereference it
      mov r13, qword ptr [rdi]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$join$while$StringIncref$2                         ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 068h], rdi                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$join$while$AfterStringIncref$2                    ; skip incref for string constants
      func$join$while$StringIncref$2:                            ; real String
        inc qword ptr [rdi]                                      ; increment reference count of segment variable
      mov qword ptr [rsp + 068h], rdi                            ; restoring slot (segment variable) to previous scope state for genuine block exit
    func$join$while$AfterStringIncref$2:                         ; after String incref
    ; Line 220: Integer segmentLength = _stringByteLength(segment);
    mov r12, qword ptr [rsp + 068h]                              ; make a copy of segment's value in case it changes before we use it
    mov r14, qword ptr [rsp + 060h]                              ; make a copy of segment's type in case it changes before we use it
    ; increment reference count for copy of segment if necessary
    cmp r14, 039h                                                ; compare type of copy of segment to String
    jne func$join$while$AfterStringIncref$3                      ; if not a String, skip incref
      mov qword ptr [rsp + 058h], 000h                           ; move segmentLength variable's value into a mutable location
      mov qword ptr [rsp + 050h], 000h                           ; move segmentLength variable's type into a mutable location
      mov qword ptr [rsp + 048h], rax                            ; move copy of items[copy of index]'s value out of rax
      mov rax, qword ptr [r12]                                   ; dereference string to get to reference count
      cmp rax, 0                                                 ; compare string reference count to 0
      jns func$join$while$StringIncref$3                         ; if reference count is negative (constant strings), skip incref
      mov rax, qword ptr [rsp + 048h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$join$while$AfterStringIncref$3                    ; skip incref for string constants
      func$join$while$StringIncref$3:                            ; real String
        inc qword ptr [r12]                                      ; increment reference count of copy of segment
      mov rax, qword ptr [rsp + 048h]                            ; restoring slot (copy of items[copy of index]) to previous scope state for genuine block exit
    func$join$while$AfterStringIncref$3:                         ; after String incref
    ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
    ; Call _stringByteLength with 1 arguments
    push r12                                                     ; value of argument #1 (copy of segment)
    push r14                                                     ; type of argument #1
    lea rsi, qword ptr [rsp + 058h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 058h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 078h], rax                              ; move copy of items[copy of index]'s value out of rax
    call func$_stringByteLength                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of _stringByteLength return value type Integer expecting Integer
    cmp qword ptr [rsp + 040h], 000h                             ; compare type of _stringByteLength return value to <sentinel>
    jne func$join$while$StringbytelengthReturnValue$TypeMatch$1  ; skip next block if _stringByteLength return value is not sentinel
      ; Error handling block for _stringByteLength return value
      ; Call __error with 1 arguments
      mov rbx, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 040h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$StringbytelengthReturnValue$TypeMatch$1:     ; after block
    mov r11, qword ptr [rsp + 048h]                              ; indirect through r11 because operand pair (stack operand #18, stack operand #20) is not allowed with mov
    mov qword ptr [rsp + 058h], r11                              ; value initialization of variable declaration for segmentLength variable (_stringByteLength return value)
    mov r11, qword ptr [rsp + 040h]                              ; indirect through r11 because operand pair (stack operand #19, stack operand #21) is not allowed with mov
    mov qword ptr [rsp + 050h], r11                              ; type initialization of variable declaration for segmentLength variable
    ; Line 221: if (segmentLength > 0) { ...
    mov r13, qword ptr [rsp + 058h]                              ; make a copy of segmentLength's value in case it changes before we use it
    mov qword ptr [rsp + 048h], r12                              ; move copy of segment's value out of r12
    mov r12, qword ptr [rsp + 050h]                              ; make a copy of segmentLength's type in case it changes before we use it
    ; sentinel check of copy of segmentLength type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of segmentLength to <sentinel>
    jne func$join$while$segmentlength$TypeMatch                  ; skip next block if copy of segmentLength is not sentinel
      ; Error handling block for segmentLength
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 040h], r14                            ; move copy of segment's type out of r14
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 040h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r14, qword ptr [rsp + 040h]                            ; restoring slot (copy of segment) to previous scope state for genuine block exit
    func$join$while$segmentlength$TypeMatch:                     ; after block
    ; sentinel check of 0 type Integer expecting Integer
    xor rsi, rsi                                                 ; clear > operator result
    cmp r13, 000h                                                ; compare copy of segmentLength with 0
    setg sil                                                     ; store result in > operator result
    ; sentinel check of > operator result type Boolean expecting Boolean
    cmp rsi, 000h                                                ; compare > operator result to false
    je func$join$while$if$continuation                           ; segmentLength > 0
      ; Line 222: Integer segmentPointer = segment __as__ Integer;
      mov r13, qword ptr [rsp + 068h]                            ; make a copy of segment's value in case it changes before we use it
      mov r12, qword ptr [rsp + 060h]                            ; make a copy of segment's type in case it changes before we use it
      ; increment reference count for copy of segment if necessary
      cmp r12, 039h                                              ; compare type of copy of segment to String
      jne func$join$while$while$if$AfterStringIncref             ; if not a String, skip incref
        mov qword ptr [rsp + 040h], 000h                         ; move segmentPointer variable's value into a mutable location
        mov qword ptr [rsp + 030h], 000h                         ; move segmentPointer variable's type into a mutable location
        mov qword ptr [rsp + 028h], r14                          ; move copy of segment's type out of r14
        mov r14, qword ptr [r13]                                 ; dereference string to get to reference count
        cmp r14, 0                                               ; compare string reference count to 0
        jns func$join$while$while$if$StringIncref                ; if reference count is negative (constant strings), skip incref
        mov r14, qword ptr [rsp + 028h]                          ; restoring slot (???) to previous scope state for synthetic block exit
        jmp func$join$while$while$if$AfterStringIncref           ; skip incref for string constants
        func$join$while$while$if$StringIncref:                   ; real String
          inc qword ptr [r13]                                    ; increment reference count of copy of segment
        mov r14, qword ptr [rsp + 028h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$join$while$while$if$AfterStringIncref:                ; after String incref
      mov rax, r13                                               ; force cast of copy of segment to Integer
      ; sentinel check of force cast of copy of segment to Integer type Integer expecting Integer
      mov qword ptr [rsp + 040h], rax                            ; value initialization of variable declaration for segmentPointer variable (force cast of copy of segment to Integer)
      mov qword ptr [rsp + 030h], 038h                           ; type initialization of variable declaration for segmentPointer variable (Integer'38)
      ; Line 223: _moveBytes(segmentPointer + 16 /* 0x10 */, cursor, segmentLength...
      mov rsi, qword ptr [rsp + 040h]                            ; make a copy of segmentPointer's value in case it changes before we use it
      mov rbx, qword ptr [rsp + 030h]                            ; make a copy of segmentPointer's type in case it changes before we use it
      ; sentinel check of copy of segmentPointer type Integer expecting Integer
      cmp rbx, 000h                                              ; compare type of copy of segmentPointer to <sentinel>
      jne func$join$while$while$if$segmentpointer$TypeMatch      ; skip next block if copy of segmentPointer is not sentinel
        ; Error handling block for segmentPointer
        ; Call __error with 1 arguments
        mov rdi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rdi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 040h], r13                          ; move copy of segment's value out of r13
        lea r13, qword ptr [rsp + 050h]                          ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 040h]                          ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r13, qword ptr [rsp + 030h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$join$while$while$if$segmentpointer$TypeMatch:         ; after block
      ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
      mov rax, rsi                                               ; assign value of copy of segmentPointer to value of + operator result
      add rax, 010h                                              ; compute (copy of segmentPointer) + (16 /* 0x10 */) (result in + operator result)
      mov qword ptr [rsp + 040h], r15                            ; move copy of items[copy of index]'s type out of r15
      mov r15, qword ptr [rsp + 078h]                            ; make a copy of cursor's value in case it changes before we use it
      mov r10, qword ptr [rsp + 070h]                            ; make a copy of cursor's type in case it changes before we use it
      mov rsi, qword ptr [rsp + 058h]                            ; make a copy of segmentLength's value in case it changes before we use it
      mov rbx, qword ptr [rsp + 050h]                            ; make a copy of segmentLength's type in case it changes before we use it
      ; sentinel check of _moveBytes type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
      ; Call _moveBytes with 3 arguments
      push rsi                                                   ; value of argument #3 (copy of segmentLength)
      push rbx                                                   ; type of argument #3
      push r15                                                   ; value of argument #2 (copy of cursor)
      push r10                                                   ; type of argument #2
      push rax                                                   ; value of argument #1 (+ operator result)
      push 038h                                                  ; type of argument #1 (Integer'38)
      mov qword ptr [rsp + 058h], r12                            ; move copy of segment's type out of r12
      lea r12, qword ptr [rsp + 060h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 003h                                              ; internal argument 1: number of actual arguments
      call func$_moveBytes                                       ; jump to subroutine
      add rsp, 060h                                              ; release shadow space and arguments (result in stack pointer)
      ; Line 224: cursor += segmentLength;
      mov qword ptr [rsp + 030h], r14                            ; move copy of segment's type out of r14
      mov r14, qword ptr [rsp + 078h]                            ; make a copy of cursor's value in case it changes before we use it
      mov rax, qword ptr [rsp + 070h]                            ; make a copy of cursor's type in case it changes before we use it
      mov r15, qword ptr [rsp + 058h]                            ; make a copy of segmentLength's value in case it changes before we use it
      mov r10, qword ptr [rsp + 050h]                            ; make a copy of segmentLength's type in case it changes before we use it
      ; sentinel check of copy of cursor type Integer expecting Integer
      cmp rax, 000h                                              ; compare type of copy of cursor to <sentinel>
      jne func$join$while$while$if$copyOfCursor$TypeMatch        ; skip next block if copy of cursor is not sentinel
        ; Error handling block for copy of cursor
        ; Call __error with 1 arguments
        mov rsi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rbx, qword ptr [rsp + 030h]                          ; load address of return value's value
        push rbx                                                 ; internal argument 6: pointer to return value slot's value
        lea rbx, qword ptr [rsp + 030h]                          ; load address of return value's type
        push rbx                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 050h], r10                          ; move copy of segmentLength's type out of r10
        mov qword ptr [rsp + 048h], rax                          ; move copy of cursor's type out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 008h]                          ; restoring slot (copy of cursor) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 010h]                          ; restoring slot (copy of segmentLength) to previous scope state for genuine block exit
      func$join$while$while$if$copyOfCursor$TypeMatch:           ; after block
      ; sentinel check of copy of segmentLength type Integer expecting Integer
      cmp r10, 000h                                              ; compare type of copy of segmentLength to <sentinel>
      jne func$join$while$while$if$copyOfSegmentlength$TypeMatch ; skip next block if copy of segmentLength is not sentinel
        ; Error handling block for copy of segmentLength
        ; Call __error with 1 arguments
        mov rdi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rdi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 028h], r13                          ; move copy of segment's value out of r13
        lea r13, qword ptr [rsp + 030h]                          ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 028h]                          ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 048h], r10                          ; move copy of segmentLength's type out of r10
        mov qword ptr [rsp + 040h], rax                          ; move copy of cursor's type out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 000h]                          ; restoring slot (copy of cursor) to previous scope state for genuine block exit
        mov r13, qword ptr [rsp + 018h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 008h]                          ; restoring slot (copy of segmentLength) to previous scope state for genuine block exit
      func$join$while$while$if$copyOfSegmentlength$TypeMatch:    ; after block
      mov r12, r14                                               ; assign value of copy of cursor to value of += operator result
      add r12, r15                                               ; += operator
      ; sentinel check of += operator result type Integer expecting Integer
      mov qword ptr [rsp + 078h], r12                            ; store value
      mov qword ptr [rsp + 070h], 038h                           ; store type (Integer'38)
      ; Decrement reference count for copy of segment (static type: String'39) via decrefMaybeString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 048h]                            ; arg #2: copy of segment's type
      mov rcx, r13                                               ; arg #1: copy of segment's value
      call decrefMaybeString                                     ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      mov r15, qword ptr [rsp + 040h]                            ; restoring slot (copy of items[copy of index]) to previous scope state for genuine block exit
      mov r14, qword ptr [rsp + 030h]                            ; restoring slot (copy of segment) to previous scope state for genuine block exit
    func$join$while$if$continuation:                             ; end of if
    ; Line 226: if (index < len(items) - 1) { ...
    mov qword ptr [rsp + 058h], r15                              ; move copy of items[copy of index]'s type out of r15
    mov r15, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov r10, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    push qword ptr [rbp + 040h]                                  ; value of argument #1 (items)
    push qword ptr [rbp + 038h]                                  ; type of argument #1
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 058h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 070h], r10                              ; move copy of index's type out of r10
    call func$len                                                ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of len return value type Integer expecting Integer
    cmp qword ptr [rsp + 040h], 000h                             ; compare type of len return value to <sentinel>
    jne func$join$while$lenItems$TypeMatch$2                     ; skip next block if len return value is not sentinel
      ; Error handling block for len(items)
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 020h], r13                            ; move copy of segment's value out of r13
      mov r13, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 020h], r12                            ; move += operator result's value out of r12
      lea r12, qword ptr [rsp + 028h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 020h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$lenItems$TypeMatch$2:                        ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov qword ptr [rsp + 018h], r15                              ; move copy of index's value out of r15
    mov r15, qword ptr [rsp + 050h]                              ; assign value of len return value to value of - operator result
    sub r15, 001h                                                ; compute (len return value) - (1)
    ; sentinel check of copy of index type Integer expecting Integer
    cmp qword ptr [rsp + 030h], 000h                             ; compare type of copy of index to <sentinel>
    jne func$join$while$index$TypeMatch$2                        ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 058h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$join$while$index$TypeMatch$2:                           ; after block
    ; sentinel check of - operator result type Integer expecting Integer
    xor r13, r13                                                 ; clear < operator result
    cmp qword ptr [rsp + 018h], r15                              ; compare copy of index with - operator result
    setl r13b                                                    ; store result in < operator result
    ; sentinel check of < operator result type Boolean expecting Boolean
    cmp r13, 000h                                                ; compare < operator result to false
    je func$join$while$if$continuation$1                         ; index < len(items) - 1
      ; Line 227: if (joinerLength > 0) { ...
      mov rax, qword ptr [rsp + 0b8h]                            ; make a copy of joinerLength's value in case it changes before we use it
      mov r15, qword ptr [rsp + 0b0h]                            ; make a copy of joinerLength's type in case it changes before we use it
      ; sentinel check of copy of joinerLength type Integer expecting Integer
      cmp r15, 000h                                              ; compare type of copy of joinerLength to <sentinel>
      jne func$join$while$while$if$1$joinerlength$TypeMatch      ; skip next block if copy of joinerLength is not sentinel
        ; Error handling block for joinerLength
        ; Call __error with 1 arguments
        mov r10, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r10                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rsi, qword ptr [rsp + 060h]                          ; load address of return value's value
        push rsi                                                 ; internal argument 6: pointer to return value slot's value
        lea rsi, qword ptr [rsp + 058h]                          ; load address of return value's type
        push rsi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 070h], rax                          ; move copy of joinerLength's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 030h]                          ; restoring slot (copy of joinerLength) to previous scope state for genuine block exit
      func$join$while$while$if$1$joinerlength$TypeMatch:         ; after block
      ; sentinel check of 0 type Integer expecting Integer
      xor r13, r13                                               ; clear > operator result
      cmp rax, 000h                                              ; compare copy of joinerLength with 0
      setg r13b                                                  ; store result in > operator result
      ; sentinel check of > operator result type Boolean expecting Boolean
      cmp r13, 000h                                              ; compare > operator result to false
      je func$join$while$while$if$1$if$continuation              ; joinerLength > 0
        ; Line 228: Integer joinerPointer = joiner __as__ Integer;
        mov rax, qword ptr [rbp + 050h]                          ; force cast of joiner to Integer
        ; sentinel check of force cast of joiner to Integer type Integer expecting Integer
        mov qword ptr [rsp + 050h], rax                          ; value initialization of variable declaration for joinerPointer variable (force cast of joiner to Integer)
        mov qword ptr [rsp + 040h], 038h                         ; type initialization of variable declaration for joinerPointer variable (Integer'38)
        ; Line 229: _moveBytes(joinerPointer + 16 /* 0x10 */, cursor, joinerLength);...
        mov rsi, qword ptr [rsp + 050h]                          ; make a copy of joinerPointer's value in case it changes before we use it
        mov rbx, qword ptr [rsp + 040h]                          ; make a copy of joinerPointer's type in case it changes before we use it
        ; sentinel check of copy of joinerPointer type Integer expecting Integer
        cmp rbx, 000h                                            ; compare type of copy of joinerPointer to <sentinel>
        jne func$join$while$while$if$1$while$if$1$if$joinerpointer$TypeMatch ; skip next block if copy of joinerPointer is not sentinel
          ; Error handling block for joinerPointer
          ; Call __error with 1 arguments
          mov rdi, offset operandTypeCheckFailureMessage         ; reading operandTypeCheckFailureMessage for push
          push rdi                                               ; value of argument #1 (operandTypeCheckFailureMessage)
          push 039h                                              ; type of argument #1 (String'39)
          lea r13, qword ptr [rsp + 060h]                        ; load address of return value's value
          push r13                                               ; internal argument 6: pointer to return value slot's value
          lea r13, qword ptr [rsp + 058h]                        ; load address of return value's type
          push r13                                               ; internal argument 5: pointer to return value slot's type
          sub rsp, 020h                                          ; allocate shadow space
          mov r9, 000h                                           ; internal argument 4: "this" pointer
          mov r8, 000h                                           ; internal argument 3: "this" pointer type
          mov rdx, 000h                                          ; internal argument 2: closure pointer
          mov rcx, 001h                                          ; internal argument 1: number of actual arguments
          call func$__error                                      ; jump to subroutine
          add rsp, 040h                                          ; release shadow space and arguments (result in stack pointer)
        func$join$while$while$if$1$while$if$1$if$joinerpointer$TypeMatch:  ; after block
        ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
        mov rax, rsi                                             ; assign value of copy of joinerPointer to value of + operator result
        add rax, 010h                                            ; compute (copy of joinerPointer) + (16 /* 0x10 */) (result in + operator result)
        mov r15, qword ptr [rsp + 078h]                          ; make a copy of cursor's value in case it changes before we use it
        mov r10, qword ptr [rsp + 070h]                          ; make a copy of cursor's type in case it changes before we use it
        mov rsi, qword ptr [rsp + 0b8h]                          ; make a copy of joinerLength's value in case it changes before we use it
        mov rbx, qword ptr [rsp + 0b0h]                          ; make a copy of joinerLength's type in case it changes before we use it
        ; sentinel check of _moveBytes type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
        ; Call _moveBytes with 3 arguments
        push rsi                                                 ; value of argument #3 (copy of joinerLength)
        push rbx                                                 ; type of argument #3
        push r15                                                 ; value of argument #2 (copy of cursor)
        push r10                                                 ; type of argument #2
        push rax                                                 ; value of argument #1 (+ operator result)
        push 038h                                                ; type of argument #1 (Integer'38)
        lea r12, qword ptr [rsp + 080h]                          ; load address of return value's value
        push r12                                                 ; internal argument 6: pointer to return value slot's value
        lea r12, qword ptr [rsp + 078h]                          ; load address of return value's type
        push r12                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 003h                                            ; internal argument 1: number of actual arguments
        call func$_moveBytes                                     ; jump to subroutine
        add rsp, 060h                                            ; release shadow space and arguments (result in stack pointer)
        ; Line 230: cursor += joinerLength;
        mov qword ptr [rsp + 050h], r14                          ; move copy of segment's type out of r14
        mov r14, qword ptr [rsp + 078h]                          ; make a copy of cursor's value in case it changes before we use it
        mov rax, qword ptr [rsp + 070h]                          ; make a copy of cursor's type in case it changes before we use it
        mov r15, qword ptr [rsp + 0b8h]                          ; make a copy of joinerLength's value in case it changes before we use it
        mov r10, qword ptr [rsp + 0b0h]                          ; make a copy of joinerLength's type in case it changes before we use it
        ; sentinel check of copy of cursor type Integer expecting Integer
        cmp rax, 000h                                            ; compare type of copy of cursor to <sentinel>
        jne func$join$while$while$if$1$while$if$1$if$copyOfCursor$TypeMatch ; skip next block if copy of cursor is not sentinel
          ; Error handling block for copy of cursor
          ; Call __error with 1 arguments
          mov rsi, offset operandTypeCheckFailureMessage         ; reading operandTypeCheckFailureMessage for push
          push rsi                                               ; value of argument #1 (operandTypeCheckFailureMessage)
          push 039h                                              ; type of argument #1 (String'39)
          lea rbx, qword ptr [rsp + 050h]                        ; load address of return value's value
          push rbx                                               ; internal argument 6: pointer to return value slot's value
          lea rbx, qword ptr [rsp + 048h]                        ; load address of return value's type
          push rbx                                               ; internal argument 5: pointer to return value slot's type
          sub rsp, 020h                                          ; allocate shadow space
          mov r9, 000h                                           ; internal argument 4: "this" pointer
          mov r8, 000h                                           ; internal argument 3: "this" pointer type
          mov rdx, 000h                                          ; internal argument 2: closure pointer
          mov rcx, 001h                                          ; internal argument 1: number of actual arguments
          mov qword ptr [rsp + 058h], r10                        ; move copy of joinerLength's type out of r10
          mov qword ptr [rsp + 048h], rax                        ; move copy of cursor's type out of rax
          call func$__error                                      ; jump to subroutine
          add rsp, 040h                                          ; release shadow space and arguments (result in stack pointer)
          mov rax, qword ptr [rsp + 008h]                        ; restoring slot (copy of cursor) to previous scope state for genuine block exit
          mov r10, qword ptr [rsp + 018h]                        ; restoring slot (copy of joinerLength) to previous scope state for genuine block exit
        func$join$while$while$if$1$while$if$1$if$copyOfCursor$TypeMatch:  ; after block
        ; sentinel check of copy of joinerLength type Integer expecting Integer
        cmp r10, 000h                                            ; compare type of copy of joinerLength to <sentinel>
        jne func$join$while$while$if$1$while$if$1$if$copyOfJoinerlength$TypeMatch ; skip next block if copy of joinerLength is not sentinel
          ; Error handling block for copy of joinerLength
          ; Call __error with 1 arguments
          mov rdi, offset operandTypeCheckFailureMessage         ; reading operandTypeCheckFailureMessage for push
          push rdi                                               ; value of argument #1 (operandTypeCheckFailureMessage)
          push 039h                                              ; type of argument #1 (String'39)
          lea r13, qword ptr [rsp + 050h]                        ; load address of return value's value
          push r13                                               ; internal argument 6: pointer to return value slot's value
          lea r13, qword ptr [rsp + 048h]                        ; load address of return value's type
          push r13                                               ; internal argument 5: pointer to return value slot's type
          sub rsp, 020h                                          ; allocate shadow space
          mov r9, 000h                                           ; internal argument 4: "this" pointer
          mov r8, 000h                                           ; internal argument 3: "this" pointer type
          mov rdx, 000h                                          ; internal argument 2: closure pointer
          mov rcx, 001h                                          ; internal argument 1: number of actual arguments
          mov qword ptr [rsp + 058h], r10                        ; move copy of joinerLength's type out of r10
          mov qword ptr [rsp + 048h], rax                        ; move copy of cursor's type out of rax
          call func$__error                                      ; jump to subroutine
          add rsp, 040h                                          ; release shadow space and arguments (result in stack pointer)
          mov rax, qword ptr [rsp + 008h]                        ; restoring slot (copy of cursor) to previous scope state for genuine block exit
          mov r10, qword ptr [rsp + 018h]                        ; restoring slot (copy of joinerLength) to previous scope state for genuine block exit
        func$join$while$while$if$1$while$if$1$if$copyOfJoinerlength$TypeMatch:  ; after block
        mov r12, r14                                             ; assign value of copy of cursor to value of += operator result
        add r12, r15                                             ; += operator
        ; sentinel check of += operator result type Integer expecting Integer
        mov qword ptr [rsp + 078h], r12                          ; store value
        mov qword ptr [rsp + 070h], 038h                         ; store type (Integer'38)
        mov r14, qword ptr [rsp + 050h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$join$while$while$if$1$if$continuation:                ; end of if
    func$join$while$if$continuation$1:                           ; end of if
    ; Line 233: index += 1;
    mov r15, qword ptr [rsp + 0d0h]                              ; make a copy of index's value in case it changes before we use it
    mov r10, qword ptr [rsp + 0c8h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$join$while$copyOfIndex$TypeMatch$3                  ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 058h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move copy of index's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$join$while$copyOfIndex$TypeMatch$3:                     ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov qword ptr [rsp + 050h], r12                              ; move += operator result's value out of r12
    mov r12, r15                                                 ; assign value of copy of index to value of += operator result
    mov qword ptr [rsp + 040h], r14                              ; move copy of segment's type out of r14
    mov r14, 001h                                                ; read second operand of add (1)
    add r12, r14                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0d0h], r12                              ; store value
    mov qword ptr [rsp + 0c8h], 038h                             ; store type (Integer'38)
    ; Decrement reference count for copy of segment (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 060h]                              ; arg #2: copy of segment's type
    mov rcx, qword ptr [rsp + 068h]                              ; arg #1: copy of segment's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of items[copy of index] (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 078h]                              ; arg #2: copy of items[copy of index]'s type
    mov rcx, qword ptr [rsp + 058h]                              ; arg #1: copy of items[copy of index]'s value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for segment variable (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 080h]                              ; arg #2: segment variable's type
    mov rcx, qword ptr [rsp + 088h]                              ; arg #1: segment variable's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$join$while$top$1                                    ; return to top of while
  func$join$while$bottom$1:                                      ; bottom of while
  ; Line 235: return resultPointer __as__ String;
  mov r10, qword ptr [rsp + 090h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 080h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov rbx, r10                                                   ; force cast of copy of resultPointer to String
  ; sentinel check of force cast of copy of resultPointer to String type String expecting String
  mov qword ptr [rsp + 030h], r12                                ; move += operator result's value out of r12
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of join into register to dereference it
  mov qword ptr [r12], rbx                                       ; join return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of join into register to dereference it
  mov qword ptr [r14], 039h                                      ; type of join return value (String'39)
  ; increment reference count for force cast of copy of resultPointer to String if necessary
    mov rax, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns func$join$StringIncref                                   ; if reference count is negative (constant strings), skip incref
    jmp func$join$AfterStringIncref                              ; skip incref for string constants
    func$join$StringIncref:                                      ; real String
      inc qword ptr [rbx]                                        ; increment reference count of force cast of copy of resultPointer to String
  func$join$AfterStringIncref:                                   ; after String incref
  func$join$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0f8h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _blockListInit
dq func$_blockListInit$annotation
func$_blockListInit:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 058h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 098h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _blockListInit to 1 (integer)
  je func$_blockListInit$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 058h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 058h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_blockListInit$parameterCountCheck$continuation:          ; end of parameter count check
  ; Check type of parameter 0, initialCount (expecting Integer)
  ; type check of initialCount type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store initialCount's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that initialCount is Integer
  jc func$_blockListInit$initialcount$TypeMatch                  ; skip next block if the type matches
    ; Error handling block for initialCount
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_blockListInit$initialcount$TypeMatch:                    ; after block
  ; Line 260: _gcLocked += 1;
  mov r14, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r15, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_blockListInit$copyOfGclocked$TypeMatch               ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 058h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 058h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_blockListInit$copyOfGclocked$TypeMatch:                  ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov r12, 001h                                                  ; read second operand of add (1)
  add rdi, r12                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rdi                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 261: Integer initialSize = initialCount * _blockEntrySize;
  mov r15, qword ptr _blockEntrySizeValue                        ; make a copy of _blockEntrySize's value in case it changes before we use it
  mov r10, qword ptr _blockEntrySizeType                         ; make a copy of _blockEntrySize's type in case it changes before we use it
  ; sentinel check of initialCount type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of initialCount to <sentinel>
  jne func$_blockListInit$initialcount$TypeMatch$1               ; skip next block if initialCount is not sentinel
    mov qword ptr [rsp + 048h], 000h                             ; move initialSize variable's value into a mutable location
    mov qword ptr [rsp + 040h], 000h                             ; move initialSize variable's type into a mutable location
    ; Error handling block for initialCount
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], r10                              ; move copy of _blockEntrySize's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 028h]                              ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
  func$_blockListInit$initialcount$TypeMatch$1:                  ; after block
  ; sentinel check of copy of _blockEntrySize type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _blockEntrySize to <sentinel>
  jne func$_blockListInit$Blockentrysize$TypeMatch               ; skip next block if copy of _blockEntrySize is not sentinel
    ; Error handling block for _blockEntrySize
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 040h], rdi                              ; move += operator result's value out of rdi
    lea rdi, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 060h], r10                              ; move copy of _blockEntrySize's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 020h]                              ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 030h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$_blockListInit$Blockentrysize$TypeMatch:                  ; after block
  mov r12, qword ptr [rbp + 040h]                                ; read left hand side operand of imul (initialCount), which is also the result
  imul r12, r15                                                  ; compute (initialCount) * (copy of _blockEntrySize) (result in * operator result)
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 048h], r12                                ; value initialization of variable declaration for initialSize variable (* operator result)
  mov qword ptr [rsp + 040h], 038h                               ; type initialization of variable declaration for initialSize variable (Integer'38)
  ; Line 262: _blockListStart = _alloc(initialSize);
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of initialSize's value in case it changes before we use it
  mov r10, qword ptr [rsp + 040h]                                ; make a copy of initialSize's type in case it changes before we use it
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push r15                                                       ; value of argument #1 (copy of initialSize)
  push r10                                                       ; type of argument #1
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 030h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne func$_blockListInit$AllocReturnValue$TypeMatch             ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], rdi                              ; move += operator result's value out of rdi
    mov rdi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rdi, qword ptr [rsp + 028h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$_blockListInit$AllocReturnValue$TypeMatch:                ; after block
  mov r11, qword ptr [rsp + 038h]                                ; indirect through r11 because operand pair (qword ptr _blockListStartValue, stack operand #3) is not allowed with mov
  mov qword ptr _blockListStartValue, r11                        ; store value
  mov r11, qword ptr [rsp + 030h]                                ; indirect through r11 because operand pair (qword ptr _blockListStartType, stack operand #4) is not allowed with mov
  mov qword ptr _blockListStartType, r11                         ; store type
  ; Line 263: _blockListEnd = _blockListStart + initialSize;
  mov r13, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov r14, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of initialSize's value in case it changes before we use it
  mov r10, qword ptr [rsp + 040h]                                ; make a copy of initialSize's type in case it changes before we use it
  ; sentinel check of copy of _blockListStart type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _blockListStart to <sentinel>
  jne func$_blockListInit$Blockliststart$TypeMatch               ; skip next block if copy of _blockListStart is not sentinel
    ; Error handling block for _blockListStart
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of initialSize's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 018h]                              ; restoring slot (copy of initialSize) to previous scope state for genuine block exit
  func$_blockListInit$Blockliststart$TypeMatch:                  ; after block
  ; sentinel check of copy of initialSize type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of initialSize to <sentinel>
  jne func$_blockListInit$initialsize$TypeMatch                  ; skip next block if copy of initialSize is not sentinel
    ; Error handling block for initialSize
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 030h], rdi                              ; move += operator result's value out of rdi
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 050h], r10                              ; move copy of initialSize's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 010h]                              ; restoring slot (copy of initialSize) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 020h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$_blockListInit$initialsize$TypeMatch:                     ; after block
  mov r12, r13                                                   ; assign value of copy of _blockListStart to value of + operator result
  add r12, r15                                                   ; compute (copy of _blockListStart) + (copy of initialSize) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _blockListEndValue, r12                          ; store value
  mov qword ptr _blockListEndType, 038h                          ; store type (Integer'38)
  ; Line 264: _blockListNext = _blockListStart;
  mov r15, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov r10, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  ; sentinel check of copy of _blockListStart type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _blockListStart to <sentinel>
  jne func$_blockListInit$copyOfBlockliststart$TypeMatch         ; skip next block if copy of _blockListStart is not sentinel
    ; Error handling block for copy of _blockListStart
    ; Call __error with 1 arguments
    mov rbx, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of _blockListStart's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 018h]                              ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
  func$_blockListInit$copyOfBlockliststart$TypeMatch:            ; after block
  mov qword ptr _blockListNextValue, r15                         ; store value
  mov qword ptr _blockListNextType, r10                          ; store type
  ; Line 265: _fillQuadWords(_blockListStart, initialSize, 0);
  mov rsi, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov qword ptr [rsp + 028h], rdi                                ; move += operator result's value out of rdi
  mov rdi, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  mov qword ptr [rsp + 020h], r12                                ; move + operator result's value out of r12
  mov r12, qword ptr [rsp + 048h]                                ; make a copy of initialSize's value in case it changes before we use it
  mov r13, qword ptr [rsp + 040h]                                ; make a copy of initialSize's type in case it changes before we use it
  ; sentinel check of _fillQuadWords type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _fillQuadWords with 3 arguments
  push 000h                                                      ; value of argument #3 (0)
  push 038h                                                      ; type of argument #3 (Integer'38)
  push r12                                                       ; value of argument #2 (copy of initialSize)
  push r13                                                       ; type of argument #2
  push rsi                                                       ; value of argument #1 (copy of _blockListStart)
  push rdi                                                       ; type of argument #1
  mov qword ptr [rsp + 040h], r10                                ; move copy of _blockListStart's type out of r10
  lea r10, qword ptr [rsp + 048h]                                ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 040h]                                ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_fillQuadWords                                       ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 266: _gcLocked -= 1;
  mov rbx, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rax, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_blockListInit$copyOfGclocked$TypeMatch$1             ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], rax                              ; move copy of _gcLocked's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
  func$_blockListInit$copyOfGclocked$TypeMatch$1:                ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r14, rbx                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov qword ptr [rsp + 018h], r15                                ; move copy of _blockListStart's value out of r15
  mov r15, 001h                                                  ; read second operand of sub (1)
  sub r14, r15                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r14                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Implicit return from _blockListInit
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of _blockListInit into register to dereference it
  mov qword ptr [rdi], 000h                                      ; _blockListInit return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of _blockListInit into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of _blockListInit return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 058h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _growBlockList
dq func$_growBlockList$annotation
func$_growBlockList:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 068h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0a8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of _growBlockList to 0 (integer)
  je func$_growBlockList$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$parameterCountCheck$continuation:          ; end of parameter count check
  ; Line 272: assert(_gcLocked > 0, '_growBlockList called without _gcLocked s...
  mov rbx, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rsi, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_growBlockList$Gclocked$TypeMatch                     ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for _gcLocked
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$Gclocked$TypeMatch:                        ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r15, r15                                                   ; clear > operator result
  cmp rbx, 000h                                                  ; compare copy of _gcLocked with 0
  setg r15b                                                      ; store result in > operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$22                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r15                                                       ; value of argument #1 (> operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rsi, qword ptr [rsp + 070h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 070h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 273: Integer oldLength = _blockListEnd - _blockListStart;
  mov rdi, qword ptr _blockListEndValue                          ; make a copy of _blockListEnd's value in case it changes before we use it
  mov r12, qword ptr _blockListEndType                           ; make a copy of _blockListEnd's type in case it changes before we use it
  mov r13, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov r14, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  ; sentinel check of copy of _blockListEnd type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _blockListEnd to <sentinel>
  jne func$_growBlockList$Blocklistend$TypeMatch                 ; skip next block if copy of _blockListEnd is not sentinel
    mov qword ptr [rsp + 050h], 000h                             ; move oldLength variable's value into a mutable location
    mov qword ptr [rsp + 048h], 000h                             ; move oldLength variable's type into a mutable location
    ; Error handling block for _blockListEnd
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$Blocklistend$TypeMatch:                    ; after block
  ; sentinel check of copy of _blockListStart type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _blockListStart to <sentinel>
  jne func$_growBlockList$Blockliststart$TypeMatch               ; skip next block if copy of _blockListStart is not sentinel
    ; Error handling block for _blockListStart
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$Blockliststart$TypeMatch:                  ; after block
  mov rsi, rdi                                                   ; assign value of copy of _blockListEnd to value of - operator result
  sub rsi, r13                                                   ; compute (copy of _blockListEnd) - (copy of _blockListStart)
  ; sentinel check of - operator result type Integer expecting Integer
  mov qword ptr [rsp + 050h], rsi                                ; value initialization of variable declaration for oldLength variable (- operator result)
  mov qword ptr [rsp + 048h], 038h                               ; type initialization of variable declaration for oldLength variable (Integer'38)
  ; Line 274: Integer newLength = oldLength * 2;
  mov r13, qword ptr [rsp + 050h]                                ; make a copy of oldLength's value in case it changes before we use it
  mov r14, qword ptr [rsp + 048h]                                ; make a copy of oldLength's type in case it changes before we use it
  ; sentinel check of copy of oldLength type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of oldLength to <sentinel>
  jne func$_growBlockList$oldlength$TypeMatch                    ; skip next block if copy of oldLength is not sentinel
    mov qword ptr [rsp + 040h], 000h                             ; move newLength variable's value into a mutable location
    mov qword ptr [rsp + 038h], 000h                             ; move newLength variable's type into a mutable location
    ; Error handling block for oldLength
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$oldlength$TypeMatch:                       ; after block
  ; sentinel check of 2 type Integer expecting Integer
  imul rsi, r13, 002h                                            ; compute (copy of oldLength) * (2) (result in * operator result)
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 040h], rsi                                ; value initialization of variable declaration for newLength variable (* operator result)
  mov qword ptr [rsp + 038h], 038h                               ; type initialization of variable declaration for newLength variable (Integer'38)
  ; Line 275: Integer newBlock = _alloc(newLength);
  mov r13, qword ptr [rsp + 040h]                                ; make a copy of newLength's value in case it changes before we use it
  mov r14, qword ptr [rsp + 038h]                                ; make a copy of newLength's type in case it changes before we use it
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push r13                                                       ; value of argument #1 (copy of newLength)
  push r14                                                       ; type of argument #1
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 018h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne func$_growBlockList$AllocReturnValue$TypeMatch             ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov rbx, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$AllocReturnValue$TypeMatch:                ; after block
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (stack operand #5, stack operand #7) is not allowed with mov
  mov qword ptr [rsp + 030h], r11                                ; value initialization of variable declaration for newBlock variable (_alloc return value)
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (stack operand #6, stack operand #8) is not allowed with mov
  mov qword ptr [rsp + 028h], r11                                ; type initialization of variable declaration for newBlock variable
  ; Line 276: _moveBytes(_blockListStart, newBlock, oldLength);
  mov rdi, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov r12, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  mov r13, qword ptr [rsp + 030h]                                ; make a copy of newBlock's value in case it changes before we use it
  mov r14, qword ptr [rsp + 028h]                                ; make a copy of newBlock's type in case it changes before we use it
  mov r15, qword ptr [rsp + 050h]                                ; make a copy of oldLength's value in case it changes before we use it
  mov r10, qword ptr [rsp + 048h]                                ; make a copy of oldLength's type in case it changes before we use it
  ; sentinel check of _moveBytes type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _moveBytes with 3 arguments
  push r15                                                       ; value of argument #3 (copy of oldLength)
  push r10                                                       ; type of argument #3
  push r13                                                       ; value of argument #2 (copy of newBlock)
  push r14                                                       ; type of argument #2
  push rdi                                                       ; value of argument #1 (copy of _blockListStart)
  push r12                                                       ; type of argument #1
  lea rsi, qword ptr [rsp + 050h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 050h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_moveBytes                                           ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 277: _fillQuadWords(newBlock + oldLength, oldLength, 0);
  mov rdi, qword ptr [rsp + 030h]                                ; make a copy of newBlock's value in case it changes before we use it
  mov r12, qword ptr [rsp + 028h]                                ; make a copy of newBlock's type in case it changes before we use it
  mov r13, qword ptr [rsp + 050h]                                ; make a copy of oldLength's value in case it changes before we use it
  mov r14, qword ptr [rsp + 048h]                                ; make a copy of oldLength's type in case it changes before we use it
  ; sentinel check of copy of newBlock type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of newBlock to <sentinel>
  jne func$_growBlockList$newblock$TypeMatch                     ; skip next block if copy of newBlock is not sentinel
    ; Error handling block for newBlock
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$newblock$TypeMatch:                        ; after block
  ; sentinel check of copy of oldLength type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of oldLength to <sentinel>
  jne func$_growBlockList$oldlength$TypeMatch$1                  ; skip next block if copy of oldLength is not sentinel
    ; Error handling block for oldLength
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 030h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$oldlength$TypeMatch$1:                     ; after block
  mov rsi, rdi                                                   ; assign value of copy of newBlock to value of + operator result
  add rsi, r13                                                   ; compute (copy of newBlock) + (copy of oldLength) (result in + operator result)
  mov rdi, qword ptr [rsp + 050h]                                ; make a copy of oldLength's value in case it changes before we use it
  mov r12, qword ptr [rsp + 048h]                                ; make a copy of oldLength's type in case it changes before we use it
  ; sentinel check of _fillQuadWords type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _fillQuadWords with 3 arguments
  push 000h                                                      ; value of argument #3 (0)
  push 038h                                                      ; type of argument #3 (Integer'38)
  push rdi                                                       ; value of argument #2 (copy of oldLength)
  push r12                                                       ; type of argument #2
  push rsi                                                       ; value of argument #1 (+ operator result)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r15, qword ptr [rsp + 050h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 050h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_fillQuadWords                                       ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 278: _free(_blockListStart);
  mov r10, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov rax, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  ; sentinel check of _free type NullFunction(Integer) expecting AnythingFunction
  ; Call _free with 1 arguments
  push r10                                                       ; value of argument #1 (copy of _blockListStart)
  push rax                                                       ; type of argument #1
  lea rdi, qword ptr [rsp + 030h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 030h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_free                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 279: _blockListStart = newBlock;
  mov r12, qword ptr [rsp + 030h]                                ; make a copy of newBlock's value in case it changes before we use it
  mov r13, qword ptr [rsp + 028h]                                ; make a copy of newBlock's type in case it changes before we use it
  ; sentinel check of copy of newBlock type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of newBlock to <sentinel>
  jne func$_growBlockList$copyOfNewblock$TypeMatch               ; skip next block if copy of newBlock is not sentinel
    ; Error handling block for copy of newBlock
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growBlockList$copyOfNewblock$TypeMatch:                  ; after block
  mov qword ptr _blockListStartValue, r12                        ; store value
  mov qword ptr _blockListStartType, r13                         ; store type
  ; Line 280: _blockListNext = newBlock + oldLength;
  mov r10, qword ptr [rsp + 030h]                                ; make a copy of newBlock's value in case it changes before we use it
  mov rax, qword ptr [rsp + 028h]                                ; make a copy of newBlock's type in case it changes before we use it
  mov rbx, qword ptr [rsp + 050h]                                ; make a copy of oldLength's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 048h]                                ; make a copy of oldLength's type in case it changes before we use it
  ; sentinel check of copy of newBlock type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of newBlock to <sentinel>
  jne func$_growBlockList$newblock$TypeMatch$1                   ; skip next block if copy of newBlock is not sentinel
    ; Error handling block for newBlock
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 028h], r12                              ; move copy of newBlock's value out of r12
    lea r12, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of newBlock's value out of r10
    mov qword ptr [rsp + 040h], rax                              ; move copy of newBlock's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
    mov r12, qword ptr [rsp + 018h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
  func$_growBlockList$newblock$TypeMatch$1:                      ; after block
  ; sentinel check of copy of oldLength type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of oldLength to <sentinel>
  jne func$_growBlockList$oldlength$TypeMatch$2                  ; skip next block if copy of oldLength is not sentinel
    ; Error handling block for oldLength
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 020h], r13                              ; move copy of newBlock's type out of r13
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of newBlock's value out of r10
    mov qword ptr [rsp + 040h], rax                              ; move copy of newBlock's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
    mov r13, qword ptr [rsp + 020h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
  func$_growBlockList$oldlength$TypeMatch$2:                     ; after block
  mov r15, r10                                                   ; assign value of copy of newBlock to value of + operator result
  add r15, rbx                                                   ; compute (copy of newBlock) + (copy of oldLength) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _blockListNextValue, r15                         ; store value
  mov qword ptr _blockListNextType, 038h                         ; store type (Integer'38)
  ; Line 281: _blockListEnd = newBlock + newLength;
  mov rbx, qword ptr [rsp + 030h]                                ; make a copy of newBlock's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 028h]                                ; make a copy of newBlock's type in case it changes before we use it
  mov rdi, qword ptr [rsp + 040h]                                ; make a copy of newLength's value in case it changes before we use it
  mov qword ptr [rsp + 020h], r12                                ; move copy of newBlock's value out of r12
  mov r12, qword ptr [rsp + 038h]                                ; make a copy of newLength's type in case it changes before we use it
  ; sentinel check of copy of newBlock type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of newBlock to <sentinel>
  jne func$_growBlockList$newblock$TypeMatch$2                   ; skip next block if copy of newBlock is not sentinel
    ; Error handling block for newBlock
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 018h], r13                              ; move copy of newBlock's type out of r13
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 018h]                              ; restoring slot (copy of newBlock) to previous scope state for genuine block exit
  func$_growBlockList$newblock$TypeMatch$2:                      ; after block
  ; sentinel check of copy of newLength type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of newLength to <sentinel>
  jne func$_growBlockList$newlength$TypeMatch                    ; skip next block if copy of newLength is not sentinel
    ; Error handling block for newLength
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 018h], r15                              ; move + operator result's value out of r15
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r15, qword ptr [rsp + 018h]                              ; restoring slot (+ operator result) to previous scope state for genuine block exit
  func$_growBlockList$newlength$TypeMatch:                       ; after block
  mov rax, rbx                                                   ; assign value of copy of newBlock to value of + operator result
  add rax, rdi                                                   ; compute (copy of newBlock) + (copy of newLength) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr _blockListEndValue, rax                          ; store value
  mov qword ptr _blockListEndType, 038h                          ; store type (Integer'38)
  ; Implicit return from _growBlockList
  ; sentinel check of null type Null expecting Null
  mov qword ptr [rsp + 018h], r13                                ; move copy of newBlock's type out of r13
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of _growBlockList into register to dereference it
  mov qword ptr [r13], 000h                                      ; _growBlockList return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of _growBlockList into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of _growBlockList return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 068h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _advanceToNextBlock
dq func$_advanceToNextBlock$annotation
func$_advanceToNextBlock:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 058h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 098h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of _advanceToNextBlock to 0 (integer)
  je func$_advanceToNextBlock$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_advanceToNextBlock$parameterCountCheck$continuation:     ; end of parameter count check
  ; Line 285: assert(_gcLocked > 0, '_advanceToNextBlock called without _gcLoc...
  mov rbx, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rsi, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_advanceToNextBlock$Gclocked$TypeMatch                ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for _gcLocked
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_advanceToNextBlock$Gclocked$TypeMatch:                   ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r15, r15                                                   ; clear > operator result
  cmp rbx, 000h                                                  ; compare copy of _gcLocked with 0
  setg r15b                                                      ; store result in > operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$23                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r15                                                       ; value of argument #1 (> operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rsi, qword ptr [rsp + 060h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 060h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 286: Integer last = _blockListNext;
  mov rdi, qword ptr _blockListNextValue                         ; make a copy of _blockListNext's value in case it changes before we use it
  mov r12, qword ptr _blockListNextType                          ; make a copy of _blockListNext's type in case it changes before we use it
  ; sentinel check of copy of _blockListNext type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _blockListNext to <sentinel>
  jne func$_advanceToNextBlock$copyOfBlocklistnext$TypeMatch     ; skip next block if copy of _blockListNext is not sentinel
    mov qword ptr [rsp + 040h], 000h                             ; move last variable's value into a mutable location
    mov qword ptr [rsp + 038h], 000h                             ; move last variable's type into a mutable location
    ; Error handling block for copy of _blockListNext
    ; Call __error with 1 arguments
    mov r13, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_advanceToNextBlock$copyOfBlocklistnext$TypeMatch:        ; after block
  mov qword ptr [rsp + 040h], rdi                                ; value initialization of variable declaration for last variable (copy of _blockListNext)
  mov qword ptr [rsp + 038h], r12                                ; type initialization of variable declaration for last variable
  func$_advanceToNextBlock$while$top:                            ; top of while
    ; Line 288: _blockListNext += _blockEntrySize;
    mov r15, qword ptr _blockListNextValue                       ; make a copy of _blockListNext's value in case it changes before we use it
    mov r10, qword ptr _blockListNextType                        ; make a copy of _blockListNext's type in case it changes before we use it
    mov rax, qword ptr _blockEntrySizeValue                      ; make a copy of _blockEntrySize's value in case it changes before we use it
    mov rbx, qword ptr _blockEntrySizeType                       ; make a copy of _blockEntrySize's type in case it changes before we use it
    ; sentinel check of copy of _blockListNext type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of _blockListNext to <sentinel>
    jne func$_advanceToNextBlock$while$copyOfBlocklistnext$TypeMatch ; skip next block if copy of _blockListNext is not sentinel
      ; Error handling block for copy of _blockListNext
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 040h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], r10                            ; move copy of _blockListNext's type out of r10
      mov qword ptr [rsp + 058h], rax                            ; move copy of _blockEntrySize's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 018h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 020h]                            ; restoring slot (copy of _blockListNext) to previous scope state for genuine block exit
    func$_advanceToNextBlock$while$copyOfBlocklistnext$TypeMatch:  ; after block
    ; sentinel check of copy of _blockEntrySize type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of _blockEntrySize to <sentinel>
    jne func$_advanceToNextBlock$while$copyOfBlockentrysize$TypeMatch ; skip next block if copy of _blockEntrySize is not sentinel
      ; Error handling block for copy of _blockEntrySize
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 040h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 040h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], r10                            ; move copy of _blockListNext's type out of r10
      mov qword ptr [rsp + 058h], rax                            ; move copy of _blockEntrySize's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 018h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 020h]                            ; restoring slot (copy of _blockListNext) to previous scope state for genuine block exit
    func$_advanceToNextBlock$while$copyOfBlockentrysize$TypeMatch:  ; after block
    mov r14, r15                                                 ; assign value of copy of _blockListNext to value of += operator result
    add r14, rax                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr _blockListNextValue, r14                       ; store value
    mov qword ptr _blockListNextType, 038h                       ; store type (Integer'38)
    ; Line 289: if (_blockListNext == last) { ...
    mov rax, qword ptr _blockListNextValue                       ; make a copy of _blockListNext's value in case it changes before we use it
    mov rbx, qword ptr _blockListNextType                        ; make a copy of _blockListNext's type in case it changes before we use it
    mov rsi, qword ptr [rsp + 040h]                              ; make a copy of last's value in case it changes before we use it
    mov rdi, qword ptr [rsp + 038h]                              ; make a copy of last's type in case it changes before we use it
    xor r12, r12                                                 ; zero value result of == (testing copy of _blockListNext and copy of last) to put the boolean in
    cmp rax, rsi                                                 ; values equal?
    sete r12b                                                    ; put result in value result of == (testing copy of _blockListNext and copy of last)
    mov r13, 037h                                                ; value result of == (testing copy of _blockListNext and copy of last) is a Boolean'37
    mov qword ptr [rsp + 030h], r14                              ; move += operator result's value out of r14
    xor r14, r14                                                 ; zero type result of == (testing copy of _blockListNext and copy of last) to put the boolean in
    cmp rbx, rdi                                                 ; types equal?
    sete r14b                                                    ; put result in type result of == (testing copy of _blockListNext and copy of last)
    mov r15, 037h                                                ; type result of == (testing copy of _blockListNext and copy of last) is a Boolean'37
    mov r10, r12                                                 ; assign value of value result of == (testing copy of _blockListNext and copy of last) to value of == operator result
    and r10, r14                                                 ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp r10, 000h                                                ; compare == operator result to false
    je func$_advanceToNextBlock$while$if$continuation            ; _blockListNext == last
      ; Line 291: _growBlockList();
      ; sentinel check of _growBlockList type NullFunction() expecting AnythingFunction
      ; Call _growBlockList with 0 arguments
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 000h                                              ; internal argument 1: number of actual arguments
      call func$_growBlockList                                   ; jump to subroutine
      add rsp, 030h                                              ; release shadow space and arguments (result in stack pointer)
      ; Line 292: return;
      ; sentinel check of null type Null expecting Null
      mov r13, qword ptr [rbp + 030h]                            ; get pointer to return value of _advanceToNextBlock into register to dereference it
      mov qword ptr [r13], 000h                                  ; _advanceToNextBlock return value
      mov r14, qword ptr [rbp + 028h]                            ; get pointer to return value type of _advanceToNextBlock into register to dereference it
      mov qword ptr [r14], 036h                                  ; type of _advanceToNextBlock return value (Null'36)
      jmp func$_advanceToNextBlock$epilog                        ; return
    func$_advanceToNextBlock$while$if$continuation:              ; end of if
    ; Line 294: if (_blockListNext == _blockListEnd) { ...
    mov r15, qword ptr _blockListNextValue                       ; make a copy of _blockListNext's value in case it changes before we use it
    mov r10, qword ptr _blockListNextType                        ; make a copy of _blockListNext's type in case it changes before we use it
    mov rax, qword ptr _blockListEndValue                        ; make a copy of _blockListEnd's value in case it changes before we use it
    mov rbx, qword ptr _blockListEndType                         ; make a copy of _blockListEnd's type in case it changes before we use it
    xor rsi, rsi                                                 ; zero value result of == (testing copy of _blockListNext and copy of _blockListEnd) to put the boolean in
    cmp r15, rax                                                 ; values equal?
    sete sil                                                     ; put result in value result of == (testing copy of _blockListNext and copy of _blockListEnd)
    mov rdi, 037h                                                ; value result of == (testing copy of _blockListNext and copy of _blockListEnd) is a Boolean'37
    xor r12, r12                                                 ; zero type result of == (testing copy of _blockListNext and copy of _blockListEnd) to put the boolean in
    cmp r10, rbx                                                 ; types equal?
    sete r12b                                                    ; put result in type result of == (testing copy of _blockListNext and copy of _blockListEnd)
    mov r9, 037h                                                 ; type result of == (testing copy of _blockListNext and copy of _blockListEnd) is a Boolean'37
    mov r8, rsi                                                  ; assign value of value result of == (testing copy of _blockListNext and copy of _blockListEnd) to value of == operator result
    and r8, r12                                                  ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp r8, 000h                                                 ; compare == operator result to false
    je func$_advanceToNextBlock$while$if$continuation$1          ; _blockListNext == _blockListEnd
      ; Line 295: _blockListNext = _blockListStart;
      mov r13, qword ptr _blockListStartValue                    ; make a copy of _blockListStart's value in case it changes before we use it
      mov r14, qword ptr _blockListStartType                     ; make a copy of _blockListStart's type in case it changes before we use it
      ; sentinel check of copy of _blockListStart type Integer expecting Integer
      cmp r14, 000h                                              ; compare type of copy of _blockListStart to <sentinel>
      jne func$_advanceToNextBlock$while$while$if$3$copyOfBlockliststart$TypeMatch ; skip next block if copy of _blockListStart is not sentinel
        ; Error handling block for copy of _blockListStart
        ; Call __error with 1 arguments
        mov r15, offset assignmentTypeCheckFailureMessage        ; reading assignmentTypeCheckFailureMessage for push
        push r15                                                 ; value of argument #1 (assignmentTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r10, qword ptr [rsp + 038h]                          ; load address of return value's value
        push r10                                                 ; internal argument 6: pointer to return value slot's value
        lea r10, qword ptr [rsp + 038h]                          ; load address of return value's type
        push r10                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_advanceToNextBlock$while$while$if$3$copyOfBlockliststart$TypeMatch:  ; after block
      mov qword ptr _blockListNextValue, r13                     ; store value
      mov qword ptr _blockListNextType, r14                      ; store type
    func$_advanceToNextBlock$while$if$continuation$1:            ; end of if
    ; Line 297: Integer pointer = __readFromAddress(_blockListNext);
    mov rax, qword ptr _blockListNextValue                       ; make a copy of _blockListNext's value in case it changes before we use it
    mov rbx, qword ptr _blockListNextType                        ; make a copy of _blockListNext's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r12, qword ptr [rax]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of _blockListNext type Integer expecting Integer
    mov qword ptr [rsp + 028h], r12                              ; value initialization of variable declaration for pointer variable (dereferenced copy of _blockListNext)
    mov qword ptr [rsp + 020h], 038h                             ; type initialization of variable declaration for pointer variable (Integer'38)
    ; Line 298: if (pointer == 0) { ...
    mov r15, qword ptr [rsp + 028h]                              ; make a copy of pointer's value in case it changes before we use it
    mov r10, qword ptr [rsp + 020h]                              ; make a copy of pointer's type in case it changes before we use it
    xor rax, rax                                                 ; zero value result of == (testing copy of pointer and 0) to put the boolean in
    cmp r15, 000h                                                ; values equal?
    sete al                                                      ; put result in value result of == (testing copy of pointer and 0)
    mov rbx, 037h                                                ; value result of == (testing copy of pointer and 0) is a Boolean'37
    xor rsi, rsi                                                 ; zero type result of == (testing copy of pointer and 0) to put the boolean in
    cmp r10, 038h                                                ; types equal?
    sete sil                                                     ; put result in type result of == (testing copy of pointer and 0)
    mov rdi, 037h                                                ; type result of == (testing copy of pointer and 0) is a Boolean'37
    mov r12, rax                                                 ; assign value of value result of == (testing copy of pointer and 0) to value of == operator result
    and r12, rsi                                                 ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp r12, 000h                                                ; compare == operator result to false
    je func$_advanceToNextBlock$while$if$continuation$2          ; pointer == 0
      ; Line 300: return;
      ; sentinel check of null type Null expecting Null
      mov rax, qword ptr [rbp + 030h]                            ; get pointer to return value of _advanceToNextBlock into register to dereference it
      mov qword ptr [rax], 000h                                  ; _advanceToNextBlock return value
      mov rbx, qword ptr [rbp + 028h]                            ; get pointer to return value type of _advanceToNextBlock into register to dereference it
      mov qword ptr [rbx], 036h                                  ; type of _advanceToNextBlock return value (Null'36)
      jmp func$_advanceToNextBlock$epilog                        ; return
    func$_advanceToNextBlock$while$if$continuation$2:            ; end of if
    jmp func$_advanceToNextBlock$while$top                       ; return to top of while
  func$_advanceToNextBlock$while$bottom:                         ; bottom of while
  ; Implicit return from _advanceToNextBlock
  ; sentinel check of null type Null expecting Null
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of _advanceToNextBlock into register to dereference it
  mov qword ptr [r12], 000h                                      ; _advanceToNextBlock return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of _advanceToNextBlock into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of _advanceToNextBlock return value (Null'36)
  func$_advanceToNextBlock$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 058h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _constructor
dq func$_constructor$annotation
func$_constructor:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of _constructor to 3 (integer)
  je func$_constructor$parameterCountCheck$continuation          ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$parameterCountCheck$continuation:            ; end of parameter count check
  ; Check type of parameter 0, typeCode (expecting Integer)
  ; type check of typeCode type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store typeCode's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that typeCode is Integer
  jc func$_constructor$typecode$TypeMatch                        ; skip next block if the type matches
    ; Error handling block for typeCode
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$typecode$TypeMatch:                          ; after block
  ; Check type of parameter 1, length (expecting Integer)
  ; type check of length type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store length's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that length is Integer
  jc func$_constructor$length$TypeMatch                          ; skip next block if the type matches
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$length$TypeMatch:                            ; after block
  ; Check type of parameter 2, size (expecting Integer)
  ; type check of size type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store size's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that size is Integer
  jc func$_constructor$size$TypeMatch                            ; skip next block if the type matches
    ; Error handling block for size
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$size$TypeMatch:                              ; after block
  ; Line 306: assert(_gcLocked > 0, '_constructor called without _gcLocked set...
  mov r10, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rbx, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_constructor$Gclocked$TypeMatch                       ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for _gcLocked
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of _gcLocked's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 018h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
  func$_constructor$Gclocked$TypeMatch:                          ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r13, r13                                                   ; clear > operator result
  cmp r10, 000h                                                  ; compare copy of _gcLocked with 0
  setg r13b                                                      ; store result in > operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r10, offset string$24                                      ; reading string for push
  push r10                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r13                                                       ; value of argument #1 (> operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rbx, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 307: assert(size >= length, 'length cannot be bigger than size');
  ; sentinel check of size type Integer expecting Integer
  cmp qword ptr [rbp + 058h], 000h                               ; compare type of size to <sentinel>
  jne func$_constructor$size$TypeMatch$1                         ; skip next block if size is not sentinel
    ; Error handling block for size
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$size$TypeMatch$1:                            ; after block
  ; sentinel check of length type Integer expecting Integer
  cmp qword ptr [rbp + 048h], 000h                               ; compare type of length to <sentinel>
  jne func$_constructor$length$TypeMatch$1                       ; skip next block if length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$length$TypeMatch$1:                          ; after block
  mov r13, qword ptr [rbp + 050h]                                ; reading second value to compare (<ParameterSlot:Integer'38 ("length")>)
  xor r14, r14                                                   ; clear >= operator result
  cmp qword ptr [rbp + 060h], r13                                ; compare size with length
  setge r14b                                                     ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rbx, offset string$25                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r14                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 308: Integer resultPointer = _alloc(64 /* 0x40 */ + 16 /* 0x10 */ * s...
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of size type Integer expecting Integer
  cmp qword ptr [rbp + 058h], 000h                               ; compare type of size to <sentinel>
  jne func$_constructor$size$TypeMatch$2                         ; skip next block if size is not sentinel
    ; Error handling block for size
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$size$TypeMatch$2:                            ; after block
  mov r14, 010h                                                  ; read left hand side operand of imul (16 /* 0x10 */), which is also the result
  imul r14, qword ptr [rbp + 060h]                               ; compute (16 /* 0x10 */) * (size) (result in * operator result)
  ; sentinel check of 64 /* 0x40 */ type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov rdi, 040h                                                  ; assign value of 64 /* 0x40 */ to value of + operator result
  add rdi, r14                                                   ; compute (64 /* 0x40 */) + (* operator result) (result in + operator result)
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push rdi                                                       ; value of argument #1 (+ operator result)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r13, qword ptr [rsp + 028h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 028h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne func$_constructor$AllocReturnValue$TypeMatch               ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$AllocReturnValue$TypeMatch:                  ; after block
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (stack operand #1, stack operand #3) is not allowed with mov
  mov qword ptr [rsp + 028h], r11                                ; value initialization of variable declaration for resultPointer variable (_alloc return value)
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (stack operand #2, stack operand #4) is not allowed with mov
  mov qword ptr [rsp + 020h], r11                                ; type initialization of variable declaration for resultPointer variable
  ; Line 309: __writeToAddress(resultPointer + _gcBlockHeaderRefCount, 0);
  mov r10, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov rsi, qword ptr _gcBlockHeaderRefCountValue                 ; make a copy of _gcBlockHeaderRefCount's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockHeaderRefCountType                  ; make a copy of _gcBlockHeaderRefCount's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_constructor$resultpointer$TypeMatch                  ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of resultPointer's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of resultPointer) to previous scope state for genuine block exit
  func$_constructor$resultpointer$TypeMatch:                     ; after block
  ; sentinel check of copy of _gcBlockHeaderRefCount type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockHeaderRefCount to <sentinel>
  jne func$_constructor$Gcblockheaderrefcount$TypeMatch          ; skip next block if copy of _gcBlockHeaderRefCount is not sentinel
    ; Error handling block for _gcBlockHeaderRefCount
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of resultPointer's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of resultPointer) to previous scope state for genuine block exit
  func$_constructor$Gcblockheaderrefcount$TypeMatch:             ; after block
  mov r15, r10                                                   ; assign value of copy of resultPointer to value of + operator result
  add r15, rsi                                                   ; compute (copy of resultPointer) + (copy of _gcBlockHeaderRefCount) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], 000h                                      ; __writeToAddress
  ; Line 310: __writeToAddress(resultPointer + _gcBlockHeaderLength, length);
  mov rsi, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rdi, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov rax, qword ptr _gcBlockHeaderLengthValue                   ; make a copy of _gcBlockHeaderLength's value in case it changes before we use it
  mov r12, qword ptr _gcBlockHeaderLengthType                    ; make a copy of _gcBlockHeaderLength's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_constructor$resultpointer$TypeMatch$1                ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], rax                              ; move copy of _gcBlockHeaderLength's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcBlockHeaderLength) to previous scope state for genuine block exit
  func$_constructor$resultpointer$TypeMatch$1:                   ; after block
  ; sentinel check of copy of _gcBlockHeaderLength type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcBlockHeaderLength to <sentinel>
  jne func$_constructor$Gcblockheaderlength$TypeMatch            ; skip next block if copy of _gcBlockHeaderLength is not sentinel
    ; Error handling block for _gcBlockHeaderLength
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], rax                              ; move copy of _gcBlockHeaderLength's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcBlockHeaderLength) to previous scope state for genuine block exit
  func$_constructor$Gcblockheaderlength$TypeMatch:               ; after block
  mov rbx, rsi                                                   ; assign value of copy of resultPointer to value of + operator result
  add rbx, rax                                                   ; compute (copy of resultPointer) + (copy of _gcBlockHeaderLength) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov rax, qword ptr [rbp + 050h]                                ; read second operand of mov (length) for MoveToDerefInstruction
  mov qword ptr [rbx], rax                                       ; __writeToAddress
  ; Line 311: __writeToAddress(resultPointer + _gcBlockHeaderScratchSpace, 0);...
  mov r12, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r13, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov r14, qword ptr _gcBlockHeaderScratchSpaceValue             ; make a copy of _gcBlockHeaderScratchSpace's value in case it changes before we use it
  mov r15, qword ptr _gcBlockHeaderScratchSpaceType              ; make a copy of _gcBlockHeaderScratchSpace's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_constructor$resultpointer$TypeMatch$2                ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$resultpointer$TypeMatch$2:                   ; after block
  ; sentinel check of copy of _gcBlockHeaderScratchSpace type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcBlockHeaderScratchSpace to <sentinel>
  jne func$_constructor$Gcblockheaderscratchspace$TypeMatch      ; skip next block if copy of _gcBlockHeaderScratchSpace is not sentinel
    ; Error handling block for _gcBlockHeaderScratchSpace
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$Gcblockheaderscratchspace$TypeMatch:         ; after block
  mov rax, r12                                                   ; assign value of copy of resultPointer to value of + operator result
  add rax, r14                                                   ; compute (copy of resultPointer) + (copy of _gcBlockHeaderScratchSpace) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rax], 000h                                      ; __writeToAddress
  ; Line 312: __writeToAddress(resultPointer + _gcBlockHeaderEntryPointer, _bl...
  mov r14, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r15, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov r10, qword ptr _gcBlockHeaderEntryPointerValue             ; make a copy of _gcBlockHeaderEntryPointer's value in case it changes before we use it
  mov rbx, qword ptr _gcBlockHeaderEntryPointerType              ; make a copy of _gcBlockHeaderEntryPointer's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_constructor$resultpointer$TypeMatch$3                ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _gcBlockHeaderEntryPointer's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcBlockHeaderEntryPointer) to previous scope state for genuine block exit
  func$_constructor$resultpointer$TypeMatch$3:                   ; after block
  ; sentinel check of copy of _gcBlockHeaderEntryPointer type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcBlockHeaderEntryPointer to <sentinel>
  jne func$_constructor$Gcblockheaderentrypointer$TypeMatch      ; skip next block if copy of _gcBlockHeaderEntryPointer is not sentinel
    ; Error handling block for _gcBlockHeaderEntryPointer
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _gcBlockHeaderEntryPointer's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcBlockHeaderEntryPointer) to previous scope state for genuine block exit
  func$_constructor$Gcblockheaderentrypointer$TypeMatch:         ; after block
  mov r13, r14                                                   ; assign value of copy of resultPointer to value of + operator result
  add r13, r10                                                   ; compute (copy of resultPointer) + (copy of _gcBlockHeaderEntryPointer) (result in + operator result)
  mov r14, qword ptr _blockListNextValue                         ; make a copy of _blockListNext's value in case it changes before we use it
  mov r15, qword ptr _blockListNextType                          ; make a copy of _blockListNext's type in case it changes before we use it
  mov r10, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov rbx, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  ; sentinel check of copy of _blockListNext type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _blockListNext to <sentinel>
  jne func$_constructor$Blocklistnext$TypeMatch                  ; skip next block if copy of _blockListNext is not sentinel
    ; Error handling block for _blockListNext
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _blockListStart's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
  func$_constructor$Blocklistnext$TypeMatch:                     ; after block
  ; sentinel check of copy of _blockListStart type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _blockListStart to <sentinel>
  jne func$_constructor$Blockliststart$TypeMatch                 ; skip next block if copy of _blockListStart is not sentinel
    ; Error handling block for _blockListStart
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _blockListStart's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
  func$_constructor$Blockliststart$TypeMatch:                    ; after block
  mov qword ptr [rsp + 018h], r13                                ; move + operator result's value out of r13
  mov r13, r14                                                   ; assign value of copy of _blockListNext to value of - operator result
  sub r13, r10                                                   ; compute (copy of _blockListNext) - (copy of _blockListStart)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov r10, qword ptr [rsp + 018h]                                ; get + operator result into register to dereference it
  mov qword ptr [r10], r13                                       ; __writeToAddress
  ; Line 313: __writeToAddress(_blockListNext, resultPointer);
  mov rbx, qword ptr _blockListNextValue                         ; make a copy of _blockListNext's value in case it changes before we use it
  mov rsi, qword ptr _blockListNextType                          ; make a copy of _blockListNext's type in case it changes before we use it
  mov rdi, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rax, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rbx], rdi                                       ; __writeToAddress
  ; Line 314: _advanceToNextBlock();
  ; sentinel check of _advanceToNextBlock type NullFunction() expecting AnythingFunction
  ; Call _advanceToNextBlock with 0 arguments
  lea r10, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 000h                                                  ; internal argument 1: number of actual arguments
  call func$_advanceToNextBlock                                  ; jump to subroutine
  add rsp, 030h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 315: _debugLiveBlocks += 1;
  mov rbx, qword ptr _debugLiveBlocksValue                       ; make a copy of _debugLiveBlocks's value in case it changes before we use it
  mov rsi, qword ptr _debugLiveBlocksType                        ; make a copy of _debugLiveBlocks's type in case it changes before we use it
  ; sentinel check of copy of _debugLiveBlocks type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _debugLiveBlocks to <sentinel>
  jne func$_constructor$copyOfDebugliveblocks$TypeMatch          ; skip next block if copy of _debugLiveBlocks is not sentinel
    ; Error handling block for copy of _debugLiveBlocks
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$copyOfDebugliveblocks$TypeMatch:             ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r14, rbx                                                   ; assign value of copy of _debugLiveBlocks to value of += operator result
  mov r15, 001h                                                  ; read second operand of add (1)
  add r14, r15                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _debugLiveBlocksValue, r14                       ; store value
  mov qword ptr _debugLiveBlocksType, 038h                       ; store type (Integer'38)
  ; Line 316: return resultPointer __dynamic_as__ typeCode as GarbageCollectab...
  mov rsi, qword ptr [rsp + 028h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rdi, qword ptr [rsp + 020h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov rax, rsi                                                   ; force cast of copy of resultPointer to the type with code typeCode
  mov r12, qword ptr [rbp + 040h]                                ; store typeCode value in force cast of copy of resultPointer to the type with code typeCode's type slot
  ; type check of force cast of copy of resultPointer to the type with code typeCode type Anything expecting GarbageCollectable
  mov r13, r12                                                   ; store force cast of copy of resultPointer to the type with code typeCode's type in testByte value slot
  mov qword ptr [rsp + 018h], rax                                ; move force cast of copy of resultPointer to the type with code typeCode's value out of rax
  mov rax, r13                                                   ; move testByte to testByte
  mov qword ptr [rsp + 010h], r14                                ; move += operator result's value out of r14
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that resultPointer __dynamic_as__ typeCode as GarbageCollectable is GarbageCollectable
  jc func$_constructor$resultpointerDynamicAsTypecodeAsGArbagecollectable$TypeMatch ; skip next block if the type matches
    ; Error handling block for resultPointer __dynamic_as__ typeCode as GarbageCollectable
    ; Call __error with 1 arguments
    mov r10, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push r10                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$resultpointerDynamicAsTypecodeAsGArbagecollectable$TypeMatch:  ; after block
  mov rsi, qword ptr [rsp + 018h]                                ; copy value of force cast of copy of resultPointer to the type with code typeCode for cast to GarbageCollectable
  mov rdi, r12                                                   ; copy type of force cast of copy of resultPointer to the type with code typeCode for cast to GarbageCollectable
  ; sentinel check of cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable type GarbageCollectable expecting GarbageCollectable
  cmp rdi, 000h                                                  ; compare type of cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable to <sentinel>
  jne func$_constructor$ConstructorReturnValue$TypeMatch         ; skip next block if cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable is not sentinel
    ; Error handling block for _constructor return value
    ; Call __error with 1 arguments
    mov r12, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_constructor$ConstructorReturnValue$TypeMatch:            ; after block
  mov rax, qword ptr [rbp + 030h]                                ; get pointer to return value of _constructor into register to dereference it
  mov qword ptr [rax], rsi                                       ; _constructor return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of _constructor into register to dereference it
  mov qword ptr [r14], rdi                                       ; type of _constructor return value
  ; increment reference count for cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable if necessary
  mov r15, rdi                                                   ; store cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_constructor$AfterGCIncref                            ; if not a GarbageCollectable, skip incref
    inc qword ptr [rsi]                                          ; increment reference count of cast of force cast of copy of resultPointer to the type with code typeCode to GarbageCollectable
  func$_constructor$AfterGCIncref:                               ; after GarbageCollectable incref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _mark
dq func$_mark$annotation
func$_mark:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 068h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0a8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of _mark to 2 (integer)
  je func$_mark$parameterCountCheck$continuation                 ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$parameterCountCheck$continuation:                   ; end of parameter count check
  ; Check type of parameter 0, pointer (expecting Integer)
  ; type check of pointer type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store pointer's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that pointer is Integer
  jc func$_mark$pointer$TypeMatch                                ; skip next block if the type matches
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$pointer$TypeMatch:                                  ; after block
  ; Check type of parameter 1, tag (expecting Integer)
  ; type check of tag type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store tag's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that tag is Integer
  jc func$_mark$tag$TypeMatch                                    ; skip next block if the type matches
    ; Error handling block for tag
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$tag$TypeMatch:                                      ; after block
  ; Line 320: Integer blockScratchSpace = __readFromAddress(pointer + _gcBlock...
  mov rdi, qword ptr _gcBlockHeaderScratchSpaceValue             ; make a copy of _gcBlockHeaderScratchSpace's value in case it changes before we use it
  mov r12, qword ptr _gcBlockHeaderScratchSpaceType              ; make a copy of _gcBlockHeaderScratchSpace's type in case it changes before we use it
  ; sentinel check of pointer type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of pointer to <sentinel>
  jne func$_mark$pointer$TypeMatch$1                             ; skip next block if pointer is not sentinel
    mov qword ptr [rsp + 050h], 000h                             ; move blockScratchSpace variable's value into a mutable location
    mov qword ptr [rsp + 048h], 000h                             ; move blockScratchSpace variable's type into a mutable location
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$pointer$TypeMatch$1:                                ; after block
  ; sentinel check of copy of _gcBlockHeaderScratchSpace type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcBlockHeaderScratchSpace to <sentinel>
  jne func$_mark$Gcblockheaderscratchspace$TypeMatch             ; skip next block if copy of _gcBlockHeaderScratchSpace is not sentinel
    ; Error handling block for _gcBlockHeaderScratchSpace
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$Gcblockheaderscratchspace$TypeMatch:                ; after block
  mov r10, qword ptr [rbp + 040h]                                ; assign value of pointer to value of + operator result
  add r10, rdi                                                   ; compute (pointer) + (copy of _gcBlockHeaderScratchSpace) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rdi, qword ptr [r10]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 050h], rdi                                ; value initialization of variable declaration for blockScratchSpace variable (dereferenced + operator result)
  mov qword ptr [rsp + 048h], 038h                               ; type initialization of variable declaration for blockScratchSpace variable (Integer'38)
  ; Line 321: if (blockScratchSpace == tag) { ...
  mov r14, qword ptr [rsp + 050h]                                ; make a copy of blockScratchSpace's value in case it changes before we use it
  mov rax, qword ptr [rsp + 048h]                                ; make a copy of blockScratchSpace's type in case it changes before we use it
  xor r15, r15                                                   ; zero value result of == (testing copy of blockScratchSpace and tag) to put the boolean in
  cmp r14, qword ptr [rbp + 050h]                                ; values equal?
  sete r15b                                                      ; put result in value result of == (testing copy of blockScratchSpace and tag)
  mov r10, 037h                                                  ; value result of == (testing copy of blockScratchSpace and tag) is a Boolean'37
  xor rbx, rbx                                                   ; zero type result of == (testing copy of blockScratchSpace and tag) to put the boolean in
  cmp rax, qword ptr [rbp + 048h]                                ; types equal?
  sete bl                                                        ; put result in type result of == (testing copy of blockScratchSpace and tag)
  mov rsi, 037h                                                  ; type result of == (testing copy of blockScratchSpace and tag) is a Boolean'37
  mov rdi, r15                                                   ; assign value of value result of == (testing copy of blockScratchSpace and tag) to value of == operator result
  and rdi, rbx                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rdi, 000h                                                  ; compare == operator result to false
  je func$_mark$if$continuation                                  ; blockScratchSpace == tag
    ; Line 322: return;
    ; sentinel check of null type Null expecting Null
    mov r15, qword ptr [rbp + 030h]                              ; get pointer to return value of _mark into register to dereference it
    mov qword ptr [r15], 000h                                    ; _mark return value
    mov r10, qword ptr [rbp + 028h]                              ; get pointer to return value type of _mark into register to dereference it
    mov qword ptr [r10], 036h                                    ; type of _mark return value (Null'36)
    jmp func$_mark$epilog                                        ; return
  func$_mark$if$continuation:                                    ; end of if
  ; Line 324: __writeToAddress(pointer + _gcBlockHeaderScratchSpace, tag);
  mov rbx, qword ptr _gcBlockHeaderScratchSpaceValue             ; make a copy of _gcBlockHeaderScratchSpace's value in case it changes before we use it
  mov rsi, qword ptr _gcBlockHeaderScratchSpaceType              ; make a copy of _gcBlockHeaderScratchSpace's type in case it changes before we use it
  ; sentinel check of pointer type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of pointer to <sentinel>
  jne func$_mark$pointer$TypeMatch$2                             ; skip next block if pointer is not sentinel
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$pointer$TypeMatch$2:                                ; after block
  ; sentinel check of copy of _gcBlockHeaderScratchSpace type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcBlockHeaderScratchSpace to <sentinel>
  jne func$_mark$Gcblockheaderscratchspace$TypeMatch$1           ; skip next block if copy of _gcBlockHeaderScratchSpace is not sentinel
    ; Error handling block for _gcBlockHeaderScratchSpace
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$Gcblockheaderscratchspace$TypeMatch$1:              ; after block
  mov rax, qword ptr [rbp + 040h]                                ; assign value of pointer to value of + operator result
  add rax, rbx                                                   ; compute (pointer) + (copy of _gcBlockHeaderScratchSpace) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov rbx, qword ptr [rbp + 050h]                                ; read second operand of mov (tag) for MoveToDerefInstruction
  mov qword ptr [rax], rbx                                       ; __writeToAddress
  ; Line 325: Integer blockLength = __readFromAddress(pointer + _gcBlockHeader...
  mov rsi, qword ptr _gcBlockHeaderLengthValue                   ; make a copy of _gcBlockHeaderLength's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockHeaderLengthType                    ; make a copy of _gcBlockHeaderLength's type in case it changes before we use it
  ; sentinel check of pointer type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of pointer to <sentinel>
  jne func$_mark$pointer$TypeMatch$3                             ; skip next block if pointer is not sentinel
    mov qword ptr [rsp + 050h], 000h                             ; move blockLength variable's value into a mutable location
    mov qword ptr [rsp + 048h], 000h                             ; move blockLength variable's type into a mutable location
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$pointer$TypeMatch$3:                                ; after block
  ; sentinel check of copy of _gcBlockHeaderLength type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockHeaderLength to <sentinel>
  jne func$_mark$Gcblockheaderlength$TypeMatch                   ; skip next block if copy of _gcBlockHeaderLength is not sentinel
    ; Error handling block for _gcBlockHeaderLength
    ; Call __error with 1 arguments
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$Gcblockheaderlength$TypeMatch:                      ; after block
  mov r15, qword ptr [rbp + 040h]                                ; assign value of pointer to value of + operator result
  add r15, rsi                                                   ; compute (pointer) + (copy of _gcBlockHeaderLength) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rsi, qword ptr [r15]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 050h], rsi                                ; value initialization of variable declaration for blockLength variable (dereferenced + operator result)
  mov qword ptr [rsp + 048h], 038h                               ; type initialization of variable declaration for blockLength variable (Integer'38)
  ; Line 326: Integer cursor = pointer + _gcBlockData;
  mov r13, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r14, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of pointer type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of pointer to <sentinel>
  jne func$_mark$pointer$TypeMatch$4                             ; skip next block if pointer is not sentinel
    mov qword ptr [rsp + 040h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 038h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for pointer
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$pointer$TypeMatch$4:                                ; after block
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_mark$Gcblockdata$TypeMatch                           ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_mark$Gcblockdata$TypeMatch:                              ; after block
  mov rsi, qword ptr [rbp + 040h]                                ; assign value of pointer to value of + operator result
  add rsi, r13                                                   ; compute (pointer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 040h], rsi                                ; value initialization of variable declaration for cursor variable (+ operator result)
  mov qword ptr [rsp + 038h], 038h                               ; type initialization of variable declaration for cursor variable (Integer'38)
  ; Line 327: Integer end = cursor + blockLength * 16 /* 0x10 */;
  mov r13, qword ptr [rsp + 040h]                                ; make a copy of cursor's value in case it changes before we use it
  mov r14, qword ptr [rsp + 038h]                                ; make a copy of cursor's type in case it changes before we use it
  mov rax, qword ptr [rsp + 050h]                                ; make a copy of blockLength's value in case it changes before we use it
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of blockLength's type in case it changes before we use it
  ; sentinel check of copy of blockLength type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of blockLength to <sentinel>
  jne func$_mark$blocklength$TypeMatch                           ; skip next block if copy of blockLength is not sentinel
    mov qword ptr [rsp + 050h], 000h                             ; move end variable's value into a mutable location
    mov qword ptr [rsp + 048h], 000h                             ; move end variable's type into a mutable location
    ; Error handling block for blockLength
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 060h], rax                              ; move copy of blockLength's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 020h]                              ; restoring slot (copy of blockLength) to previous scope state for genuine block exit
  func$_mark$blocklength$TypeMatch:                              ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  imul r12, rax, 010h                                            ; compute (copy of blockLength) * (16 /* 0x10 */) (result in * operator result)
  ; sentinel check of copy of cursor type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of cursor to <sentinel>
  jne func$_mark$cursor$TypeMatch                                ; skip next block if copy of cursor is not sentinel
    ; Error handling block for cursor
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 030h], r13                              ; move copy of cursor's value out of r13
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 030h], r14                              ; move copy of cursor's type out of r14
    lea r14, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 030h]                              ; restoring slot (copy of cursor) to previous scope state for genuine block exit
    mov r14, qword ptr [rsp + 020h]                              ; restoring slot (copy of cursor) to previous scope state for genuine block exit
  func$_mark$cursor$TypeMatch:                                   ; after block
  ; sentinel check of * operator result type Integer expecting Integer
  mov r10, r13                                                   ; assign value of copy of cursor to value of + operator result
  add r10, r12                                                   ; compute (copy of cursor) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 050h], r10                                ; value initialization of variable declaration for end variable (+ operator result)
  mov qword ptr [rsp + 048h], 038h                               ; type initialization of variable declaration for end variable (Integer'38)
  func$_mark$while$top:                                          ; top of while
    mov rdi, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    mov r13, qword ptr [rsp + 050h]                              ; make a copy of end's value in case it changes before we use it
    mov r14, qword ptr [rsp + 048h]                              ; make a copy of end's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_mark$while$cursor$TypeMatch                        ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 040h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 040h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_mark$while$cursor$TypeMatch:                           ; after block
    ; sentinel check of copy of end type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of end to <sentinel>
    jne func$_mark$while$end$TypeMatch                           ; skip next block if copy of end is not sentinel
      ; Error handling block for end
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 040h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_mark$while$end$TypeMatch:                              ; after block
    xor rsi, rsi                                                 ; clear < operator result
    cmp rdi, r13                                                 ; compare copy of cursor with copy of end
    setl sil                                                     ; store result in < operator result
    cmp rsi, 000h                                                ; compare < operator result to false
    jne func$_mark$while$body                                    ; while condition
    jmp func$_mark$while$bottom                                  ; break out of while
    func$_mark$while$body:                                       ; start of while
    ; Line 329: Whatever value = __readFromAddress(cursor + 8) __dynamic_as__ __...
    mov rdi, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_mark$while$cursor$TypeMatch$1                      ; skip next block if copy of cursor is not sentinel
      mov qword ptr [rsp + 030h], 000h                           ; move value variable's value into a mutable location
      mov qword ptr [rsp + 028h], 000h                           ; move value variable's type into a mutable location
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov r13, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 030h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 030h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_mark$while$cursor$TypeMatch$1:                         ; after block
    ; sentinel check of 8 type Integer expecting Integer
    mov r10, rdi                                                 ; assign value of copy of cursor to value of + operator result
    add r10, 008h                                                ; compute (copy of cursor) + (8) (result in + operator result)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov rdi, qword ptr [r10]                                     ; dereference first argument of __readFromAddress
    mov r12, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r13, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r13, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_mark$while$cursor$TypeMatch$2                      ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 030h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 030h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_mark$while$cursor$TypeMatch$2:                         ; after block
    ; sentinel check of 0 type Integer expecting Integer
    mov rbx, r12                                                 ; compute (copy of cursor) + (0)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r12, qword ptr [rbx]                                     ; dereference first argument of __readFromAddress
    mov r13, rdi                                                 ; force cast of dereferenced + operator result to the type with code dereferenced + operator result
    mov r14, r12                                                 ; store dereferenced + operator result value in force cast of dereferenced + operator result to the type with code dereferenced + operator result's type slot
    ; sentinel check of force cast of dereferenced + operator result to the type with code dereferenced + operator result type Anything expecting Whatever
    cmp r14, 000h                                                ; compare type of force cast of dereferenced + operator result to the type with code dereferenced + operator result to <sentinel>
    jne func$_mark$while$forceCastOfDereferencedOperatorResultToTheTypeWithCodeDereferencedOperatorResult$TypeMatch ; skip next block if force cast of dereferenced + operator result to the type with code dereferenced + operator result is not sentinel
      ; Error handling block for force cast of dereferenced + operator result to the type with code dereferenced + operator result
      ; Call __error with 1 arguments
      mov rax, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 030h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 030h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_mark$while$forceCastOfDereferencedOperatorResultToTheTypeWithCodeDereferencedOperatorResult$TypeMatch:  ; after block
    mov qword ptr [rsp + 030h], r13                              ; value initialization of variable declaration for value variable (force cast of dereferenced + operator result to the type with code dereferenced + operator result)
    mov qword ptr [rsp + 028h], r14                              ; type initialization of variable declaration for value variable
    ; increment reference count for value variable if necessary
    mov r10, qword ptr [rsp + 028h]                              ; store value variable's type in testByte value slot
    mov rax, r10                                                 ; move testByte to testByte
    mov rbx, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rbx                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rsi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rsi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_mark$while$AfterGCIncref                           ; if not a GarbageCollectable, skip incref
      mov rdi, qword ptr [rsp + 030h]                            ; read slot into register for dereferencing
      inc qword ptr [rdi]                                        ; increment reference count of value variable
      mov qword ptr [rsp + 030h], rdi                            ; restoring slot (value variable) to previous scope state for genuine block exit
    func$_mark$while$AfterGCIncref:                              ; after GarbageCollectable incref
    cmp qword ptr [rsp + 028h], 039h                             ; compare type of value variable to String
    jne func$_mark$while$AfterStringIncref                       ; if not a String, skip incref
      mov r12, qword ptr [rsp + 030h]                            ; get value variable into register to dereference it
      mov r13, qword ptr [r12]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$_mark$while$StringIncref                          ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 030h], r12                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$_mark$while$AfterStringIncref                     ; skip incref for string constants
      func$_mark$while$StringIncref:                             ; real String
        inc qword ptr [r12]                                      ; increment reference count of value variable
      mov qword ptr [rsp + 030h], r12                            ; restoring slot (value variable) to previous scope state for genuine block exit
    func$_mark$while$AfterStringIncref:                          ; after String incref
    ; Line 330: if (value is GarbageCollectable) { ...
    mov r14, qword ptr [rsp + 030h]                              ; make a copy of value's value in case it changes before we use it
    mov r15, qword ptr [rsp + 028h]                              ; make a copy of value's type in case it changes before we use it
    ; increment reference count for copy of value if necessary
    mov r9, r15                                                  ; store copy of value's type in testByte value slot
    mov rax, r9                                                  ; move testByte to testByte
    mov r8, 004h                                                 ; read operand of mul (type table width in bytes) 
    mul r8                                                       ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rdx, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rdx                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_mark$while$AfterGCIncref$1                         ; if not a GarbageCollectable, skip incref
      inc qword ptr [r14]                                        ; increment reference count of copy of value
    func$_mark$while$AfterGCIncref$1:                            ; after GarbageCollectable incref
    cmp r15, 039h                                                ; compare type of copy of value to String
    jne func$_mark$while$AfterStringIncref$1                     ; if not a String, skip incref
      mov rcx, qword ptr [r14]                                   ; dereference string to get to reference count
      cmp rcx, 0                                                 ; compare string reference count to 0
      jns func$_mark$while$StringIncref$1                        ; if reference count is negative (constant strings), skip incref
      jmp func$_mark$while$AfterStringIncref$1                   ; skip incref for string constants
      func$_mark$while$StringIncref$1:                           ; real String
        inc qword ptr [r14]                                      ; increment reference count of copy of value
    func$_mark$while$AfterStringIncref$1:                        ; after String incref
    mov r10, r15                                                 ; store copy of value's type in testByte value slot
    mov rax, r10                                                 ; move testByte to testByte
    mov rbx, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rbx                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rsi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rsi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that value is GarbageCollectable
    mov rdi, 000h                                                ; clear is expression result
    setc dil                                                     ; store result in is expression result
    ; sentinel check of is expression result type Boolean expecting Boolean
    cmp rdi, 000h                                                ; compare is expression result to false
    je func$_mark$while$if$continuation                          ; value is GarbageCollectable
      ; Line 331: _mark(value __as__ Integer, tag);
      mov qword ptr [rsp + 020h], r14                            ; move copy of value's value out of r14
      mov r14, qword ptr [rsp + 030h]                            ; make a copy of value's value in case it changes before we use it
      mov qword ptr [rsp + 018h], r15                            ; move copy of value's type out of r15
      mov r15, qword ptr [rsp + 028h]                            ; make a copy of value's type in case it changes before we use it
      ; increment reference count for copy of value if necessary
      mov r10, r15                                               ; store copy of value's type in testByte value slot
      mov rax, r10                                               ; move testByte to testByte
      mov rbx, 004h                                              ; read operand of mul (type table width in bytes) 
      mul rbx                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov rsi, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, rsi                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_mark$while$while$if$5$AfterGCIncref              ; if not a GarbageCollectable, skip incref
        inc qword ptr [r14]                                      ; increment reference count of copy of value
      func$_mark$while$while$if$5$AfterGCIncref:                 ; after GarbageCollectable incref
      cmp r15, 039h                                              ; compare type of copy of value to String
      jne func$_mark$while$while$if$5$AfterStringIncref          ; if not a String, skip incref
        mov rdi, qword ptr [r14]                                 ; dereference string to get to reference count
        cmp rdi, 0                                               ; compare string reference count to 0
        jns func$_mark$while$while$if$5$StringIncref             ; if reference count is negative (constant strings), skip incref
        jmp func$_mark$while$while$if$5$AfterStringIncref        ; skip incref for string constants
        func$_mark$while$while$if$5$StringIncref:                ; real String
          inc qword ptr [r14]                                    ; increment reference count of copy of value
      func$_mark$while$while$if$5$AfterStringIncref:             ; after String incref
      mov r12, r14                                               ; force cast of copy of value to Integer
      ; sentinel check of _mark type NullFunction(Integer, Integer) expecting AnythingFunction
      ; Call _mark with 2 arguments
      push qword ptr [rbp + 050h]                                ; value of argument #2 (tag)
      push qword ptr [rbp + 048h]                                ; type of argument #2
      push r12                                                   ; value of argument #1 (force cast of copy of value to Integer)
      push 038h                                                  ; type of argument #1 (Integer'38)
      mov qword ptr [rsp + 028h], r14                            ; move copy of value's value out of r14
      lea r14, qword ptr [rsp + 030h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 028h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 002h                                              ; internal argument 1: number of actual arguments
      call func$_mark                                            ; jump to subroutine
      add rsp, 050h                                              ; release shadow space and arguments (result in stack pointer)
      ; Decrement reference count for copy of value (static type: Whatever) via decrefMaybeGCOrString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, r15                                               ; arg #2: copy of value's type
      mov rcx, qword ptr [rsp + 028h]                            ; arg #1: copy of value's value
      call decrefMaybeGCOrString                                 ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      mov r15, qword ptr [rsp + 018h]                            ; restoring slot (copy of value) to previous scope state for genuine block exit
      mov r14, qword ptr [rsp + 020h]                            ; restoring slot (copy of value) to previous scope state for genuine block exit
    func$_mark$while$if$continuation:                            ; end of if
    ; Line 333: cursor += 16 /* 0x10 */;
    mov qword ptr [rsp + 020h], r15                              ; move copy of value's type out of r15
    mov r15, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r10, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_mark$while$copyOfCursor$TypeMatch                  ; skip next block if copy of cursor is not sentinel
      ; Error handling block for copy of cursor
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move copy of cursor's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (copy of cursor) to previous scope state for genuine block exit
    func$_mark$while$copyOfCursor$TypeMatch:                     ; after block
    ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
    mov r12, r15                                                 ; assign value of copy of cursor to value of += operator result
    mov r13, 010h                                                ; read second operand of add (16 /* 0x10 */)
    add r12, r13                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 040h], r12                              ; store value
    mov qword ptr [rsp + 038h], 038h                             ; store type (Integer'38)
    ; Decrement reference count for copy of value (static type: Whatever) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 040h]                              ; arg #2: copy of value's type
    mov rcx, r14                                                 ; arg #1: copy of value's value
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for value variable (static type: Whatever) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 048h]                              ; arg #2: value variable's type
    mov rcx, qword ptr [rsp + 050h]                              ; arg #1: value variable's value
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_mark$while$top                                     ; return to top of while
  func$_mark$while$bottom:                                       ; bottom of while
  ; Implicit return from _mark
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of _mark into register to dereference it
  mov qword ptr [rbx], 000h                                      ; _mark return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of _mark into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of _mark return value (Null'36)
  func$_mark$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 068h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _garbageCollectorImplementation
dq func$_garbageCollectorImplementation$annotation
func$_garbageCollectorImplementation:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 078h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0b8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of _garbageCollectorImplementation to 0 (integer)
  je func$_garbageCollectorImplementation$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_garbageCollectorImplementation$parameterCountCheck$continuation:  ; end of parameter count check
  ; Line 340: if (_gcLocked > 0) { ...
  mov rbx, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rsi, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_garbageCollectorImplementation$Gclocked$TypeMatch    ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for _gcLocked
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_garbageCollectorImplementation$Gclocked$TypeMatch:       ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r15, r15                                                   ; clear > operator result
  cmp rbx, 000h                                                  ; compare copy of _gcLocked with 0
  setg r15b                                                      ; store result in > operator result
  ; sentinel check of > operator result type Boolean expecting Boolean
  cmp r15, 000h                                                  ; compare > operator result to false
  je func$_garbageCollectorImplementation$if$continuation        ; _gcLocked > 0
    ; Line 341: return;
    ; sentinel check of null type Null expecting Null
    mov rdi, qword ptr [rbp + 030h]                              ; get pointer to return value of _garbageCollectorImplementation into register to dereference it
    mov qword ptr [rdi], 000h                                    ; _garbageCollectorImplementation return value
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of _garbageCollectorImplementation into register to dereference it
    mov qword ptr [r12], 036h                                    ; type of _garbageCollectorImplementation return value (Null'36)
    jmp func$_garbageCollectorImplementation$epilog              ; return
  func$_garbageCollectorImplementation$if$continuation:          ; end of if
  ; Line 343: _gcLocked += 1;
  mov r13, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r14, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_garbageCollectorImplementation$copyOfGclocked$TypeMatch ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_garbageCollectorImplementation$copyOfGclocked$TypeMatch:  ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rsi, r13                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov rdi, 001h                                                  ; read second operand of add (1)
  add rsi, rdi                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rsi                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 344: _currentTag += 1;
  mov r14, qword ptr _currentTagValue                            ; make a copy of _currentTag's value in case it changes before we use it
  mov r15, qword ptr _currentTagType                             ; make a copy of _currentTag's type in case it changes before we use it
  ; sentinel check of copy of _currentTag type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _currentTag to <sentinel>
  jne func$_garbageCollectorImplementation$copyOfCurrenttag$TypeMatch ; skip next block if copy of _currentTag is not sentinel
    ; Error handling block for copy of _currentTag
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_garbageCollectorImplementation$copyOfCurrenttag$TypeMatch:  ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of _currentTag to value of += operator result
  mov r12, 001h                                                  ; read second operand of add (1)
  add rdi, r12                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _currentTagValue, rdi                            ; store value
  mov qword ptr _currentTagType, 038h                            ; store type (Integer'38)
  ; Line 345: Integer cursor = _blockListStart;
  mov r15, qword ptr _blockListStartValue                        ; make a copy of _blockListStart's value in case it changes before we use it
  mov r10, qword ptr _blockListStartType                         ; make a copy of _blockListStart's type in case it changes before we use it
  ; sentinel check of copy of _blockListStart type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _blockListStart to <sentinel>
  jne func$_garbageCollectorImplementation$copyOfBlockliststart$TypeMatch ; skip next block if copy of _blockListStart is not sentinel
    mov qword ptr [rsp + 060h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 058h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for copy of _blockListStart
    ; Call __error with 1 arguments
    mov rax, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], r10                              ; move copy of _blockListStart's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 040h]                              ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
  func$_garbageCollectorImplementation$copyOfBlockliststart$TypeMatch:  ; after block
  mov qword ptr [rsp + 060h], r15                                ; value initialization of variable declaration for cursor variable (copy of _blockListStart)
  mov qword ptr [rsp + 058h], r10                                ; type initialization of variable declaration for cursor variable
  func$_garbageCollectorImplementation$while$top:                ; top of while
    mov qword ptr [rsp + 050h], rsi                              ; move += operator result's value out of rsi
    mov rsi, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov qword ptr [rsp + 048h], rdi                              ; move += operator result's value out of rdi
    mov rdi, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    mov r12, qword ptr _blockListEndValue                        ; make a copy of _blockListEnd's value in case it changes before we use it
    mov r13, qword ptr _blockListEndType                         ; make a copy of _blockListEnd's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_garbageCollectorImplementation$while$cursor$TypeMatch ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 050h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 050h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_garbageCollectorImplementation$while$cursor$TypeMatch:  ; after block
    ; sentinel check of copy of _blockListEnd type Integer expecting Integer
    cmp r13, 000h                                                ; compare type of copy of _blockListEnd to <sentinel>
    jne func$_garbageCollectorImplementation$while$Blocklistend$TypeMatch ; skip next block if copy of _blockListEnd is not sentinel
      ; Error handling block for _blockListEnd
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 050h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 050h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_garbageCollectorImplementation$while$Blocklistend$TypeMatch:  ; after block
    xor rbx, rbx                                                 ; clear < operator result
    cmp rsi, r12                                                 ; compare copy of cursor with copy of _blockListEnd
    setl bl                                                      ; store result in < operator result
    cmp rbx, 000h                                                ; compare < operator result to false
    jne func$_garbageCollectorImplementation$while$body          ; while condition
    mov rsi, qword ptr [rsp + 050h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    mov rdi, qword ptr [rsp + 048h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_garbageCollectorImplementation$while$bottom        ; break out of while
    func$_garbageCollectorImplementation$while$body:             ; start of while
    ; Line 347: Integer pointer = __readFromAddress(cursor);
    mov rsi, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov rdi, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r14, qword ptr [rsi]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of cursor type Integer expecting Integer
    mov qword ptr [rsp + 040h], r14                              ; value initialization of variable declaration for pointer variable (dereferenced copy of cursor)
    mov qword ptr [rsp + 038h], 038h                             ; type initialization of variable declaration for pointer variable (Integer'38)
    ; Line 348: if (pointer != 0) { ...
    mov rax, qword ptr [rsp + 040h]                              ; make a copy of pointer's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 038h]                              ; make a copy of pointer's type in case it changes before we use it
    xor rsi, rsi                                                 ; zero value result of == (testing copy of pointer and 0) to put the boolean in
    cmp rax, 000h                                                ; values equal?
    sete sil                                                     ; put result in value result of == (testing copy of pointer and 0)
    mov rdi, 037h                                                ; value result of == (testing copy of pointer and 0) is a Boolean'37
    xor r12, r12                                                 ; zero type result of == (testing copy of pointer and 0) to put the boolean in
    cmp rbx, 038h                                                ; types equal?
    sete r12b                                                    ; put result in type result of == (testing copy of pointer and 0)
    mov r13, 037h                                                ; type result of == (testing copy of pointer and 0) is a Boolean'37
    mov r14, rsi                                                 ; assign value of value result of == (testing copy of pointer and 0) to value of != operator result
    and r14, r12                                                 ; && type temp and value temp
    mov r15, 001h                                                ; read second operand of xor (1 (integer))
    xor r14, r15                                                 ; negating <DynamicSlot:Boolean ("!= operator result")>
    ; sentinel check of != operator result type Boolean expecting Boolean
    cmp r14, 000h                                                ; compare != operator result to false
    je func$_garbageCollectorImplementation$while$if$continuation ; pointer != 0
      ; Line 349: Integer blockRefCount = __readFromAddress(pointer + _gcBlockHead...
      mov rax, qword ptr [rsp + 040h]                            ; make a copy of pointer's value in case it changes before we use it
      mov rbx, qword ptr [rsp + 038h]                            ; make a copy of pointer's type in case it changes before we use it
      mov rsi, qword ptr _gcBlockHeaderRefCountValue             ; make a copy of _gcBlockHeaderRefCount's value in case it changes before we use it
      mov rdi, qword ptr _gcBlockHeaderRefCountType              ; make a copy of _gcBlockHeaderRefCount's type in case it changes before we use it
      ; sentinel check of copy of pointer type Integer expecting Integer
      cmp rbx, 000h                                              ; compare type of copy of pointer to <sentinel>
      jne func$_garbageCollectorImplementation$while$while$if$6$pointer$TypeMatch ; skip next block if copy of pointer is not sentinel
        mov qword ptr [rsp + 030h], 000h                         ; move blockRefCount variable's value into a mutable location
        mov qword ptr [rsp + 028h], 000h                         ; move blockRefCount variable's type into a mutable location
        ; Error handling block for pointer
        ; Call __error with 1 arguments
        mov r12, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r12                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r13, qword ptr [rsp + 030h]                          ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 030h]                          ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 050h], rax                          ; move copy of pointer's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 010h]                          ; restoring slot (copy of pointer) to previous scope state for genuine block exit
      func$_garbageCollectorImplementation$while$while$if$6$pointer$TypeMatch:  ; after block
      ; sentinel check of copy of _gcBlockHeaderRefCount type Integer expecting Integer
      cmp rdi, 000h                                              ; compare type of copy of _gcBlockHeaderRefCount to <sentinel>
      jne func$_garbageCollectorImplementation$while$while$if$6$Gcblockheaderrefcount$TypeMatch ; skip next block if copy of _gcBlockHeaderRefCount is not sentinel
        ; Error handling block for _gcBlockHeaderRefCount
        ; Call __error with 1 arguments
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r15, qword ptr [rsp + 030h]                          ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 030h]                          ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 050h], rax                          ; move copy of pointer's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 010h]                          ; restoring slot (copy of pointer) to previous scope state for genuine block exit
      func$_garbageCollectorImplementation$while$while$if$6$Gcblockheaderrefcount$TypeMatch:  ; after block
      mov r10, rax                                               ; assign value of copy of pointer to value of + operator result
      add r10, rsi                                               ; compute (copy of pointer) + (copy of _gcBlockHeaderRefCount) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov rsi, qword ptr [r10]                                   ; dereference first argument of __readFromAddress
      ; sentinel check of dereferenced + operator result type Integer expecting Integer
      mov qword ptr [rsp + 030h], rsi                            ; value initialization of variable declaration for blockRefCount variable (dereferenced + operator result)
      mov qword ptr [rsp + 028h], 038h                           ; type initialization of variable declaration for blockRefCount variable (Integer'38)
      ; Line 350: assert(blockRefCount >= 0, 'Reference count underflow.');
      mov r13, qword ptr [rsp + 030h]                            ; make a copy of blockRefCount's value in case it changes before we use it
      mov r14, qword ptr [rsp + 028h]                            ; make a copy of blockRefCount's type in case it changes before we use it
      ; sentinel check of copy of blockRefCount type Integer expecting Integer
      cmp r14, 000h                                              ; compare type of copy of blockRefCount to <sentinel>
      jne func$_garbageCollectorImplementation$while$while$if$6$blockrefcount$TypeMatch ; skip next block if copy of blockRefCount is not sentinel
        ; Error handling block for blockRefCount
        ; Call __error with 1 arguments
        mov r15, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r15                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r10, qword ptr [rsp + 030h]                          ; load address of return value's value
        push r10                                                 ; internal argument 6: pointer to return value slot's value
        lea r10, qword ptr [rsp + 030h]                          ; load address of return value's type
        push r10                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_garbageCollectorImplementation$while$while$if$6$blockrefcount$TypeMatch:  ; after block
      ; sentinel check of 0 type Integer expecting Integer
      xor rsi, rsi                                               ; clear >= operator result
      cmp r13, 000h                                              ; compare copy of blockRefCount with 0
      setge sil                                                  ; store result in >= operator result
      ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
      ; Call assert with 2 arguments
      mov r13, offset string$26                                  ; reading string for push
      push r13                                                   ; value of argument #2 (string)
      push 039h                                                  ; type of argument #2 (String'39)
      push rsi                                                   ; value of argument #1 (>= operator result)
      push 037h                                                  ; type of argument #1 (Boolean'37)
      lea r14, qword ptr [rsp + 040h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 040h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 002h                                              ; internal argument 1: number of actual arguments
      call func$assert                                           ; jump to subroutine
      add rsp, 050h                                              ; release shadow space and arguments (result in stack pointer)
      ; Line 351: if (blockRefCount != 0) { ...
      mov r15, qword ptr [rsp + 030h]                            ; make a copy of blockRefCount's value in case it changes before we use it
      mov r10, qword ptr [rsp + 028h]                            ; make a copy of blockRefCount's type in case it changes before we use it
      xor rax, rax                                               ; zero value result of == (testing copy of blockRefCount and 0) to put the boolean in
      cmp r15, 000h                                              ; values equal?
      sete al                                                    ; put result in value result of == (testing copy of blockRefCount and 0)
      mov rbx, 037h                                              ; value result of == (testing copy of blockRefCount and 0) is a Boolean'37
      xor rsi, rsi                                               ; zero type result of == (testing copy of blockRefCount and 0) to put the boolean in
      cmp r10, 038h                                              ; types equal?
      sete sil                                                   ; put result in type result of == (testing copy of blockRefCount and 0)
      mov rdi, 037h                                              ; type result of == (testing copy of blockRefCount and 0) is a Boolean'37
      mov r12, rax                                               ; assign value of value result of == (testing copy of blockRefCount and 0) to value of != operator result
      and r12, rsi                                               ; && type temp and value temp
      mov r13, 001h                                              ; read second operand of xor (1 (integer))
      xor r12, r13                                               ; negating <DynamicSlot:Boolean ("!= operator result")>
      ; sentinel check of != operator result type Boolean expecting Boolean
      cmp r12, 000h                                              ; compare != operator result to false
      je func$_garbageCollectorImplementation$while$while$if$6$if$continuation ; blockRefCount != 0
        ; Line 352: _mark(pointer, _currentTag);
        mov r15, qword ptr [rsp + 040h]                          ; make a copy of pointer's value in case it changes before we use it
        mov r10, qword ptr [rsp + 038h]                          ; make a copy of pointer's type in case it changes before we use it
        mov rax, qword ptr _currentTagValue                      ; make a copy of _currentTag's value in case it changes before we use it
        mov rbx, qword ptr _currentTagType                       ; make a copy of _currentTag's type in case it changes before we use it
        ; sentinel check of _mark type NullFunction(Integer, Integer) expecting AnythingFunction
        ; Call _mark with 2 arguments
        push rax                                                 ; value of argument #2 (copy of _currentTag)
        push rbx                                                 ; type of argument #2
        push r15                                                 ; value of argument #1 (copy of pointer)
        push r10                                                 ; type of argument #1
        lea r12, qword ptr [rsp + 050h]                          ; load address of return value's value
        push r12                                                 ; internal argument 6: pointer to return value slot's value
        lea r12, qword ptr [rsp + 050h]                          ; load address of return value's type
        push r12                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 002h                                            ; internal argument 1: number of actual arguments
        call func$_mark                                          ; jump to subroutine
        add rsp, 050h                                            ; release shadow space and arguments (result in stack pointer)
      func$_garbageCollectorImplementation$while$while$if$6$if$continuation:  ; end of if
    func$_garbageCollectorImplementation$while$if$continuation:  ; end of if
    ; Line 355: cursor += _blockEntrySize;
    mov r13, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r14, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    mov r15, qword ptr _blockEntrySizeValue                      ; make a copy of _blockEntrySize's value in case it changes before we use it
    mov r10, qword ptr _blockEntrySizeType                       ; make a copy of _blockEntrySize's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_garbageCollectorImplementation$while$copyOfCursor$TypeMatch ; skip next block if copy of cursor is not sentinel
      ; Error handling block for copy of cursor
      ; Call __error with 1 arguments
      mov rax, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 050h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 050h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move copy of _blockEntrySize's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$copyOfCursor$TypeMatch:  ; after block
    ; sentinel check of copy of _blockEntrySize type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of _blockEntrySize to <sentinel>
    jne func$_garbageCollectorImplementation$while$copyOfBlockentrysize$TypeMatch ; skip next block if copy of _blockEntrySize is not sentinel
      ; Error handling block for copy of _blockEntrySize
      ; Call __error with 1 arguments
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 050h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 050h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move copy of _blockEntrySize's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$copyOfBlockentrysize$TypeMatch:  ; after block
    mov r12, r13                                                 ; assign value of copy of cursor to value of += operator result
    add r12, r15                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 060h], r12                              ; store value
    mov qword ptr [rsp + 058h], 038h                             ; store type (Integer'38)
    mov rsi, qword ptr [rsp + 050h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    mov rdi, qword ptr [rsp + 048h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_garbageCollectorImplementation$while$top           ; return to top of while
  func$_garbageCollectorImplementation$while$bottom:             ; bottom of while
  func$_garbageCollectorImplementation$while$top$1:              ; top of while
    mov r15, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r10, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    mov rax, qword ptr _blockListStartValue                      ; make a copy of _blockListStart's value in case it changes before we use it
    mov rbx, qword ptr _blockListStartType                       ; make a copy of _blockListStart's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_garbageCollectorImplementation$while$cursor$TypeMatch$1 ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 050h], rsi                            ; move += operator result's value out of rsi
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 050h], rdi                            ; move += operator result's value out of rdi
      lea rdi, qword ptr [rsp + 058h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 050h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move copy of cursor's type out of r10
      mov qword ptr [rsp + 068h], rax                            ; move copy of _blockListStart's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 028h]                            ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of cursor) to previous scope state for genuine block exit
      mov rsi, qword ptr [rsp + 050h]                            ; restoring slot (+= operator result) to previous scope state for genuine block exit
      mov rdi, qword ptr [rsp + 040h]                            ; restoring slot (+= operator result) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$cursor$TypeMatch$1:  ; after block
    ; sentinel check of copy of _blockListStart type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of _blockListStart to <sentinel>
    jne func$_garbageCollectorImplementation$while$Blockliststart$TypeMatch ; skip next block if copy of _blockListStart is not sentinel
      ; Error handling block for _blockListStart
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 050h], r12                            ; move += operator result's value out of r12
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 078h], r10                            ; move copy of cursor's type out of r10
      mov qword ptr [rsp + 070h], rax                            ; move copy of _blockListStart's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 030h]                            ; restoring slot (copy of _blockListStart) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 038h]                            ; restoring slot (copy of cursor) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$Blockliststart$TypeMatch:  ; after block
    xor r14, r14                                                 ; clear > operator result
    cmp r15, rax                                                 ; compare copy of cursor with copy of _blockListStart
    setg r14b                                                    ; store result in > operator result
    cmp r14, 000h                                                ; compare > operator result to false
    jne func$_garbageCollectorImplementation$while$body$1        ; while condition
    jmp func$_garbageCollectorImplementation$while$bottom$1      ; break out of while
    func$_garbageCollectorImplementation$while$body$1:           ; start of while
    ; Line 358: cursor -= _blockEntrySize;
    mov r15, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r10, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    mov rax, qword ptr _blockEntrySizeValue                      ; make a copy of _blockEntrySize's value in case it changes before we use it
    mov rbx, qword ptr _blockEntrySizeType                       ; make a copy of _blockEntrySize's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_garbageCollectorImplementation$while$copyOfCursor$TypeMatch$1 ; skip next block if copy of cursor is not sentinel
      ; Error handling block for copy of cursor
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 048h], rsi                            ; move += operator result's value out of rsi
      mov rsi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 048h], rdi                            ; move += operator result's value out of rdi
      lea rdi, qword ptr [rsp + 050h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 048h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 068h], r10                            ; move copy of cursor's type out of r10
      mov qword ptr [rsp + 060h], rax                            ; move copy of _blockEntrySize's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 020h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 028h]                            ; restoring slot (copy of cursor) to previous scope state for genuine block exit
      mov rsi, qword ptr [rsp + 048h]                            ; restoring slot (+= operator result) to previous scope state for genuine block exit
      mov rdi, qword ptr [rsp + 038h]                            ; restoring slot (+= operator result) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$copyOfCursor$TypeMatch$1:  ; after block
    ; sentinel check of copy of _blockEntrySize type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of _blockEntrySize to <sentinel>
    jne func$_garbageCollectorImplementation$while$copyOfBlockentrysize$TypeMatch$1 ; skip next block if copy of _blockEntrySize is not sentinel
      ; Error handling block for copy of _blockEntrySize
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 078h], r10                            ; move copy of cursor's type out of r10
      mov qword ptr [rsp + 070h], rax                            ; move copy of _blockEntrySize's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 030h]                            ; restoring slot (copy of _blockEntrySize) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 038h]                            ; restoring slot (copy of cursor) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$copyOfBlockentrysize$TypeMatch$1:  ; after block
    mov r14, r15                                                 ; assign value of copy of cursor to value of -= operator result
    sub r14, rax                                                 ; -= operator
    ; sentinel check of -= operator result type Integer expecting Integer
    mov qword ptr [rsp + 060h], r14                              ; store value
    mov qword ptr [rsp + 058h], 038h                             ; store type (Integer'38)
    ; Line 359: Integer pointer = __readFromAddress(cursor);
    mov rax, qword ptr [rsp + 060h]                              ; make a copy of cursor's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 058h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r12, qword ptr [rax]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of cursor type Integer expecting Integer
    mov qword ptr [rsp + 048h], r12                              ; value initialization of variable declaration for pointer variable (dereferenced copy of cursor)
    mov qword ptr [rsp + 040h], 038h                             ; type initialization of variable declaration for pointer variable (Integer'38)
    ; Line 360: if (pointer != 0) { ...
    mov r15, qword ptr [rsp + 048h]                              ; make a copy of pointer's value in case it changes before we use it
    mov r10, qword ptr [rsp + 040h]                              ; make a copy of pointer's type in case it changes before we use it
    xor rax, rax                                                 ; zero value result of == (testing copy of pointer and 0) to put the boolean in
    cmp r15, 000h                                                ; values equal?
    sete al                                                      ; put result in value result of == (testing copy of pointer and 0)
    mov rbx, 037h                                                ; value result of == (testing copy of pointer and 0) is a Boolean'37
    mov qword ptr [rsp + 038h], rsi                              ; move += operator result's value out of rsi
    xor rsi, rsi                                                 ; zero type result of == (testing copy of pointer and 0) to put the boolean in
    cmp r10, 038h                                                ; types equal?
    sete sil                                                     ; put result in type result of == (testing copy of pointer and 0)
    mov qword ptr [rsp + 030h], rdi                              ; move += operator result's value out of rdi
    mov rdi, 037h                                                ; type result of == (testing copy of pointer and 0) is a Boolean'37
    mov r12, rax                                                 ; assign value of value result of == (testing copy of pointer and 0) to value of != operator result
    and r12, rsi                                                 ; && type temp and value temp
    mov r13, 001h                                                ; read second operand of xor (1 (integer))
    xor r12, r13                                                 ; negating <DynamicSlot:Boolean ("!= operator result")>
    ; sentinel check of != operator result type Boolean expecting Boolean
    cmp r12, 000h                                                ; compare != operator result to false
    je func$_garbageCollectorImplementation$while$if$continuation$1 ; pointer != 0
      ; Line 361: Integer blockScratchSpace = __readFromAddress(pointer + _gcBlock...
      mov r15, qword ptr [rsp + 048h]                            ; make a copy of pointer's value in case it changes before we use it
      mov r10, qword ptr [rsp + 040h]                            ; make a copy of pointer's type in case it changes before we use it
      mov rax, qword ptr _gcBlockHeaderScratchSpaceValue         ; make a copy of _gcBlockHeaderScratchSpace's value in case it changes before we use it
      mov rbx, qword ptr _gcBlockHeaderScratchSpaceType          ; make a copy of _gcBlockHeaderScratchSpace's type in case it changes before we use it
      ; sentinel check of copy of pointer type Integer expecting Integer
      cmp r10, 000h                                              ; compare type of copy of pointer to <sentinel>
      jne func$_garbageCollectorImplementation$while$while$if$7$pointer$TypeMatch ; skip next block if copy of pointer is not sentinel
        mov qword ptr [rsp + 028h], 000h                         ; move blockScratchSpace variable's value into a mutable location
        mov qword ptr [rsp + 020h], 000h                         ; move blockScratchSpace variable's type into a mutable location
        ; Error handling block for pointer
        ; Call __error with 1 arguments
        mov rsi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rdi, qword ptr [rsp + 028h]                          ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 028h]                          ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 048h], r10                          ; move copy of pointer's type out of r10
        mov qword ptr [rsp + 040h], rax                          ; move copy of _gcBlockHeaderScratchSpace's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 000h]                          ; restoring slot (copy of _gcBlockHeaderScratchSpace) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 008h]                          ; restoring slot (copy of pointer) to previous scope state for genuine block exit
      func$_garbageCollectorImplementation$while$while$if$7$pointer$TypeMatch:  ; after block
      ; sentinel check of copy of _gcBlockHeaderScratchSpace type Integer expecting Integer
      cmp rbx, 000h                                              ; compare type of copy of _gcBlockHeaderScratchSpace to <sentinel>
      jne func$_garbageCollectorImplementation$while$while$if$7$Gcblockheaderscratchspace$TypeMatch ; skip next block if copy of _gcBlockHeaderScratchSpace is not sentinel
        ; Error handling block for _gcBlockHeaderScratchSpace
        ; Call __error with 1 arguments
        mov r12, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r12                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r13, qword ptr [rsp + 028h]                          ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 028h]                          ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 048h], r10                          ; move copy of pointer's type out of r10
        mov qword ptr [rsp + 040h], rax                          ; move copy of _gcBlockHeaderScratchSpace's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 000h]                          ; restoring slot (copy of _gcBlockHeaderScratchSpace) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 008h]                          ; restoring slot (copy of pointer) to previous scope state for genuine block exit
      func$_garbageCollectorImplementation$while$while$if$7$Gcblockheaderscratchspace$TypeMatch:  ; after block
      mov qword ptr [rsp + 018h], r14                            ; move -= operator result's value out of r14
      mov r14, r15                                               ; assign value of copy of pointer to value of + operator result
      add r14, rax                                               ; compute (copy of pointer) + (copy of _gcBlockHeaderScratchSpace) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov rax, qword ptr [r14]                                   ; dereference first argument of __readFromAddress
      ; sentinel check of dereferenced + operator result type Integer expecting Integer
      mov qword ptr [rsp + 028h], rax                            ; value initialization of variable declaration for blockScratchSpace variable (dereferenced + operator result)
      mov qword ptr [rsp + 020h], 038h                           ; type initialization of variable declaration for blockScratchSpace variable (Integer'38)
      ; Line 362: if (blockScratchSpace != _currentTag) { ...
      mov rdi, qword ptr [rsp + 028h]                            ; make a copy of blockScratchSpace's value in case it changes before we use it
      mov r12, qword ptr [rsp + 020h]                            ; make a copy of blockScratchSpace's type in case it changes before we use it
      mov r13, qword ptr _currentTagValue                        ; make a copy of _currentTag's value in case it changes before we use it
      mov r14, qword ptr _currentTagType                         ; make a copy of _currentTag's type in case it changes before we use it
      xor r15, r15                                               ; zero value result of == (testing copy of blockScratchSpace and copy of _currentTag) to put the boolean in
      cmp rdi, r13                                               ; values equal?
      sete r15b                                                  ; put result in value result of == (testing copy of blockScratchSpace and copy of _currentTag)
      mov r10, 037h                                              ; value result of == (testing copy of blockScratchSpace and copy of _currentTag) is a Boolean'37
      xor rax, rax                                               ; zero type result of == (testing copy of blockScratchSpace and copy of _currentTag) to put the boolean in
      cmp r12, r14                                               ; types equal?
      sete al                                                    ; put result in type result of == (testing copy of blockScratchSpace and copy of _currentTag)
      mov rbx, 037h                                              ; type result of == (testing copy of blockScratchSpace and copy of _currentTag) is a Boolean'37
      mov rsi, r15                                               ; assign value of value result of == (testing copy of blockScratchSpace and copy of _currentTag) to value of != operator result
      and rsi, rax                                               ; && type temp and value temp
      mov r9, 001h                                               ; read second operand of xor (1 (integer))
      xor rsi, r9                                                ; negating <DynamicSlot:Boolean ("!= operator result")>
      ; sentinel check of != operator result type Boolean expecting Boolean
      cmp rsi, 000h                                              ; compare != operator result to false
      je func$_garbageCollectorImplementation$while$while$if$7$if$continuation ; blockScratchSpace != _currentTag
        ; Line 364: _free(pointer);
        mov rdi, qword ptr [rsp + 048h]                          ; make a copy of pointer's value in case it changes before we use it
        mov r12, qword ptr [rsp + 040h]                          ; make a copy of pointer's type in case it changes before we use it
        ; sentinel check of _free type NullFunction(Integer) expecting AnythingFunction
        ; Call _free with 1 arguments
        push rdi                                                 ; value of argument #1 (copy of pointer)
        push r12                                                 ; type of argument #1
        lea r15, qword ptr [rsp + 038h]                          ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 038h]                          ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$_free                                          ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        ; Line 365: __writeToAddress(cursor, 0);
        mov r10, qword ptr [rsp + 060h]                          ; make a copy of cursor's value in case it changes before we use it
        mov rax, qword ptr [rsp + 058h]                          ; make a copy of cursor's type in case it changes before we use it
        ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
        ; Call __writeToAddress with 2 arguments
        mov qword ptr [r10], 000h                                ; __writeToAddress
        ; Line 366: _debugLiveBlocks -= 1;
        mov rdi, qword ptr _debugLiveBlocksValue                 ; make a copy of _debugLiveBlocks's value in case it changes before we use it
        mov r12, qword ptr _debugLiveBlocksType                  ; make a copy of _debugLiveBlocks's type in case it changes before we use it
        ; sentinel check of copy of _debugLiveBlocks type Integer expecting Integer
        cmp r12, 000h                                            ; compare type of copy of _debugLiveBlocks to <sentinel>
        jne func$_garbageCollectorImplementation$while$while$if$7$while$if$7$if$copyOfDebugliveblocks$TypeMatch ; skip next block if copy of _debugLiveBlocks is not sentinel
          ; Error handling block for copy of _debugLiveBlocks
          ; Call __error with 1 arguments
          mov r13, offset operandTypeCheckFailureMessage         ; reading operandTypeCheckFailureMessage for push
          push r13                                               ; value of argument #1 (operandTypeCheckFailureMessage)
          push 039h                                              ; type of argument #1 (String'39)
          lea r14, qword ptr [rsp + 038h]                        ; load address of return value's value
          push r14                                               ; internal argument 6: pointer to return value slot's value
          lea r14, qword ptr [rsp + 038h]                        ; load address of return value's type
          push r14                                               ; internal argument 5: pointer to return value slot's type
          sub rsp, 020h                                          ; allocate shadow space
          mov r9, 000h                                           ; internal argument 4: "this" pointer
          mov r8, 000h                                           ; internal argument 3: "this" pointer type
          mov rdx, 000h                                          ; internal argument 2: closure pointer
          mov rcx, 001h                                          ; internal argument 1: number of actual arguments
          call func$__error                                      ; jump to subroutine
          add rsp, 040h                                          ; release shadow space and arguments (result in stack pointer)
        func$_garbageCollectorImplementation$while$while$if$7$while$if$7$if$copyOfDebugliveblocks$TypeMatch:  ; after block
        ; sentinel check of 1 type Integer expecting Integer
        mov rax, rdi                                             ; assign value of copy of _debugLiveBlocks to value of -= operator result
        mov rbx, 001h                                            ; read second operand of sub (1)
        sub rax, rbx                                             ; -= operator
        ; sentinel check of -= operator result type Integer expecting Integer
        mov qword ptr _debugLiveBlocksValue, rax                 ; store value
        mov qword ptr _debugLiveBlocksType, 038h                 ; store type (Integer'38)
      func$_garbageCollectorImplementation$while$while$if$7$if$continuation:  ; end of if
      mov r14, qword ptr [rsp + 018h]                            ; restoring slot (-= operator result) to previous scope state for genuine block exit
    func$_garbageCollectorImplementation$while$if$continuation$1:  ; end of if
    mov rsi, qword ptr [rsp + 038h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    mov rdi, qword ptr [rsp + 030h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_garbageCollectorImplementation$while$top$1         ; return to top of while
  func$_garbageCollectorImplementation$while$bottom$1:           ; bottom of while
  ; Line 370: _gcLocked -= 1;
  mov r12, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r13, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_garbageCollectorImplementation$copyOfGclocked$TypeMatch$1 ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 060h], r14                              ; move -= operator result's value out of r14
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], rax                              ; move -= operator result's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_garbageCollectorImplementation$copyOfGclocked$TypeMatch$1:  ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rbx, r12                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov qword ptr [rsp + 058h], rsi                                ; move += operator result's value out of rsi
  mov rsi, 001h                                                  ; read second operand of sub (1)
  sub rbx, rsi                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rbx                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Implicit return from _garbageCollectorImplementation
  ; sentinel check of null type Null expecting Null
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of _garbageCollectorImplementation into register to dereference it
  mov qword ptr [r15], 000h                                      ; _garbageCollectorImplementation return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of _garbageCollectorImplementation into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of _garbageCollectorImplementation return value (Null'36)
  func$_garbageCollectorImplementation$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 078h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _listConstructor
dq func$_listConstructor$annotation
func$_listConstructor:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0d8h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0118h]                               ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of _listConstructor to 2 (integer)
  je func$_listConstructor$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0d0h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$parameterCountCheck$continuation:        ; end of parameter count check
  ; Check type of parameter 0, typeCode (expecting Integer)
  ; type check of typeCode type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store typeCode's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that typeCode is Integer
  jc func$_listConstructor$typecode$TypeMatch                    ; skip next block if the type matches
    ; Error handling block for typeCode
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0d0h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$typecode$TypeMatch:                      ; after block
  ; Check type of parameter 1, initialSize (expecting Integer)
  ; type check of initialSize type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store initialSize's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that initialSize is Integer
  jc func$_listConstructor$initialsize$TypeMatch                 ; skip next block if the type matches
    ; Error handling block for initialSize
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0d0h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$initialsize$TypeMatch:                   ; after block
  ; Line 388: _gcLocked += 1;
  mov rdi, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r12, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_listConstructor$copyOfGclocked$TypeMatch             ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 0d0h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$copyOfGclocked$TypeMatch:                ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov rbx, 001h                                                  ; read second operand of add (1)
  add r10, rbx                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r10                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 389: WhateverList list = _constructor(typeCode, 2, 2) as WhateverList...
  ; sentinel check of _constructor type GarbageCollectableFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _constructor with 3 arguments
  push 002h                                                      ; value of argument #3 (2)
  push 038h                                                      ; type of argument #3 (Integer'38)
  push 002h                                                      ; value of argument #2 (2)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (typeCode)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea r14, qword ptr [rsp + 0e0h]                                ; load address of return value's value
  push r14                                                       ; internal argument 6: pointer to return value slot's value
  lea r14, qword ptr [rsp + 0e0h]                                ; load address of return value's type
  push r14                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 0100h], r10                               ; move += operator result's value out of r10
  call func$_constructor                                         ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; type check of _constructor return value type GarbageCollectable expecting WhateverList
  mov rax, qword ptr [rsp + 0a8h]                                ; store _constructor return value's type in testByte value slot
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that _constructor(typeCode, 2, 2) as WhateverList is WhateverList
  jc func$_listConstructor$ConstructorTypecode22AsWHateverlist$TypeMatch ; skip next block if the type matches
    ; Error handling block for _constructor(typeCode, 2, 2) as WhateverList
    ; Call __error with 1 arguments
    mov rbx, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rbx                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$ConstructorTypecode22AsWHateverlist$TypeMatch:  ; after block
  mov rdi, qword ptr [rsp + 0b0h]                                ; copy value of _constructor return value for cast to WhateverList
  mov r12, qword ptr [rsp + 0a8h]                                ; copy type of _constructor return value for cast to WhateverList
  ; sentinel check of cast of _constructor return value to WhateverList type WhateverList expecting WhateverList
  cmp r12, 000h                                                  ; compare type of cast of _constructor return value to WhateverList to <sentinel>
  jne func$_listConstructor$castOfConstructorReturnValueToWHateverlist$TypeMatch ; skip next block if cast of _constructor return value to WhateverList is not sentinel
    ; Error handling block for cast of _constructor return value to WhateverList
    ; Call __error with 1 arguments
    mov r13, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$castOfConstructorReturnValueToWHateverlist$TypeMatch:  ; after block
  mov qword ptr [rsp + 0c0h], rdi                                ; value initialization of variable declaration for list variable (cast of _constructor return value to WhateverList)
  mov qword ptr [rsp + 0b8h], r12                                ; type initialization of variable declaration for list variable
  ; increment reference count for list variable if necessary
  mov rax, qword ptr [rsp + 0b8h]                                ; store list variable's type in testByte value slot
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref                        ; if not a GarbageCollectable, skip incref
    mov rbx, qword ptr [rsp + 0c0h]                              ; read slot into register for dereferencing
    inc qword ptr [rbx]                                          ; increment reference count of list variable
    mov qword ptr [rsp + 0c0h], rbx                              ; restoring slot (list variable) to previous scope state for genuine block exit
  func$_listConstructor$AfterGCIncref:                           ; after GarbageCollectable incref
  ; Line 390: __ListData data = _constructor(__typeToCode __ListData, 0, initi...
  ; sentinel check of _constructor type GarbageCollectableFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _constructor with 3 arguments
  push qword ptr [rbp + 050h]                                    ; value of argument #3 (initialSize)
  push qword ptr [rbp + 048h]                                    ; type of argument #3
  push 000h                                                      ; value of argument #2 (0)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push 03ah                                                      ; value of argument #1 (code of __ListData)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r12, qword ptr [rsp + 0b8h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 0b8h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_constructor                                         ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; type check of _constructor return value type GarbageCollectable expecting __ListData
  mov r13, qword ptr [rsp + 080h]                                ; store _constructor return value's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that _constructor(__typeToCode __ListData, 0, initialSize) as __ListData is __ListData
  jc func$_listConstructor$ConstructorTypetocodeLIstdata0InitialsizeAsLIstdata$TypeMatch ; skip next block if the type matches
    ; Error handling block for _constructor(__typeToCode __ListData, 0, initialSize) as __ListData
    ; Call __error with 1 arguments
    mov r10, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push r10                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 088h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 088h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$ConstructorTypetocodeLIstdata0InitialsizeAsLIstdata$TypeMatch:  ; after block
  mov rsi, qword ptr [rsp + 088h]                                ; copy value of _constructor return value for cast to __ListData
  mov rdi, qword ptr [rsp + 080h]                                ; copy type of _constructor return value for cast to __ListData
  ; sentinel check of cast of _constructor return value to __ListData type __ListData expecting __ListData
  cmp rdi, 000h                                                  ; compare type of cast of _constructor return value to __ListData to <sentinel>
  jne func$_listConstructor$castOfConstructorReturnValueToLIstdata$TypeMatch ; skip next block if cast of _constructor return value to __ListData is not sentinel
    ; Error handling block for cast of _constructor return value to __ListData
    ; Call __error with 1 arguments
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 088h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 088h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_listConstructor$castOfConstructorReturnValueToLIstdata$TypeMatch:  ; after block
  mov qword ptr [rsp + 098h], rsi                                ; value initialization of variable declaration for data variable (cast of _constructor return value to __ListData)
  mov qword ptr [rsp + 090h], rdi                                ; type initialization of variable declaration for data variable
  ; increment reference count for data variable if necessary
  mov rax, qword ptr [rsp + 090h]                                ; store data variable's type in testByte value slot
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$1                      ; if not a GarbageCollectable, skip incref
    mov r10, qword ptr [rsp + 098h]                              ; read slot into register for dereferencing
    inc qword ptr [r10]                                          ; increment reference count of data variable
    mov qword ptr [rsp + 098h], r10                              ; restoring slot (data variable) to previous scope state for genuine block exit
  func$_listConstructor$AfterGCIncref$1:                         ; after GarbageCollectable incref
  ; Line 391: __writeToAddress(list __as__ Integer + _gcBlockData + 0, __typeO...
  mov rbx, qword ptr [rsp + 0c0h]                                ; make a copy of list's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 0b8h]                                ; make a copy of list's type in case it changes before we use it
  ; increment reference count for copy of list if necessary
  mov rdi, rsi                                                   ; store copy of list's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$2                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [rbx]                                          ; increment reference count of copy of list
  func$_listConstructor$AfterGCIncref$2:                         ; after GarbageCollectable incref
  mov r9, rbx                                                    ; force cast of copy of list to Integer
  mov r8, qword ptr _gcBlockDataValue                            ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdx, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdx, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_listConstructor$Gcblockdata$TypeMatch                ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 088h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 088h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 0a8h], r9                               ; move force cast of copy of list to Integer's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 0a0h], r8                               ; move copy of _gcBlockData's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov qword ptr [rsp + 098h], rdx                              ; move copy of _gcBlockData's type out of rdx
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 068h]                               ; restoring slot (force cast of copy of list to Integer) to previous scope state for genuine block exit
    mov rdx, qword ptr [rsp + 058h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 060h]                               ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$_listConstructor$Gcblockdata$TypeMatch:                   ; after block
  mov qword ptr [rsp + 078h], rbx                                ; move copy of list's value out of rbx
  mov rbx, r9                                                    ; assign value of force cast of copy of list to Integer to value of + operator result
  add rbx, r8                                                    ; compute (force cast of copy of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 0 type Integer expecting Integer
  mov r13, rbx                                                   ; compute (+ operator result) + (0)
  mov r14, qword ptr [rbp + 048h]                                ; store initialSize's type in __typeOf unary operator result value slot
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r13], r14                                       ; __writeToAddress
  ; Line 392: __writeToAddress(list __as__ Integer + _gcBlockData + 8, initial...
  mov rbx, qword ptr [rsp + 0c0h]                                ; make a copy of list's value in case it changes before we use it
  mov qword ptr [rsp + 070h], rsi                                ; move copy of list's type out of rsi
  mov rsi, qword ptr [rsp + 0b8h]                                ; make a copy of list's type in case it changes before we use it
  ; increment reference count for copy of list if necessary
  mov rdi, rsi                                                   ; store copy of list's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$3                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [rbx]                                          ; increment reference count of copy of list
  func$_listConstructor$AfterGCIncref$3:                         ; after GarbageCollectable incref
  mov r14, rbx                                                   ; force cast of copy of list to Integer
  mov r15, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r10, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_listConstructor$Gcblockdata$TypeMatch$1              ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 068h], rbx                              ; move copy of list's value out of rbx
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 068h], rsi                              ; move copy of list's type out of rsi
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 068h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 088h], r10                              ; move copy of _gcBlockData's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rbx, qword ptr [rsp + 068h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 058h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 048h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$_listConstructor$Gcblockdata$TypeMatch$1:                 ; after block
  mov rdi, r14                                                   ; assign value of force cast of copy of list to Integer to value of + operator result
  add rdi, r15                                                   ; compute (force cast of copy of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov r15, rdi                                                   ; assign value of + operator result to value of + operator result
  add r15, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  mov r10, qword ptr [rbp + 050h]                                ; force cast of initialSize to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], r10                                       ; __writeToAddress
  ; Line 393: __writeToAddress(list __as__ Integer + _gcBlockData + 16 /* 0x10...
  mov rdi, qword ptr [rsp + 0c0h]                                ; make a copy of list's value in case it changes before we use it
  mov rax, qword ptr [rsp + 0b8h]                                ; make a copy of list's type in case it changes before we use it
  ; increment reference count for copy of list if necessary
  mov r12, rax                                                   ; store copy of list's type in testByte value slot
  mov qword ptr [rsp + 068h], rax                                ; move copy of list's type out of rax
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$4                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [rdi]                                          ; increment reference count of copy of list
  func$_listConstructor$AfterGCIncref$4:                         ; after GarbageCollectable incref
  mov r15, rdi                                                   ; force cast of copy of list to Integer
  mov r10, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov qword ptr [rsp + 060h], rbx                                ; move copy of list's value out of rbx
  mov rbx, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_listConstructor$Gcblockdata$TypeMatch$2              ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 058h], rdi                              ; move copy of list's value out of rdi
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], r10                              ; move copy of _gcBlockData's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 040h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 058h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
  func$_listConstructor$Gcblockdata$TypeMatch$2:                 ; after block
  mov rax, r15                                                   ; assign value of force cast of copy of list to Integer to value of + operator result
  add rax, r10                                                   ; compute (force cast of copy of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov rbx, rax                                                   ; assign value of + operator result to value of + operator result
  add rbx, 010h                                                  ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
  mov qword ptr [rsp + 058h], rsi                                ; move copy of list's type out of rsi
  mov rsi, qword ptr [rsp + 098h]                                ; make a copy of data's value in case it changes before we use it
  mov qword ptr [rsp + 050h], rdi                                ; move copy of list's value out of rdi
  mov rdi, qword ptr [rsp + 090h]                                ; make a copy of data's type in case it changes before we use it
  ; increment reference count for copy of data if necessary
  mov r12, rdi                                                   ; store copy of data's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$5                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [rsi]                                          ; increment reference count of copy of data
  func$_listConstructor$AfterGCIncref$5:                         ; after GarbageCollectable incref
  mov r15, rdi                                                   ; store copy of data's type in __typeOf unary operator result value slot
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rbx], r15                                       ; __writeToAddress
  ; Line 394: __writeToAddress(list __as__ Integer + _gcBlockData + 24 /* 0x18...
  mov rbx, qword ptr [rsp + 0c0h]                                ; make a copy of list's value in case it changes before we use it
  mov qword ptr [rsp + 048h], rsi                                ; move copy of data's value out of rsi
  mov rsi, qword ptr [rsp + 0b8h]                                ; make a copy of list's type in case it changes before we use it
  ; increment reference count for copy of list if necessary
  mov qword ptr [rsp + 040h], rdi                                ; move copy of data's type out of rdi
  mov rdi, rsi                                                   ; store copy of list's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$6                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [rbx]                                          ; increment reference count of copy of list
  func$_listConstructor$AfterGCIncref$6:                         ; after GarbageCollectable incref
  mov r14, rbx                                                   ; force cast of copy of list to Integer
  mov r15, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r10, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_listConstructor$Gcblockdata$TypeMatch$3              ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 038h], rbx                              ; move copy of list's value out of rbx
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 038h], rsi                              ; move copy of list's type out of rsi
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of _gcBlockData's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rbx, qword ptr [rsp + 038h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 028h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 018h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$_listConstructor$Gcblockdata$TypeMatch$3:                 ; after block
  mov rdi, r14                                                   ; assign value of force cast of copy of list to Integer to value of + operator result
  add rdi, r15                                                   ; compute (force cast of copy of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 24 /* 0x18 */ type Integer expecting Integer
  mov r15, rdi                                                   ; assign value of + operator result to value of + operator result
  add r15, 018h                                                  ; compute (+ operator result) + (24 /* 0x18 */) (result in + operator result)
  mov r10, qword ptr [rsp + 098h]                                ; make a copy of data's value in case it changes before we use it
  mov qword ptr [rsp + 038h], rbx                                ; move copy of list's value out of rbx
  mov rbx, qword ptr [rsp + 090h]                                ; make a copy of data's type in case it changes before we use it
  ; increment reference count for copy of data if necessary
  mov qword ptr [rsp + 030h], rsi                                ; move copy of list's type out of rsi
  mov rsi, rbx                                                   ; store copy of data's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$7                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r10]                                          ; increment reference count of copy of data
  func$_listConstructor$AfterGCIncref$7:                         ; after GarbageCollectable incref
  mov r13, r10                                                   ; force cast of copy of data to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], r13                                       ; __writeToAddress
  ; Line 395: _gcLocked -= 1;
  mov r15, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov qword ptr [rsp + 028h], r10                                ; move copy of data's value out of r10
  mov r10, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_listConstructor$copyOfGclocked$TypeMatch$1           ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 020h], rbx                              ; move copy of data's type out of rbx
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _gcLocked's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rbx, qword ptr [rsp + 020h]                              ; restoring slot (copy of data) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
  func$_listConstructor$copyOfGclocked$TypeMatch$1:              ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r12, r15                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov r13, 001h                                                  ; read second operand of sub (1)
  sub r12, r13                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r12                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 396: return list;
  mov r10, qword ptr [rsp + 0c0h]                                ; make a copy of list's value in case it changes before we use it
  mov qword ptr [rsp + 020h], rbx                                ; move copy of data's type out of rbx
  mov rbx, qword ptr [rsp + 0b8h]                                ; make a copy of list's type in case it changes before we use it
  ; increment reference count for copy of list if necessary
  mov rsi, rbx                                                   ; store copy of list's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 018h], r12                                ; move -= operator result's value out of r12
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$8                      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r10]                                          ; increment reference count of copy of list
  func$_listConstructor$AfterGCIncref$8:                         ; after GarbageCollectable incref
  ; sentinel check of copy of list type WhateverList expecting WhateverList
  cmp rbx, 000h                                                  ; compare type of copy of list to <sentinel>
  jne func$_listConstructor$ListconstructorReturnValue$TypeMatch ; skip next block if copy of list is not sentinel
    ; Error handling block for _listConstructor return value
    ; Call __error with 1 arguments
    mov r13, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], r10                              ; move copy of list's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 000h]                              ; restoring slot (copy of list) to previous scope state for genuine block exit
  func$_listConstructor$ListconstructorReturnValue$TypeMatch:    ; after block
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of _listConstructor into register to dereference it
  mov qword ptr [r15], r10                                       ; _listConstructor return value
  mov qword ptr [rsp + 010h], r10                                ; move copy of list's value out of r10
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of _listConstructor into register to dereference it
  mov qword ptr [r10], rbx                                       ; type of _listConstructor return value
  ; increment reference count for copy of list if necessary
  mov qword ptr [rsp + 008h], rbx                                ; move copy of list's type out of rbx
  mov rbx, qword ptr [rsp + 008h]                                ; store copy of list's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_listConstructor$AfterGCIncref$9                      ; if not a GarbageCollectable, skip incref
    mov r12, qword ptr [rsp + 010h]                              ; read slot into register for dereferencing
    inc qword ptr [r12]                                          ; increment reference count of copy of list
    mov qword ptr [rsp + 010h], r12                              ; restoring slot (copy of list) to previous scope state for genuine block exit
  func$_listConstructor$AfterGCIncref$9:                         ; after GarbageCollectable incref
  ; Decrement reference count for copy of list (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 028h]                                ; arg #2: copy of list's type
  mov rcx, qword ptr [rsp + 030h]                                ; arg #1: copy of list's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for list variable (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0d8h]                                ; arg #2: list variable's type
  mov rcx, qword ptr [rsp + 0e0h]                                ; arg #1: list variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of list (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 078h]                                ; arg #2: copy of list's type
  mov rcx, qword ptr [rsp + 080h]                                ; arg #1: copy of list's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of list (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 050h]                                ; arg #2: copy of list's type
  mov rcx, qword ptr [rsp + 058h]                                ; arg #1: copy of list's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of data (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 040h]                                ; arg #2: copy of data's type
  mov rcx, qword ptr [rsp + 048h]                                ; arg #1: copy of data's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for data variable (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0b0h]                                ; arg #2: data variable's type
  mov rcx, qword ptr [rsp + 0b8h]                                ; arg #1: data variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _constructor return value (static type: GarbageCollectable'4a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0c8h]                                ; arg #2: _constructor return value's type
  mov rcx, qword ptr [rsp + 0d0h]                                ; arg #1: _constructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of list (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 088h]                                ; arg #2: copy of list's type
  mov rcx, qword ptr [rsp + 070h]                                ; arg #1: copy of list's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of data (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 060h]                                ; arg #2: copy of data's type
  mov rcx, qword ptr [rsp + 068h]                                ; arg #1: copy of data's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _constructor return value (static type: GarbageCollectable'4a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0a0h]                                ; arg #2: _constructor return value's type
  mov rcx, qword ptr [rsp + 0a8h]                                ; arg #1: _constructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of list (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 090h]                                ; arg #2: copy of list's type
  mov rcx, qword ptr [rsp + 098h]                                ; arg #1: copy of list's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0d8h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _growList
dq func$_growList$annotation
func$_growList:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 098h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0d8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _growList to 1 (integer)
  je func$_growList$parameterCountCheck$continuation             ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 090h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 090h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$parameterCountCheck$continuation:               ; end of parameter count check
  ; Check type of parameter 0, list (expecting WhateverList)
  ; type check of list type WhateverList expecting WhateverList
  mov rbx, qword ptr [rbp + 038h]                                ; store list's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that list is WhateverList
  jc func$_growList$list$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for list
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 090h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$list$TypeMatch:                                 ; after block
  ; Line 400: _gcLocked += 1;
  mov r14, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r15, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_growList$copyOfGclocked$TypeMatch                    ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 090h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 090h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$copyOfGclocked$TypeMatch:                       ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov r12, 001h                                                  ; read second operand of add (1)
  add rdi, r12                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rdi                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 401: Integer newSize = len(list) * 2;
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (list)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rbx, qword ptr [rsp + 080h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 080h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of len return value type Integer expecting Integer
  cmp qword ptr [rsp + 068h], 000h                               ; compare type of len return value to <sentinel>
  jne func$_growList$lenList$TypeMatch                           ; skip next block if len return value is not sentinel
    ; Error handling block for len(list)
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$lenList$TypeMatch:                              ; after block
  ; sentinel check of 2 type Integer expecting Integer
  mov r14, qword ptr [rsp + 070h]                                ; read left hand side operand of imul (len return value)
  imul r13, r14, 002h                                            ; compute (len return value) * (2) (result in * operator result)
  ; sentinel check of * operator result type Integer expecting Integer
  mov qword ptr [rsp + 080h], r13                                ; value initialization of variable declaration for newSize variable (* operator result)
  mov qword ptr [rsp + 078h], 038h                               ; type initialization of variable declaration for newSize variable (Integer'38)
  ; Line 402: __ListData newData = _constructor(__typeToCode __ListData, len(l...
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (list)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rsi, qword ptr [rsp + 070h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 070h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov qword ptr [rsp + 050h], rdi                                ; move += operator result's value out of rdi
  mov rdi, qword ptr [rsp + 080h]                                ; make a copy of newSize's value in case it changes before we use it
  mov r12, qword ptr [rsp + 078h]                                ; make a copy of newSize's type in case it changes before we use it
  ; sentinel check of _constructor type GarbageCollectableFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _constructor with 3 arguments
  push rdi                                                       ; value of argument #3 (copy of newSize)
  push r12                                                       ; type of argument #3
  push qword ptr [rsp + 070h]                                    ; value of argument #2 (len return value)
  push qword ptr [rsp + 070h]                                    ; type of argument #2
  push 03ah                                                      ; value of argument #1 (code of __ListData)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r15, qword ptr [rsp + 090h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 090h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_constructor                                         ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; type check of _constructor return value type GarbageCollectable expecting __ListData
  mov r10, qword ptr [rsp + 058h]                                ; store _constructor return value's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that _constructor(__typeToCode __ListData, len(list), newSize) as __ListData is __ListData
  jc func$_growList$ConstructorTypetocodeLIstdataLenListNewsizeAsLIstdata$TypeMatch ; skip next block if the type matches
    ; Error handling block for _constructor(__typeToCode __ListData, len(list), newSize) as __ListData
    ; Call __error with 1 arguments
    mov rdi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rdi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$ConstructorTypetocodeLIstdataLenListNewsizeAsLIstdata$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 060h]                                ; copy value of _constructor return value for cast to __ListData
  mov r14, qword ptr [rsp + 058h]                                ; copy type of _constructor return value for cast to __ListData
  ; sentinel check of cast of _constructor return value to __ListData type __ListData expecting __ListData
  cmp r14, 000h                                                  ; compare type of cast of _constructor return value to __ListData to <sentinel>
  jne func$_growList$castOfConstructorReturnValueToLIstdata$TypeMatch ; skip next block if cast of _constructor return value to __ListData is not sentinel
    ; Error handling block for cast of _constructor return value to __ListData
    ; Call __error with 1 arguments
    mov r15, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$castOfConstructorReturnValueToLIstdata$TypeMatch:  ; after block
  mov qword ptr [rsp + 070h], r13                                ; value initialization of variable declaration for newData variable (cast of _constructor return value to __ListData)
  mov qword ptr [rsp + 068h], r14                                ; type initialization of variable declaration for newData variable
  ; increment reference count for newData variable if necessary
  mov rax, qword ptr [rsp + 068h]                                ; store newData variable's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_growList$AfterGCIncref                               ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 070h]                              ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of newData variable
    mov qword ptr [rsp + 070h], rdi                              ; restoring slot (newData variable) to previous scope state for genuine block exit
  func$_growList$AfterGCIncref:                                  ; after GarbageCollectable incref
  ; Line 403: __ListData oldData = __readFromAddress(list __as__ Integer + _gc...
  mov r12, qword ptr [rbp + 040h]                                ; force cast of list to Integer
  mov r13, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r14, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_growList$Gcblockdata$TypeMatch                       ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$Gcblockdata$TypeMatch:                          ; after block
  mov rsi, r12                                                   ; assign value of force cast of list to Integer to value of + operator result
  add rsi, r13                                                   ; compute (force cast of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov r15, rsi                                                   ; assign value of + operator result to value of + operator result
  add r15, 010h                                                  ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov rdi, r15                                                   ; assign value of + operator result to value of + operator result
  add rdi, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov r14, qword ptr [rdi]                                       ; dereference first argument of __readFromAddress
  mov r15, r14                                                   ; force cast of dereferenced + operator result to __ListData
  ; sentinel check of force cast of dereferenced + operator result to __ListData type __ListData expecting __ListData
  mov qword ptr [rsp + 048h], r15                                ; value initialization of variable declaration for oldData variable (force cast of dereferenced + operator result to __ListData)
  mov qword ptr [rsp + 040h], 03ah                               ; type initialization of variable declaration for oldData variable (__ListData'3a)
  ; increment reference count for oldData variable if necessary
  mov rbx, qword ptr [rsp + 040h]                                ; store oldData variable's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_growList$AfterGCIncref$1                             ; if not a GarbageCollectable, skip incref
    mov r12, qword ptr [rsp + 048h]                              ; read slot into register for dereferencing
    inc qword ptr [r12]                                          ; increment reference count of oldData variable
    mov qword ptr [rsp + 048h], r12                              ; restoring slot (oldData variable) to previous scope state for genuine block exit
  func$_growList$AfterGCIncref$1:                                ; after GarbageCollectable incref
  ; Line 404: _moveBytes(oldData __as__ Integer + _gcBlockData, newData __as__...
  mov r13, qword ptr [rsp + 048h]                                ; make a copy of oldData's value in case it changes before we use it
  mov r14, qword ptr [rsp + 040h]                                ; make a copy of oldData's type in case it changes before we use it
  ; increment reference count for copy of oldData if necessary
  mov r15, r14                                                   ; store copy of oldData's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r9, offset typeTable                                       ; read second operand of + (type table pointer)
  add rax, r9                                                    ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_growList$AfterGCIncref$2                             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of oldData
  func$_growList$AfterGCIncref$2:                                ; after GarbageCollectable incref
  mov r8, r13                                                    ; force cast of copy of oldData to Integer
  mov rdx, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rcx, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of oldData to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rcx, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_growList$Gcblockdata$TypeMatch$1                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 068h], r8                               ; move force cast of copy of oldData to Integer's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov qword ptr [rsp + 060h], rdx                              ; move copy of _gcBlockData's value out of rdx
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov qword ptr [rsp + 058h], rcx                              ; move copy of _gcBlockData's type out of rcx
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rdx, qword ptr [rsp + 020h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
    mov rcx, qword ptr [rsp + 018h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 028h]                               ; restoring slot (force cast of copy of oldData to Integer) to previous scope state for genuine block exit
  func$_growList$Gcblockdata$TypeMatch$1:                        ; after block
  mov qword ptr [rsp + 038h], r13                                ; move copy of oldData's value out of r13
  mov r13, r8                                                    ; assign value of force cast of copy of oldData to Integer to value of + operator result
  add r13, rdx                                                   ; compute (force cast of copy of oldData to Integer) + (copy of _gcBlockData) (result in + operator result)
  mov qword ptr [rsp + 030h], r14                                ; move copy of oldData's type out of r14
  mov r14, qword ptr [rsp + 070h]                                ; make a copy of newData's value in case it changes before we use it
  mov r15, qword ptr [rsp + 068h]                                ; make a copy of newData's type in case it changes before we use it
  ; increment reference count for copy of newData if necessary
  mov rax, r15                                                   ; store copy of newData's type in testByte value slot
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_growList$AfterGCIncref$3                             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r14]                                          ; increment reference count of copy of newData
  func$_growList$AfterGCIncref$3:                                ; after GarbageCollectable incref
  mov rsi, r14                                                   ; force cast of copy of newData to Integer
  mov rdi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r12, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of newData to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_growList$Gcblockdata$TypeMatch$2                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r13                              ; move + operator result's value out of r13
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 028h], r14                              ; move copy of newData's value out of r14
    lea r14, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 028h]                              ; restoring slot (+ operator result) to previous scope state for genuine block exit
    mov r14, qword ptr [rsp + 018h]                              ; restoring slot (copy of newData) to previous scope state for genuine block exit
  func$_growList$Gcblockdata$TypeMatch$2:                        ; after block
  mov qword ptr [rsp + 028h], r15                                ; move copy of newData's type out of r15
  mov r15, rsi                                                   ; assign value of force cast of copy of newData to Integer to value of + operator result
  add r15, rdi                                                   ; compute (force cast of copy of newData to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (list)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rbx, qword ptr [rsp + 030h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 030h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of len return value type Integer expecting Integer
  cmp qword ptr [rsp + 018h], 000h                               ; compare type of len return value to <sentinel>
  jne func$_growList$lenList$TypeMatch$1                         ; skip next block if len return value is not sentinel
    ; Error handling block for len(list)
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$lenList$TypeMatch$1:                            ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov qword ptr [rsp + 010h], r14                                ; move copy of newData's value out of r14
  mov qword ptr [rsp + 008h], r15                                ; move + operator result's value out of r15
  mov r15, qword ptr [rsp + 020h]                                ; read left hand side operand of imul (len return value)
  imul r14, r15, 010h                                            ; compute (len return value) * (16 /* 0x10 */) (result in * operator result)
  ; sentinel check of _moveBytes type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _moveBytes with 3 arguments
  push r14                                                       ; value of argument #3 (* operator result)
  push 038h                                                      ; type of argument #3 (Integer'38)
  push qword ptr [rsp + 018h]                                    ; value of argument #2 (+ operator result)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push r13                                                       ; value of argument #1 (+ operator result)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rbx, qword ptr [rsp + 050h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 050h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_moveBytes                                           ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 405: __writeToAddress(list __as__ Integer + _gcBlockData + 8, newSize...
  mov rsi, qword ptr [rbp + 040h]                                ; force cast of list to Integer
  mov rdi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r12, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_growList$Gcblockdata$TypeMatch$3                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 030h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$Gcblockdata$TypeMatch$3:                        ; after block
  mov r10, rsi                                                   ; assign value of force cast of list to Integer to value of + operator result
  add r10, rdi                                                   ; compute (force cast of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov r13, r10                                                   ; assign value of + operator result to value of + operator result
  add r13, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  mov r14, qword ptr [rsp + 080h]                                ; make a copy of newSize's value in case it changes before we use it
  mov r15, qword ptr [rsp + 078h]                                ; make a copy of newSize's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r13], r14                                       ; __writeToAddress
  ; Line 406: __writeToAddress(list __as__ Integer + _gcBlockData + 16 /* 0x10...
  mov rbx, qword ptr [rbp + 040h]                                ; force cast of list to Integer
  mov rsi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of list to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_growList$Gcblockdata$TypeMatch$4                     ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 090h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_growList$Gcblockdata$TypeMatch$4:                        ; after block
  mov rax, rbx                                                   ; assign value of force cast of list to Integer to value of + operator result
  add rax, rsi                                                   ; compute (force cast of list to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov r12, rax                                                   ; assign value of + operator result to value of + operator result
  add r12, 010h                                                  ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov r10, r12                                                   ; assign value of + operator result to value of + operator result
  add r10, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  mov rbx, qword ptr [rsp + 070h]                                ; make a copy of newData's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 068h]                                ; make a copy of newData's type in case it changes before we use it
  ; increment reference count for copy of newData if necessary
  mov rdi, rsi                                                   ; store copy of newData's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_growList$AfterGCIncref$4                             ; if not a GarbageCollectable, skip incref
    inc qword ptr [rbx]                                          ; increment reference count of copy of newData
  func$_growList$AfterGCIncref$4:                                ; after GarbageCollectable incref
  mov r14, rbx                                                   ; force cast of copy of newData to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r10], r14                                       ; __writeToAddress
  ; Line 407: _gcLocked -= 1;
  mov r10, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov qword ptr [rsp + 080h], rbx                                ; move copy of newData's value out of rbx
  mov rbx, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_growList$copyOfGclocked$TypeMatch$1                  ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 078h], rsi                              ; move copy of newData's type out of rsi
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 030h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _gcLocked's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 078h]                              ; restoring slot (copy of newData) to previous scope state for genuine block exit
  func$_growList$copyOfGclocked$TypeMatch$1:                     ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r13, r10                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov r14, 001h                                                  ; read second operand of sub (1)
  sub r13, r14                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r13                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Implicit return from _growList
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of _growList into register to dereference it
  mov qword ptr [rdi], 000h                                      ; _growList return value
  mov rax, qword ptr [rbp + 028h]                                ; get pointer to return value type of _growList into register to dereference it
  mov qword ptr [rax], 036h                                      ; type of _growList return value (Null'36)
  ; Decrement reference count for copy of oldData (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 050h]                                ; arg #2: copy of oldData's type
  mov rcx, qword ptr [rsp + 058h]                                ; arg #1: copy of oldData's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for oldData variable (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 060h]                                ; arg #2: oldData variable's type
  mov rcx, qword ptr [rsp + 068h]                                ; arg #1: oldData variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _constructor return value (static type: GarbageCollectable'4a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 078h]                                ; arg #2: _constructor return value's type
  mov rcx, qword ptr [rsp + 080h]                                ; arg #1: _constructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of newData (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rsi                                                   ; arg #2: copy of newData's type
  mov rcx, qword ptr [rsp + 0a0h]                                ; arg #1: copy of newData's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of newData (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 048h]                                ; arg #2: copy of newData's type
  mov rcx, qword ptr [rsp + 030h]                                ; arg #1: copy of newData's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for newData variable (static type: __ListData'3a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 088h]                                ; arg #2: newData variable's type
  mov rcx, qword ptr [rsp + 090h]                                ; arg #1: newData variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 098h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; append
dq func$append$annotation
func$append:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 078h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0b8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of append to 2 (integer)
  je func$append$parameterCountCheck$continuation                ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$parameterCountCheck$continuation:                  ; end of parameter count check
  ; Check type of parameter 0, list (expecting WhateverList)
  ; type check of list type WhateverList expecting WhateverList
  mov rbx, qword ptr [rbp + 038h]                                ; store list's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that list is WhateverList
  jc func$append$list$TypeMatch                                  ; skip next block if the type matches
    ; Error handling block for list
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$list$TypeMatch:                                    ; after block
  ; Check type of parameter 1, element (expecting Anything)
  ; type check of element type Anything expecting Anything
  mov r14, qword ptr [rbp + 048h]                                ; store element's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that element is Anything
  jc func$append$element$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for element
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$element$TypeMatch:                                 ; after block
  ; Line 411: _gcLocked += 1;
  mov rdi, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r12, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$append$copyOfGclocked$TypeMatch                       ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$copyOfGclocked$TypeMatch:                          ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov rbx, 001h                                                  ; read second operand of add (1)
  add r10, rbx                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r10                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 412: Integer intermediaryAddress = list __as__ Integer;
  mov r12, qword ptr [rbp + 040h]                                ; force cast of list to Integer
  ; sentinel check of force cast of list to Integer type Integer expecting Integer
  mov qword ptr [rsp + 060h], r12                                ; value initialization of variable declaration for intermediaryAddress variable (force cast of list to Integer)
  mov qword ptr [rsp + 058h], 038h                               ; type initialization of variable declaration for intermediaryAddress variable (Integer'38)
  ; Line 413: Integer size = __readFromAddress(intermediaryAddress + _gcBlockD...
  mov rax, qword ptr [rsp + 060h]                                ; make a copy of intermediaryAddress's value in case it changes before we use it
  mov r15, qword ptr [rsp + 058h]                                ; make a copy of intermediaryAddress's type in case it changes before we use it
  mov qword ptr [rsp + 050h], r10                                ; move += operator result's value out of r10
  mov r10, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rbx, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of copy of intermediaryAddress type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of intermediaryAddress to <sentinel>
  jne func$append$intermediaryaddress$TypeMatch                  ; skip next block if copy of intermediaryAddress is not sentinel
    mov qword ptr [rsp + 048h], 000h                             ; move size variable's value into a mutable location
    mov qword ptr [rsp + 040h], 000h                             ; move size variable's type into a mutable location
    ; Error handling block for intermediaryAddress
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], r10                              ; move copy of _gcBlockData's value out of r10
    mov qword ptr [rsp + 060h], rax                              ; move copy of intermediaryAddress's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 020h]                              ; restoring slot (copy of intermediaryAddress) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 028h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$intermediaryaddress$TypeMatch:                     ; after block
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$append$Gcblockdata$TypeMatch                          ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], r10                              ; move copy of _gcBlockData's value out of r10
    mov qword ptr [rsp + 060h], rax                              ; move copy of intermediaryAddress's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 020h]                              ; restoring slot (copy of intermediaryAddress) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 028h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$Gcblockdata$TypeMatch:                             ; after block
  mov r14, rax                                                   ; assign value of copy of intermediaryAddress to value of + operator result
  add r14, r10                                                   ; compute (copy of intermediaryAddress) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 0 type Integer expecting Integer
  mov rsi, r14                                                   ; compute (+ operator result) + (0)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov rax, rsi                                                   ; assign value of + operator result to value of + operator result
  add rax, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rbx, qword ptr [rax]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 048h], rbx                                ; value initialization of variable declaration for size variable (dereferenced + operator result)
  mov qword ptr [rsp + 040h], 038h                               ; type initialization of variable declaration for size variable (Integer'38)
  ; Line 414: Integer dataAddress = __readFromAddress(intermediaryAddress + _g...
  mov r12, qword ptr [rsp + 060h]                                ; make a copy of intermediaryAddress's value in case it changes before we use it
  mov r13, qword ptr [rsp + 058h]                                ; make a copy of intermediaryAddress's type in case it changes before we use it
  mov r14, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rax, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of copy of intermediaryAddress type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of intermediaryAddress to <sentinel>
  jne func$append$intermediaryaddress$TypeMatch$1                ; skip next block if copy of intermediaryAddress is not sentinel
    mov qword ptr [rsp + 038h], 000h                             ; move dataAddress variable's value into a mutable location
    mov qword ptr [rsp + 030h], 000h                             ; move dataAddress variable's type into a mutable location
    ; Error handling block for intermediaryAddress
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], rax                              ; move copy of _gcBlockData's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 018h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$intermediaryaddress$TypeMatch$1:                   ; after block
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$append$Gcblockdata$TypeMatch$1                        ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], rax                              ; move copy of _gcBlockData's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 018h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$Gcblockdata$TypeMatch$1:                           ; after block
  mov rdi, r12                                                   ; assign value of copy of intermediaryAddress to value of + operator result
  add rdi, r14                                                   ; compute (copy of intermediaryAddress) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov r15, rdi                                                   ; assign value of + operator result to value of + operator result
  add r15, 010h                                                  ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov r12, r15                                                   ; assign value of + operator result to value of + operator result
  add r12, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rax, qword ptr [r12]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 038h], rax                                ; value initialization of variable declaration for dataAddress variable (dereferenced + operator result)
  mov qword ptr [rsp + 030h], 038h                               ; type initialization of variable declaration for dataAddress variable (Integer'38)
  ; Line 415: Integer length = len(list);
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (list)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea rdi, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$len                                                  ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of len return value type Integer expecting Integer
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of len return value to <sentinel>
  jne func$append$lenReturnValue$TypeMatch                       ; skip next block if len return value is not sentinel
    ; Error handling block for len return value
    ; Call __error with 1 arguments
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$lenReturnValue$TypeMatch:                          ; after block
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (stack operand #8, stack operand #10) is not allowed with mov
  mov qword ptr [rsp + 028h], r11                                ; value initialization of variable declaration for length variable (len return value)
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (stack operand #9, stack operand #11) is not allowed with mov
  mov qword ptr [rsp + 020h], r11                                ; type initialization of variable declaration for length variable
  ; Line 416: if (length == size) { ...
  mov r14, qword ptr [rsp + 028h]                                ; make a copy of length's value in case it changes before we use it
  mov rax, qword ptr [rsp + 020h]                                ; make a copy of length's type in case it changes before we use it
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of size's value in case it changes before we use it
  mov r10, qword ptr [rsp + 040h]                                ; make a copy of size's type in case it changes before we use it
  xor rbx, rbx                                                   ; zero value result of == (testing copy of length and copy of size) to put the boolean in
  cmp r14, r15                                                   ; values equal?
  sete bl                                                        ; put result in value result of == (testing copy of length and copy of size)
  mov rsi, 037h                                                  ; value result of == (testing copy of length and copy of size) is a Boolean'37
  xor rdi, rdi                                                   ; zero type result of == (testing copy of length and copy of size) to put the boolean in
  cmp rax, r10                                                   ; types equal?
  sete dil                                                       ; put result in type result of == (testing copy of length and copy of size)
  mov r12, 037h                                                  ; type result of == (testing copy of length and copy of size) is a Boolean'37
  mov r13, rbx                                                   ; assign value of value result of == (testing copy of length and copy of size) to value of == operator result
  and r13, rdi                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r13, 000h                                                  ; compare == operator result to false
  je func$append$if$continuation                                 ; length == size
    ; Line 417: _growList(list);
    ; sentinel check of _growList type NullFunction(WhateverList) expecting AnythingFunction
    ; Call _growList with 1 arguments
    push qword ptr [rbp + 040h]                                  ; value of argument #1 (list)
    push qword ptr [rbp + 038h]                                  ; type of argument #1
    lea r15, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$_growList                                          ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 418: dataAddress = __readFromAddress(intermediaryAddress + _gcBlockDa...
    mov r10, qword ptr [rsp + 060h]                              ; make a copy of intermediaryAddress's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 058h]                              ; make a copy of intermediaryAddress's type in case it changes before we use it
    mov rsi, qword ptr _gcBlockDataValue                         ; make a copy of _gcBlockData's value in case it changes before we use it
    mov rdi, qword ptr _gcBlockDataType                          ; make a copy of _gcBlockData's type in case it changes before we use it
    ; sentinel check of copy of intermediaryAddress type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of intermediaryAddress to <sentinel>
    jne func$append$append$if$intermediaryaddress$TypeMatch      ; skip next block if copy of intermediaryAddress is not sentinel
      ; Error handling block for intermediaryAddress
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 058h], r10                            ; move copy of intermediaryAddress's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 018h]                            ; restoring slot (copy of intermediaryAddress) to previous scope state for genuine block exit
    func$append$append$if$intermediaryaddress$TypeMatch:         ; after block
    ; sentinel check of copy of _gcBlockData type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of _gcBlockData to <sentinel>
    jne func$append$append$if$Gcblockdata$TypeMatch              ; skip next block if copy of _gcBlockData is not sentinel
      ; Error handling block for _gcBlockData
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 058h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 058h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 058h], r10                            ; move copy of intermediaryAddress's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 018h]                            ; restoring slot (copy of intermediaryAddress) to previous scope state for genuine block exit
    func$append$append$if$Gcblockdata$TypeMatch:                 ; after block
    mov r15, r10                                                 ; assign value of copy of intermediaryAddress to value of + operator result
    add r15, rsi                                                 ; compute (copy of intermediaryAddress) + (copy of _gcBlockData) (result in + operator result)
    ; sentinel check of + operator result type Integer expecting Integer
    ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
    mov r12, r15                                                 ; assign value of + operator result to value of + operator result
    add r12, 010h                                                ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
    ; sentinel check of + operator result type Integer expecting Integer
    ; sentinel check of 8 type Integer expecting Integer
    mov r10, r12                                                 ; assign value of + operator result to value of + operator result
    add r10, 008h                                                ; compute (+ operator result) + (8) (result in + operator result)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov rdi, qword ptr [r10]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced + operator result type Integer expecting Integer
    mov qword ptr [rsp + 038h], rdi                              ; store value
    mov qword ptr [rsp + 030h], 038h                             ; store type (Integer'38)
  func$append$if$continuation:                                   ; end of if
  ; Line 420: __writeToAddress(dataAddress + _gcBlockData + length * 16 /* 0x1...
  mov r14, qword ptr [rsp + 038h]                                ; make a copy of dataAddress's value in case it changes before we use it
  mov rax, qword ptr [rsp + 030h]                                ; make a copy of dataAddress's type in case it changes before we use it
  mov r15, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r10, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of copy of dataAddress type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of dataAddress to <sentinel>
  jne func$append$dataaddress$TypeMatch                          ; skip next block if copy of dataAddress is not sentinel
    ; Error handling block for dataAddress
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 088h], r10                              ; move copy of _gcBlockData's type out of r10
    mov qword ptr [rsp + 080h], rax                              ; move copy of dataAddress's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 040h]                              ; restoring slot (copy of dataAddress) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 048h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$dataaddress$TypeMatch:                             ; after block
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$append$Gcblockdata$TypeMatch$2                        ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 060h], rdi                              ; move dereferenced + operator result's value out of rdi
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], r10                              ; move copy of _gcBlockData's type out of r10
    mov qword ptr [rsp + 058h], rax                              ; move copy of dataAddress's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 018h]                              ; restoring slot (copy of dataAddress) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 040h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$append$Gcblockdata$TypeMatch$2:                           ; after block
  mov r13, r14                                                   ; assign value of copy of dataAddress to value of + operator result
  add r13, r15                                                   ; compute (copy of dataAddress) + (copy of _gcBlockData) (result in + operator result)
  mov r14, qword ptr [rsp + 028h]                                ; make a copy of length's value in case it changes before we use it
  mov rax, qword ptr [rsp + 020h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$append$length$TypeMatch                               ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], rax                              ; move copy of length's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 040h]                              ; restoring slot (copy of length) to previous scope state for genuine block exit
  func$append$length$TypeMatch:                                  ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  imul rdi, r14, 010h                                            ; compute (copy of length) * (16 /* 0x10 */) (result in * operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov r15, r13                                                   ; assign value of + operator result to value of + operator result
  add r15, rdi                                                   ; compute (+ operator result) + (* operator result) (result in + operator result)
  mov r10, qword ptr [rbp + 048h]                                ; store element's type in __typeOf unary operator result value slot
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], r10                                       ; __writeToAddress
  ; Line 421: __writeToAddress(dataAddress + _gcBlockData + length * 16 /* 0x1...
  mov rdi, qword ptr [rsp + 038h]                                ; make a copy of dataAddress's value in case it changes before we use it
  mov r12, qword ptr [rsp + 030h]                                ; make a copy of dataAddress's type in case it changes before we use it
  mov r13, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov r14, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of copy of dataAddress type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of dataAddress to <sentinel>
  jne func$append$dataaddress$TypeMatch$1                        ; skip next block if copy of dataAddress is not sentinel
    ; Error handling block for dataAddress
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$dataaddress$TypeMatch$1:                           ; after block
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$append$Gcblockdata$TypeMatch$3                        ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 068h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$Gcblockdata$TypeMatch$3:                           ; after block
  mov rsi, rdi                                                   ; assign value of copy of dataAddress to value of + operator result
  add rsi, r13                                                   ; compute (copy of dataAddress) + (copy of _gcBlockData) (result in + operator result)
  mov rdi, qword ptr [rsp + 028h]                                ; make a copy of length's value in case it changes before we use it
  mov r12, qword ptr [rsp + 020h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$append$length$TypeMatch$1                             ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$length$TypeMatch$1:                                ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  imul r10, rdi, 010h                                            ; compute (copy of length) * (16 /* 0x10 */) (result in * operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov r13, rsi                                                   ; assign value of + operator result to value of + operator result
  add r13, r10                                                   ; compute (+ operator result) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov rbx, r13                                                   ; assign value of + operator result to value of + operator result
  add rbx, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  mov rsi, qword ptr [rbp + 050h]                                ; force cast of element to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rbx], rsi                                       ; __writeToAddress
  ; Line 422: __writeToAddress(dataAddress + _gcBlockHeaderLength, length + 1)...
  mov r13, qword ptr [rsp + 038h]                                ; make a copy of dataAddress's value in case it changes before we use it
  mov r14, qword ptr [rsp + 030h]                                ; make a copy of dataAddress's type in case it changes before we use it
  mov rax, qword ptr _gcBlockHeaderLengthValue                   ; make a copy of _gcBlockHeaderLength's value in case it changes before we use it
  mov r15, qword ptr _gcBlockHeaderLengthType                    ; make a copy of _gcBlockHeaderLength's type in case it changes before we use it
  ; sentinel check of copy of dataAddress type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of dataAddress to <sentinel>
  jne func$append$dataaddress$TypeMatch$2                        ; skip next block if copy of dataAddress is not sentinel
    ; Error handling block for dataAddress
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 068h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], rax                              ; move copy of _gcBlockHeaderLength's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 040h]                              ; restoring slot (copy of _gcBlockHeaderLength) to previous scope state for genuine block exit
  func$append$dataaddress$TypeMatch$2:                           ; after block
  ; sentinel check of copy of _gcBlockHeaderLength type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcBlockHeaderLength to <sentinel>
  jne func$append$Gcblockheaderlength$TypeMatch                  ; skip next block if copy of _gcBlockHeaderLength is not sentinel
    ; Error handling block for _gcBlockHeaderLength
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 068h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 080h], rax                              ; move copy of _gcBlockHeaderLength's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 040h]                              ; restoring slot (copy of _gcBlockHeaderLength) to previous scope state for genuine block exit
  func$append$Gcblockheaderlength$TypeMatch:                     ; after block
  mov r12, r13                                                   ; assign value of copy of dataAddress to value of + operator result
  add r12, rax                                                   ; compute (copy of dataAddress) + (copy of _gcBlockHeaderLength) (result in + operator result)
  mov r13, qword ptr [rsp + 028h]                                ; make a copy of length's value in case it changes before we use it
  mov r14, qword ptr [rsp + 020h]                                ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r14, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$append$length$TypeMatch$2                             ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$length$TypeMatch$2:                                ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rsi, r13                                                   ; assign value of copy of length to value of + operator result
  add rsi, 001h                                                  ; compute (copy of length) + (1) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r12], rsi                                       ; __writeToAddress
  ; Line 423: __incref(element);
  ; sentinel check of __incref type NullFunction(Anything) expecting AnythingFunction
  ; Call __incref with 1 arguments
  ; increment reference count for element if necessary
  cmp qword ptr [rbp + 048h], 039h                               ; compare type of element to String
  jne func$append$AfterStringIncref                              ; if not a String, skip incref
    mov rax, qword ptr [rbp + 050h]                              ; get element into register to dereference it
    mov r15, qword ptr [rax]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns func$append$StringIncref                                 ; if reference count is negative (constant strings), skip incref
    jmp func$append$AfterStringIncref                            ; skip incref for string constants
    func$append$StringIncref:                                    ; real String
      mov r10, qword ptr [rbp + 050h]                            ; read slot into register for dereferencing
      inc qword ptr [r10]                                        ; increment reference count of element
  func$append$AfterStringIncref:                                 ; after String incref
  ; Line 424: _gcLocked -= 1;
  mov rbx, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rsi, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$append$copyOfGclocked$TypeMatch$1                     ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$append$copyOfGclocked$TypeMatch$1:                        ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rax, rbx                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov r15, 001h                                                  ; read second operand of sub (1)
  sub rax, r15                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rax                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Implicit return from append
  ; sentinel check of null type Null expecting Null
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of append into register to dereference it
  mov qword ptr [r12], 000h                                      ; append return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of append into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of append return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 078h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _classAllocator
dq func$_classAllocator$annotation
func$_classAllocator:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0a8h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0e8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _classAllocator to 1 (integer)
  je func$_classAllocator$parameterCountCheck$continuation       ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$parameterCountCheck$continuation:         ; end of parameter count check
  ; Check type of parameter 0, vmt (expecting Integer)
  ; type check of vmt type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store vmt's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that vmt is Integer
  jc func$_classAllocator$vmt$TypeMatch                          ; skip next block if the type matches
    ; Error handling block for vmt
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$vmt$TypeMatch:                            ; after block
  ; Line 548: _gcLocked += 1;
  mov r14, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r15, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_classAllocator$copyOfGclocked$TypeMatch              ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 0a8h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 0a8h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$copyOfGclocked$TypeMatch:                 ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov r12, 001h                                                  ; read second operand of add (1)
  add rdi, r12                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rdi                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 549: Integer typeCode = __readFromAddress(vmt + _vmtTypeCode);
  mov r15, qword ptr _vmtTypeCodeValue                           ; make a copy of _vmtTypeCode's value in case it changes before we use it
  mov r10, qword ptr _vmtTypeCodeType                            ; make a copy of _vmtTypeCode's type in case it changes before we use it
  ; sentinel check of vmt type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of vmt to <sentinel>
  jne func$_classAllocator$vmt$TypeMatch$1                       ; skip next block if vmt is not sentinel
    mov qword ptr [rsp + 098h], 000h                             ; move typeCode variable's value into a mutable location
    mov qword ptr [rsp + 090h], 000h                             ; move typeCode variable's type into a mutable location
    ; Error handling block for vmt
    ; Call __error with 1 arguments
    mov rbx, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 098h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0b8h], r10                              ; move copy of _vmtTypeCode's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 078h]                              ; restoring slot (copy of _vmtTypeCode) to previous scope state for genuine block exit
  func$_classAllocator$vmt$TypeMatch$1:                          ; after block
  ; sentinel check of copy of _vmtTypeCode type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _vmtTypeCode to <sentinel>
  jne func$_classAllocator$Vmttypecode$TypeMatch                 ; skip next block if copy of _vmtTypeCode is not sentinel
    ; Error handling block for _vmtTypeCode
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 090h], rdi                              ; move += operator result's value out of rdi
    lea rdi, qword ptr [rsp + 098h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 090h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0b0h], r10                              ; move copy of _vmtTypeCode's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 070h]                              ; restoring slot (copy of _vmtTypeCode) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 080h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$_classAllocator$Vmttypecode$TypeMatch:                    ; after block
  mov r12, qword ptr [rbp + 040h]                                ; assign value of vmt to value of + operator result
  add r12, r15                                                   ; compute (vmt) + (copy of _vmtTypeCode) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov r15, qword ptr [r12]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 098h], r15                                ; value initialization of variable declaration for typeCode variable (dereferenced + operator result)
  mov qword ptr [rsp + 090h], 038h                               ; type initialization of variable declaration for typeCode variable (Integer'38)
  ; Line 550: assert(typeCode >= 0, 'tried to construct class without a type c...
  mov rax, qword ptr [rsp + 098h]                                ; make a copy of typeCode's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 090h]                                ; make a copy of typeCode's type in case it changes before we use it
  ; sentinel check of copy of typeCode type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of typeCode to <sentinel>
  jne func$_classAllocator$typecode$TypeMatch                    ; skip next block if copy of typeCode is not sentinel
    ; Error handling block for typeCode
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 088h], rdi                              ; move += operator result's value out of rdi
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 090h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0b0h], rax                              ; move copy of typeCode's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 070h]                              ; restoring slot (copy of typeCode) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 088h]                              ; restoring slot (+= operator result) to previous scope state for genuine block exit
  func$_classAllocator$typecode$TypeMatch:                       ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r15, r15                                                   ; clear >= operator result
  cmp rax, 000h                                                  ; compare copy of typeCode with 0
  setge r15b                                                     ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov rax, offset string$29                                      ; reading string for push
  push rax                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r15                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rsi, qword ptr [rsp + 0a8h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 0a8h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 551: Integer fieldCount = __readFromAddress(vmt + _vmtFieldCount);
  mov qword ptr [rsp + 088h], rdi                                ; move += operator result's value out of rdi
  mov rdi, qword ptr _vmtFieldCountValue                         ; make a copy of _vmtFieldCount's value in case it changes before we use it
  mov r12, qword ptr _vmtFieldCountType                          ; make a copy of _vmtFieldCount's type in case it changes before we use it
  ; sentinel check of vmt type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of vmt to <sentinel>
  jne func$_classAllocator$vmt$TypeMatch$2                       ; skip next block if vmt is not sentinel
    mov qword ptr [rsp + 080h], 000h                             ; move fieldCount variable's value into a mutable location
    mov qword ptr [rsp + 078h], 000h                             ; move fieldCount variable's type into a mutable location
    ; Error handling block for vmt
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 080h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 080h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$vmt$TypeMatch$2:                          ; after block
  ; sentinel check of copy of _vmtFieldCount type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _vmtFieldCount to <sentinel>
  jne func$_classAllocator$Vmtfieldcount$TypeMatch               ; skip next block if copy of _vmtFieldCount is not sentinel
    ; Error handling block for _vmtFieldCount
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 080h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 080h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$Vmtfieldcount$TypeMatch:                  ; after block
  mov rbx, qword ptr [rbp + 040h]                                ; assign value of vmt to value of + operator result
  add rbx, rdi                                                   ; compute (vmt) + (copy of _vmtFieldCount) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rdi, qword ptr [rbx]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 080h], rdi                                ; value initialization of variable declaration for fieldCount variable (dereferenced + operator result)
  mov qword ptr [rsp + 078h], 038h                               ; type initialization of variable declaration for fieldCount variable (Integer'38)
  ; Line 552: assert(fieldCount >= 2, 'unexpectedly small field count');
  mov r14, qword ptr [rsp + 080h]                                ; make a copy of fieldCount's value in case it changes before we use it
  mov r15, qword ptr [rsp + 078h]                                ; make a copy of fieldCount's type in case it changes before we use it
  ; sentinel check of copy of fieldCount type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of fieldCount to <sentinel>
  jne func$_classAllocator$fieldcount$TypeMatch                  ; skip next block if copy of fieldCount is not sentinel
    ; Error handling block for fieldCount
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 080h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 080h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$fieldcount$TypeMatch:                     ; after block
  ; sentinel check of 2 type Integer expecting Integer
  xor rdi, rdi                                                   ; clear >= operator result
  cmp r14, 002h                                                  ; compare copy of fieldCount with 2
  setge dil                                                      ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r14, offset string$30                                      ; reading string for push
  push r14                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r15, qword ptr [rsp + 090h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 090h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 553: __Object instance = _constructor(typeCode, fieldCount, fieldCoun...
  mov r10, qword ptr [rsp + 098h]                                ; make a copy of typeCode's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 090h]                                ; make a copy of typeCode's type in case it changes before we use it
  mov rax, qword ptr [rsp + 080h]                                ; make a copy of fieldCount's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 078h]                                ; make a copy of fieldCount's type in case it changes before we use it
  mov rdi, qword ptr [rsp + 080h]                                ; make a copy of fieldCount's value in case it changes before we use it
  mov r12, qword ptr [rsp + 078h]                                ; make a copy of fieldCount's type in case it changes before we use it
  ; sentinel check of _constructor type GarbageCollectableFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _constructor with 3 arguments
  push rdi                                                       ; value of argument #3 (copy of fieldCount)
  push r12                                                       ; type of argument #3
  push rax                                                       ; value of argument #2 (copy of fieldCount)
  push rsi                                                       ; type of argument #2
  push r10                                                       ; value of argument #1 (copy of typeCode)
  push rbx                                                       ; type of argument #1
  lea r15, qword ptr [rsp + 0a0h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 0a0h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_constructor                                         ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; type check of _constructor return value type GarbageCollectable expecting __Object
  mov r10, qword ptr [rsp + 068h]                                ; store _constructor return value's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that _constructor(typeCode, fieldCount, fieldCount) as __Object is __Object
  jc func$_classAllocator$ConstructorTypecodeFieldcountFieldcountAsOBject$TypeMatch ; skip next block if the type matches
    ; Error handling block for _constructor(typeCode, fieldCount, fieldCount) as __Object
    ; Call __error with 1 arguments
    mov rdi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rdi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$ConstructorTypecodeFieldcountFieldcountAsOBject$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 070h]                                ; copy value of _constructor return value for cast to __Object
  mov r14, qword ptr [rsp + 068h]                                ; copy type of _constructor return value for cast to __Object
  ; sentinel check of cast of _constructor return value to __Object type __Object expecting __Object
  cmp r14, 000h                                                  ; compare type of cast of _constructor return value to __Object to <sentinel>
  jne func$_classAllocator$castOfConstructorReturnValueToOBject$TypeMatch ; skip next block if cast of _constructor return value to __Object is not sentinel
    ; Error handling block for cast of _constructor return value to __Object
    ; Call __error with 1 arguments
    mov r15, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$castOfConstructorReturnValueToOBject$TypeMatch:  ; after block
  mov qword ptr [rsp + 098h], r13                                ; value initialization of variable declaration for instance variable (cast of _constructor return value to __Object)
  mov qword ptr [rsp + 090h], r14                                ; type initialization of variable declaration for instance variable
  ; increment reference count for instance variable if necessary
  mov rax, qword ptr [rsp + 090h]                                ; store instance variable's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 098h]                              ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of instance variable
    mov qword ptr [rsp + 098h], rdi                              ; restoring slot (instance variable) to previous scope state for genuine block exit
  func$_classAllocator$AfterGCIncref:                            ; after GarbageCollectable incref
  ; Line 554: __writeToAddress(instance __as__ Integer + _gcBlockData + 0, __t...
  mov r12, qword ptr [rsp + 098h]                                ; make a copy of instance's value in case it changes before we use it
  mov r13, qword ptr [rsp + 090h]                                ; make a copy of instance's type in case it changes before we use it
  ; increment reference count for copy of instance if necessary
  mov r14, r13                                                   ; store copy of instance's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$1                       ; if not a GarbageCollectable, skip incref
    inc qword ptr [r12]                                          ; increment reference count of copy of instance
  func$_classAllocator$AfterGCIncref$1:                          ; after GarbageCollectable incref
  mov r9, r12                                                    ; force cast of copy of instance to Integer
  mov r8, qword ptr _gcBlockDataValue                            ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdx, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of instance to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdx, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_classAllocator$Gcblockdata$TypeMatch                 ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 070h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 070h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 090h], r9                               ; move force cast of copy of instance to Integer's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 088h], r8                               ; move copy of _gcBlockData's value out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov qword ptr [rsp + 080h], rdx                              ; move copy of _gcBlockData's type out of rdx
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 050h]                               ; restoring slot (force cast of copy of instance to Integer) to previous scope state for genuine block exit
    mov rdx, qword ptr [rsp + 040h]                              ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 048h]                               ; restoring slot (copy of _gcBlockData) to previous scope state for genuine block exit
  func$_classAllocator$Gcblockdata$TypeMatch:                    ; after block
  mov qword ptr [rsp + 060h], r12                                ; move copy of instance's value out of r12
  mov r12, r9                                                    ; assign value of force cast of copy of instance to Integer to value of + operator result
  add r12, r8                                                    ; compute (force cast of copy of instance to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 0 type Integer expecting Integer
  mov r10, r12                                                   ; compute (+ operator result) + (0)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r10], 038h                                      ; __writeToAddress
  ; Line 555: __writeToAddress(instance __as__ Integer + _gcBlockData + 8, vmt...
  mov rdi, qword ptr [rsp + 098h]                                ; make a copy of instance's value in case it changes before we use it
  mov r12, qword ptr [rsp + 090h]                                ; make a copy of instance's type in case it changes before we use it
  ; increment reference count for copy of instance if necessary
  mov qword ptr [rsp + 058h], r13                                ; move copy of instance's type out of r13
  mov r13, r12                                                   ; store copy of instance's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$2                       ; if not a GarbageCollectable, skip incref
    inc qword ptr [rdi]                                          ; increment reference count of copy of instance
  func$_classAllocator$AfterGCIncref$2:                          ; after GarbageCollectable incref
  mov r10, rdi                                                   ; force cast of copy of instance to Integer
  mov rbx, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rsi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of instance to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_classAllocator$Gcblockdata$TypeMatch$1               ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 050h], rdi                              ; move copy of instance's value out of rdi
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 050h], r12                              ; move copy of instance's type out of r12
    lea r12, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 070h], r10                              ; move force cast of copy of instance to Integer's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 040h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 030h]                              ; restoring slot (force cast of copy of instance to Integer) to previous scope state for genuine block exit
    mov rdi, qword ptr [rsp + 050h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$Gcblockdata$TypeMatch$1:                  ; after block
  mov r13, r10                                                   ; assign value of force cast of copy of instance to Integer to value of + operator result
  add r13, rbx                                                   ; compute (force cast of copy of instance to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  mov rbx, r13                                                   ; assign value of + operator result to value of + operator result
  add rbx, 008h                                                  ; compute (+ operator result) + (8) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rsp + 050h], r12                                ; move copy of instance's type out of r12
  mov r12, qword ptr [rbp + 040h]                                ; read second operand of mov (vmt) for MoveToDerefInstruction
  mov qword ptr [rbx], r12                                       ; __writeToAddress
  ; Line 556: __writeToAddress(instance __as__ Integer + _gcBlockData + 16 /* ...
  mov r13, qword ptr [rsp + 098h]                                ; make a copy of instance's value in case it changes before we use it
  mov rax, qword ptr [rsp + 090h]                                ; make a copy of instance's type in case it changes before we use it
  ; increment reference count for copy of instance if necessary
  mov r14, rax                                                   ; store copy of instance's type in testByte value slot
  mov qword ptr [rsp + 048h], rax                                ; move copy of instance's type out of rax
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$3                       ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of instance
  func$_classAllocator$AfterGCIncref$3:                          ; after GarbageCollectable incref
  mov rbx, r13                                                   ; force cast of copy of instance to Integer
  mov rsi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov qword ptr [rsp + 040h], rdi                                ; move copy of instance's value out of rdi
  mov rdi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of instance to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_classAllocator$Gcblockdata$TypeMatch$2               ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 040h], r13                              ; move copy of instance's value out of r13
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 030h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$Gcblockdata$TypeMatch$2:                  ; after block
  mov r14, rbx                                                   ; assign value of force cast of copy of instance to Integer to value of + operator result
  add r14, rsi                                                   ; compute (force cast of copy of instance to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov rsi, r14                                                   ; assign value of + operator result to value of + operator result
  add rsi, 010h                                                  ; compute (+ operator result) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rsi], 039h                                      ; __writeToAddress
  ; Line 557: __writeToAddress(instance __as__ Integer + _gcBlockData + 24 /* ...
  mov qword ptr [rsp + 038h], r13                                ; move copy of instance's value out of r13
  mov r13, qword ptr [rsp + 098h]                                ; make a copy of instance's value in case it changes before we use it
  mov r14, qword ptr [rsp + 090h]                                ; make a copy of instance's type in case it changes before we use it
  ; increment reference count for copy of instance if necessary
  mov rax, r14                                                   ; store copy of instance's type in testByte value slot
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$4                       ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of copy of instance
  func$_classAllocator$AfterGCIncref$4:                          ; after GarbageCollectable incref
  mov rbx, r13                                                   ; force cast of copy of instance to Integer
  mov rsi, qword ptr _gcBlockDataValue                           ; make a copy of _gcBlockData's value in case it changes before we use it
  mov rdi, qword ptr _gcBlockDataType                            ; make a copy of _gcBlockData's type in case it changes before we use it
  ; sentinel check of force cast of copy of instance to Integer type Integer expecting Integer
  ; sentinel check of copy of _gcBlockData type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _gcBlockData to <sentinel>
  jne func$_classAllocator$Gcblockdata$TypeMatch$3               ; skip next block if copy of _gcBlockData is not sentinel
    ; Error handling block for _gcBlockData
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 030h], r13                              ; move copy of instance's value out of r13
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 030h], r14                              ; move copy of instance's type out of r14
    lea r14, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 030h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
    mov r14, qword ptr [rsp + 020h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$Gcblockdata$TypeMatch$3:                  ; after block
  mov rax, rbx                                                   ; assign value of force cast of copy of instance to Integer to value of + operator result
  add rax, rsi                                                   ; compute (force cast of copy of instance to Integer) + (copy of _gcBlockData) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of 24 /* 0x18 */ type Integer expecting Integer
  mov rdi, rax                                                   ; assign value of + operator result to value of + operator result
  add rdi, 018h                                                  ; compute (+ operator result) + (24 /* 0x18 */) (result in + operator result)
  mov r12, qword ptr _vmtClassNameValue                          ; make a copy of _vmtClassName's value in case it changes before we use it
  mov qword ptr [rsp + 030h], r13                                ; move copy of instance's value out of r13
  mov r13, qword ptr _vmtClassNameType                           ; make a copy of _vmtClassName's type in case it changes before we use it
  ; sentinel check of vmt type Integer expecting Integer
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of vmt to <sentinel>
  jne func$_classAllocator$vmt$TypeMatch$3                       ; skip next block if vmt is not sentinel
    ; Error handling block for vmt
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r14                              ; move copy of instance's type out of r14
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 030h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r14, qword ptr [rsp + 028h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$vmt$TypeMatch$3:                          ; after block
  ; sentinel check of copy of _vmtClassName type Integer expecting Integer
  cmp r13, 000h                                                  ; compare type of copy of _vmtClassName to <sentinel>
  jne func$_classAllocator$Vmtclassname$TypeMatch                ; skip next block if copy of _vmtClassName is not sentinel
    ; Error handling block for _vmtClassName
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$Vmtclassname$TypeMatch:                   ; after block
  mov rbx, qword ptr [rbp + 040h]                                ; assign value of vmt to value of + operator result
  add rbx, r12                                                   ; compute (vmt) + (copy of _vmtClassName) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov r12, qword ptr [rbx]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rdi], r12                                       ; __writeToAddress
  ; Line 558: if (fieldCount > 2) { ...
  mov rax, qword ptr [rsp + 080h]                                ; make a copy of fieldCount's value in case it changes before we use it
  mov r15, qword ptr [rsp + 078h]                                ; make a copy of fieldCount's type in case it changes before we use it
  ; sentinel check of copy of fieldCount type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of fieldCount to <sentinel>
  jne func$_classAllocator$fieldcount$TypeMatch$1                ; skip next block if copy of fieldCount is not sentinel
    ; Error handling block for fieldCount
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], rax                              ; move copy of fieldCount's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 018h]                              ; restoring slot (copy of fieldCount) to previous scope state for genuine block exit
  func$_classAllocator$fieldcount$TypeMatch$1:                   ; after block
  ; sentinel check of 2 type Integer expecting Integer
  xor r12, r12                                                   ; clear > operator result
  cmp rax, 002h                                                  ; compare copy of fieldCount with 2
  setg r12b                                                      ; store result in > operator result
  ; sentinel check of > operator result type Boolean expecting Boolean
  cmp r12, 000h                                                  ; compare > operator result to false
  je func$_classAllocator$if$continuation                        ; fieldCount > 2
    ; Line 559: _fillQuadWords(instance __as__ Integer + _gcBlockData + 32 /* 0x...
    mov rax, qword ptr [rsp + 098h]                              ; make a copy of instance's value in case it changes before we use it
    mov r15, qword ptr [rsp + 090h]                              ; make a copy of instance's type in case it changes before we use it
    ; increment reference count for copy of instance if necessary
    mov r10, r15                                                 ; store copy of instance's type in testByte value slot
    mov qword ptr [rsp + 028h], rax                              ; move copy of instance's value out of rax
    mov rax, r10                                                 ; move testByte to testByte
    mov rbx, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rbx                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rsi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rsi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_classAllocator$Classallocator$if$AfterGCIncref     ; if not a GarbageCollectable, skip incref
      mov rdi, qword ptr [rsp + 028h]                            ; read slot into register for dereferencing
      inc qword ptr [rdi]                                        ; increment reference count of copy of instance
      mov qword ptr [rsp + 028h], rdi                            ; restoring slot (copy of instance) to previous scope state for genuine block exit
    func$_classAllocator$Classallocator$if$AfterGCIncref:        ; after GarbageCollectable incref
    mov r12, qword ptr [rsp + 028h]                              ; force cast of copy of instance to Integer
    mov r13, qword ptr _gcBlockDataValue                         ; make a copy of _gcBlockData's value in case it changes before we use it
    mov qword ptr [rsp + 020h], r14                              ; move copy of instance's type out of r14
    mov r14, qword ptr _gcBlockDataType                          ; make a copy of _gcBlockData's type in case it changes before we use it
    ; sentinel check of force cast of copy of instance to Integer type Integer expecting Integer
    ; sentinel check of copy of _gcBlockData type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of _gcBlockData to <sentinel>
    jne func$_classAllocator$Classallocator$if$Gcblockdata$TypeMatch ; skip next block if copy of _gcBlockData is not sentinel
      ; Error handling block for _gcBlockData
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 018h], r15                            ; move copy of instance's type out of r15
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 020h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 020h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r15, qword ptr [rsp + 018h]                            ; restoring slot (copy of instance) to previous scope state for genuine block exit
    func$_classAllocator$Classallocator$if$Gcblockdata$TypeMatch:  ; after block
    mov rax, r12                                                 ; assign value of force cast of copy of instance to Integer to value of + operator result
    add rax, r13                                                 ; compute (force cast of copy of instance to Integer) + (copy of _gcBlockData) (result in + operator result)
    ; sentinel check of + operator result type Integer expecting Integer
    ; sentinel check of 32 /* 0x20 */ type Integer expecting Integer
    mov r13, rax                                                 ; assign value of + operator result to value of + operator result
    add r13, 020h                                                ; compute (+ operator result) + (32 /* 0x20 */) (result in + operator result)
    mov r14, qword ptr [rsp + 080h]                              ; make a copy of fieldCount's value in case it changes before we use it
    mov qword ptr [rsp + 018h], r15                              ; move copy of instance's type out of r15
    mov r15, qword ptr [rsp + 078h]                              ; make a copy of fieldCount's type in case it changes before we use it
    ; sentinel check of copy of fieldCount type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of fieldCount to <sentinel>
    jne func$_classAllocator$Classallocator$if$fieldcount$TypeMatch ; skip next block if copy of fieldCount is not sentinel
      ; Error handling block for fieldCount
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_classAllocator$Classallocator$if$fieldcount$TypeMatch:  ; after block
    ; sentinel check of 2 type Integer expecting Integer
    mov rdi, r14                                                 ; assign value of copy of fieldCount to value of - operator result
    sub rdi, 002h                                                ; compute (copy of fieldCount) - (2)
    ; sentinel check of - operator result type Integer expecting Integer
    ; sentinel check of 8 type Integer expecting Integer
    imul r10, rdi, 008h                                          ; compute (- operator result) * (8) (result in * operator result)
    ; sentinel check of _fillQuadWords type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
    ; Call _fillQuadWords with 3 arguments
    push 000h                                                    ; value of argument #3 (0)
    push 038h                                                    ; type of argument #3 (Integer'38)
    push r10                                                     ; value of argument #2 (* operator result)
    push 038h                                                    ; type of argument #2 (Integer'38)
    push r13                                                     ; value of argument #1 (+ operator result)
    push 038h                                                    ; type of argument #1 (Integer'38)
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 003h                                                ; internal argument 1: number of actual arguments
    call func$_fillQuadWords                                     ; jump to subroutine
    add rsp, 060h                                                ; release shadow space and arguments (result in stack pointer)
    ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 038h]                              ; arg #2: copy of instance's type
    mov rcx, qword ptr [rsp + 048h]                              ; arg #1: copy of instance's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    mov r14, qword ptr [rsp + 020h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$if$continuation:                          ; end of if
  ; Line 561: _gcLocked -= 1;
  mov rdi, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov r12, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_classAllocator$copyOfGclocked$TypeMatch$1            ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 088h], r14                              ; move copy of instance's type out of r14
    lea r14, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r14, qword ptr [rsp + 078h]                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$copyOfGclocked$TypeMatch$1:               ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov rax, rdi                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov rbx, 001h                                                  ; read second operand of sub (1)
  sub rax, rbx                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, rax                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 562: return instance;
  mov r12, qword ptr [rsp + 098h]                                ; make a copy of instance's value in case it changes before we use it
  mov r13, qword ptr [rsp + 090h]                                ; make a copy of instance's type in case it changes before we use it
  ; increment reference count for copy of instance if necessary
  mov qword ptr [rsp + 080h], r14                                ; move copy of instance's type out of r14
  mov r14, r13                                                   ; store copy of instance's type in testByte value slot
  mov qword ptr [rsp + 078h], rax                                ; move -= operator result's value out of rax
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$5                       ; if not a GarbageCollectable, skip incref
    inc qword ptr [r12]                                          ; increment reference count of copy of instance
  func$_classAllocator$AfterGCIncref$5:                          ; after GarbageCollectable incref
  ; sentinel check of copy of instance type __Object expecting __Object
  cmp r13, 000h                                                  ; compare type of copy of instance to <sentinel>
  jne func$_classAllocator$ClassallocatorReturnValue$TypeMatch   ; skip next block if copy of instance is not sentinel
    ; Error handling block for _classAllocator return value
    ; Call __error with 1 arguments
    mov rbx, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 030h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_classAllocator$ClassallocatorReturnValue$TypeMatch:      ; after block
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of _classAllocator into register to dereference it
  mov qword ptr [rdi], r12                                       ; _classAllocator return value
  mov qword ptr [rsp + 020h], r12                                ; move copy of instance's value out of r12
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of _classAllocator into register to dereference it
  mov qword ptr [r12], r13                                       ; type of _classAllocator return value
  ; increment reference count for copy of instance if necessary
  mov qword ptr [rsp + 010h], r13                                ; move copy of instance's type out of r13
  mov r13, qword ptr [rsp + 010h]                                ; store copy of instance's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_classAllocator$AfterGCIncref$6                       ; if not a GarbageCollectable, skip incref
    mov r10, qword ptr [rsp + 020h]                              ; read slot into register for dereferencing
    inc qword ptr [r10]                                          ; increment reference count of copy of instance
    mov qword ptr [rsp + 020h], r10                              ; restoring slot (copy of instance) to previous scope state for genuine block exit
  func$_classAllocator$AfterGCIncref$6:                          ; after GarbageCollectable incref
  ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 070h]                                ; arg #2: copy of instance's type
  mov rcx, qword ptr [rsp + 060h]                                ; arg #1: copy of instance's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 068h]                                ; arg #2: copy of instance's type
  mov rcx, qword ptr [rsp + 058h]                                ; arg #1: copy of instance's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0a0h]                                ; arg #2: copy of instance's type
  mov rcx, qword ptr [rsp + 050h]                                ; arg #1: copy of instance's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _constructor return value (static type: GarbageCollectable'4a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 088h]                                ; arg #2: _constructor return value's type
  mov rcx, qword ptr [rsp + 090h]                                ; arg #1: _constructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for instance variable (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0b0h]                                ; arg #2: instance variable's type
  mov rcx, qword ptr [rsp + 0b8h]                                ; arg #1: instance variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of instance's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of instance's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of instance (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 078h]                                ; arg #2: copy of instance's type
  mov rcx, qword ptr [rsp + 080h]                                ; arg #1: copy of instance's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0a8h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; toString
dq method$__Object$toString$annotation
method$__Object$toString:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 048h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 088h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of toString to 0 (integer)
  je method$__Object$toString$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 068h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 060h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 028h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 020h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$__Object$toString$parameterCountCheck$continuation:     ; end of parameter count check
  ; Line 569: return concat('<', className, '>');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, r9                                                    ; move "this" pointer to register to dereference a field
  mov r12, qword ptr [rdi + 038h]                                ; make a copy of __Object.className's value in case it changes before we use it
  mov r13, qword ptr [rdi + 030h]                                ; make a copy of __Object.className's type in case it changes before we use it
  ; increment reference count for copy of __Object.className if necessary
  cmp r13, 039h                                                  ; compare type of copy of __Object.className to String
  jne method$__Object$toString$AfterStringIncref                 ; if not a String, skip incref
    mov r14, qword ptr [r12]                                     ; dereference string to get to reference count
    cmp r14, 0                                                   ; compare string reference count to 0
    jns method$__Object$toString$StringIncref                    ; if reference count is negative (constant strings), skip incref
    jmp method$__Object$toString$AfterStringIncref               ; skip incref for string constants
    method$__Object$toString$StringIncref:                       ; real String
      inc qword ptr [r12]                                        ; increment reference count of copy of __Object.className
  method$__Object$toString$AfterStringIncref:                    ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$__Object$toString$copyOfConcat$TypeMatch            ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r15, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 068h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r8, qword ptr [rsp + 028h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$__Object$toString$copyOfConcat$TypeMatch:               ; after block
  ; Call copy of concat with 3 arguments
  mov rax, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  mov rsi, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 030h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$32                                      ; reading string for push
  push rbx                                                       ; value of argument #3 (string)
  push 039h                                                      ; type of argument #3 (String'39)
  push r12                                                       ; value of argument #2 (copy of __Object.className)
  push r13                                                       ; type of argument #2
  mov qword ptr [rsp + 048h], rdi                                ; move this variable's value out of rdi
  mov rdi, offset string$31                                      ; reading string for push
  push rdi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  mov qword ptr [rsp + 048h], r12                                ; move copy of __Object.className's value out of r12
  lea r12, qword ptr [rsp + 050h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 048h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rax                                                    ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 068h], r8                                 ; move this variable's type out of r8
  mov r8, rsi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 060h], r13                                ; move copy of __Object.className's type out of r13
  mov r13, qword ptr [rsp + 090h]                                ; reading copy of concat to dereference it
  call qword ptr [r13 + 038h]                                    ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$__Object$toString$tostringReturnValue$TypeMatch     ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for toString return value
    ; Call __error with 1 arguments
    mov r14, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$toString$tostringReturnValue$TypeMatch:        ; after block
  mov r10, qword ptr [rsp + 020h]                                ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
  mov rax, qword ptr [rbp + 030h]                                ; get pointer to return value of toString into register to dereference it
  mov qword ptr [rax], r10                                       ; toString return value
  mov rsi, qword ptr [rsp + 010h]                                ; reading type of copy of concat return value
  mov rbx, qword ptr [rbp + 028h]                                ; get pointer to return value type of toString into register to dereference it
  mov qword ptr [rbx], rsi                                       ; type of toString return value
  ; increment reference count for copy of concat return value if necessary
  cmp rsi, 039h                                                  ; compare type of copy of concat return value to String
  jne method$__Object$toString$AfterStringIncref$1               ; if not a String, skip incref
    mov rdi, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp rdi, 0                                                   ; compare string reference count to 0
    jns method$__Object$toString$StringIncref$1                  ; if reference count is negative (constant strings), skip incref
    jmp method$__Object$toString$AfterStringIncref$1             ; skip incref for string constants
    method$__Object$toString$StringIncref$1:                     ; real String
      inc qword ptr [r10]                                        ; increment reference count of copy of concat return value
  method$__Object$toString$AfterStringIncref$1:                  ; after String incref
  ; Decrement reference count for copy of __Object.className (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 020h]                                ; arg #2: copy of __Object.className's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: copy of __Object.className's value
  mov qword ptr [rsp + 058h], r10                                ; move copy of concat return value's value out of r10
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rsi                                                   ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 058h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for this variable (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 028h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 048h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 048h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; constructor
dq method$__Object$constructor$annotation
method$__Object$constructor:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of constructor to 0 (integer)
  je method$__Object$constructor$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$constructor$parameterCountCheck$continuation:  ; end of parameter count check
  ; Implicit return from constructor
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of constructor into register to dereference it
  mov qword ptr [rdi], 000h                                      ; constructor return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of constructor into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of constructor return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _createMethodPointer
dq func$_createMethodPointer$annotation
func$_createMethodPointer:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 058h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 098h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 003h                                                  ; compare parameter count of _createMethodPointer to 3 (integer)
  je func$_createMethodPointer$parameterCountCheck$continuation  ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$parameterCountCheck$continuation:    ; end of parameter count check
  ; Check type of parameter 0, receiver (expecting __Object)
  ; type check of receiver type __Object expecting __Object
  mov rbx, qword ptr [rbp + 038h]                                ; store receiver's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that receiver is __Object
  jc func$_createMethodPointer$receiver$TypeMatch                ; skip next block if the type matches
    ; Error handling block for receiver
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$receiver$TypeMatch:                  ; after block
  ; Check type of parameter 1, codePointer (expecting __CodeAddress)
  ; type check of codePointer type __CodeAddress expecting __CodeAddress
  mov r14, qword ptr [rbp + 048h]                                ; store codePointer's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 005h                                       ; check that codePointer is __CodeAddress
  jc func$_createMethodPointer$codepointer$TypeMatch             ; skip next block if the type matches
    ; Error handling block for codePointer
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$codepointer$TypeMatch:               ; after block
  ; Check type of parameter 2, functionTypeCode (expecting Integer)
  ; type check of functionTypeCode type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store functionTypeCode's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that functionTypeCode is Integer
  jc func$_createMethodPointer$functiontypecode$TypeMatch        ; skip next block if the type matches
    ; Error handling block for functionTypeCode
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$functiontypecode$TypeMatch:          ; after block
  ; Line 579: _gcLocked += 1;
  mov r10, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rbx, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_createMethodPointer$copyOfGclocked$TypeMatch         ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 070h], r10                              ; move copy of _gcLocked's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 030h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
  func$_createMethodPointer$copyOfGclocked$TypeMatch:            ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r13, r10                                                   ; assign value of copy of _gcLocked to value of += operator result
  mov r14, 001h                                                  ; read second operand of add (1)
  add r13, r14                                                   ; += operator
  ; sentinel check of += operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r13                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 580: WhateverFunction result = _constructor(functionTypeCode, 2, 2) a...
  ; sentinel check of _constructor type GarbageCollectableFunction(Integer, Integer, Integer) expecting AnythingFunction
  ; Call _constructor with 3 arguments
  push 002h                                                      ; value of argument #3 (2)
  push 038h                                                      ; type of argument #3 (Integer'38)
  push 002h                                                      ; value of argument #2 (2)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push qword ptr [rbp + 060h]                                    ; value of argument #1 (functionTypeCode)
  push qword ptr [rbp + 058h]                                    ; type of argument #1
  lea rdi, qword ptr [rsp + 060h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 060h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_constructor                                         ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; type check of _constructor return value type GarbageCollectable expecting WhateverFunction
  mov rax, qword ptr [rsp + 028h]                                ; store _constructor return value's type in testByte value slot
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 020h], r13                                ; move += operator result's value out of r13
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that _constructor(functionTypeCode, 2, 2) as WhateverFunction is WhateverFunction
  jc func$_createMethodPointer$ConstructorFunctiontypecode22AsWHateverfunction$TypeMatch ; skip next block if the type matches
    ; Error handling block for _constructor(functionTypeCode, 2, 2) as WhateverFunction
    ; Call __error with 1 arguments
    mov r14, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push r14                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$ConstructorFunctiontypecode22AsWHateverfunction$TypeMatch:  ; after block
  mov r10, qword ptr [rsp + 030h]                                ; copy value of _constructor return value for cast to WhateverFunction
  mov rbx, qword ptr [rsp + 028h]                                ; copy type of _constructor return value for cast to WhateverFunction
  ; sentinel check of cast of _constructor return value to WhateverFunction type WhateverFunction expecting WhateverFunction
  cmp rbx, 000h                                                  ; compare type of cast of _constructor return value to WhateverFunction to <sentinel>
  jne func$_createMethodPointer$castOfConstructorReturnValueToWHateverfunction$TypeMatch ; skip next block if cast of _constructor return value to WhateverFunction is not sentinel
    ; Error handling block for cast of _constructor return value to WhateverFunction
    ; Call __error with 1 arguments
    mov rsi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move cast of _constructor return value to WhateverFunction's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (cast of _constructor return value to WhateverFunction) to previous scope state for genuine block exit
  func$_createMethodPointer$castOfConstructorReturnValueToWHateverfunction$TypeMatch:  ; after block
  mov qword ptr [rsp + 040h], r10                                ; value initialization of variable declaration for result variable (cast of _constructor return value to WhateverFunction)
  mov qword ptr [rsp + 038h], rbx                                ; type initialization of variable declaration for result variable
  ; increment reference count for result variable if necessary
  mov rax, qword ptr [rsp + 038h]                                ; store result variable's type in testByte value slot
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_createMethodPointer$AfterGCIncref                    ; if not a GarbageCollectable, skip incref
    mov r14, qword ptr [rsp + 040h]                              ; read slot into register for dereferencing
    inc qword ptr [r14]                                          ; increment reference count of result variable
    mov qword ptr [rsp + 040h], r14                              ; restoring slot (result variable) to previous scope state for genuine block exit
  func$_createMethodPointer$AfterGCIncref:                       ; after GarbageCollectable incref
  ; Line 581: __writeToAddress(result __as__ Integer + _subroutineReceiverType...
  mov r15, qword ptr [rsp + 040h]                                ; make a copy of result's value in case it changes before we use it
  mov r10, qword ptr [rsp + 038h]                                ; make a copy of result's type in case it changes before we use it
  mov rbx, r15                                                   ; force cast of copy of result to Integer
  mov rsi, qword ptr _subroutineReceiverTypeValue                ; make a copy of _subroutineReceiverType's value in case it changes before we use it
  mov rdi, qword ptr _subroutineReceiverTypeType                 ; make a copy of _subroutineReceiverType's type in case it changes before we use it
  ; sentinel check of force cast of copy of result to Integer type Integer expecting Integer
  ; sentinel check of copy of _subroutineReceiverType type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _subroutineReceiverType to <sentinel>
  jne func$_createMethodPointer$Subroutinereceivertype$TypeMatch ; skip next block if copy of _subroutineReceiverType is not sentinel
    ; Error handling block for _subroutineReceiverType
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$Subroutinereceivertype$TypeMatch:    ; after block
  mov r13, rbx                                                   ; assign value of force cast of copy of result to Integer to value of + operator result
  add r13, rsi                                                   ; compute (force cast of copy of result to Integer) + (copy of _subroutineReceiverType) (result in + operator result)
  mov r14, qword ptr [rbp + 038h]                                ; store receiver's type in __typeOf unary operator result value slot
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r13], r14                                       ; __writeToAddress
  ; Line 582: __writeToAddress(result __as__ Integer + _subroutineReceiverPoin...
  mov rbx, qword ptr [rsp + 040h]                                ; make a copy of result's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 038h]                                ; make a copy of result's type in case it changes before we use it
  mov rdi, rbx                                                   ; force cast of copy of result to Integer
  mov rax, qword ptr _subroutineReceiverPointerValue             ; make a copy of _subroutineReceiverPointer's value in case it changes before we use it
  mov r12, qword ptr _subroutineReceiverPointerType              ; make a copy of _subroutineReceiverPointer's type in case it changes before we use it
  ; sentinel check of force cast of copy of result to Integer type Integer expecting Integer
  ; sentinel check of copy of _subroutineReceiverPointer type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _subroutineReceiverPointer to <sentinel>
  jne func$_createMethodPointer$Subroutinereceiverpointer$TypeMatch ; skip next block if copy of _subroutineReceiverPointer is not sentinel
    ; Error handling block for _subroutineReceiverPointer
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], rax                              ; move copy of _subroutineReceiverPointer's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 008h]                              ; restoring slot (copy of _subroutineReceiverPointer) to previous scope state for genuine block exit
  func$_createMethodPointer$Subroutinereceiverpointer$TypeMatch:  ; after block
  mov rbx, rdi                                                   ; assign value of force cast of copy of result to Integer to value of + operator result
  add rbx, rax                                                   ; compute (force cast of copy of result to Integer) + (copy of _subroutineReceiverPointer) (result in + operator result)
  mov rsi, qword ptr [rbp + 040h]                                ; force cast of receiver to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [rbx], rsi                                       ; __writeToAddress
  ; Line 583: __writeToAddress(result __as__ Integer + _subroutineCodeType, __...
  mov r12, qword ptr [rsp + 040h]                                ; make a copy of result's value in case it changes before we use it
  mov r13, qword ptr [rsp + 038h]                                ; make a copy of result's type in case it changes before we use it
  mov r14, r12                                                   ; force cast of copy of result to Integer
  mov r15, qword ptr _subroutineCodeTypeValue                    ; make a copy of _subroutineCodeType's value in case it changes before we use it
  mov r10, qword ptr _subroutineCodeTypeType                     ; make a copy of _subroutineCodeType's type in case it changes before we use it
  ; sentinel check of force cast of copy of result to Integer type Integer expecting Integer
  ; sentinel check of copy of _subroutineCodeType type Integer expecting Integer
  cmp r10, 000h                                                  ; compare type of copy of _subroutineCodeType to <sentinel>
  jne func$_createMethodPointer$Subroutinecodetype$TypeMatch     ; skip next block if copy of _subroutineCodeType is not sentinel
    ; Error handling block for _subroutineCodeType
    ; Call __error with 1 arguments
    mov rdi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move copy of _subroutineCodeType's type out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (copy of _subroutineCodeType) to previous scope state for genuine block exit
  func$_createMethodPointer$Subroutinecodetype$TypeMatch:        ; after block
  mov r12, r14                                                   ; assign value of force cast of copy of result to Integer to value of + operator result
  add r12, r15                                                   ; compute (force cast of copy of result to Integer) + (copy of _subroutineCodeType) (result in + operator result)
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r12], 038h                                      ; __writeToAddress
  ; Line 584: __writeToAddress(result __as__ Integer + _subroutineCodePointer,...
  mov r15, qword ptr [rsp + 040h]                                ; make a copy of result's value in case it changes before we use it
  mov r10, qword ptr [rsp + 038h]                                ; make a copy of result's type in case it changes before we use it
  mov rbx, r15                                                   ; force cast of copy of result to Integer
  mov rsi, qword ptr _subroutineCodePointerValue                 ; make a copy of _subroutineCodePointer's value in case it changes before we use it
  mov rdi, qword ptr _subroutineCodePointerType                  ; make a copy of _subroutineCodePointer's type in case it changes before we use it
  ; sentinel check of force cast of copy of result to Integer type Integer expecting Integer
  ; sentinel check of copy of _subroutineCodePointer type Integer expecting Integer
  cmp rdi, 000h                                                  ; compare type of copy of _subroutineCodePointer to <sentinel>
  jne func$_createMethodPointer$Subroutinecodepointer$TypeMatch  ; skip next block if copy of _subroutineCodePointer is not sentinel
    ; Error handling block for _subroutineCodePointer
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_createMethodPointer$Subroutinecodepointer$TypeMatch:     ; after block
  mov r15, rbx                                                   ; assign value of force cast of copy of result to Integer to value of + operator result
  add r15, rsi                                                   ; compute (force cast of copy of result to Integer) + (copy of _subroutineCodePointer) (result in + operator result)
  mov r10, qword ptr [rbp + 050h]                                ; force cast of codePointer to Integer
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], r10                                       ; __writeToAddress
  ; Line 585: _gcLocked -= 1;
  mov rdi, qword ptr _gcLockedValue                              ; make a copy of _gcLocked's value in case it changes before we use it
  mov rax, qword ptr _gcLockedType                               ; make a copy of _gcLocked's type in case it changes before we use it
  ; sentinel check of copy of _gcLocked type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of _gcLocked to <sentinel>
  jne func$_createMethodPointer$copyOfGclocked$TypeMatch$1       ; skip next block if copy of _gcLocked is not sentinel
    ; Error handling block for copy of _gcLocked
    ; Call __error with 1 arguments
    mov r12, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], rax                              ; move copy of _gcLocked's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 008h]                              ; restoring slot (copy of _gcLocked) to previous scope state for genuine block exit
  func$_createMethodPointer$copyOfGclocked$TypeMatch$1:          ; after block
  ; sentinel check of 1 type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of copy of _gcLocked to value of -= operator result
  mov rbx, 001h                                                  ; read second operand of sub (1)
  sub r10, rbx                                                   ; -= operator
  ; sentinel check of -= operator result type Integer expecting Integer
  mov qword ptr _gcLockedValue, r10                              ; store value
  mov qword ptr _gcLockedType, 038h                              ; store type (Integer'38)
  ; Line 586: return result;
  mov rax, qword ptr [rsp + 040h]                                ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr [rsp + 038h]                                ; make a copy of result's type in case it changes before we use it
  ; sentinel check of copy of result type WhateverFunction expecting WhateverFunction
  cmp r12, 000h                                                  ; compare type of copy of result to <sentinel>
  jne func$_createMethodPointer$CreatemethodpointerReturnValue$TypeMatch ; skip next block if copy of result is not sentinel
    ; Error handling block for _createMethodPointer return value
    ; Call __error with 1 arguments
    mov r13, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 048h], r10                              ; move -= operator result's value out of r10
    mov qword ptr [rsp + 040h], rax                              ; move copy of result's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
    mov r10, qword ptr [rsp + 008h]                              ; restoring slot (-= operator result) to previous scope state for genuine block exit
  func$_createMethodPointer$CreatemethodpointerReturnValue$TypeMatch:  ; after block
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of _createMethodPointer into register to dereference it
  mov qword ptr [r15], rax                                       ; _createMethodPointer return value
  mov qword ptr [rsp + 018h], r10                                ; move -= operator result's value out of r10
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of _createMethodPointer into register to dereference it
  mov qword ptr [r10], r12                                       ; type of _createMethodPointer return value
  ; increment reference count for copy of result if necessary
  mov rbx, r12                                                   ; store copy of result's type in testByte value slot
  mov qword ptr [rsp + 010h], rax                                ; move copy of result's value out of rax
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_createMethodPointer$AfterGCIncref$1                  ; if not a GarbageCollectable, skip incref
    mov qword ptr [rsp + 008h], r12                              ; move copy of result's type out of r12
    mov r12, qword ptr [rsp + 010h]                              ; read slot into register for dereferencing
    inc qword ptr [r12]                                          ; increment reference count of copy of result
    mov qword ptr [rsp + 010h], r12                              ; restoring slot (copy of result) to previous scope state for genuine block exit
    mov r12, qword ptr [rsp + 008h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  func$_createMethodPointer$AfterGCIncref$1:                     ; after GarbageCollectable incref
  ; Decrement reference count for _constructor return value (static type: GarbageCollectable'4a) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 048h]                                ; arg #2: _constructor return value's type
  mov rcx, qword ptr [rsp + 050h]                                ; arg #1: _constructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 058h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _dummy1
dq func$_dummy1$annotation
func$_dummy1:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of _dummy1 to 0 (integer)
  je func$_dummy1$parameterCountCheck$continuation               ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dummy1$parameterCountCheck$continuation:                 ; end of parameter count check
  ; Line 590: throw('dummy function called');
  ; sentinel check of throw type NullFunction(String) expecting AnythingFunction
  ; Call throw with 1 arguments
  mov rdi, offset string$33                                      ; reading string for push
  push rdi                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r12, qword ptr [rsp + 018h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 018h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$throw                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _dummy1
  ; sentinel check of null type Null expecting Whatever
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of _dummy1 into register to dereference it
  mov qword ptr [r15], 000h                                      ; _dummy1 return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of _dummy1 into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of _dummy1 return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _dynamicLookup
dq func$_dynamicLookup$annotation
func$_dynamicLookup:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 088h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0c8h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of _dynamicLookup to 2 (integer)
  je func$_dynamicLookup$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 080h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 080h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$parameterCountCheck$continuation:          ; end of parameter count check
  ; Check type of parameter 0, receiver (expecting Anything)
  ; type check of receiver type Anything expecting Anything
  mov rbx, qword ptr [rbp + 038h]                                ; store receiver's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that receiver is Anything
  jc func$_dynamicLookup$receiver$TypeMatch                      ; skip next block if the type matches
    ; Error handling block for receiver
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 080h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 080h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$receiver$TypeMatch:                        ; after block
  ; Check type of parameter 1, methodId (expecting Integer)
  ; type check of methodId type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store methodId's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that methodId is Integer
  jc func$_dynamicLookup$methodid$TypeMatch                      ; skip next block if the type matches
    ; Error handling block for methodId
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 080h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 080h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$methodid$TypeMatch:                        ; after block
  ; Line 595: if (!receiver is __Object) { ...
  mov rdi, qword ptr [rbp + 038h]                                ; store receiver's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that receiver is __Object
  mov r14, 000h                                                  ; clear is expression result
  setc r14b                                                      ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  xor rbx, rbx                                                   ; zero ! unary operator result to put the boolean in
  cmp r14, 000h                                                  ; ! unary operator
  sete bl                                                        ; put result in ! unary operator result
  mov rsi, 037h                                                  ; ! unary operator result is a Boolean'37
  ; sentinel check of ! unary operator result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare ! unary operator result to false
  je func$_dynamicLookup$if$continuation                         ; !receiver is __Object
    ; Line 596: throw(concat('Cannot dynamic dispatch on ', receiver, ' which is...
    mov r12, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov r13, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp r13, 000h                                                ; compare type of copy of concat to <sentinel>
    jne func$_dynamicLookup$Dynamiclookup$if$copyOfConcat$TypeMatch ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 080h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 080h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_dynamicLookup$Dynamiclookup$if$copyOfConcat$TypeMatch:  ; after block
    ; Call copy of concat with 3 arguments
    mov r10, qword ptr [r12 + 028h]                              ; read receiver pointer
    mov rbx, qword ptr [r12 + 020h]                              ; read receiver type
    mov rsi, offset string$35                                    ; reading string for push
    push rsi                                                     ; value of argument #3 (string)
    push 039h                                                    ; type of argument #3 (String'39)
    push qword ptr [rbp + 040h]                                  ; value of argument #2 (receiver)
    push qword ptr [rbp + 038h]                                  ; type of argument #2
    mov rdi, offset string$34                                    ; reading string for push
    push rdi                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r10                                                  ; internal argument 4: "this" pointer
    mov r8, rbx                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 003h                                                ; internal argument 1: number of actual arguments
    call qword ptr [r12 + 038h]                                  ; jump to subroutine
    add rsp, 060h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of throw type NullFunction(String) expecting AnythingFunction
    ; Call throw with 1 arguments
    push qword ptr [rsp + 070h]                                  ; value of argument #1 (copy of concat return value)
    push qword ptr [rsp + 070h]                                  ; type of argument #1
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 070h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$throw                                              ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 088h]                              ; arg #2: copy of concat return value's type
    mov rcx, qword ptr [rsp + 090h]                              ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
  func$_dynamicLookup$if$continuation:                           ; end of if
  ; Line 598: Integer vmt = receiver as __Object.vmt#;
  ; type check of receiver type Anything expecting __Object
  mov r15, qword ptr [rbp + 038h]                                ; store receiver's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that receiver as __Object is __Object
  jc func$_dynamicLookup$receiverAsOBject$TypeMatch              ; skip next block if the type matches
    mov qword ptr [rsp + 060h], 000h                             ; move vmt variable's value into a mutable location
    mov qword ptr [rsp + 058h], 000h                             ; move vmt variable's type into a mutable location
    ; Error handling block for receiver as __Object
    ; Call __error with 1 arguments
    mov rsi, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push rsi                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 060h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$receiverAsOBject$TypeMatch:                ; after block
  mov r12, qword ptr [rbp + 040h]                                ; copy value of receiver for cast to __Object
  mov r13, qword ptr [rbp + 038h]                                ; copy type of receiver for cast to __Object
  mov r14, qword ptr [r12 + 028h]                                ; make a copy of __Object.vmt#'s value in case it changes before we use it
  mov r15, qword ptr [r12 + 020h]                                ; make a copy of __Object.vmt#'s type in case it changes before we use it
  ; sentinel check of copy of __Object.vmt# type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of __Object.vmt# to <sentinel>
  jne func$_dynamicLookup$copyOfOBjectVmt$TypeMatch              ; skip next block if copy of __Object.vmt# is not sentinel
    ; Error handling block for copy of __Object.vmt#
    ; Call __error with 1 arguments
    mov rax, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 060h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 060h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$copyOfOBjectVmt$TypeMatch:                 ; after block
  mov qword ptr [rsp + 060h], r14                                ; value initialization of variable declaration for vmt variable (copy of __Object.vmt#)
  mov qword ptr [rsp + 058h], r15                                ; type initialization of variable declaration for vmt variable
  ; Line 599: Integer ddt = __readFromAddress(vmt + _vmtDynamicDispatchTable);...
  mov rbx, qword ptr [rsp + 060h]                                ; make a copy of vmt's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 058h]                                ; make a copy of vmt's type in case it changes before we use it
  mov rdi, qword ptr _vmtDynamicDispatchTableValue               ; make a copy of _vmtDynamicDispatchTable's value in case it changes before we use it
  mov r12, qword ptr _vmtDynamicDispatchTableType                ; make a copy of _vmtDynamicDispatchTable's type in case it changes before we use it
  ; sentinel check of copy of vmt type Integer expecting Integer
  cmp rsi, 000h                                                  ; compare type of copy of vmt to <sentinel>
  jne func$_dynamicLookup$vmt$TypeMatch                          ; skip next block if copy of vmt is not sentinel
    mov qword ptr [rsp + 050h], 000h                             ; move ddt variable's value into a mutable location
    mov qword ptr [rsp + 048h], 000h                             ; move ddt variable's type into a mutable location
    ; Error handling block for vmt
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$vmt$TypeMatch:                             ; after block
  ; sentinel check of copy of _vmtDynamicDispatchTable type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of _vmtDynamicDispatchTable to <sentinel>
  jne func$_dynamicLookup$Vmtdynamicdispatchtable$TypeMatch      ; skip next block if copy of _vmtDynamicDispatchTable is not sentinel
    ; Error handling block for _vmtDynamicDispatchTable
    ; Call __error with 1 arguments
    mov r15, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 050h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$Vmtdynamicdispatchtable$TypeMatch:         ; after block
  mov r10, rbx                                                   ; assign value of copy of vmt to value of + operator result
  add r10, rdi                                                   ; compute (copy of vmt) + (copy of _vmtDynamicDispatchTable) (result in + operator result)
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rdi, qword ptr [r10]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced + operator result type Integer expecting Integer
  mov qword ptr [rsp + 050h], rdi                                ; value initialization of variable declaration for ddt variable (dereferenced + operator result)
  mov qword ptr [rsp + 048h], 038h                               ; type initialization of variable declaration for ddt variable (Integer'38)
  ; Line 601: Integer cursor = ddt + 8;
  mov r14, qword ptr [rsp + 050h]                                ; make a copy of ddt's value in case it changes before we use it
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of ddt's type in case it changes before we use it
  ; sentinel check of copy of ddt type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of ddt to <sentinel>
  jne func$_dynamicLookup$ddt$TypeMatch                          ; skip next block if copy of ddt is not sentinel
    mov qword ptr [rsp + 040h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 038h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for ddt
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$ddt$TypeMatch:                             ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of ddt to value of + operator result
  add rdi, 008h                                                  ; compute (copy of ddt) + (8) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 040h], rdi                                ; value initialization of variable declaration for cursor variable (+ operator result)
  mov qword ptr [rsp + 038h], 038h                               ; type initialization of variable declaration for cursor variable (Integer'38)
  ; Line 602: Integer end = ddt + 8 + __readFromAddress(ddt) * 8;
  mov r14, qword ptr [rsp + 050h]                                ; make a copy of ddt's value in case it changes before we use it
  mov r15, qword ptr [rsp + 048h]                                ; make a copy of ddt's type in case it changes before we use it
  ; sentinel check of copy of ddt type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of ddt to <sentinel>
  jne func$_dynamicLookup$ddt$TypeMatch$1                        ; skip next block if copy of ddt is not sentinel
    mov qword ptr [rsp + 030h], 000h                             ; move end variable's value into a mutable location
    mov qword ptr [rsp + 028h], 000h                             ; move end variable's type into a mutable location
    ; Error handling block for ddt
    ; Call __error with 1 arguments
    mov rax, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 030h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 030h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$ddt$TypeMatch$1:                           ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov rdi, r14                                                   ; assign value of copy of ddt to value of + operator result
  add rdi, 008h                                                  ; compute (copy of ddt) + (8) (result in + operator result)
  mov r12, qword ptr [rsp + 050h]                                ; make a copy of ddt's value in case it changes before we use it
  mov r13, qword ptr [rsp + 048h]                                ; make a copy of ddt's type in case it changes before we use it
  ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __readFromAddress with 1 arguments
  mov rax, qword ptr [r12]                                       ; dereference first argument of __readFromAddress
  ; sentinel check of dereferenced copy of ddt type Integer expecting Integer
  ; sentinel check of 8 type Integer expecting Integer
  imul r12, rax, 008h                                            ; compute (dereferenced copy of ddt) * (8) (result in * operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  ; sentinel check of * operator result type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of + operator result to value of + operator result
  add r10, r12                                                   ; compute (+ operator result) + (* operator result) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 030h], r10                                ; value initialization of variable declaration for end variable (+ operator result)
  mov qword ptr [rsp + 028h], 038h                               ; type initialization of variable declaration for end variable (Integer'38)
  func$_dynamicLookup$while$top:                                 ; top of while
    mov rdi, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    mov r13, qword ptr [rsp + 030h]                              ; make a copy of end's value in case it changes before we use it
    mov r14, qword ptr [rsp + 028h]                              ; make a copy of end's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of cursor to <sentinel>
    jne func$_dynamicLookup$while$cursor$TypeMatch               ; skip next block if copy of cursor is not sentinel
      ; Error handling block for cursor
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 060h]                            ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_dynamicLookup$while$cursor$TypeMatch:                  ; after block
    ; sentinel check of copy of end type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of end to <sentinel>
    jne func$_dynamicLookup$while$end$TypeMatch                  ; skip next block if copy of end is not sentinel
      ; Error handling block for end
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_dynamicLookup$while$end$TypeMatch:                     ; after block
    xor rsi, rsi                                                 ; clear < operator result
    cmp rdi, r13                                                 ; compare copy of cursor with copy of end
    setl sil                                                     ; store result in < operator result
    cmp rsi, 000h                                                ; compare < operator result to false
    jne func$_dynamicLookup$while$body                           ; while condition
    jmp func$_dynamicLookup$while$bottom                         ; break out of while
    func$_dynamicLookup$while$body:                              ; start of while
    ; Line 604: Integer entry = __readFromAddress(cursor);
    mov rdi, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r12, qword ptr [rsp + 038h]                              ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r15, qword ptr [rdi]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced copy of cursor type Integer expecting Integer
    mov qword ptr [rsp + 050h], r15                              ; value initialization of variable declaration for entry variable (dereferenced copy of cursor)
    mov qword ptr [rsp + 048h], 038h                             ; type initialization of variable declaration for entry variable (Integer'38)
    ; Line 605: if (entry & 4294967295 /* 0xffffffff */ == methodId) { ...
    mov rbx, qword ptr [rsp + 050h]                              ; make a copy of entry's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 048h]                              ; make a copy of entry's type in case it changes before we use it
    ; sentinel check of copy of entry type Integer expecting Integer
    cmp rsi, 000h                                                ; compare type of copy of entry to <sentinel>
    jne func$_dynamicLookup$while$entry$TypeMatch                ; skip next block if copy of entry is not sentinel
      ; Error handling block for entry
      ; Call __error with 1 arguments
      mov rdi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 030h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 030h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_dynamicLookup$while$entry$TypeMatch:                   ; after block
    ; sentinel check of 4294967295 /* 0xffffffff */ type Integer expecting Integer
    mov r15, rbx                                                 ; assign value of copy of entry to value of & operator result
    mov rax, 0ffffffffh                                          ; read second operand of and (4294967295 /* 0xffffffff */)
    and r15, rax                                                 ; compute (copy of entry) & (4294967295 /* 0xffffffff */)
    xor r10, r10                                                 ; zero value result of == (testing & operator result and methodId) to put the boolean in
    cmp r15, qword ptr [rbp + 050h]                              ; values equal?
    sete r10b                                                    ; put result in value result of == (testing & operator result and methodId)
    mov rbx, 037h                                                ; value result of == (testing & operator result and methodId) is a Boolean'37
    xor rsi, rsi                                                 ; zero type result of == (testing & operator result and methodId) to put the boolean in
    mov rdi, 038h                                                ; reading type of & operator result for comparison with type of methodId
    cmp rdi, qword ptr [rbp + 048h]                              ; types equal?
    sete sil                                                     ; put result in type result of == (testing & operator result and methodId)
    mov r12, 037h                                                ; type result of == (testing & operator result and methodId) is a Boolean'37
    mov r13, r10                                                 ; assign value of value result of == (testing & operator result and methodId) to value of == operator result
    and r13, rsi                                                 ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp r13, 000h                                                ; compare == operator result to false
    je func$_dynamicLookup$while$if$continuation                 ; entry & 4294967295 /* 0xffffffff */ == methodId
      ; Line 606: return _createMethodPointer(receiver as __Object, __readFromAddr...
      ; type check of receiver type Anything expecting __Object
      mov r15, qword ptr [rbp + 038h]                            ; store receiver's type in testByte value slot
      mov rax, r15                                               ; move testByte to testByte
      mov r10, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r10                                                    ; adjust to the relative start of that type's entry in the type table
      mov rbx, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, rbx                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 006h                                   ; check that receiver as __Object is __Object
      jc func$_dynamicLookup$while$while$if$8$receiverAsOBject$TypeMatch ; skip next block if the type matches
        ; Error handling block for receiver as __Object
        ; Call __error with 1 arguments
        mov rsi, offset asOperatorFailureMessage                 ; reading asOperatorFailureMessage for push
        push rsi                                                 ; value of argument #1 (asOperatorFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rdi, qword ptr [rsp + 030h]                          ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 030h]                          ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_dynamicLookup$while$while$if$8$receiverAsOBject$TypeMatch:  ; after block
      mov r12, qword ptr [rbp + 040h]                            ; copy value of receiver for cast to __Object
      mov r13, qword ptr [rbp + 038h]                            ; copy type of receiver for cast to __Object
      mov r14, qword ptr [rsp + 060h]                            ; make a copy of vmt's value in case it changes before we use it
      mov r15, qword ptr [rsp + 058h]                            ; make a copy of vmt's type in case it changes before we use it
      mov rax, qword ptr [rsp + 050h]                            ; make a copy of entry's value in case it changes before we use it
      mov r10, qword ptr [rsp + 048h]                            ; make a copy of entry's type in case it changes before we use it
      ; sentinel check of copy of entry type Integer expecting Integer
      cmp r10, 000h                                              ; compare type of copy of entry to <sentinel>
      jne func$_dynamicLookup$while$while$if$8$entry$TypeMatch   ; skip next block if copy of entry is not sentinel
        ; Error handling block for entry
        ; Call __error with 1 arguments
        mov rbx, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rbx                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rsi, qword ptr [rsp + 030h]                          ; load address of return value's value
        push rsi                                                 ; internal argument 6: pointer to return value slot's value
        lea rsi, qword ptr [rsp + 030h]                          ; load address of return value's type
        push rsi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 050h], r10                          ; move copy of entry's type out of r10
        mov qword ptr [rsp + 048h], rax                          ; move copy of entry's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 008h]                          ; restoring slot (copy of entry) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 010h]                          ; restoring slot (copy of entry) to previous scope state for genuine block exit
      func$_dynamicLookup$while$while$if$8$entry$TypeMatch:      ; after block
      ; sentinel check of 32 /* 0x20 */ type Integer expecting Integer
      mov qword ptr [rsp + 020h], r13                            ; move cast of receiver to __Object's type out of r13
      mov r13, rax                                               ; assign value of copy of entry to value of >> operator result
      shr r13, 020h                                              ; compute (copy of entry) >> (32 /* 0x20 */)
      ; sentinel check of copy of vmt type Integer expecting Integer
      cmp r15, 000h                                              ; compare type of copy of vmt to <sentinel>
      jne func$_dynamicLookup$while$while$if$8$vmt$TypeMatch     ; skip next block if copy of vmt is not sentinel
        ; Error handling block for vmt
        ; Call __error with 1 arguments
        mov qword ptr [rsp + 018h], r14                          ; move copy of vmt's value out of r14
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 018h], r15                          ; move copy of vmt's type out of r15
        lea r15, qword ptr [rsp + 020h]                          ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 018h]                          ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r15, qword ptr [rsp + 008h]                          ; restoring slot (copy of vmt) to previous scope state for genuine block exit
        mov r14, qword ptr [rsp + 018h]                          ; restoring slot (copy of vmt) to previous scope state for genuine block exit
      func$_dynamicLookup$while$while$if$8$vmt$TypeMatch:        ; after block
      ; sentinel check of >> operator result type Integer expecting Integer
      mov rbx, r14                                               ; assign value of copy of vmt to value of + operator result
      add rbx, r13                                               ; compute (copy of vmt) + (>> operator result) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov qword ptr [rsp + 018h], r12                            ; move cast of receiver to __Object's value out of r12
      mov r12, qword ptr [rbx]                                   ; dereference first argument of __readFromAddress
      mov r13, r12                                               ; force cast of dereferenced + operator result to __CodeAddress
      mov r14, 018h                                              ; store _dummy1's type in __typeOf unary operator result value slot
      ; sentinel check of _createMethodPointer type WhateverFunctionFunction(__Object, __CodeAddress, Integer) expecting AnythingFunction
      ; Call _createMethodPointer with 3 arguments
      push r14                                                   ; value of argument #3 (__typeOf unary operator result)
      push 038h                                                  ; type of argument #3 (Integer'38)
      push r13                                                   ; value of argument #2 (force cast of dereferenced + operator result to __CodeAddress)
      push 03bh                                                  ; type of argument #2 (__CodeAddress'3b)
      push qword ptr [rsp + 038h]                                ; value of argument #1 (cast of receiver to __Object)
      push qword ptr [rsp + 048h]                                ; type of argument #1
      lea r10, qword ptr [rsp + 050h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 050h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 003h                                              ; internal argument 1: number of actual arguments
      call func$_createMethodPointer                             ; jump to subroutine
      add rsp, 060h                                              ; release shadow space and arguments (result in stack pointer)
      ; sentinel check of _createMethodPointer return value type WhateverFunction expecting WhateverFunction
      cmp qword ptr [rsp + 018h], 000h                           ; compare type of _createMethodPointer return value to <sentinel>
      jne func$_dynamicLookup$while$while$if$8$DynamiclookupReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
        ; Error handling block for _dynamicLookup return value
        ; Call __error with 1 arguments
        mov rbx, offset returnValueTypeCheckFailureMessage       ; reading returnValueTypeCheckFailureMessage for push
        push rbx                                                 ; value of argument #1 (returnValueTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rsi, qword ptr [rsp + 020h]                          ; load address of return value's value
        push rsi                                                 ; internal argument 6: pointer to return value slot's value
        lea rsi, qword ptr [rsp + 020h]                          ; load address of return value's type
        push rsi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_dynamicLookup$while$while$if$8$DynamiclookupReturnValue$TypeMatch:  ; after block
      mov rdi, qword ptr [rsp + 020h]                            ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
      mov r12, qword ptr [rbp + 030h]                            ; get pointer to return value of _dynamicLookup into register to dereference it
      mov qword ptr [r12], rdi                                   ; _dynamicLookup return value
      mov r13, qword ptr [rsp + 018h]                            ; reading type of _createMethodPointer return value
      mov r14, qword ptr [rbp + 028h]                            ; get pointer to return value type of _dynamicLookup into register to dereference it
      mov qword ptr [r14], r13                                   ; type of _dynamicLookup return value
      ; increment reference count for _createMethodPointer return value if necessary
      mov r15, r13                                               ; store _createMethodPointer return value's type in testByte value slot
      mov rax, r15                                               ; move testByte to testByte
      mov r10, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r10                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov rbx, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, rbx                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_dynamicLookup$while$while$if$8$AfterGCIncref     ; if not a GarbageCollectable, skip incref
        inc qword ptr [rdi]                                      ; increment reference count of _createMethodPointer return value
      func$_dynamicLookup$while$while$if$8$AfterGCIncref:        ; after GarbageCollectable incref
      jmp func$_dynamicLookup$epilog                             ; return
    func$_dynamicLookup$while$if$continuation:                   ; end of if
    ; Line 608: cursor += 8;
    mov rsi, qword ptr [rsp + 040h]                              ; make a copy of cursor's value in case it changes before we use it
    mov r9, qword ptr [rsp + 038h]                               ; make a copy of cursor's type in case it changes before we use it
    ; sentinel check of copy of cursor type Integer expecting Integer
    cmp r9, 000h                                                 ; compare type of copy of cursor to <sentinel>
    jne func$_dynamicLookup$while$copyOfCursor$TypeMatch         ; skip next block if copy of cursor is not sentinel
      ; Error handling block for copy of cursor
      ; Call __error with 1 arguments
      mov r8, offset operandTypeCheckFailureMessage              ; reading operandTypeCheckFailureMessage for push
      push r8                                                    ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdx, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rdx                                                   ; internal argument 6: pointer to return value slot's value
      lea rdx, qword ptr [rsp + 060h]                            ; load address of return value's type
      push rdx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov qword ptr [rsp + 060h], r9                             ; move copy of cursor's type out of r9
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r9, qword ptr [rsp + 020h]                             ; restoring slot (copy of cursor) to previous scope state for genuine block exit
    func$_dynamicLookup$while$copyOfCursor$TypeMatch:            ; after block
    ; sentinel check of 8 type Integer expecting Integer
    mov r13, rsi                                                 ; assign value of copy of cursor to value of += operator result
    mov r14, 008h                                                ; read second operand of add (8)
    add r13, r14                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 040h], r13                              ; store value
    mov qword ptr [rsp + 038h], 038h                             ; store type (Integer'38)
    jmp func$_dynamicLookup$while$top                            ; return to top of while
  func$_dynamicLookup$while$bottom:                              ; bottom of while
  ; Line 610: throw(concat('No member with specified name found on "', receive...
  mov r10, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rbx, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  ; type check of receiver type Anything expecting __Object
  mov rsi, qword ptr [rbp + 038h]                                ; store receiver's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that receiver as __Object is __Object
  jc func$_dynamicLookup$receiverAsOBject$TypeMatch$1            ; skip next block if the type matches
    ; Error handling block for receiver as __Object
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 060h], r13                              ; move += operator result's value out of r13
    mov r13, offset asOperatorFailureMessage                     ; reading asOperatorFailureMessage for push
    push r13                                                     ; value of argument #1 (asOperatorFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 068h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 068h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 088h], r10                              ; move copy of concat's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 048h]                              ; restoring slot (copy of concat) to previous scope state for genuine block exit
  func$_dynamicLookup$receiverAsOBject$TypeMatch$1:              ; after block
  mov r15, qword ptr [rbp + 040h]                                ; copy value of receiver for cast to __Object
  mov qword ptr [rsp + 058h], r10                                ; move copy of concat's value out of r10
  mov r10, qword ptr [rbp + 038h]                                ; copy type of receiver for cast to __Object
  mov qword ptr [rsp + 050h], rbx                                ; move copy of concat's type out of rbx
  mov rbx, qword ptr [r15 + 038h]                                ; make a copy of __Object.className's value in case it changes before we use it
  mov rsi, qword ptr [r15 + 030h]                                ; make a copy of __Object.className's type in case it changes before we use it
  ; increment reference count for copy of __Object.className if necessary
  cmp rsi, 039h                                                  ; compare type of copy of __Object.className to String
  jne func$_dynamicLookup$AfterStringIncref                      ; if not a String, skip incref
    mov rax, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns func$_dynamicLookup$StringIncref                         ; if reference count is negative (constant strings), skip incref
    jmp func$_dynamicLookup$AfterStringIncref                    ; skip incref for string constants
    func$_dynamicLookup$StringIncref:                            ; real String
      inc qword ptr [rbx]                                        ; increment reference count of copy of __Object.className
  func$_dynamicLookup$AfterStringIncref:                         ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp qword ptr [rsp + 050h], 000h                               ; compare type of copy of concat to <sentinel>
  jne func$_dynamicLookup$copyOfConcat$TypeMatch                 ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov rdi, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 058h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 058h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$copyOfConcat$TypeMatch:                    ; after block
  ; Call copy of concat with 3 arguments
  mov r13, qword ptr [rsp + 058h]                                ; get copy of concat into register to dereference it
  mov r14, qword ptr [r13 + 028h]                                ; read receiver pointer
  mov r15, qword ptr [r13 + 020h]                                ; read receiver type
  mov r10, offset string$37                                      ; reading string for push
  push r10                                                       ; value of argument #3 (string)
  push 039h                                                      ; type of argument #3 (String'39)
  push rbx                                                       ; value of argument #2 (copy of __Object.className)
  push rsi                                                       ; type of argument #2
  mov qword ptr [rsp + 078h], rbx                                ; move copy of __Object.className's value out of rbx
  mov rbx, offset string$36                                      ; reading string for push
  push rbx                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  mov qword ptr [rsp + 070h], rsi                                ; move copy of __Object.className's type out of rsi
  lea rsi, qword ptr [rsp + 078h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 070h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r14                                                    ; internal argument 4: "this" pointer
  mov r8, r15                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [r13 + 038h]                                    ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of throw type NullFunction(String) expecting AnythingFunction
  ; Call throw with 1 arguments
  push qword ptr [rsp + 048h]                                    ; value of argument #1 (copy of concat return value)
  push qword ptr [rsp + 040h]                                    ; type of argument #1
  lea r12, qword ptr [rsp + 060h]                                ; load address of return value's value
  push r12                                                       ; internal argument 6: pointer to return value slot's value
  lea r12, qword ptr [rsp + 048h]                                ; load address of return value's type
  push r12                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$throw                                                ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _dynamicLookup
  ; type check of null type Null expecting WhateverFunction
  mov r13, 036h                                                  ; store null's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that _dynamicLookup return value is WhateverFunction
  jc func$_dynamicLookup$DynamiclookupReturnValue$TypeMatch      ; skip next block if the type matches
    ; Error handling block for _dynamicLookup return value
    ; Call __error with 1 arguments
    mov r10, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 060h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 048h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_dynamicLookup$DynamiclookupReturnValue$TypeMatch:        ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of _dynamicLookup into register to dereference it
  mov qword ptr [rsi], 000h                                      ; _dynamicLookup return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of _dynamicLookup into register to dereference it
  mov qword ptr [rdi], 036h                                      ; type of _dynamicLookup return value (Null'36)
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 058h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 068h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of __Object.className (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 060h]                                ; arg #2: copy of __Object.className's type
  mov rcx, qword ptr [rsp + 078h]                                ; arg #1: copy of __Object.className's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  func$_dynamicLookup$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 088h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __getStdHandle
dq func$__getStdHandle$annotation
func$__getStdHandle:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of __getStdHandle to 1 (integer)
  je func$__getStdHandle$parameterCountCheck$continuation        ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__getStdHandle$parameterCountCheck$continuation:          ; end of parameter count check
  ; Check type of parameter 0, handle (expecting Integer)
  ; type check of handle type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store handle's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that handle is Integer
  jc func$__getStdHandle$handle$TypeMatch                        ; skip next block if the type matches
    ; Error handling block for handle
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__getStdHandle$handle$TypeMatch:                          ; after block
  ; Calling GetStdHandle
  mov rcx, qword ptr [rbp + 040h]                                ; argument #1
  sub rsp, 020h                                                  ; allocate shadow space
  call GetStdHandle                                              ; calls GetStdHandle from kernel32.lib
  add rsp, 020h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of GetStdHandle system call type Integer expecting Integer
  mov r10, qword ptr [rbp + 030h]                                ; get pointer to return value of __getStdHandle into register to dereference it
  mov qword ptr [r10], rax                                       ; __getStdHandle return value
  mov rbx, qword ptr [rbp + 028h]                                ; get pointer to return value type of __getStdHandle into register to dereference it
  mov qword ptr [rbx], 038h                                      ; type of __getStdHandle return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __writeFile
dq func$__writeFile$annotation
func$__writeFile:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 005h                                                  ; compare parameter count of __writeFile to 5 (integer)
  je func$__writeFile$parameterCountCheck$continuation           ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$parameterCountCheck$continuation:             ; end of parameter count check
  ; Check type of parameter 0, hFile (expecting Integer)
  ; type check of hFile type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store hFile's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that hFile is Integer
  jc func$__writeFile$hfile$TypeMatch                            ; skip next block if the type matches
    ; Error handling block for hFile
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$hfile$TypeMatch:                              ; after block
  ; Check type of parameter 1, lpBuffer (expecting Integer)
  ; type check of lpBuffer type Integer expecting Integer
  mov r14, qword ptr [rbp + 048h]                                ; store lpBuffer's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that lpBuffer is Integer
  jc func$__writeFile$lpbuffer$TypeMatch                         ; skip next block if the type matches
    ; Error handling block for lpBuffer
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$lpbuffer$TypeMatch:                           ; after block
  ; Check type of parameter 2, nNumberOfBytesToWrite (expecting Integer)
  ; type check of nNumberOfBytesToWrite type Integer expecting Integer
  mov rdi, qword ptr [rbp + 058h]                                ; store nNumberOfBytesToWrite's type in testByte value slot
  mov rax, rdi                                                   ; move testByte to testByte
  mov r12, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r12                                                        ; adjust to the relative start of that type's entry in the type table
  mov r13, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r13                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that nNumberOfBytesToWrite is Integer
  jc func$__writeFile$nnumberofbytestowrite$TypeMatch            ; skip next block if the type matches
    ; Error handling block for nNumberOfBytesToWrite
    ; Call __error with 1 arguments
    mov r14, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$nnumberofbytestowrite$TypeMatch:              ; after block
  ; Check type of parameter 3, lpNumberOfBytesWritten (expecting Integer)
  ; type check of lpNumberOfBytesWritten type Integer expecting Integer
  mov r10, qword ptr [rbp + 068h]                                ; store lpNumberOfBytesWritten's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that lpNumberOfBytesWritten is Integer
  jc func$__writeFile$lpnumberofbyteswritten$TypeMatch           ; skip next block if the type matches
    ; Error handling block for lpNumberOfBytesWritten
    ; Call __error with 1 arguments
    mov rdi, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 020h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$lpnumberofbyteswritten$TypeMatch:             ; after block
  ; Check type of parameter 4, lpOverlapped (expecting Integer)
  ; type check of lpOverlapped type Integer expecting Integer
  mov r13, qword ptr [rbp + 078h]                                ; store lpOverlapped's type in testByte value slot
  mov rax, r13                                                   ; move testByte to testByte
  mov r14, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r14                                                        ; adjust to the relative start of that type's entry in the type table
  mov r15, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r15                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that lpOverlapped is Integer
  jc func$__writeFile$lpoverlapped$TypeMatch                     ; skip next block if the type matches
    ; Error handling block for lpOverlapped
    ; Call __error with 1 arguments
    mov r10, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 020h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeFile$lpoverlapped$TypeMatch:                       ; after block
  ; Calling WriteFile
  mov rsi, -0778899aabbccddefh                                   ; reading -778899aabbccddef (integer) for push
  push rsi                                                       ; align stack
  push qword ptr [rbp + 080h]                                    ; argument #5
  mov r9, qword ptr [rbp + 070h]                                 ; argument #4
  mov r8, qword ptr [rbp + 060h]                                 ; argument #3
  mov rdx, qword ptr [rbp + 050h]                                ; argument #2
  mov rcx, qword ptr [rbp + 040h]                                ; argument #1
  sub rsp, 020h                                                  ; allocate shadow space
  call WriteFile                                                 ; calls WriteFile from kernel32.lib
  add rsp, 030h                                                  ; release shadow space and arguments if there were more than four (result in stack pointer)
  ; sentinel check of return value of WriteFile system call type Integer expecting Integer
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of __writeFile into register to dereference it
  mov qword ptr [r13], rax                                       ; __writeFile return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of __writeFile into register to dereference it
  mov qword ptr [r14], 038h                                      ; type of __writeFile return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __writeToHandle
dq func$__writeToHandle$annotation
func$__writeToHandle:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 048h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 088h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 002h                                                  ; compare parameter count of __writeToHandle to 2 (integer)
  je func$__writeToHandle$parameterCountCheck$continuation       ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToHandle$parameterCountCheck$continuation:         ; end of parameter count check
  ; Check type of parameter 0, handle (expecting Integer)
  ; type check of handle type Integer expecting Integer
  mov rbx, qword ptr [rbp + 038h]                                ; store handle's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that handle is Integer
  jc func$__writeToHandle$handle$TypeMatch                       ; skip next block if the type matches
    ; Error handling block for handle
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 040h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 040h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToHandle$handle$TypeMatch:                         ; after block
  ; Check type of parameter 1, message (expecting String)
  ; type check of message type String expecting String
  mov r14, qword ptr [rbp + 048h]                                ; store message's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that message is String
  jc func$__writeToHandle$message$TypeMatch                      ; skip next block if the type matches
    ; Error handling block for message
    ; Call __error with 1 arguments
    mov rbx, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push rbx                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$__writeToHandle$message$TypeMatch:                        ; after block
  ; Line 684: __writeFile(__getStdHandle(handle), message __as__ Integer + 16 ...
  ; sentinel check of __getStdHandle type IntegerFunction(Integer) expecting AnythingFunction
  ; Call __getStdHandle with 1 arguments
  push qword ptr [rbp + 040h]                                    ; value of argument #1 (handle)
  push qword ptr [rbp + 038h]                                    ; type of argument #1
  lea r13, qword ptr [rsp + 040h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 040h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$__getStdHandle                                       ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r14, qword ptr [rbp + 050h]                                ; force cast of message to Integer
  ; sentinel check of force cast of message to Integer type Integer expecting Integer
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov rsi, r14                                                   ; assign value of force cast of message to Integer to value of + operator result
  add rsi, 010h                                                  ; compute (force cast of message to Integer) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
  ; Call _stringByteLength with 1 arguments
  push qword ptr [rbp + 050h]                                    ; value of argument #1 (message)
  push qword ptr [rbp + 048h]                                    ; type of argument #1
  lea r13, qword ptr [rsp + 030h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 030h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_stringByteLength                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r14, qword ptr _scratchValue                               ; make a copy of _scratch's value in case it changes before we use it
  mov rax, qword ptr _scratchType                                ; make a copy of _scratch's type in case it changes before we use it
  ; sentinel check of __writeFile type IntegerFunction(Integer, Integer, Integer, Integer, Integer) expecting AnythingFunction
  ; Call __writeFile with 5 arguments
  push 000h                                                      ; value of argument #5 (0)
  push 038h                                                      ; type of argument #5 (Integer'38)
  push r14                                                       ; value of argument #4 (copy of _scratch)
  push rax                                                       ; type of argument #4
  push qword ptr [rsp + 040h]                                    ; value of argument #3 (_stringByteLength return value)
  push qword ptr [rsp + 040h]                                    ; type of argument #3
  push rsi                                                       ; value of argument #2 (+ operator result)
  push 038h                                                      ; type of argument #2 (Integer'38)
  push qword ptr [rsp + 070h]                                    ; value of argument #1 (__getStdHandle return value)
  push qword ptr [rsp + 070h]                                    ; type of argument #1
  lea rbx, qword ptr [rsp + 080h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 080h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 005h                                                  ; internal argument 1: number of actual arguments
  call func$__writeFile                                          ; jump to subroutine
  add rsp, 080h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from __writeToHandle
  ; sentinel check of null type Null expecting Null
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of __writeToHandle into register to dereference it
  mov qword ptr [r12], 000h                                      ; __writeToHandle return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of __writeToHandle into register to dereference it
  mov qword ptr [r13], 036h                                      ; type of __writeToHandle return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 048h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _stringify
dq func$_stringify$annotation
func$_stringify:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0168h                                                 ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 01a8h]                               ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of _stringify to 1 (integer)
  je func$_stringify$parameterCountCheck$continuation            ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0168h]                             ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0168h]                             ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_stringify$parameterCountCheck$continuation:              ; end of parameter count check
  ; Check type of parameter 0, arg (expecting Anything)
  ; type check of arg type Anything expecting Anything
  mov rbx, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that arg is Anything
  jc func$_stringify$arg$TypeMatch                               ; skip next block if the type matches
    ; Error handling block for arg
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 0168h]                             ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 0168h]                             ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_stringify$arg$TypeMatch:                                 ; after block
  ; Line 688: if (arg is String) { ...
  mov r14, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that arg is String
  mov rbx, 000h                                                  ; clear is expression result
  setc bl                                                        ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation                             ; arg is String
    ; Line 689: return arg as String;
    ; type check of arg type Anything expecting String
    mov r12, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, r12                                                 ; move testByte to testByte
    mov r13, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r13                                                      ; adjust to the relative start of that type's entry in the type table
    mov r14, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r14                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 003h                                     ; check that arg as String is String
    jc func$_stringify$Stringify$if$argAsSTring$TypeMatch        ; skip next block if the type matches
      ; Error handling block for arg as String
      ; Call __error with 1 arguments
      mov r15, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push r15                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0168h]                           ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$argAsSTring$TypeMatch:          ; after block
    mov rbx, qword ptr [rbp + 040h]                              ; copy value of arg for cast to String
    mov rsi, qword ptr [rbp + 038h]                              ; copy type of arg for cast to String
    ; sentinel check of cast of arg to String type String expecting String
    cmp rsi, 000h                                                ; compare type of cast of arg to String to <sentinel>
    jne func$_stringify$Stringify$if$StringifyReturnValue$TypeMatch ; skip next block if cast of arg to String is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov rdi, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 0168h]                           ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$StringifyReturnValue$TypeMatch:  ; after block
    mov rax, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [rax], rbx                                     ; _stringify return value
    mov r13, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r13], rsi                                     ; type of _stringify return value
    ; increment reference count for cast of arg to String if necessary
    cmp rsi, 039h                                                ; compare type of cast of arg to String to String
    jne func$_stringify$Stringify$if$AfterStringIncref           ; if not a String, skip incref
      mov r14, qword ptr [rbx]                                   ; dereference string to get to reference count
      cmp r14, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$StringIncref              ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$AfterStringIncref         ; skip incref for string constants
      func$_stringify$Stringify$if$StringIncref:                 ; real String
        inc qword ptr [rbx]                                      ; increment reference count of cast of arg to String
    func$_stringify$Stringify$if$AfterStringIncref:              ; after String incref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation:                               ; end of if
  ; Line 691: if (arg is Boolean) { ...
  mov r15, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 001h                                       ; check that arg is Boolean
  mov rsi, 000h                                                  ; clear is expression result
  setc sil                                                       ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp rsi, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation$1                           ; arg is Boolean
    ; Line 692: if (arg as Boolean) { ...
    ; type check of arg type Anything expecting Boolean
    mov r13, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, r13                                                 ; move testByte to testByte
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 001h                                     ; check that arg as Boolean is Boolean
    jc func$_stringify$Stringify$if$1$argAsBOolean$TypeMatch     ; skip next block if the type matches
      ; Error handling block for arg as Boolean
      ; Call __error with 1 arguments
      mov r10, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push r10                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0168h]                           ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$1$argAsBOolean$TypeMatch:       ; after block
    mov rsi, qword ptr [rbp + 040h]                              ; copy value of arg for cast to Boolean
    mov rdi, qword ptr [rbp + 038h]                              ; copy type of arg for cast to Boolean
    ; sentinel check of cast of arg to Boolean type Boolean expecting Boolean
    cmp rdi, 000h                                                ; compare type of cast of arg to Boolean to <sentinel>
    jne func$_stringify$Stringify$if$1$ifCondition$TypeMatch     ; skip next block if cast of arg to Boolean is not sentinel
      ; Error handling block for if condition
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0168h]                           ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$1$ifCondition$TypeMatch:        ; after block
    cmp rsi, 000h                                                ; compare cast of arg to Boolean to false
    je func$_stringify$Stringify$if$1$if$continuation            ; arg as Boolean
      ; Line 693: return 'true';
      ; sentinel check of string type String expecting String
      mov r15, offset string$44                                  ; read second operand of mov (string) for MoveToDerefInstruction
      mov r10, qword ptr [rbp + 030h]                            ; get pointer to return value of _stringify into register to dereference it
      mov qword ptr [r10], r15                                   ; _stringify return value
      mov rbx, qword ptr [rbp + 028h]                            ; get pointer to return value type of _stringify into register to dereference it
      mov qword ptr [rbx], 039h                                  ; type of _stringify return value (String'39)
      jmp func$_stringify$epilog                                 ; return
    func$_stringify$Stringify$if$1$if$continuation:              ; end of if
    ; Line 695: return 'false';
    ; sentinel check of string type String expecting String
    mov r12, offset string$45                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r13, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [r13], r12                                     ; _stringify return value
    mov rax, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [rax], 039h                                    ; type of _stringify return value (String'39)
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$1:                             ; end of if
  ; Line 697: if (arg is Null) { ...
  mov r14, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that arg is Null
  mov rbx, 000h                                                  ; clear is expression result
  setc bl                                                        ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation$2                           ; arg is Null
    ; Line 698: return 'null';
    ; sentinel check of string type String expecting String
    mov r14, offset string$46                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov rax, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [rax], r14                                     ; _stringify return value
    mov r15, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r15], 039h                                    ; type of _stringify return value (String'39)
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$2:                             ; end of if
  ; Line 700: if (arg is Integer) { ...
  mov r10, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that arg is Integer
  mov rdi, 000h                                                  ; clear is expression result
  setc dil                                                       ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp rdi, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation$3                           ; arg is Integer
    ; Line 701: return intToStr(arg as Integer);
    ; type check of arg type Anything expecting Integer
    mov r14, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, r14                                                 ; move testByte to testByte
    mov r15, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r15                                                      ; adjust to the relative start of that type's entry in the type table
    mov r10, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r10                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 002h                                     ; check that arg as Integer is Integer
    jc func$_stringify$Stringify$if$3$argAsINteger$TypeMatch     ; skip next block if the type matches
      ; Error handling block for arg as Integer
      ; Call __error with 1 arguments
      mov rbx, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push rbx                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 0168h]                           ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$3$argAsINteger$TypeMatch:       ; after block
    mov rdi, qword ptr [rbp + 040h]                              ; copy value of arg for cast to Integer
    mov r12, qword ptr [rbp + 038h]                              ; copy type of arg for cast to Integer
    ; sentinel check of intToStr type StringFunction(Integer) expecting AnythingFunction
    ; Call intToStr with 1 arguments
    push rdi                                                     ; value of argument #1 (cast of arg to Integer)
    push r12                                                     ; type of argument #1
    lea rax, qword ptr [rsp + 0168h]                             ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0168h]                             ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$intToStr                                           ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of intToStr return value type String expecting String
    cmp qword ptr [rsp + 0150h], 000h                            ; compare type of intToStr return value to <sentinel>
    jne func$_stringify$Stringify$if$3$StringifyReturnValue$TypeMatch ; skip next block if intToStr return value is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov r15, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0158h]                           ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0158h]                           ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$3$StringifyReturnValue$TypeMatch:  ; after block
    mov rbx, qword ptr [rsp + 0158h]                             ; read second operand of mov (intToStr return value) for MoveToDerefInstruction
    mov rsi, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [rsi], rbx                                     ; _stringify return value
    mov rdi, qword ptr [rsp + 0150h]                             ; reading type of intToStr return value
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r12], rdi                                     ; type of _stringify return value
    ; increment reference count for intToStr return value if necessary
    cmp rdi, 039h                                                ; compare type of intToStr return value to String
    jne func$_stringify$Stringify$if$3$AfterStringIncref         ; if not a String, skip incref
      mov r13, qword ptr [rbx]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$3$StringIncref            ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$3$AfterStringIncref       ; skip incref for string constants
      func$_stringify$Stringify$if$3$StringIncref:               ; real String
        inc qword ptr [rbx]                                      ; increment reference count of intToStr return value
    func$_stringify$Stringify$if$3$AfterStringIncref:            ; after String incref
    ; Decrement reference count for intToStr return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, rdi                                                 ; arg #2: intToStr return value's type
    mov rcx, rbx                                                 ; arg #1: intToStr return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$3:                             ; end of if
  ; Line 703: if (arg is __Object) { ...
  mov r14, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that arg is __Object
  mov r9, 000h                                                   ; clear is expression result
  setc r9b                                                       ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp r9, 000h                                                   ; compare is expression result to false
  je func$_stringify$if$continuation$4                           ; arg is __Object
    ; Line 704: return arg as __Object.toString();
    ; type check of arg type Anything expecting __Object
    mov qword ptr [rsp + 0158h], rbx                             ; move intToStr return value's value out of rbx
    mov rbx, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, rbx                                                 ; move testByte to testByte
    mov rsi, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rsi                                                      ; adjust to the relative start of that type's entry in the type table
    mov qword ptr [rsp + 0150h], rdi                             ; move intToStr return value's type out of rdi
    mov rdi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rdi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 006h                                     ; check that arg as __Object is __Object
    jc func$_stringify$Stringify$if$4$argAsOBject$TypeMatch      ; skip next block if the type matches
      ; Error handling block for arg as __Object
      ; Call __error with 1 arguments
      mov r12, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push r12                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0158h]                           ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0158h]                           ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$4$argAsOBject$TypeMatch:        ; after block
    mov r14, qword ptr [rbp + 040h]                              ; copy value of arg for cast to __Object
    mov r15, qword ptr [rbp + 038h]                              ; copy type of arg for cast to __Object
    mov r10, qword ptr [r14 + 028h]                              ; get vmt
    add r10, 060h                                                ; add offset for dereference (result in code address for __Object.toString)
    mov r10, qword ptr [r10]                                     ; get call method
    mov rbx, 03bh                                                ; store code of __CodeAddress value in code address for __Object.toString's type slot
    ; sentinel check of code address for __Object.toString type __CodeAddress expecting __CodeAddress
    cmp rbx, 000h                                                ; compare type of code address for __Object.toString to <sentinel>
    jne func$_stringify$Stringify$if$4$codeAddressForOBjectTostring$TypeMatch ; skip next block if code address for __Object.toString is not sentinel
      ; Error handling block for code address for __Object.toString
      ; Call __error with 1 arguments
      mov rax, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 0158h]                           ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 0158h]                           ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0178h], r10                           ; move code address for __Object.toString's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0138h]                           ; restoring slot (code address for __Object.toString) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$4$codeAddressForOBjectTostring$TypeMatch:  ; after block
    ; Call code address for __Object.toString with 0 arguments
    lea rdi, qword ptr [rsp + 0148h]                             ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 0148h]                             ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r14                                                  ; internal argument 4: "this" pointer
    mov r8, r15                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 000h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0168h], r10                             ; move code address for __Object.toString's value out of r10
    call qword ptr [rsp + 0168h]                                 ; jump to subroutine
    add rsp, 030h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of code address for __Object.toString return value type String expecting String
    cmp qword ptr [rsp + 0140h], 000h                            ; compare type of code address for __Object.toString return value to <sentinel>
    jne func$_stringify$Stringify$if$4$StringifyReturnValue$TypeMatch ; skip next block if code address for __Object.toString return value is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov r12, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0148h]                           ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0148h]                           ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$4$StringifyReturnValue$TypeMatch:  ; after block
    mov r14, qword ptr [rsp + 0148h]                             ; read second operand of mov (code address for __Object.toString return value) for MoveToDerefInstruction
    mov r15, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [r15], r14                                     ; _stringify return value
    mov r10, qword ptr [rsp + 0140h]                             ; reading type of code address for __Object.toString return value
    mov rbx, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [rbx], r10                                     ; type of _stringify return value
    ; increment reference count for code address for __Object.toString return value if necessary
    cmp r10, 039h                                                ; compare type of code address for __Object.toString return value to String
    jne func$_stringify$Stringify$if$4$AfterStringIncref         ; if not a String, skip incref
      mov rax, qword ptr [r14]                                   ; dereference string to get to reference count
      cmp rax, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$4$StringIncref            ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$4$AfterStringIncref       ; skip incref for string constants
      func$_stringify$Stringify$if$4$StringIncref:               ; real String
        inc qword ptr [r14]                                      ; increment reference count of code address for __Object.toString return value
    func$_stringify$Stringify$if$4$AfterStringIncref:            ; after String incref
    ; Decrement reference count for code address for __Object.toString return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r10                                                 ; arg #2: code address for __Object.toString return value's type
    mov rcx, r14                                                 ; arg #1: code address for __Object.toString return value's value
    mov qword ptr [rsp + 0168h], r10                             ; move code address for __Object.toString return value's type out of r10
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$4:                             ; end of if
  ; Line 706: if (arg is AnythingFunction) { ...
  mov rsi, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that arg is AnythingFunction
  mov r13, 000h                                                  ; clear is expression result
  setc r13b                                                      ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp r13, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation$5                           ; arg is AnythingFunction
    ; Line 707: Integer func = arg __as__ Integer;
    mov qword ptr [rsp + 0140h], r14                             ; move code address for __Object.toString return value's value out of r14
    mov r14, qword ptr [rbp + 040h]                              ; force cast of arg to Integer
    ; sentinel check of force cast of arg to Integer type Integer expecting Integer
    mov qword ptr [rsp + 0138h], r14                             ; value initialization of variable declaration for func variable (force cast of arg to Integer)
    mov qword ptr [rsp + 0130h], 038h                            ; type initialization of variable declaration for func variable (Integer'38)
    ; Line 708: if (__readFromAddress(func + _subroutineReceiverPointer) != 0) {...
    mov rbx, qword ptr [rsp + 0138h]                             ; make a copy of func's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 0130h]                             ; make a copy of func's type in case it changes before we use it
    mov rax, qword ptr _subroutineReceiverPointerValue           ; make a copy of _subroutineReceiverPointer's value in case it changes before we use it
    mov rdi, qword ptr _subroutineReceiverPointerType            ; make a copy of _subroutineReceiverPointer's type in case it changes before we use it
    ; sentinel check of copy of func type Integer expecting Integer
    cmp rsi, 000h                                                ; compare type of copy of func to <sentinel>
    jne func$_stringify$Stringify$if$5$func$TypeMatch            ; skip next block if copy of func is not sentinel
      ; Error handling block for func
      ; Call __error with 1 arguments
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0138h]                           ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0138h]                           ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0158h], rax                           ; move copy of _subroutineReceiverPointer's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0118h]                           ; restoring slot (copy of _subroutineReceiverPointer) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$5$func$TypeMatch:               ; after block
    ; sentinel check of copy of _subroutineReceiverPointer type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of _subroutineReceiverPointer to <sentinel>
    jne func$_stringify$Stringify$if$5$Subroutinereceiverpointer$TypeMatch ; skip next block if copy of _subroutineReceiverPointer is not sentinel
      ; Error handling block for _subroutineReceiverPointer
      ; Call __error with 1 arguments
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0138h]                           ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0138h]                           ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0158h], rax                           ; move copy of _subroutineReceiverPointer's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0118h]                           ; restoring slot (copy of _subroutineReceiverPointer) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$5$Subroutinereceiverpointer$TypeMatch:  ; after block
    mov r10, rbx                                                 ; assign value of copy of func to value of + operator result
    add r10, rax                                                 ; compute (copy of func) + (copy of _subroutineReceiverPointer) (result in + operator result)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov rax, qword ptr [r10]                                     ; dereference first argument of __readFromAddress
    xor rdi, rdi                                                 ; zero value result of == (testing dereferenced + operator result and 0) to put the boolean in
    cmp rax, 000h                                                ; values equal?
    sete dil                                                     ; put result in value result of == (testing dereferenced + operator result and 0)
    mov r12, 037h                                                ; value result of == (testing dereferenced + operator result and 0) is a Boolean'37
    xor r13, r13                                                 ; zero type result of == (testing dereferenced + operator result and 0) to put the boolean in
    mov r14, 038h                                                ; reading type of dereferenced + operator result for comparison with type of 0
    cmp r14, 038h                                                ; types equal?
    sete r13b                                                    ; put result in type result of == (testing dereferenced + operator result and 0)
    mov r15, 037h                                                ; type result of == (testing dereferenced + operator result and 0) is a Boolean'37
    mov r10, rdi                                                 ; assign value of value result of == (testing dereferenced + operator result and 0) to value of != operator result
    and r10, r13                                                 ; && type temp and value temp
    mov rbx, 001h                                                ; read second operand of xor (1 (integer))
    xor r10, rbx                                                 ; negating <DynamicSlot:Boolean ("!= operator result")>
    ; sentinel check of != operator result type Boolean expecting Boolean
    cmp r10, 000h                                                ; compare != operator result to false
    je func$_stringify$Stringify$if$5$if$continuation            ; __readFromAddress(func + _subroutineReceiverPointer) != 0
      ; Line 709: Integer annotation = __readFromAddress(__readFromAddress(func + ...
      mov rax, qword ptr [rsp + 0138h]                           ; make a copy of func's value in case it changes before we use it
      mov rdi, qword ptr [rsp + 0130h]                           ; make a copy of func's type in case it changes before we use it
      mov r12, qword ptr _subroutineCodePointerValue             ; make a copy of _subroutineCodePointer's value in case it changes before we use it
      mov r13, qword ptr _subroutineCodePointerType              ; make a copy of _subroutineCodePointer's type in case it changes before we use it
      ; sentinel check of copy of func type Integer expecting Integer
      cmp rdi, 000h                                              ; compare type of copy of func to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch ; skip next block if copy of func is not sentinel
        mov qword ptr [rsp + 0128h], 000h                        ; move annotation variable's value into a mutable location
        mov qword ptr [rsp + 0120h], 000h                        ; move annotation variable's type into a mutable location
        ; Error handling block for func
        ; Call __error with 1 arguments
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r15, qword ptr [rsp + 0128h]                         ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 0128h]                         ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0148h], rax                         ; move copy of func's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 0108h]                         ; restoring slot (copy of func) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch:  ; after block
      ; sentinel check of copy of _subroutineCodePointer type Integer expecting Integer
      cmp r13, 000h                                              ; compare type of copy of _subroutineCodePointer to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinecodepointer$TypeMatch ; skip next block if copy of _subroutineCodePointer is not sentinel
        ; Error handling block for _subroutineCodePointer
        ; Call __error with 1 arguments
        mov r10, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r10                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rbx, qword ptr [rsp + 0128h]                         ; load address of return value's value
        push rbx                                                 ; internal argument 6: pointer to return value slot's value
        lea rbx, qword ptr [rsp + 0128h]                         ; load address of return value's type
        push rbx                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0148h], rax                         ; move copy of func's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 0108h]                         ; restoring slot (copy of func) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinecodepointer$TypeMatch:  ; after block
      mov rsi, rax                                               ; assign value of copy of func to value of + operator result
      add rsi, r12                                               ; compute (copy of func) + (copy of _subroutineCodePointer) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov r12, qword ptr [rsi]                                   ; dereference first argument of __readFromAddress
      ; sentinel check of dereferenced + operator result type Integer expecting Integer
      ; sentinel check of 8 type Integer expecting Integer
      mov rbx, r12                                               ; assign value of dereferenced + operator result to value of - operator result
      sub rbx, 008h                                              ; compute (dereferenced + operator result) - (8)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov rdi, qword ptr [rbx]                                   ; dereference first argument of __readFromAddress
      ; sentinel check of dereferenced - operator result type Integer expecting Integer
      mov qword ptr [rsp + 0128h], rdi                           ; value initialization of variable declaration for annotation variable (dereferenced - operator result)
      mov qword ptr [rsp + 0120h], 038h                          ; type initialization of variable declaration for annotation variable (Integer'38)
      ; Line 710: __Object class = __readFromAddress(func + _subroutineReceiverPoi...
      mov r14, qword ptr [rsp + 0138h]                           ; make a copy of func's value in case it changes before we use it
      mov r15, qword ptr [rsp + 0130h]                           ; make a copy of func's type in case it changes before we use it
      mov r10, qword ptr _subroutineReceiverPointerValue         ; make a copy of _subroutineReceiverPointer's value in case it changes before we use it
      mov rbx, qword ptr _subroutineReceiverPointerType          ; make a copy of _subroutineReceiverPointer's type in case it changes before we use it
      ; sentinel check of copy of func type Integer expecting Integer
      cmp r15, 000h                                              ; compare type of copy of func to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch$1 ; skip next block if copy of func is not sentinel
        mov qword ptr [rsp + 0118h], 000h                        ; move class variable's value into a mutable location
        mov qword ptr [rsp + 0110h], 000h                        ; move class variable's type into a mutable location
        ; Error handling block for func
        ; Call __error with 1 arguments
        mov rsi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rax, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push rax                                                 ; internal argument 6: pointer to return value slot's value
        lea rax, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push rax                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0138h], r10                         ; move copy of _subroutineReceiverPointer's value out of r10
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r10, qword ptr [rsp + 0f8h]                          ; restoring slot (copy of _subroutineReceiverPointer) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch$1:  ; after block
      ; sentinel check of copy of _subroutineReceiverPointer type Integer expecting Integer
      cmp rbx, 000h                                              ; compare type of copy of _subroutineReceiverPointer to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinereceiverpointer$TypeMatch ; skip next block if copy of _subroutineReceiverPointer is not sentinel
        ; Error handling block for _subroutineReceiverPointer
        ; Call __error with 1 arguments
        mov rdi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rdi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r12, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push r12                                                 ; internal argument 6: pointer to return value slot's value
        lea r12, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push r12                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0138h], r10                         ; move copy of _subroutineReceiverPointer's value out of r10
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r10, qword ptr [rsp + 0f8h]                          ; restoring slot (copy of _subroutineReceiverPointer) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinereceiverpointer$TypeMatch:  ; after block
      mov r13, r14                                               ; assign value of copy of func to value of + operator result
      add r13, r10                                               ; compute (copy of func) + (copy of _subroutineReceiverPointer) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov r10, qword ptr [r13]                                   ; dereference first argument of __readFromAddress
      mov rbx, qword ptr [rsp + 0138h]                           ; make a copy of func's value in case it changes before we use it
      mov rsi, qword ptr [rsp + 0130h]                           ; make a copy of func's type in case it changes before we use it
      mov rax, qword ptr _subroutineReceiverTypeValue            ; make a copy of _subroutineReceiverType's value in case it changes before we use it
      mov rdi, qword ptr _subroutineReceiverTypeType             ; make a copy of _subroutineReceiverType's type in case it changes before we use it
      ; sentinel check of copy of func type Integer expecting Integer
      cmp rsi, 000h                                              ; compare type of copy of func to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch$2 ; skip next block if copy of func is not sentinel
        ; Error handling block for func
        ; Call __error with 1 arguments
        mov r12, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r12                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r13, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0138h], r10                         ; move dereferenced + operator result's value out of r10
        mov qword ptr [rsp + 0130h], rax                         ; move copy of _subroutineReceiverType's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 0f0h]                          ; restoring slot (copy of _subroutineReceiverType) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 0f8h]                          ; restoring slot (dereferenced + operator result) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$func$TypeMatch$2:  ; after block
      ; sentinel check of copy of _subroutineReceiverType type Integer expecting Integer
      cmp rdi, 000h                                              ; compare type of copy of _subroutineReceiverType to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinereceivertype$TypeMatch ; skip next block if copy of _subroutineReceiverType is not sentinel
        ; Error handling block for _subroutineReceiverType
        ; Call __error with 1 arguments
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r15, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 0138h], r10                         ; move dereferenced + operator result's value out of r10
        mov qword ptr [rsp + 0130h], rax                         ; move copy of _subroutineReceiverType's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 0f0h]                          ; restoring slot (copy of _subroutineReceiverType) to previous scope state for genuine block exit
        mov r10, qword ptr [rsp + 0f8h]                          ; restoring slot (dereferenced + operator result) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$Subroutinereceivertype$TypeMatch:  ; after block
      mov qword ptr [rsp + 0108h], r10                           ; move dereferenced + operator result's value out of r10
      mov r10, rbx                                               ; assign value of copy of func to value of + operator result
      add r10, rax                                               ; compute (copy of func) + (copy of _subroutineReceiverType) (result in + operator result)
      ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
      ; Call __readFromAddress with 1 arguments
      mov rax, qword ptr [r10]                                   ; dereference first argument of __readFromAddress
      mov rdi, qword ptr [rsp + 0108h]                           ; force cast of dereferenced + operator result to the type with code dereferenced + operator result
      mov r12, rax                                               ; store dereferenced + operator result value in force cast of dereferenced + operator result to the type with code dereferenced + operator result's type slot
      ; type check of force cast of dereferenced + operator result to the type with code dereferenced + operator result type Anything expecting __Object
      mov r13, r12                                               ; store force cast of dereferenced + operator result to the type with code dereferenced + operator result's type in testByte value slot
      mov rax, r13                                               ; move testByte to testByte
      mov r14, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r14                                                    ; adjust to the relative start of that type's entry in the type table
      mov r15, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, r15                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 006h                                   ; check that __readFromAddress(func + _subroutineReceiverPointer) __dynamic_as__ __readFromAddress(func + _subroutineReceiverType) as __Object is __Object
      jc func$_stringify$Stringify$if$5$stringify$if$5$if$ReadfromaddressFuncSubroutinereceiverpointerDynamicAsReadfromaddressFuncSubroutinereceivertypeAsOBject$TypeMatch ; skip next block if the type matches
        ; Error handling block for __readFromAddress(func + _subroutineReceiverPointer) __dynamic_as__ __readFromAddress(func + _subroutineReceiverType) as __Object
        ; Call __error with 1 arguments
        mov r10, offset asOperatorFailureMessage                 ; reading asOperatorFailureMessage for push
        push r10                                                 ; value of argument #1 (asOperatorFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rbx, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push rbx                                                 ; internal argument 6: pointer to return value slot's value
        lea rbx, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push rbx                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_stringify$Stringify$if$5$stringify$if$5$if$ReadfromaddressFuncSubroutinereceiverpointerDynamicAsReadfromaddressFuncSubroutinereceivertypeAsOBject$TypeMatch:  ; after block
      mov rsi, rdi                                               ; copy value of force cast of dereferenced + operator result to the type with code dereferenced + operator result for cast to __Object
      mov qword ptr [rsp + 0108h], rdi                           ; move force cast of dereferenced + operator result to the type with code dereferenced + operator result's value out of rdi
      mov rdi, r12                                               ; copy type of force cast of dereferenced + operator result to the type with code dereferenced + operator result for cast to __Object
      ; sentinel check of cast of force cast of dereferenced + operator result to the type with code dereferenced + operator result to __Object type __Object expecting __Object
      cmp rdi, 000h                                              ; compare type of cast of force cast of dereferenced + operator result to the type with code dereferenced + operator result to __Object to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$castOfForceCastOfDereferencedOperatorResultToTheTypeWithCodeDereferencedOperatorResultToOBject$TypeMatch ; skip next block if cast of force cast of dereferenced + operator result to the type with code dereferenced + operator result to __Object is not sentinel
        ; Error handling block for cast of force cast of dereferenced + operator result to the type with code dereferenced + operator result to __Object
        ; Call __error with 1 arguments
        mov r12, offset assignmentTypeCheckFailureMessage        ; reading assignmentTypeCheckFailureMessage for push
        push r12                                                 ; value of argument #1 (assignmentTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r13, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 0118h]                         ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_stringify$Stringify$if$5$stringify$if$5$if$castOfForceCastOfDereferencedOperatorResultToTheTypeWithCodeDereferencedOperatorResultToOBject$TypeMatch:  ; after block
      mov qword ptr [rsp + 0118h], rsi                           ; value initialization of variable declaration for class variable (cast of force cast of dereferenced + operator result to the type with code dereferenced + operator result to __Object)
      mov qword ptr [rsp + 0110h], rdi                           ; type initialization of variable declaration for class variable
      ; increment reference count for class variable if necessary
      mov rax, qword ptr [rsp + 0110h]                           ; store class variable's type in testByte value slot
      mov r14, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r14                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov r15, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, r15                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$5$stringify$if$5$if$AfterGCIncref ; if not a GarbageCollectable, skip incref
        mov r10, qword ptr [rsp + 0118h]                         ; read slot into register for dereferencing
        inc qword ptr [r10]                                      ; increment reference count of class variable
        mov qword ptr [rsp + 0118h], r10                         ; restoring slot (class variable) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$AfterGCIncref:  ; after GarbageCollectable incref
      ; Line 711: return concat('<function (method ', class.className, '.', annota...
      mov rbx, qword ptr concatValue                             ; make a copy of concat's value in case it changes before we use it
      mov rsi, qword ptr concatType                              ; make a copy of concat's type in case it changes before we use it
      mov rdi, qword ptr [rsp + 0118h]                           ; make a copy of class's value in case it changes before we use it
      mov r12, qword ptr [rsp + 0110h]                           ; make a copy of class's type in case it changes before we use it
      ; increment reference count for copy of class if necessary
      mov r13, r12                                               ; store copy of class's type in testByte value slot
      mov rax, r13                                               ; move testByte to testByte
      mov r9, 004h                                               ; read operand of mul (type table width in bytes) 
      mul r9                                                     ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov r8, offset typeTable                                   ; read second operand of + (type table pointer)
      add rax, r8                                                ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$5$stringify$if$5$if$AfterGCIncref$1 ; if not a GarbageCollectable, skip incref
        inc qword ptr [rdi]                                      ; increment reference count of copy of class
      func$_stringify$Stringify$if$5$stringify$if$5$if$AfterGCIncref$1:  ; after GarbageCollectable incref
      mov rdx, qword ptr [rdi + 038h]                            ; make a copy of __Object.className's value in case it changes before we use it
      mov rcx, qword ptr [rdi + 030h]                            ; make a copy of __Object.className's type in case it changes before we use it
      ; increment reference count for copy of __Object.className if necessary
      cmp rcx, 039h                                              ; compare type of copy of __Object.className to String
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref ; if not a String, skip incref
        mov r14, qword ptr [rdx]                                 ; dereference string to get to reference count
        cmp r14, 0                                               ; compare string reference count to 0
        jns func$_stringify$Stringify$if$5$stringify$if$5$if$StringIncref ; if reference count is negative (constant strings), skip incref
        jmp func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref ; skip incref for string constants
        func$_stringify$Stringify$if$5$stringify$if$5$if$StringIncref:  ; real String
          inc qword ptr [rdx]                                    ; increment reference count of copy of __Object.className
      func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref:  ; after String incref
      mov r15, qword ptr [rsp + 0128h]                           ; make a copy of annotation's value in case it changes before we use it
      mov r10, qword ptr [rsp + 0120h]                           ; make a copy of annotation's type in case it changes before we use it
      mov qword ptr [rsp + 0128h], rbx                           ; move copy of concat's value out of rbx
      mov rbx, r15                                               ; force cast of copy of annotation to String
      ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
      cmp rsi, 000h                                              ; compare type of copy of concat to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$copyOfConcat$TypeMatch ; skip next block if copy of concat is not sentinel
        ; Error handling block for copy of concat
        ; Call __error with 1 arguments
        mov qword ptr [rsp + 0120h], rsi                         ; move copy of concat's type out of rsi
        mov rsi, offset subroutineCallTypeCheckFailureMessage    ; reading subroutineCallTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 0110h], rdi                         ; move copy of class's value out of rdi
        lea rdi, qword ptr [rsp + 0118h]                         ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 0110h]                         ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov qword ptr [rsp + 0130h], rdx                         ; move copy of __Object.className's value out of rdx
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov qword ptr [rsp + 0128h], rcx                         ; move copy of __Object.className's type out of rcx
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rcx, qword ptr [rsp + 0e8h]                          ; restoring slot (copy of __Object.className) to previous scope state for genuine block exit
        mov rdx, qword ptr [rsp + 0f0h]                          ; restoring slot (copy of __Object.className) to previous scope state for genuine block exit
        mov rsi, qword ptr [rsp + 0120h]                         ; restoring slot (copy of concat) to previous scope state for genuine block exit
        mov rdi, qword ptr [rsp + 0100h]                         ; restoring slot (copy of class) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$copyOfConcat$TypeMatch:  ; after block
      ; Call copy of concat with 5 arguments
      mov qword ptr [rsp + 0120h], r12                           ; move copy of class's type out of r12
      mov r12, qword ptr [rsp + 0128h]                           ; get copy of concat into register to dereference it
      mov r13, qword ptr [r12 + 028h]                            ; read receiver pointer
      mov rax, qword ptr [r12 + 020h]                            ; read receiver type
      mov r14, offset string$49                                  ; reading string for push
      push r14                                                   ; value of argument #5 (string)
      push 039h                                                  ; type of argument #5 (String'39)
      push rbx                                                   ; value of argument #4 (force cast of copy of annotation to String)
      push 039h                                                  ; type of argument #4 (String'39)
      mov r15, offset string$48                                  ; reading string for push
      push r15                                                   ; value of argument #3 (string)
      push 039h                                                  ; type of argument #3 (String'39)
      push rdx                                                   ; value of argument #2 (copy of __Object.className)
      push rcx                                                   ; type of argument #2
      mov r10, offset string$47                                  ; reading string for push
      push r10                                                   ; value of argument #1 (string)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0178h]                           ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0160h]                           ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, r13                                                ; internal argument 4: "this" pointer
      mov r8, rax                                                ; internal argument 3: "this" pointer type
      mov qword ptr [rsp + 0180h], rdx                           ; move copy of __Object.className's value out of rdx
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 0178h], rcx                           ; move copy of __Object.className's type out of rcx
      mov rcx, 005h                                              ; internal argument 1: number of actual arguments
      call qword ptr [r12 + 038h]                                ; jump to subroutine
      add rsp, 080h                                              ; release shadow space and arguments (result in stack pointer)
      ; sentinel check of copy of concat return value type String expecting String
      cmp qword ptr [rsp + 0108h], 000h                          ; compare type of copy of concat return value to <sentinel>
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$StringifyReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
        ; Error handling block for _stringify return value
        ; Call __error with 1 arguments
        mov rsi, offset returnValueTypeCheckFailureMessage       ; reading returnValueTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (returnValueTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 0f8h], rdi                          ; move copy of class's value out of rdi
        lea rdi, qword ptr [rsp + 0100h]                         ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 0f8h]                          ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rdi, qword ptr [rsp + 0e8h]                          ; restoring slot (copy of class) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$5$stringify$if$5$if$StringifyReturnValue$TypeMatch:  ; after block
      mov r12, qword ptr [rsp + 0128h]                           ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
      mov r13, qword ptr [rbp + 030h]                            ; get pointer to return value of _stringify into register to dereference it
      mov qword ptr [r13], r12                                   ; _stringify return value
      mov rax, qword ptr [rsp + 0108h]                           ; reading type of copy of concat return value
      mov r14, qword ptr [rbp + 028h]                            ; get pointer to return value type of _stringify into register to dereference it
      mov qword ptr [r14], rax                                   ; type of _stringify return value
      ; increment reference count for copy of concat return value if necessary
      cmp rax, 039h                                              ; compare type of copy of concat return value to String
      jne func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref$1 ; if not a String, skip incref
        mov r15, qword ptr [r12]                                 ; dereference string to get to reference count
        cmp r15, 0                                               ; compare string reference count to 0
        jns func$_stringify$Stringify$if$5$stringify$if$5$if$StringIncref$1 ; if reference count is negative (constant strings), skip incref
        jmp func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref$1 ; skip incref for string constants
        func$_stringify$Stringify$if$5$stringify$if$5$if$StringIncref$1:  ; real String
          inc qword ptr [r12]                                    ; increment reference count of copy of concat return value
      func$_stringify$Stringify$if$5$stringify$if$5$if$AfterStringIncref$1:  ; after String incref
      ; Decrement reference count for copy of __Object.className (static type: String'39) via decrefMaybeString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0118h]                           ; arg #2: copy of __Object.className's type
      mov rcx, qword ptr [rsp + 0120h]                           ; arg #1: copy of __Object.className's value
      mov qword ptr [rsp + 0148h], rax                           ; move copy of concat return value's type out of rax
      call decrefMaybeString                                     ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for class variable (static type: __Object'3c) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0130h]                           ; arg #2: class variable's type
      mov rcx, qword ptr [rsp + 0138h]                           ; arg #1: class variable's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0148h]                           ; arg #2: copy of concat return value's type
      mov rcx, r12                                               ; arg #1: copy of concat return value's value
      call decrefMaybeString                                     ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of class (static type: __Object'3c) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0140h]                           ; arg #2: copy of class's type
      mov rcx, rdi                                               ; arg #1: copy of class's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      jmp func$_stringify$epilog                                 ; return
    func$_stringify$Stringify$if$5$if$continuation:              ; end of if
    ; Line 713: Integer annotation = __readFromAddress(__readFromAddress(func + ...
    mov r10, qword ptr [rsp + 0138h]                             ; make a copy of func's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 0130h]                             ; make a copy of func's type in case it changes before we use it
    mov rsi, qword ptr _subroutineCodePointerValue               ; make a copy of _subroutineCodePointer's value in case it changes before we use it
    mov qword ptr [rsp + 0138h], rdi                             ; move copy of class's value out of rdi
    mov rdi, qword ptr _subroutineCodePointerType                ; make a copy of _subroutineCodePointer's type in case it changes before we use it
    ; sentinel check of copy of func type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of func to <sentinel>
    jne func$_stringify$Stringify$if$5$func$TypeMatch$1          ; skip next block if copy of func is not sentinel
      mov qword ptr [rsp + 0130h], 000h                          ; move annotation variable's value into a mutable location
      mov qword ptr [rsp + 0108h], 000h                          ; move annotation variable's type into a mutable location
      ; Error handling block for func
      ; Call __error with 1 arguments
      mov r9, offset operandTypeCheckFailureMessage              ; reading operandTypeCheckFailureMessage for push
      push r9                                                    ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r8, qword ptr [rsp + 0100h]                            ; load address of return value's value
      push r8                                                    ; internal argument 6: pointer to return value slot's value
      lea r8, qword ptr [rsp + 0100h]                            ; load address of return value's type
      push r8                                                    ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0120h], r10                           ; move copy of func's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0e0h]                            ; restoring slot (copy of func) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$5$func$TypeMatch$1:             ; after block
    ; sentinel check of copy of _subroutineCodePointer type Integer expecting Integer
    cmp rdi, 000h                                                ; compare type of copy of _subroutineCodePointer to <sentinel>
    jne func$_stringify$Stringify$if$5$Subroutinecodepointer$TypeMatch ; skip next block if copy of _subroutineCodePointer is not sentinel
      ; Error handling block for _subroutineCodePointer
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 0f0h], r12                            ; move copy of concat return value's value out of r12
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0f8h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0f8h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0118h], r10                           ; move copy of func's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0d8h]                            ; restoring slot (copy of func) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$5$Subroutinecodepointer$TypeMatch:  ; after block
    mov rax, r10                                                 ; assign value of copy of func to value of + operator result
    add rax, rsi                                                 ; compute (copy of func) + (copy of _subroutineCodePointer) (result in + operator result)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r10, qword ptr [rax]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced + operator result type Integer expecting Integer
    ; sentinel check of 8 type Integer expecting Integer
    mov r13, r10                                                 ; assign value of dereferenced + operator result to value of - operator result
    sub r13, 008h                                                ; compute (dereferenced + operator result) - (8)
    ; sentinel check of __readFromAddress type IntegerFunction(Integer) expecting AnythingFunction
    ; Call __readFromAddress with 1 arguments
    mov r15, qword ptr [r13]                                     ; dereference first argument of __readFromAddress
    ; sentinel check of dereferenced - operator result type Integer expecting Integer
    mov qword ptr [rsp + 0130h], r15                             ; value initialization of variable declaration for annotation variable (dereferenced - operator result)
    mov qword ptr [rsp + 0108h], 038h                            ; type initialization of variable declaration for annotation variable (Integer'38)
    ; Line 714: return concat('<function (', annotation __as__ String, ')>');
    mov rsi, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov rdi, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    mov r12, qword ptr [rsp + 0130h]                             ; make a copy of annotation's value in case it changes before we use it
    mov r13, qword ptr [rsp + 0108h]                             ; make a copy of annotation's type in case it changes before we use it
    mov rax, r12                                                 ; force cast of copy of annotation to String
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp rdi, 000h                                                ; compare type of copy of concat to <sentinel>
    jne func$_stringify$Stringify$if$5$copyOfConcat$TypeMatch    ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov r14, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0140h]                           ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0120h]                           ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0128h], rax                           ; move force cast of copy of annotation to String's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0e8h]                            ; restoring slot (force cast of copy of annotation to String) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$5$copyOfConcat$TypeMatch:       ; after block
    ; Call copy of concat with 3 arguments
    mov r10, qword ptr [rsi + 028h]                              ; read receiver pointer
    mov rbx, qword ptr [rsi + 020h]                              ; read receiver type
    mov qword ptr [rsp + 0130h], rsi                             ; move copy of concat's value out of rsi
    mov rsi, offset string$49                                    ; reading string for push
    push rsi                                                     ; value of argument #3 (string)
    push 039h                                                    ; type of argument #3 (String'39)
    push rax                                                     ; value of argument #2 (force cast of copy of annotation to String)
    push 039h                                                    ; type of argument #2 (String'39)
    mov qword ptr [rsp + 0128h], rdi                             ; move copy of concat's type out of rdi
    mov rdi, offset string$50                                    ; reading string for push
    push rdi                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 0118h]                             ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0118h]                             ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r10                                                  ; internal argument 4: "this" pointer
    mov r8, rbx                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 003h                                                ; internal argument 1: number of actual arguments
    mov r13, qword ptr [rsp + 0190h]                             ; reading copy of concat to dereference it
    call qword ptr [r13 + 038h]                                  ; jump to subroutine
    add rsp, 060h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat return value type String expecting String
    cmp qword ptr [rsp + 0e0h], 000h                             ; compare type of copy of concat return value to <sentinel>
    jne func$_stringify$Stringify$if$5$StringifyReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov rax, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push rax                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 0140h]                           ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 0120h]                           ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$5$StringifyReturnValue$TypeMatch:  ; after block
    mov r15, qword ptr [rsp + 0e8h]                              ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
    mov r10, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [r10], r15                                     ; _stringify return value
    mov rbx, qword ptr [rsp + 0e0h]                              ; reading type of copy of concat return value
    mov rsi, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [rsi], rbx                                     ; type of _stringify return value
    ; increment reference count for copy of concat return value if necessary
    cmp rbx, 039h                                                ; compare type of copy of concat return value to String
    jne func$_stringify$Stringify$if$5$AfterStringIncref         ; if not a String, skip incref
      mov rdi, qword ptr [r15]                                   ; dereference string to get to reference count
      cmp rdi, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$5$StringIncref            ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$5$AfterStringIncref       ; skip incref for string constants
      func$_stringify$Stringify$if$5$StringIncref:               ; real String
        inc qword ptr [r15]                                      ; increment reference count of copy of concat return value
    func$_stringify$Stringify$if$5$AfterStringIncref:            ; after String incref
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, rbx                                                 ; arg #2: copy of concat return value's type
    mov rcx, r15                                                 ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$5:                             ; end of if
  ; Line 716: if (arg is StringList) { ...
  mov r12, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 007h                                       ; check that arg is StringList
  mov r9, 000h                                                   ; clear is expression result
  setc r9b                                                       ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp r9, 000h                                                   ; compare is expression result to false
  je func$_stringify$if$continuation$6                           ; arg is StringList
    ; Line 717: return concat('[', join(arg as StringList, ', '), ']');
    mov qword ptr [rsp + 0130h], r15                             ; move copy of concat return value's value out of r15
    mov r15, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov r10, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    ; type check of arg type Anything expecting StringList
    mov qword ptr [rsp + 0108h], rbx                             ; move copy of concat return value's type out of rbx
    mov rbx, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, rbx                                                 ; move testByte to testByte
    mov rsi, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rsi                                                      ; adjust to the relative start of that type's entry in the type table
    mov rdi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rdi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 007h                                     ; check that arg as StringList is StringList
    jc func$_stringify$Stringify$if$6$argAsSTringlist$TypeMatch  ; skip next block if the type matches
      ; Error handling block for arg as StringList
      ; Call __error with 1 arguments
      mov r12, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push r12                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r13, qword ptr [rsp + 0f8h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0f8h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0118h], r10                           ; move copy of concat's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0d8h]                            ; restoring slot (copy of concat) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$6$argAsSTringlist$TypeMatch:    ; after block
    mov r14, qword ptr [rbp + 040h]                              ; copy value of arg for cast to StringList
    mov qword ptr [rsp + 0e8h], r15                              ; move copy of concat's value out of r15
    mov r15, qword ptr [rbp + 038h]                              ; copy type of arg for cast to StringList
    ; sentinel check of join type StringFunction(StringList, String) expecting AnythingFunction
    ; Call join with 2 arguments
    mov rax, offset string$52                                    ; reading string for push
    push rax                                                     ; value of argument #2 (string)
    push 039h                                                    ; type of argument #2 (String'39)
    push r14                                                     ; value of argument #1 (cast of arg to StringList)
    push r15                                                     ; type of argument #1
    lea rsi, qword ptr [rsp + 0100h]                             ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 0100h]                             ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0120h], r10                             ; move copy of concat's type out of r10
    call func$join                                               ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp qword ptr [rsp + 0d0h], 000h                             ; compare type of copy of concat to <sentinel>
    jne func$_stringify$Stringify$if$6$copyOfConcat$TypeMatch    ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov rdi, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 0d8h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 0d8h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$6$copyOfConcat$TypeMatch:       ; after block
    ; Call copy of concat with 3 arguments
    mov r13, qword ptr [rsp + 0e8h]                              ; get copy of concat into register to dereference it
    mov r14, qword ptr [r13 + 028h]                              ; read receiver pointer
    mov r15, qword ptr [r13 + 020h]                              ; read receiver type
    mov r10, offset string$53                                    ; reading string for push
    push r10                                                     ; value of argument #3 (string)
    push 039h                                                    ; type of argument #3 (String'39)
    push qword ptr [rsp + 0f0h]                                  ; value of argument #2 (join return value)
    push qword ptr [rsp + 0f0h]                                  ; type of argument #2
    mov rbx, offset string$51                                    ; reading string for push
    push rbx                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0118h]                             ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0100h]                             ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r14                                                  ; internal argument 4: "this" pointer
    mov r8, r15                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 003h                                                ; internal argument 1: number of actual arguments
    call qword ptr [r13 + 038h]                                  ; jump to subroutine
    add rsp, 060h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat return value type String expecting String
    cmp qword ptr [rsp + 0c8h], 000h                             ; compare type of copy of concat return value to <sentinel>
    jne func$_stringify$Stringify$if$6$StringifyReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov rsi, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rdi, qword ptr [rsp + 0e0h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 0d8h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$6$StringifyReturnValue$TypeMatch:  ; after block
    mov r12, qword ptr [rsp + 0e8h]                              ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
    mov r13, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [r13], r12                                     ; _stringify return value
    mov r14, qword ptr [rsp + 0c8h]                              ; reading type of copy of concat return value
    mov r15, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r15], r14                                     ; type of _stringify return value
    ; increment reference count for copy of concat return value if necessary
    cmp r14, 039h                                                ; compare type of copy of concat return value to String
    jne func$_stringify$Stringify$if$6$AfterStringIncref         ; if not a String, skip incref
      mov r10, qword ptr [r12]                                   ; dereference string to get to reference count
      cmp r10, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$6$StringIncref            ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$6$AfterStringIncref       ; skip incref for string constants
      func$_stringify$Stringify$if$6$StringIncref:               ; real String
        inc qword ptr [r12]                                      ; increment reference count of copy of concat return value
    func$_stringify$Stringify$if$6$AfterStringIncref:            ; after String incref
    ; Decrement reference count for join return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0f8h]                              ; arg #2: join return value's type
    mov rcx, qword ptr [rsp + 0100h]                             ; arg #1: join return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r14                                                 ; arg #2: copy of concat return value's type
    mov rcx, r12                                                 ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$6:                             ; end of if
  ; Line 719: if (arg is WhateverList) { ...
  mov rbx, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that arg is WhateverList
  mov r9, 000h                                                   ; clear is expression result
  setc r9b                                                       ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp r9, 000h                                                   ; compare is expression result to false
  je func$_stringify$if$continuation$7                           ; arg is WhateverList
    ; Line 720: StringList new = []:String;
    ; Call _listConstructor with 2 arguments
    push 001h                                                    ; value of argument #2 (1 (integer))
    push 038h                                                    ; type of argument #2 (Integer'38)
    push 03dh                                                    ; value of argument #1 (code of StringList)
    push 038h                                                    ; type of argument #1 (Integer'38)
    mov qword ptr [rsp + 0f0h], r12                              ; move copy of concat return value's value out of r12
    lea r12, qword ptr [rsp + 0108h]                             ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0f0h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$_listConstructor                                   ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    mov r13, qword ptr [rsp + 0e8h]                              ; copy list literal's value over to slot with better static type
    mov qword ptr [rsp + 0c0h], r14                              ; move copy of concat return value's type out of r14
    mov r14, qword ptr [rsp + 0c8h]                              ; copy list literal's dynamic type over to slot with better static type
    ; sentinel check of list literal type StringList expecting StringList
    cmp r14, 000h                                                ; compare type of list literal to <sentinel>
    jne func$_stringify$Stringify$if$7$listLiteral$TypeMatch     ; skip next block if list literal is not sentinel
      mov qword ptr [rsp + 0b8h], 000h                           ; move new variable's value into a mutable location
      mov qword ptr [rsp + 0b0h], 000h                           ; move new variable's type into a mutable location
      ; Error handling block for list literal
      ; Call __error with 1 arguments
      mov r15, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0b8h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0b8h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$7$listLiteral$TypeMatch:        ; after block
    mov qword ptr [rsp + 0b8h], r13                              ; value initialization of variable declaration for new variable (list literal)
    mov qword ptr [rsp + 0b0h], r14                              ; type initialization of variable declaration for new variable
    ; increment reference count for new variable if necessary
    mov rbx, qword ptr [rsp + 0b0h]                              ; store new variable's type in testByte value slot
    mov rax, rbx                                                 ; move testByte to testByte
    mov rsi, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rsi                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rdi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rdi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_stringify$Stringify$if$7$AfterGCIncref             ; if not a GarbageCollectable, skip incref
      mov r12, qword ptr [rsp + 0b8h]                            ; read slot into register for dereferencing
      inc qword ptr [r12]                                        ; increment reference count of new variable
      mov qword ptr [rsp + 0b8h], r12                            ; restoring slot (new variable) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$7$AfterGCIncref:                ; after GarbageCollectable incref
    ; Line 721: WhateverList old = arg as WhateverList;
    ; type check of arg type Anything expecting WhateverList
    mov r13, qword ptr [rbp + 038h]                              ; store arg's type in testByte value slot
    mov rax, r13                                                 ; move testByte to testByte
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 003h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 000h                                     ; check that arg as WhateverList is WhateverList
    jc func$_stringify$Stringify$if$7$argAsWHateverlist$TypeMatch ; skip next block if the type matches
      mov qword ptr [rsp + 0a8h], 000h                           ; move old variable's value into a mutable location
      mov qword ptr [rsp + 0a0h], 000h                           ; move old variable's type into a mutable location
      ; Error handling block for arg as WhateverList
      ; Call __error with 1 arguments
      mov r10, offset asOperatorFailureMessage                   ; reading asOperatorFailureMessage for push
      push r10                                                   ; value of argument #1 (asOperatorFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r9, qword ptr [rsp + 0a8h]                             ; load address of return value's value
      push r9                                                    ; internal argument 6: pointer to return value slot's value
      lea r9, qword ptr [rsp + 0a8h]                             ; load address of return value's type
      push r9                                                    ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$7$argAsWHateverlist$TypeMatch:  ; after block
    mov rbx, qword ptr [rbp + 040h]                              ; copy value of arg for cast to WhateverList
    mov rsi, qword ptr [rbp + 038h]                              ; copy type of arg for cast to WhateverList
    ; sentinel check of cast of arg to WhateverList type WhateverList expecting WhateverList
    cmp rsi, 000h                                                ; compare type of cast of arg to WhateverList to <sentinel>
    jne func$_stringify$Stringify$if$7$castOfArgToWHateverlist$TypeMatch ; skip next block if cast of arg to WhateverList is not sentinel
      ; Error handling block for cast of arg to WhateverList
      ; Call __error with 1 arguments
      mov rdi, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 0a8h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 0a8h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$7$castOfArgToWHateverlist$TypeMatch:  ; after block
    mov qword ptr [rsp + 0a8h], rbx                              ; value initialization of variable declaration for old variable (cast of arg to WhateverList)
    mov qword ptr [rsp + 0a0h], rsi                              ; type initialization of variable declaration for old variable
    ; increment reference count for old variable if necessary
    mov r13, qword ptr [rsp + 0a0h]                              ; store old variable's type in testByte value slot
    mov rax, r13                                                 ; move testByte to testByte
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_stringify$Stringify$if$7$AfterGCIncref$1           ; if not a GarbageCollectable, skip incref
      mov r10, qword ptr [rsp + 0a8h]                            ; read slot into register for dereferencing
      inc qword ptr [r10]                                        ; increment reference count of old variable
      mov qword ptr [rsp + 0a8h], r10                            ; restoring slot (old variable) to previous scope state for genuine block exit
    func$_stringify$Stringify$if$7$AfterGCIncref$1:              ; after GarbageCollectable incref
    ; Line 722: Integer i = 0;
    ; sentinel check of 0 type Integer expecting Integer
    mov qword ptr [rsp + 098h], 000h                             ; value initialization of variable declaration for i variable (0)
    mov qword ptr [rsp + 090h], 038h                             ; type initialization of variable declaration for i variable (Integer'38)
    func$_stringify$Stringify$if$7$while$top:                    ; top of while
      mov rdi, qword ptr [rsp + 098h]                            ; make a copy of i's value in case it changes before we use it
      mov r12, qword ptr [rsp + 090h]                            ; make a copy of i's type in case it changes before we use it
      mov r13, qword ptr [rsp + 0a8h]                            ; make a copy of old's value in case it changes before we use it
      mov rax, qword ptr [rsp + 0a0h]                            ; make a copy of old's type in case it changes before we use it
      ; increment reference count for copy of old if necessary
      mov r14, rax                                               ; store copy of old's type in testByte value slot
      mov qword ptr [rsp + 088h], rax                            ; move copy of old's type out of rax
      mov rax, r14                                               ; move testByte to testByte
      mov r15, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r15                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov r10, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, r10                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$7$while$AfterGCIncref     ; if not a GarbageCollectable, skip incref
        inc qword ptr [r13]                                      ; increment reference count of copy of old
      func$_stringify$Stringify$if$7$while$AfterGCIncref:        ; after GarbageCollectable incref
      ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
      ; Call len with 1 arguments
      push r13                                                   ; value of argument #1 (copy of old)
      push qword ptr [rsp + 090h]                                ; type of argument #1
      mov qword ptr [rsp + 088h], rdi                            ; move copy of i's value out of rdi
      lea rdi, qword ptr [rsp + 090h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 088h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$len                                              ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      ; sentinel check of copy of i type Integer expecting Integer
      cmp r12, 000h                                              ; compare type of copy of i to <sentinel>
      jne func$_stringify$Stringify$if$7$while$i$TypeMatch       ; skip next block if copy of i is not sentinel
        ; Error handling block for i
        ; Call __error with 1 arguments
        mov qword ptr [rsp + 068h], r12                          ; move copy of i's type out of r12
        mov r12, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r12                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 068h], r13                          ; move copy of old's value out of r13
        lea r13, qword ptr [rsp + 070h]                          ; load address of return value's value
        push r13                                                 ; internal argument 6: pointer to return value slot's value
        lea r13, qword ptr [rsp + 068h]                          ; load address of return value's type
        push r13                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r12, qword ptr [rsp + 068h]                          ; restoring slot (copy of i) to previous scope state for genuine block exit
        mov r13, qword ptr [rsp + 058h]                          ; restoring slot (copy of old) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$7$while$i$TypeMatch:          ; after block
      ; sentinel check of len return value type Integer expecting Integer
      cmp qword ptr [rsp + 070h], 000h                           ; compare type of len return value to <sentinel>
      jne func$_stringify$Stringify$if$7$while$lenOld$TypeMatch  ; skip next block if len return value is not sentinel
        ; Error handling block for len(old)
        ; Call __error with 1 arguments
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rax, qword ptr [rsp + 078h]                          ; load address of return value's value
        push rax                                                 ; internal argument 6: pointer to return value slot's value
        lea rax, qword ptr [rsp + 078h]                          ; load address of return value's type
        push rax                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
      func$_stringify$Stringify$if$7$while$lenOld$TypeMatch:     ; after block
      mov r15, qword ptr [rsp + 080h]                            ; reading second value to compare (<DynamicSlot:Integer'38 ("len return value")>)
      xor r10, r10                                               ; clear < operator result
      cmp qword ptr [rsp + 078h], r15                            ; compare copy of i with len return value
      setl r10b                                                  ; store result in < operator result
      cmp r10, 000h                                              ; compare < operator result to false
      jne func$_stringify$Stringify$if$7$while$body              ; while condition
      ; Decrement reference count for copy of old (static type: WhateverList'4e) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0a8h]                            ; arg #2: copy of old's type
      mov rcx, r13                                               ; arg #1: copy of old's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      jmp func$_stringify$Stringify$if$7$while$bottom            ; break out of while
      func$_stringify$Stringify$if$7$while$body:                 ; start of while
      ; Line 725: append(new, _stringify(old[i]));
      mov rbx, qword ptr [rsp + 0b8h]                            ; make a copy of new's value in case it changes before we use it
      mov rsi, qword ptr [rsp + 0b0h]                            ; make a copy of new's type in case it changes before we use it
      ; increment reference count for copy of new if necessary
      mov rdi, rsi                                               ; store copy of new's type in testByte value slot
      mov rax, rdi                                               ; move testByte to testByte
      mov r12, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r12                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov qword ptr [rsp + 080h], r13                            ; move copy of old's value out of r13
      mov r13, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, r13                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$7$while$AfterGCIncref$1   ; if not a GarbageCollectable, skip incref
        inc qword ptr [rbx]                                      ; increment reference count of copy of new
      func$_stringify$Stringify$if$7$while$AfterGCIncref$1:      ; after GarbageCollectable incref
      mov r14, qword ptr [rsp + 0a8h]                            ; make a copy of old's value in case it changes before we use it
      mov r9, qword ptr [rsp + 0a0h]                             ; make a copy of old's type in case it changes before we use it
      ; increment reference count for copy of old if necessary
      mov r8, r9                                                 ; store copy of old's type in testByte value slot
      mov rax, r8                                                ; move testByte to testByte
      mov rcx, 004h                                              ; read operand of mul (type table width in bytes) 
      mul rcx                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov rdx, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, rdx                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$7$while$AfterGCIncref$2   ; if not a GarbageCollectable, skip incref
        inc qword ptr [r14]                                      ; increment reference count of copy of old
      func$_stringify$Stringify$if$7$while$AfterGCIncref$2:      ; after GarbageCollectable incref
      ; sentinel check of copy of old type WhateverList expecting WhateverReadOnlyList
      cmp r9, 000h                                               ; compare type of copy of old to <sentinel>
      jne func$_stringify$Stringify$if$7$while$old$TypeMatch     ; skip next block if copy of old is not sentinel
        ; Error handling block for old
        ; Call __error with 1 arguments
        mov r15, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r15                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r10, qword ptr [rsp + 088h]                          ; load address of return value's value
        push r10                                                 ; internal argument 6: pointer to return value slot's value
        lea r10, qword ptr [rsp + 088h]                          ; load address of return value's type
        push r10                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov qword ptr [rsp + 0a8h], r9                           ; move copy of old's type out of r9
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r9, qword ptr [rsp + 068h]                           ; restoring slot (copy of old) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$7$while$old$TypeMatch:        ; after block
      mov qword ptr [rsp + 078h], rbx                            ; move copy of new's value out of rbx
      mov rbx, qword ptr [rsp + 098h]                            ; make a copy of i's value in case it changes before we use it
      mov qword ptr [rsp + 070h], rsi                            ; move copy of new's type out of rsi
      mov rsi, qword ptr [rsp + 090h]                            ; make a copy of i's type in case it changes before we use it
      ; sentinel check of copy of i type Integer expecting Integer
      cmp rsi, 000h                                              ; compare type of copy of i to <sentinel>
      jne func$_stringify$Stringify$if$7$while$copyOfI$TypeMatch ; skip next block if copy of i is not sentinel
        ; Error handling block for copy of i
        ; Call __error with 1 arguments
        mov rdi, offset subscriptTypeCheckFailureMessage         ; reading subscriptTypeCheckFailureMessage for push
        push rdi                                                 ; value of argument #1 (subscriptTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r12, qword ptr [rsp + 078h]                          ; load address of return value's value
        push r12                                                 ; internal argument 6: pointer to return value slot's value
        lea r12, qword ptr [rsp + 078h]                          ; load address of return value's type
        push r12                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov qword ptr [rsp + 098h], r9                           ; move copy of old's type out of r9
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r9, qword ptr [rsp + 058h]                           ; restoring slot (copy of old) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$7$while$copyOfI$TypeMatch:    ; after block
      mov r13, qword ptr [r14 + 038h]                            ; list data is the second field in its block
      mov qword ptr [rsp + 068h], r14                            ; move copy of old's value out of r14
      mov r14, qword ptr [r13 + 008h]                            ; read length from the list data block's metadata
      lea rax, qword ptr [r13 + 020h]                            ; compute address of 0th entry in list data block
      cmp rbx, r14                                               ; compare copy of i to length of list
      jge func$_stringify$Stringify$if$7$while$subscript$boundsError ; index out of range (too high)
      cmp rbx, 000h                                              ; compare copy of i to 0 (integer)
      jge func$_stringify$Stringify$if$7$while$subscript$inBounds ; index not out of range (not negative)
      func$_stringify$Stringify$if$7$while$subscript$boundsError:  ; invalid index
        ; Error handling block for subscript bounds error
        ; Call __error with 1 arguments
        mov r15, offset boundsFailureMessage                     ; reading boundsFailureMessage for push
        push r15                                                 ; value of argument #1 (boundsFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r10, qword ptr [rsp + 070h]                          ; load address of return value's value
        push r10                                                 ; internal argument 6: pointer to return value slot's value
        lea r10, qword ptr [rsp + 070h]                          ; load address of return value's type
        push r10                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov qword ptr [rsp + 090h], r9                           ; move copy of old's type out of r9
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 088h], rax                          ; move base address of list's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 048h]                          ; restoring slot (base address of list) to previous scope state for genuine block exit
        mov r9, qword ptr [rsp + 050h]                           ; restoring slot (copy of old) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$7$while$subscript$inBounds:   ; valid index
      mov qword ptr [rsp + 060h], rbx                            ; move copy of i's value out of rbx
      mov rbx, qword ptr [rsp + 060h]                            ; assign value of copy of i to value of index into list * 16
      shl rbx, 004h                                              ; multiply by 8*2
      mov rsi, rax                                               ; assign value of base address of list to value of pointer to copy of old[copy of i]
      add rsi, rbx                                               ; compute address of specified list entry (result in pointer to copy of old[copy of i])
      mov rdi, qword ptr [rsi + 008h]                            ; value of copy of old[copy of i]
      mov r12, qword ptr [rsi]                                   ; type of copy of old[copy of i]
      ; increment reference count for copy of copy of old[copy of i] if necessary
      mov r13, r12                                               ; store copy of copy of old[copy of i]'s type in testByte value slot
      mov rax, r13                                               ; move testByte to testByte
      mov r14, 004h                                              ; read operand of mul (type table width in bytes) 
      mul r14                                                    ; adjust to the relative start of that type's entry in the type table
      add rax, 002h                                              ; adjust to the byte containing the bit to check against (result in testByte)
      mov r15, offset typeTable                                  ; read second operand of + (type table pointer)
      add rax, r15                                               ; finally offset all of that by the start of the type table itself (result in testByte)
      bt qword ptr [rax], 004h                                   ; check that possibly GarbageCollectable value is GarbageCollectable
      jnc func$_stringify$Stringify$if$7$while$AfterGCIncref$3   ; if not a GarbageCollectable, skip incref
        inc qword ptr [rdi]                                      ; increment reference count of copy of copy of old[copy of i]
      func$_stringify$Stringify$if$7$while$AfterGCIncref$3:      ; after GarbageCollectable incref
      cmp r12, 039h                                              ; compare type of copy of copy of old[copy of i] to String
      jne func$_stringify$Stringify$if$7$while$AfterStringIncref ; if not a String, skip incref
        mov r10, qword ptr [rdi]                                 ; dereference string to get to reference count
        cmp r10, 0                                               ; compare string reference count to 0
        jns func$_stringify$Stringify$if$7$while$StringIncref    ; if reference count is negative (constant strings), skip incref
        jmp func$_stringify$Stringify$if$7$while$AfterStringIncref ; skip incref for string constants
        func$_stringify$Stringify$if$7$while$StringIncref:       ; real String
          inc qword ptr [rdi]                                    ; increment reference count of copy of copy of old[copy of i]
      func$_stringify$Stringify$if$7$while$AfterStringIncref:    ; after String incref
      ; sentinel check of _stringify type StringFunction(Anything) expecting AnythingFunction
      ; Call _stringify with 1 arguments
      push rdi                                                   ; value of argument #1 (copy of copy of old[copy of i])
      push r12                                                   ; type of argument #1
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 070h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov qword ptr [rsp + 090h], r9                             ; move copy of old's type out of r9
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$_stringify                                       ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      ; sentinel check of append type NullFunction(WhateverList, Anything) expecting AnythingFunction
      ; Call append with 2 arguments
      push qword ptr [rsp + 060h]                                ; value of argument #2 (_stringify return value)
      push qword ptr [rsp + 060h]                                ; type of argument #2
      push qword ptr [rsp + 088h]                                ; value of argument #1 (copy of new)
      push qword ptr [rsp + 088h]                                ; type of argument #1
      mov qword ptr [rsp + 060h], r12                            ; move copy of copy of old[copy of i]'s type out of r12
      lea r12, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 060h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 002h                                              ; internal argument 1: number of actual arguments
      call func$append                                           ; jump to subroutine
      add rsp, 050h                                              ; release shadow space and arguments (result in stack pointer)
      ; Line 726: i += 1;
      mov r13, qword ptr [rsp + 098h]                            ; make a copy of i's value in case it changes before we use it
      mov rax, qword ptr [rsp + 090h]                            ; make a copy of i's type in case it changes before we use it
      ; sentinel check of copy of i type Integer expecting Integer
      cmp rax, 000h                                              ; compare type of copy of i to <sentinel>
      jne func$_stringify$Stringify$if$7$while$copyOfI$TypeMatch$1 ; skip next block if copy of i is not sentinel
        ; Error handling block for copy of i
        ; Call __error with 1 arguments
        mov r14, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r14                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea r15, qword ptr [rsp + 058h]                          ; load address of return value's value
        push r15                                                 ; internal argument 6: pointer to return value slot's value
        lea r15, qword ptr [rsp + 050h]                          ; load address of return value's type
        push r15                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 070h], rax                          ; move copy of i's type out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 030h]                          ; restoring slot (copy of i) to previous scope state for genuine block exit
      func$_stringify$Stringify$if$7$while$copyOfI$TypeMatch$1:  ; after block
      ; sentinel check of 1 type Integer expecting Integer
      mov rsi, r13                                               ; assign value of copy of i to value of += operator result
      mov qword ptr [rsp + 048h], rdi                            ; move copy of copy of old[copy of i]'s value out of rdi
      mov rdi, 001h                                              ; read second operand of add (1)
      add rsi, rdi                                               ; += operator
      ; sentinel check of += operator result type Integer expecting Integer
      mov qword ptr [rsp + 098h], rsi                            ; store value
      mov qword ptr [rsp + 090h], 038h                           ; store type (Integer'38)
      ; Decrement reference count for _stringify return value (static type: String'39) via decrefMaybeString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 078h]                            ; arg #2: _stringify return value's type
      mov rcx, qword ptr [rsp + 080h]                            ; arg #1: _stringify return value's value
      call decrefMaybeString                                     ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of new (static type: StringList'3d) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 090h]                            ; arg #2: copy of new's type
      mov rcx, qword ptr [rsp + 098h]                            ; arg #1: copy of new's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of copy of old[copy of i] (static type: Whatever) via decrefMaybeGCOrString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 060h]                            ; arg #2: copy of copy of old[copy of i]'s type
      mov rcx, qword ptr [rsp + 068h]                            ; arg #1: copy of copy of old[copy of i]'s value
      call decrefMaybeGCOrString                                 ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of old (static type: WhateverList'4e) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 070h]                            ; arg #2: copy of old's type
      mov rcx, qword ptr [rsp + 088h]                            ; arg #1: copy of old's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      ; Decrement reference count for copy of old (static type: WhateverList'4e) via decrefMaybeGC
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 0a8h]                            ; arg #2: copy of old's type
      mov rcx, qword ptr [rsp + 0a0h]                            ; arg #1: copy of old's value
      call decrefMaybeGC                                         ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      jmp func$_stringify$Stringify$if$7$while$top               ; return to top of while
    func$_stringify$Stringify$if$7$while$bottom:                 ; bottom of while
    ; Line 728: return concat('[', join(new, ', '), ']');
    mov rax, qword ptr concatValue                               ; make a copy of concat's value in case it changes before we use it
    mov r14, qword ptr concatType                                ; make a copy of concat's type in case it changes before we use it
    mov r15, qword ptr [rsp + 0b8h]                              ; make a copy of new's value in case it changes before we use it
    mov r10, qword ptr [rsp + 0b0h]                              ; make a copy of new's type in case it changes before we use it
    ; increment reference count for copy of new if necessary
    mov rbx, r10                                                 ; store copy of new's type in testByte value slot
    mov qword ptr [rsp + 098h], rax                              ; move copy of concat's value out of rax
    mov rax, rbx                                                 ; move testByte to testByte
    mov qword ptr [rsp + 090h], rsi                              ; move += operator result's value out of rsi
    mov rsi, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rsi                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rdi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rdi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_stringify$Stringify$if$7$AfterGCIncref$2           ; if not a GarbageCollectable, skip incref
      inc qword ptr [r15]                                        ; increment reference count of copy of new
    func$_stringify$Stringify$if$7$AfterGCIncref$2:              ; after GarbageCollectable incref
    ; sentinel check of join type StringFunction(StringList, String) expecting AnythingFunction
    ; Call join with 2 arguments
    mov qword ptr [rsp + 038h], r14                              ; move copy of concat's type out of r14
    mov r14, offset string$52                                    ; reading string for push
    push r14                                                     ; value of argument #2 (string)
    push 039h                                                    ; type of argument #2 (String'39)
    push r15                                                     ; value of argument #1 (copy of new)
    push r10                                                     ; type of argument #1
    mov qword ptr [rsp + 048h], r15                              ; move copy of new's value out of r15
    lea r15, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], r10                              ; move copy of new's type out of r10
    call func$join                                               ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
    cmp qword ptr [rsp + 038h], 000h                             ; compare type of copy of concat to <sentinel>
    jne func$_stringify$Stringify$if$7$copyOfConcat$TypeMatch    ; skip next block if copy of concat is not sentinel
      ; Error handling block for copy of concat
      ; Call __error with 1 arguments
      mov r10, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 020h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$7$copyOfConcat$TypeMatch:       ; after block
    ; Call copy of concat with 3 arguments
    mov rax, qword ptr [rsp + 098h]                              ; get copy of concat into register to dereference it
    mov rsi, qword ptr [rax + 028h]                              ; read receiver pointer
    mov rdi, qword ptr [rax + 020h]                              ; read receiver type
    mov r12, offset string$53                                    ; reading string for push
    push r12                                                     ; value of argument #3 (string)
    push 039h                                                    ; type of argument #3 (String'39)
    push qword ptr [rsp + 040h]                                  ; value of argument #2 (join return value)
    push qword ptr [rsp + 038h]                                  ; type of argument #2
    mov r13, offset string$51                                    ; reading string for push
    push r13                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 0c8h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 048h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, rsi                                                  ; internal argument 4: "this" pointer
    mov r8, rdi                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 003h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 068h], rax                              ; move copy of concat's value out of rax
    mov r15, qword ptr [rsp + 068h]                              ; reading copy of concat to dereference it
    call qword ptr [r15 + 038h]                                  ; jump to subroutine
    add rsp, 060h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of concat return value type String expecting String
    cmp qword ptr [rsp + 010h], 000h                             ; compare type of copy of concat return value to <sentinel>
    jne func$_stringify$Stringify$if$7$StringifyReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
      ; Error handling block for _stringify return value
      ; Call __error with 1 arguments
      mov r10, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 048h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 020h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_stringify$Stringify$if$7$StringifyReturnValue$TypeMatch:  ; after block
    mov rax, qword ptr [rsp + 098h]                              ; read second operand of mov (copy of concat return value) for MoveToDerefInstruction
    mov rsi, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [rsi], rax                                     ; _stringify return value
    mov rdi, qword ptr [rsp + 010h]                              ; reading type of copy of concat return value
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r12], rdi                                     ; type of _stringify return value
    ; increment reference count for copy of concat return value if necessary
    cmp rdi, 039h                                                ; compare type of copy of concat return value to String
    jne func$_stringify$Stringify$if$7$AfterStringIncref         ; if not a String, skip incref
      mov r13, qword ptr [rax]                                   ; dereference string to get to reference count
      cmp r13, 0                                                 ; compare string reference count to 0
      jns func$_stringify$Stringify$if$7$StringIncref            ; if reference count is negative (constant strings), skip incref
      jmp func$_stringify$Stringify$if$7$AfterStringIncref       ; skip incref for string constants
      func$_stringify$Stringify$if$7$StringIncref:               ; real String
        inc qword ptr [rax]                                      ; increment reference count of copy of concat return value
    func$_stringify$Stringify$if$7$AfterStringIncref:            ; after String incref
    ; Decrement reference count for copy of new (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 038h]                              ; arg #2: copy of new's type
    mov rcx, qword ptr [rsp + 048h]                              ; arg #1: copy of new's value
    mov qword ptr [rsp + 0b8h], rax                              ; move copy of concat return value's value out of rax
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for join return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 040h]                              ; arg #2: join return value's type
    mov rcx, qword ptr [rsp + 050h]                              ; arg #1: join return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for new variable (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0d0h]                              ; arg #2: new variable's type
    mov rcx, qword ptr [rsp + 0d8h]                              ; arg #1: new variable's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for old variable (static type: WhateverList'4e) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0c0h]                              ; arg #2: old variable's type
    mov rcx, qword ptr [rsp + 0c8h]                              ; arg #1: old variable's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, rdi                                                 ; arg #2: copy of concat return value's type
    mov rcx, qword ptr [rsp + 0b8h]                              ; arg #1: copy of concat return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for _listConstructor return value (static type: WhateverList'4e) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0e8h]                              ; arg #2: _listConstructor return value's type
    mov rcx, qword ptr [rsp + 0108h]                             ; arg #1: _listConstructor return value's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$7:                             ; end of if
  ; Line 730: if (arg is __ListData) { ...
  mov r14, qword ptr [rbp + 038h]                                ; store arg's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that arg is __ListData
  mov rbx, 000h                                                  ; clear is expression result
  setc bl                                                        ; store result in is expression result
  ; sentinel check of is expression result type Boolean expecting Boolean
  cmp rbx, 000h                                                  ; compare is expression result to false
  je func$_stringify$if$continuation$8                           ; arg is __ListData
    ; Line 731: return '<__ListData>';
    ; sentinel check of string type String expecting String
    mov r12, offset string$54                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov r13, qword ptr [rbp + 030h]                              ; get pointer to return value of _stringify into register to dereference it
    mov qword ptr [r13], r12                                     ; _stringify return value
    mov r14, qword ptr [rbp + 028h]                              ; get pointer to return value type of _stringify into register to dereference it
    mov qword ptr [r14], 039h                                    ; type of _stringify return value (String'39)
    jmp func$_stringify$epilog                                   ; return
  func$_stringify$if$continuation$8:                             ; end of if
  ; Line 733: stderr('value cannot be stringified\n');
  mov rax, qword ptr stderrValue                                 ; make a copy of stderr's value in case it changes before we use it
  mov r15, qword ptr stderrType                                  ; make a copy of stderr's type in case it changes before we use it
  ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
  cmp r15, 000h                                                  ; compare type of copy of stderr to <sentinel>
  jne func$_stringify$copyOfStderr$TypeMatch                     ; skip next block if copy of stderr is not sentinel
    ; Error handling block for copy of stderr
    ; Call __error with 1 arguments
    mov r10, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 048h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 020h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 040h], rax                              ; move copy of stderr's value out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 000h]                              ; restoring slot (copy of stderr) to previous scope state for genuine block exit
  func$_stringify$copyOfStderr$TypeMatch:                        ; after block
  ; Call copy of stderr with 1 arguments
  mov rsi, qword ptr [rax + 028h]                                ; read receiver pointer
  mov rdi, qword ptr [rax + 020h]                                ; read receiver type
  mov r12, offset string$55                                      ; reading string for push
  push r12                                                       ; value of argument #1 (string)
  push 039h                                                      ; type of argument #1 (String'39)
  lea r13, qword ptr [rsp + 048h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rsi                                                    ; internal argument 4: "this" pointer
  mov r8, rdi                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 040h], rax                                ; move copy of stderr's value out of rax
  mov r14, qword ptr [rsp + 040h]                                ; reading copy of stderr to dereference it
  call qword ptr [r14 + 038h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 734: exit(1);
  ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
  ; Call exit with 1 arguments
  push 001h                                                      ; value of argument #1 (1)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r10, qword ptr [rsp + 048h]                                ; load address of return value's value
  push r10                                                       ; internal argument 6: pointer to return value slot's value
  lea r10, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r10                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _stringify
  ; type check of null type Null expecting String
  mov rbx, 036h                                                  ; store null's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that _stringify return value is String
  jc func$_stringify$StringifyReturnValue$TypeMatch              ; skip next block if the type matches
    ; Error handling block for _stringify return value
    ; Call __error with 1 arguments
    mov r12, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 048h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 020h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_stringify$StringifyReturnValue$TypeMatch:                ; after block
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of _stringify into register to dereference it
  mov qword ptr [r14], 000h                                      ; _stringify return value
  mov r15, qword ptr [rbp + 028h]                                ; get pointer to return value type of _stringify into register to dereference it
  mov qword ptr [r15], 036h                                      ; type of _stringify return value (Null'36)
  func$_stringify$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0168h                                                 ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _concat
dq func$_concat$annotation
func$_concat:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 0188h                                                 ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 01c8h]                               ; set up frame pointer
  ; Varargs parameter type check; expecting parameters to be Anything
  lea r10, qword ptr [rbp + 038h]                                ; get base address of varargs, where loop will start
  mov rax, rcx                                                   ; assign value of parameter count of _concat to value of pointer to last argument
  mov rbx, 010h                                                  ; read operand of mul (10 (integer)) 
  mul rbx                                                        ; end of loop is the number of arguments times the width of each argument (010h)...
  add rax, r10                                                   ; ...offset from the initial index (result in pointer to last argument)
  func$_concat$varargTypeChecks$Loop:                            ; top of loop
    mov qword ptr [rsp + 0178h], 000h                            ; move pointer to indexth argument's type into a mutable location
    cmp r10, rax                                                 ; compare pointer to indexth argument to pointer to last argument
    je func$_concat$varargTypeChecks$TypesAllMatch               ; we have type-checked all the arguments
    mov rsi, qword ptr [r10]                                     ; load type of indexth argument into indexth argument
    mov rdi, rsi                                                 ; store indexth argument's type in testByte value slot
    mov qword ptr [rsp + 0170h], rax                             ; move pointer to last argument's value out of rax
    mov rax, rdi                                                 ; move testByte to testByte
    mov r12, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r12                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r13, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r13                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 003h                                     ; check that vararg types is Anything
    jc func$_concat$varargTypeChecks$TypeMatch                   ; skip next block if the type matches
      ; Error handling block for vararg types
      ; Call __error with 1 arguments
      mov r14, offset parameterTypeCheckFailureMessage           ; reading parameterTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (parameterTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0178h]                           ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0178h]                           ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 0198h], rcx                           ; move parameter count of _concat's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0190h], r10                           ; move pointer to indexth argument's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0150h]                           ; restoring slot (pointer to indexth argument) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 0158h]                           ; restoring slot (parameter count of _concat) to previous scope state for genuine block exit
    func$_concat$varargTypeChecks$TypeMatch:                     ; after block
    add r10, 010h                                                ; next argument (result in pointer to indexth argument)
    mov rax, qword ptr [rsp + 0170h]                             ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_concat$varargTypeChecks$Loop                       ; return to top of loop
    func$_concat$varargTypeChecks$TypesAllMatch:                 ; after loop
    mov rax, qword ptr [rsp + 0170h]                             ; restoring slot (pointer to last argument) to previous scope state for genuine block exit
  ; Line 738: if (len(arguments) == 0) { ...
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  xor rsi, rsi                                                   ; zero value result of == (testing parameter count of _concat and 0) to put the boolean in
  cmp rcx, 000h                                                  ; values equal?
  sete sil                                                       ; put result in value result of == (testing parameter count of _concat and 0)
  mov rdi, 037h                                                  ; value result of == (testing parameter count of _concat and 0) is a Boolean'37
  xor rax, rax                                                   ; zero type result of == (testing parameter count of _concat and 0) to put the boolean in
  mov r12, 038h                                                  ; reading type of parameter count of _concat for comparison with type of 0
  cmp r12, 038h                                                  ; types equal?
  sete al                                                        ; put result in type result of == (testing parameter count of _concat and 0)
  mov r13, 037h                                                  ; type result of == (testing parameter count of _concat and 0) is a Boolean'37
  mov r14, rsi                                                   ; assign value of value result of == (testing parameter count of _concat and 0) to value of == operator result
  and r14, rax                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp r14, 000h                                                  ; compare == operator result to false
  je func$_concat$if$continuation                                ; len(arguments) == 0
    ; Line 739: return '';
    ; sentinel check of string type String expecting String
    mov rdi, offset string$19                                    ; read second operand of mov (string) for MoveToDerefInstruction
    mov rax, qword ptr [rbp + 030h]                              ; get pointer to return value of _concat into register to dereference it
    mov qword ptr [rax], rdi                                     ; _concat return value
    mov qword ptr [rsp + 0178h], r12                             ; move parameter count of _concat's type out of r12
    mov r12, qword ptr [rbp + 028h]                              ; get pointer to return value type of _concat into register to dereference it
    mov qword ptr [r12], 039h                                    ; type of _concat return value (String'39)
    jmp func$_concat$epilog                                      ; return
  func$_concat$if$continuation:                                  ; end of if
  ; Line 741: if (len(arguments) == 1) { ...
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  xor r15, r15                                                   ; zero value result of == (testing parameter count of _concat and 1) to put the boolean in
  cmp rcx, 001h                                                  ; values equal?
  sete r15b                                                      ; put result in value result of == (testing parameter count of _concat and 1)
  mov r10, 037h                                                  ; value result of == (testing parameter count of _concat and 1) is a Boolean'37
  xor rbx, rbx                                                   ; zero type result of == (testing parameter count of _concat and 1) to put the boolean in
  cmp r12, 038h                                                  ; types equal?
  sete bl                                                        ; put result in type result of == (testing parameter count of _concat and 1)
  mov rsi, 037h                                                  ; type result of == (testing parameter count of _concat and 1) is a Boolean'37
  mov rdi, r15                                                   ; assign value of value result of == (testing parameter count of _concat and 1) to value of == operator result
  and rdi, rbx                                                   ; && type temp and value temp
  ; sentinel check of == operator result type Boolean expecting Boolean
  cmp rdi, 000h                                                  ; compare == operator result to false
  je func$_concat$if$continuation$1                              ; len(arguments) == 1
    ; Line 742: return _stringify(arguments[0]);
    ; sentinel check of arguments type AnythingReadOnlyList expecting WhateverReadOnlyList
    ; sentinel check of 0 type Integer expecting Integer
    lea rbx, qword ptr [rbp + 038h]                              ; base address of varargs
    mov rsi, 000h                                                ; reading first operand of cmp (0) for a conditional jump
    cmp rsi, rcx                                                 ; compare 0 to parameter count of _concat
    jge func$_concat$Concat$if$1$subscript$boundsError           ; index out of range (too high)
    jmp func$_concat$Concat$if$1$subscript$inBounds              ; index not out of range (not negative)
    func$_concat$Concat$if$1$subscript$boundsError:              ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov rdi, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push rdi                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rax, qword ptr [rsp + 0188h]                           ; load address of return value's value
      push rax                                                   ; internal argument 6: pointer to return value slot's value
      lea rax, qword ptr [rsp + 0188h]                           ; load address of return value's type
      push rax                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 01a8h], rcx                           ; move parameter count of _concat's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rcx, qword ptr [rsp + 0168h]                           ; restoring slot (parameter count of _concat) to previous scope state for genuine block exit
    func$_concat$Concat$if$1$subscript$inBounds:                 ; valid index
    mov qword ptr [rsp + 0178h], r12                             ; move parameter count of _concat's type out of r12
    mov r12, 000h                                                ; assign value of 0 to value of index into list * 16
    shl r12, 004h                                                ; multiply by 8*2
    mov r13, rbx                                                 ; assign value of base address of varargs to value of pointer to arguments[0]
    add r13, r12                                                 ; compute address of specified list entry (result in pointer to arguments[0])
    mov r14, qword ptr [r13 + 008h]                              ; value of arguments[0]
    mov r15, qword ptr [r13]                                     ; type of arguments[0]
    ; increment reference count for copy of arguments[0] if necessary
    mov r10, r15                                                 ; store copy of arguments[0]'s type in testByte value slot
    mov rax, r10                                                 ; move testByte to testByte
    mov rbx, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rbx                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rsi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rsi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$Concat$if$1$AfterGCIncref                   ; if not a GarbageCollectable, skip incref
      inc qword ptr [r14]                                        ; increment reference count of copy of arguments[0]
    func$_concat$Concat$if$1$AfterGCIncref:                      ; after GarbageCollectable incref
    cmp r15, 039h                                                ; compare type of copy of arguments[0] to String
    jne func$_concat$Concat$if$1$AfterStringIncref               ; if not a String, skip incref
      mov rdi, qword ptr [r14]                                   ; dereference string to get to reference count
      cmp rdi, 0                                                 ; compare string reference count to 0
      jns func$_concat$Concat$if$1$StringIncref                  ; if reference count is negative (constant strings), skip incref
      jmp func$_concat$Concat$if$1$AfterStringIncref             ; skip incref for string constants
      func$_concat$Concat$if$1$StringIncref:                     ; real String
        inc qword ptr [r14]                                      ; increment reference count of copy of arguments[0]
    func$_concat$Concat$if$1$AfterStringIncref:                  ; after String incref
    ; sentinel check of _stringify type StringFunction(Anything) expecting AnythingFunction
    ; Call _stringify with 1 arguments
    push r14                                                     ; value of argument #1 (copy of arguments[0])
    push r15                                                     ; type of argument #1
    lea r12, qword ptr [rsp + 0180h]                             ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0180h]                             ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov qword ptr [rsp + 01a0h], rcx                             ; move parameter count of _concat's value out of rcx
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$_stringify                                         ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of _stringify return value type String expecting String
    cmp qword ptr [rsp + 0168h], 000h                            ; compare type of _stringify return value to <sentinel>
    jne func$_concat$Concat$if$1$ConcatReturnValue$TypeMatch     ; skip next block if _stringify return value is not sentinel
      ; Error handling block for _concat return value
      ; Call __error with 1 arguments
      mov r13, offset returnValueTypeCheckFailureMessage         ; reading returnValueTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (returnValueTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0160h], r14                           ; move copy of arguments[0]'s value out of r14
      lea r14, qword ptr [rsp + 0168h]                           ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 0160h]                           ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r14, qword ptr [rsp + 0150h]                           ; restoring slot (copy of arguments[0]) to previous scope state for genuine block exit
    func$_concat$Concat$if$1$ConcatReturnValue$TypeMatch:        ; after block
    mov qword ptr [rsp + 0158h], r15                             ; move copy of arguments[0]'s type out of r15
    mov r15, qword ptr [rsp + 0170h]                             ; read second operand of mov (_stringify return value) for MoveToDerefInstruction
    mov r10, qword ptr [rbp + 030h]                              ; get pointer to return value of _concat into register to dereference it
    mov qword ptr [r10], r15                                     ; _concat return value
    mov rax, qword ptr [rsp + 0168h]                             ; reading type of _stringify return value
    mov rbx, qword ptr [rbp + 028h]                              ; get pointer to return value type of _concat into register to dereference it
    mov qword ptr [rbx], rax                                     ; type of _concat return value
    ; increment reference count for _stringify return value if necessary
    cmp rax, 039h                                                ; compare type of _stringify return value to String
    jne func$_concat$Concat$if$1$AfterStringIncref$1             ; if not a String, skip incref
      mov rsi, qword ptr [r15]                                   ; dereference string to get to reference count
      cmp rsi, 0                                                 ; compare string reference count to 0
      jns func$_concat$Concat$if$1$StringIncref$1                ; if reference count is negative (constant strings), skip incref
      jmp func$_concat$Concat$if$1$AfterStringIncref$1           ; skip incref for string constants
      func$_concat$Concat$if$1$StringIncref$1:                   ; real String
        inc qword ptr [r15]                                      ; increment reference count of _stringify return value
    func$_concat$Concat$if$1$AfterStringIncref$1:                ; after String incref
    ; Decrement reference count for copy of arguments[0] (static type: Anything'49) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0178h]                             ; arg #2: copy of arguments[0]'s type
    mov rcx, r14                                                 ; arg #1: copy of arguments[0]'s value
    mov qword ptr [rsp + 0190h], rax                             ; move _stringify return value's type out of rax
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for _stringify return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0190h]                             ; arg #2: _stringify return value's type
    mov rcx, r15                                                 ; arg #1: _stringify return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$epilog                                      ; return
  func$_concat$if$continuation$1:                                ; end of if
  ; Line 744: StringList strings = []:String;
  ; Call _listConstructor with 2 arguments
  push 001h                                                      ; value of argument #2 (1 (integer))
  push 038h                                                      ; type of argument #2 (Integer'38)
  push 03dh                                                      ; value of argument #1 (code of StringList)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rdi, qword ptr [rsp + 0198h]                               ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 0190h]                               ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 01b0h], rcx                               ; move parameter count of _concat's value out of rcx
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$_listConstructor                                     ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  mov qword ptr [rsp + 0150h], r12                               ; move parameter count of _concat's type out of r12
  mov r12, qword ptr [rsp + 0178h]                               ; copy list literal's value over to slot with better static type
  mov r13, qword ptr [rsp + 0168h]                               ; copy list literal's dynamic type over to slot with better static type
  ; sentinel check of list literal type StringList expecting StringList
  cmp r13, 000h                                                  ; compare type of list literal to <sentinel>
  jne func$_concat$listLiteral$TypeMatch                         ; skip next block if list literal is not sentinel
    mov qword ptr [rsp + 0148h], 000h                            ; move strings variable's value into a mutable location
    mov qword ptr [rsp + 0140h], 000h                            ; move strings variable's type into a mutable location
    ; Error handling block for list literal
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 0138h], r14                             ; move copy of arguments[0]'s value out of r14
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 0138h], r15                             ; move _stringify return value's value out of r15
    lea r15, qword ptr [rsp + 0140h]                             ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0138h]                             ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_concat$listLiteral$TypeMatch:                            ; after block
  mov qword ptr [rsp + 0148h], r12                               ; value initialization of variable declaration for strings variable (list literal)
  mov qword ptr [rsp + 0140h], r13                               ; type initialization of variable declaration for strings variable
  ; increment reference count for strings variable if necessary
  mov r10, qword ptr [rsp + 0140h]                               ; store strings variable's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_concat$AfterGCIncref                                 ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 0148h]                             ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of strings variable
    mov qword ptr [rsp + 0148h], rdi                             ; restoring slot (strings variable) to previous scope state for genuine block exit
  func$_concat$AfterGCIncref:                                    ; after GarbageCollectable incref
  ; Line 745: Integer index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0130h], 000h                              ; value initialization of variable declaration for index variable (0)
  mov qword ptr [rsp + 0120h], 038h                              ; type initialization of variable declaration for index variable (Integer'38)
  func$_concat$while$top:                                        ; top of while
    mov r14, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov r15, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$index$TypeMatch                       ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 0128h]                           ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 0128h]                           ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$while$index$TypeMatch:                          ; after block
    ; sentinel check of parameter count of _concat type Integer expecting Integer
    cmp qword ptr [rsp + 0150h], 000h                            ; compare type of parameter count of _concat to <sentinel>
    jne func$_concat$while$lenArguments$TypeMatch                ; skip next block if parameter count of _concat is not sentinel
      ; Error handling block for len(arguments)
      ; Call __error with 1 arguments
      mov rdi, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 0128h]                           ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 0128h]                           ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$while$lenArguments$TypeMatch:                   ; after block
    xor r13, r13                                                 ; clear < operator result
    cmp r14, qword ptr [rsp + 0160h]                             ; compare copy of index with parameter count of _concat
    setl r13b                                                    ; store result in < operator result
    cmp r13, 000h                                                ; compare < operator result to false
    jne func$_concat$while$body                                  ; while condition
    jmp func$_concat$while$bottom                                ; break out of while
    func$_concat$while$body:                                     ; start of while
    ; Line 747: append(strings, _stringify(arguments[index]));
    mov r14, qword ptr [rsp + 0148h]                             ; make a copy of strings's value in case it changes before we use it
    mov r15, qword ptr [rsp + 0140h]                             ; make a copy of strings's type in case it changes before we use it
    ; increment reference count for copy of strings if necessary
    mov r10, r15                                                 ; store copy of strings's type in testByte value slot
    mov rax, r10                                                 ; move testByte to testByte
    mov rbx, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rbx                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rsi, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rsi                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
      inc qword ptr [r14]                                        ; increment reference count of copy of strings
    func$_concat$while$AfterGCIncref:                            ; after GarbageCollectable incref
    ; sentinel check of arguments type AnythingReadOnlyList expecting WhateverReadOnlyList
    mov r13, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov qword ptr [rsp + 0118h], r14                             ; move copy of strings's value out of r14
    mov r14, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch                 ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 0110h], r15                           ; move copy of strings's type out of r15
      mov r15, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0118h]                           ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0118h]                           ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r15, qword ptr [rsp + 0110h]                           ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch:                    ; after block
    lea rax, qword ptr [rbp + 038h]                              ; base address of varargs
    cmp r13, qword ptr [rsp + 0160h]                             ; compare copy of index to parameter count of _concat
    jge func$_concat$while$subscript$boundsError                 ; index out of range (too high)
    cmp r13, 000h                                                ; compare copy of index to 0 (integer)
    jge func$_concat$while$subscript$inBounds                    ; index not out of range (not negative)
    func$_concat$while$subscript$boundsError:                    ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov rbx, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push rbx                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 0120h]                           ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 0120h]                           ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0140h], rax                           ; move base address of varargs's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0100h]                           ; restoring slot (base address of varargs) to previous scope state for genuine block exit
    func$_concat$while$subscript$inBounds:                       ; valid index
    mov rdi, r13                                                 ; assign value of copy of index to value of index into list * 16
    shl rdi, 004h                                                ; multiply by 8*2
    mov r12, rax                                                 ; assign value of base address of varargs to value of pointer to arguments[copy of index]
    add r12, rdi                                                 ; compute address of specified list entry (result in pointer to arguments[copy of index])
    mov r13, qword ptr [r12 + 008h]                              ; value of arguments[copy of index]
    mov r14, qword ptr [r12]                                     ; type of arguments[copy of index]
    ; increment reference count for copy of arguments[copy of index] if necessary
    mov qword ptr [rsp + 0110h], r15                             ; move copy of strings's type out of r15
    mov r15, r14                                                 ; store copy of arguments[copy of index]'s type in testByte value slot
    mov rax, r15                                                 ; move testByte to testByte
    mov r10, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r10                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rbx, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rbx                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref$1                       ; if not a GarbageCollectable, skip incref
      inc qword ptr [r13]                                        ; increment reference count of copy of arguments[copy of index]
    func$_concat$while$AfterGCIncref$1:                          ; after GarbageCollectable incref
    cmp r14, 039h                                                ; compare type of copy of arguments[copy of index] to String
    jne func$_concat$while$AfterStringIncref                     ; if not a String, skip incref
      mov rsi, qword ptr [r13]                                   ; dereference string to get to reference count
      cmp rsi, 0                                                 ; compare string reference count to 0
      jns func$_concat$while$StringIncref                        ; if reference count is negative (constant strings), skip incref
      jmp func$_concat$while$AfterStringIncref                   ; skip incref for string constants
      func$_concat$while$StringIncref:                           ; real String
        inc qword ptr [r13]                                      ; increment reference count of copy of arguments[copy of index]
    func$_concat$while$AfterStringIncref:                        ; after String incref
    ; sentinel check of _stringify type StringFunction(Anything) expecting AnythingFunction
    ; Call _stringify with 1 arguments
    push r13                                                     ; value of argument #1 (copy of arguments[copy of index])
    push r14                                                     ; type of argument #1
    lea rdi, qword ptr [rsp + 0118h]                             ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 0118h]                             ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$_stringify                                         ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of append type NullFunction(WhateverList, Anything) expecting AnythingFunction
    ; Call append with 2 arguments
    push qword ptr [rsp + 0108h]                                 ; value of argument #2 (_stringify return value)
    push qword ptr [rsp + 0108h]                                 ; type of argument #2
    push qword ptr [rsp + 0128h]                                 ; value of argument #1 (copy of strings)
    push qword ptr [rsp + 0128h]                                 ; type of argument #1
    mov qword ptr [rsp + 0110h], r14                             ; move copy of arguments[copy of index]'s type out of r14
    lea r14, qword ptr [rsp + 0118h]                             ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 0110h]                             ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$append                                             ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 748: index += 1;
    mov r15, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov rax, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp rax, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch$1               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 0108h]                           ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 0100h]                           ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0120h], rax                           ; move copy of index's type out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0e0h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch$1:                  ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov r12, r15                                                 ; assign value of copy of index to value of += operator result
    mov qword ptr [rsp + 0f8h], r13                              ; move copy of arguments[copy of index]'s value out of r13
    mov r13, 001h                                                ; read second operand of add (1)
    add r12, r13                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0130h], r12                             ; store value
    mov qword ptr [rsp + 0120h], 038h                            ; store type (Integer'38)
    ; Decrement reference count for _stringify return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0120h]                             ; arg #2: _stringify return value's type
    mov rcx, qword ptr [rsp + 0128h]                             ; arg #1: _stringify return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of arguments[copy of index] (static type: Anything'49) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0110h]                             ; arg #2: copy of arguments[copy of index]'s type
    mov rcx, qword ptr [rsp + 0118h]                             ; arg #1: copy of arguments[copy of index]'s value
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0130h]                             ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 0138h]                             ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$while$top                                   ; return to top of while
  func$_concat$while$bottom:                                     ; bottom of while
  ; Line 750: Integer length = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0160h], 000h                              ; value initialization of variable declaration for length variable (0)
  mov qword ptr [rsp + 0150h], 038h                              ; type initialization of variable declaration for length variable (Integer'38)
  ; Line 751: index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0130h], 000h                              ; store value
  mov qword ptr [rsp + 0120h], 038h                              ; store type (Integer'38)
  func$_concat$while$top$1:                                      ; top of while
    mov rdi, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov qword ptr [rsp + 0e8h], r12                              ; move += operator result's value out of r12
    mov r12, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    mov r13, qword ptr [rsp + 0148h]                             ; make a copy of strings's value in case it changes before we use it
    mov r14, qword ptr [rsp + 0140h]                             ; make a copy of strings's type in case it changes before we use it
    ; increment reference count for copy of strings if necessary
    mov r15, r14                                                 ; store copy of strings's type in testByte value slot
    mov rax, r15                                                 ; move testByte to testByte
    mov r10, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r10                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov rbx, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, rbx                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref$2                       ; if not a GarbageCollectable, skip incref
      inc qword ptr [r13]                                        ; increment reference count of copy of strings
    func$_concat$while$AfterGCIncref$2:                          ; after GarbageCollectable incref
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    push r13                                                     ; value of argument #1 (copy of strings)
    push r14                                                     ; type of argument #1
    mov qword ptr [rsp + 0e8h], rdi                              ; move copy of index's value out of rdi
    lea rdi, qword ptr [rsp + 0f0h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 0e8h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$len                                                ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$index$TypeMatch$1                     ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 0c8h], r12                            ; move copy of index's type out of r12
      mov r12, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r12                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0c8h], r13                            ; move copy of strings's value out of r13
      lea r13, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push r13                                                   ; internal argument 6: pointer to return value slot's value
      lea r13, qword ptr [rsp + 0c8h]                            ; load address of return value's type
      push r13                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r12, qword ptr [rsp + 0c8h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov r13, qword ptr [rsp + 0b8h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$index$TypeMatch$1:                        ; after block
    ; sentinel check of len return value type Integer expecting Integer
    cmp qword ptr [rsp + 0d0h], 000h                             ; compare type of len return value to <sentinel>
    jne func$_concat$while$lenStrings$TypeMatch                  ; skip next block if len return value is not sentinel
      ; Error handling block for len(strings)
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 0c8h], r14                            ; move copy of strings's type out of r14
      mov r14, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r14, qword ptr [rsp + 0c8h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$lenStrings$TypeMatch:                     ; after block
    mov rax, qword ptr [rsp + 0e0h]                              ; reading second value to compare (<DynamicSlot:Integer'38 ("len return value")>)
    xor r10, r10                                                 ; clear < operator result
    cmp qword ptr [rsp + 0d8h], rax                              ; compare copy of index with len return value
    setl r10b                                                    ; store result in < operator result
    cmp r10, 000h                                                ; compare < operator result to false
    jne func$_concat$while$body$1                                ; while condition
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r14                                                 ; arg #2: copy of strings's type
    mov rcx, r13                                                 ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$while$bottom$1                              ; break out of while
    func$_concat$while$body$1:                                   ; start of while
    ; Line 753: length += _stringByteLength(strings[index]);
    mov rbx, qword ptr [rsp + 0160h]                             ; make a copy of length's value in case it changes before we use it
    mov rsi, qword ptr [rsp + 0150h]                             ; make a copy of length's type in case it changes before we use it
    mov rdi, qword ptr [rsp + 0148h]                             ; make a copy of strings's value in case it changes before we use it
    mov r12, qword ptr [rsp + 0140h]                             ; make a copy of strings's type in case it changes before we use it
    ; increment reference count for copy of strings if necessary
    mov qword ptr [rsp + 0e0h], r13                              ; move copy of strings's value out of r13
    mov r13, r12                                                 ; store copy of strings's type in testByte value slot
    mov rax, r13                                                 ; move testByte to testByte
    mov qword ptr [rsp + 0d8h], r14                              ; move copy of strings's type out of r14
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref$3                       ; if not a GarbageCollectable, skip incref
      inc qword ptr [rdi]                                        ; increment reference count of copy of strings
    func$_concat$while$AfterGCIncref$3:                          ; after GarbageCollectable incref
    ; sentinel check of copy of strings type StringList expecting WhateverReadOnlyList
    cmp r12, 000h                                                ; compare type of copy of strings to <sentinel>
    jne func$_concat$while$strings$TypeMatch                     ; skip next block if copy of strings is not sentinel
      ; Error handling block for strings
      ; Call __error with 1 arguments
      mov r9, offset operandTypeCheckFailureMessage              ; reading operandTypeCheckFailureMessage for push
      push r9                                                    ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r8, qword ptr [rsp + 0e0h]                             ; load address of return value's value
      push r8                                                    ; internal argument 6: pointer to return value slot's value
      lea r8, qword ptr [rsp + 0e0h]                             ; load address of return value's type
      push r8                                                    ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$while$strings$TypeMatch:                        ; after block
    mov r10, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov qword ptr [rsp + 0d0h], rbx                              ; move copy of length's value out of rbx
    mov rbx, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp rbx, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch$2               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 0c8h], rsi                            ; move copy of length's type out of rsi
      mov rsi, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push rsi                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0c8h], rdi                            ; move copy of strings's value out of rdi
      lea rdi, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 0c8h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0e8h], r10                            ; move copy of index's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 0a8h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov rsi, qword ptr [rsp + 0c8h]                            ; restoring slot (copy of length) to previous scope state for genuine block exit
      mov rdi, qword ptr [rsp + 0b8h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch$2:                  ; after block
    mov qword ptr [rsp + 0c8h], r12                              ; move copy of strings's type out of r12
    mov r12, qword ptr [rdi + 038h]                              ; list data is the second field in its block
    mov r13, qword ptr [r12 + 008h]                              ; read length from the list data block's metadata
    lea rax, qword ptr [r12 + 020h]                              ; compute address of 0th entry in list data block
    cmp r10, r13                                                 ; compare copy of index to length of list
    jge func$_concat$while$subscript$boundsError$1               ; index out of range (too high)
    cmp r10, 000h                                                ; compare copy of index to 0 (integer)
    jge func$_concat$while$subscript$inBounds$1                  ; index not out of range (not negative)
    func$_concat$while$subscript$boundsError$1:                  ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov r14, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push r14                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 0d0h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0f0h], r10                            ; move copy of index's value out of r10
      mov qword ptr [rsp + 0e8h], rax                            ; move base address of list's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0a8h]                            ; restoring slot (base address of list) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 0b0h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$subscript$inBounds$1:                     ; valid index
    mov qword ptr [rsp + 0c0h], r10                              ; move copy of index's value out of r10
    mov r10, qword ptr [rsp + 0c0h]                              ; assign value of copy of index to value of index into list * 16
    shl r10, 004h                                                ; multiply by 8*2
    mov rbx, rax                                                 ; assign value of base address of list to value of pointer to copy of strings[copy of index]
    add rbx, r10                                                 ; compute address of specified list entry (result in pointer to copy of strings[copy of index])
    mov qword ptr [rsp + 0c0h], rsi                              ; move copy of length's type out of rsi
    mov rsi, qword ptr [rbx + 008h]                              ; value of copy of strings[copy of index]
    mov qword ptr [rsp + 0b8h], rdi                              ; move copy of strings's value out of rdi
    mov rdi, qword ptr [rbx]                                     ; type of copy of strings[copy of index]
    ; increment reference count for copy of copy of strings[copy of index] if necessary
    cmp rdi, 039h                                                ; compare type of copy of copy of strings[copy of index] to String
    jne func$_concat$while$AfterStringIncref$1                   ; if not a String, skip incref
      mov r12, qword ptr [rsi]                                   ; dereference string to get to reference count
      cmp r12, 0                                                 ; compare string reference count to 0
      jns func$_concat$while$StringIncref$1                      ; if reference count is negative (constant strings), skip incref
      jmp func$_concat$while$AfterStringIncref$1                 ; skip incref for string constants
      func$_concat$while$StringIncref$1:                         ; real String
        inc qword ptr [rsi]                                      ; increment reference count of copy of copy of strings[copy of index]
    func$_concat$while$AfterStringIncref$1:                      ; after String incref
    ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
    ; Call _stringByteLength with 1 arguments
    push rsi                                                     ; value of argument #1 (copy of copy of strings[copy of index])
    push rdi                                                     ; type of argument #1
    lea r14, qword ptr [rsp + 0c0h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 0c0h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$_stringByteLength                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of length type Integer expecting Integer
    cmp qword ptr [rsp + 0c0h], 000h                             ; compare type of copy of length to <sentinel>
    jne func$_concat$while$copyOfLength$TypeMatch                ; skip next block if copy of length is not sentinel
      ; Error handling block for copy of length
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0b0h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0b0h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$while$copyOfLength$TypeMatch:                   ; after block
    ; sentinel check of _stringByteLength return value type Integer expecting Integer
    cmp qword ptr [rsp + 0a8h], 000h                             ; compare type of _stringByteLength return value to <sentinel>
    jne func$_concat$while$StringbytelengthReturnValue$TypeMatch ; skip next block if _stringByteLength return value is not sentinel
      ; Error handling block for _stringByteLength return value
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 0a8h], rsi                            ; move copy of copy of strings[copy of index]'s value out of rsi
      lea rsi, qword ptr [rsp + 0b0h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 0a8h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rsi, qword ptr [rsp + 098h]                            ; restoring slot (copy of copy of strings[copy of index]) to previous scope state for genuine block exit
    func$_concat$while$StringbytelengthReturnValue$TypeMatch:    ; after block
    mov qword ptr [rsp + 0a0h], rdi                              ; move copy of copy of strings[copy of index]'s type out of rdi
    mov rdi, qword ptr [rsp + 0d0h]                              ; assign value of copy of length to value of += operator result
    add rdi, qword ptr [rsp + 0b0h]                              ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0160h], rdi                             ; store value
    mov qword ptr [rsp + 0150h], 038h                            ; store type (Integer'38)
    ; Line 754: index += 1;
    mov rax, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov r14, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r14, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch$3               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 0e0h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 0d8h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 0f0h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 0b0h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch$3:                  ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov qword ptr [rsp + 0d0h], rdi                              ; move += operator result's value out of rdi
    mov rdi, rax                                                 ; assign value of copy of index to value of += operator result
    mov r12, 001h                                                ; read second operand of add (1)
    add rdi, r12                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0130h], rdi                             ; store value
    mov qword ptr [rsp + 0120h], 038h                            ; store type (Integer'38)
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0f8h]                              ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 0100h]                             ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of copy of strings[copy of index] (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0c0h]                              ; arg #2: copy of copy of strings[copy of index]'s type
    mov rcx, rsi                                                 ; arg #1: copy of copy of strings[copy of index]'s value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 0e8h]                              ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 0d8h]                              ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$while$top$1                                 ; return to top of while
  func$_concat$while$bottom$1:                                   ; bottom of while
  ; Line 756: assert(length >= 0, 'negative length detected');
  mov r14, qword ptr [rsp + 0160h]                               ; make a copy of length's value in case it changes before we use it
  mov r15, qword ptr [rsp + 0150h]                               ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp r15, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$_concat$length$TypeMatch                              ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 0d0h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 0c8h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_concat$length$TypeMatch:                                 ; after block
  ; sentinel check of 0 type Integer expecting Integer
  xor r12, r12                                                   ; clear >= operator result
  cmp r14, 000h                                                  ; compare copy of length with 0
  setge r12b                                                     ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r14, offset string$20                                      ; reading string for push
  push r14                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r12                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea r15, qword ptr [rsp + 0d0h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 0c0h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 757: if (length >= 2147483648 /* 0x80000000 */) { ...
  mov r10, qword ptr [rsp + 0160h]                               ; make a copy of length's value in case it changes before we use it
  mov rbx, qword ptr [rsp + 0150h]                               ; make a copy of length's type in case it changes before we use it
  ; sentinel check of copy of length type Integer expecting Integer
  cmp rbx, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$_concat$length$TypeMatch$1                            ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov rsi, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rdi, qword ptr [rsp + 0c0h]                              ; load address of return value's value
    push rdi                                                     ; internal argument 6: pointer to return value slot's value
    lea rdi, qword ptr [rsp + 0b0h]                              ; load address of return value's type
    push rdi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0d0h], r10                              ; move copy of length's value out of r10
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r10, qword ptr [rsp + 090h]                              ; restoring slot (copy of length) to previous scope state for genuine block exit
  func$_concat$length$TypeMatch$1:                               ; after block
  ; sentinel check of 2147483648 /* 0x80000000 */ type Integer expecting Integer
  mov rax, 080000000h                                            ; reading second value to compare (<ImmediateIntegerSlot:Integer'38 ("2147483648 /* 0x80000000 */")>)
  xor r14, r14                                                   ; clear >= operator result
  cmp r10, rax                                                   ; compare copy of length with 2147483648 /* 0x80000000 */
  setge r14b                                                     ; store result in >= operator result
  ; sentinel check of >= operator result type Boolean expecting Boolean
  cmp r14, 000h                                                  ; compare >= operator result to false
  je func$_concat$if$continuation$2                              ; length >= 2147483648 /* 0x80000000 */
    ; Line 758: stderr('absurd length detected (as exit code)\n');
    mov rbx, qword ptr stderrValue                               ; make a copy of stderr's value in case it changes before we use it
    mov rsi, qword ptr stderrType                                ; make a copy of stderr's type in case it changes before we use it
    ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
    cmp rsi, 000h                                                ; compare type of copy of stderr to <sentinel>
    jne func$_concat$Concat$if$2$copyOfStderr$TypeMatch          ; skip next block if copy of stderr is not sentinel
      ; Error handling block for copy of stderr
      ; Call __error with 1 arguments
      mov rdi, offset subroutineCallTypeCheckFailureMessage      ; reading subroutineCallTypeCheckFailureMessage for push
      push rdi                                                   ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r12, qword ptr [rsp + 0c0h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 0b0h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$Concat$if$2$copyOfStderr$TypeMatch:             ; after block
    ; Call copy of stderr with 1 arguments
    mov r13, qword ptr [rbx + 028h]                              ; read receiver pointer
    mov rax, qword ptr [rbx + 020h]                              ; read receiver type
    mov r14, offset string$21                                    ; reading string for push
    push r14                                                     ; value of argument #1 (string)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 0c0h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 0b0h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, r13                                                  ; internal argument 4: "this" pointer
    mov r8, rax                                                  ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call qword ptr [rbx + 038h]                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 759: exit(length);
    mov r10, qword ptr [rsp + 0160h]                             ; make a copy of length's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 0150h]                             ; make a copy of length's type in case it changes before we use it
    ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
    ; Call exit with 1 arguments
    push r10                                                     ; value of argument #1 (copy of length)
    push rbx                                                     ; type of argument #1
    lea r12, qword ptr [rsp + 0c0h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 0b0h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$exit                                               ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_concat$if$continuation$2:                                ; end of if
  ; Line 761: Integer resultPointer = _alloc(16 /* 0x10 */ + length);
  mov r13, qword ptr [rsp + 0160h]                               ; make a copy of length's value in case it changes before we use it
  mov rax, qword ptr [rsp + 0150h]                               ; make a copy of length's type in case it changes before we use it
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  ; sentinel check of copy of length type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of length to <sentinel>
  jne func$_concat$length$TypeMatch$2                            ; skip next block if copy of length is not sentinel
    ; Error handling block for length
    ; Call __error with 1 arguments
    mov r10, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rbx, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rbx                                                     ; internal argument 6: pointer to return value slot's value
    lea rbx, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rbx                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0c0h], rax                              ; move copy of length's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 080h]                              ; restoring slot (copy of length) to previous scope state for genuine block exit
  func$_concat$length$TypeMatch$2:                               ; after block
  mov rsi, 010h                                                  ; assign value of 16 /* 0x10 */ to value of + operator result
  add rsi, r13                                                   ; compute (16 /* 0x10 */) + (copy of length) (result in + operator result)
  ; sentinel check of _alloc type IntegerFunction(Integer) expecting AnythingFunction
  ; Call _alloc with 1 arguments
  push rsi                                                       ; value of argument #1 (+ operator result)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r13, qword ptr [rsp + 0a0h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 0a0h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_alloc                                               ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _alloc return value type Integer expecting Integer
  cmp qword ptr [rsp + 088h], 000h                               ; compare type of _alloc return value to <sentinel>
  jne func$_concat$AllocReturnValue$TypeMatch                    ; skip next block if _alloc return value is not sentinel
    ; Error handling block for _alloc return value
    ; Call __error with 1 arguments
    mov rax, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rax                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r14, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 090h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_concat$AllocReturnValue$TypeMatch:                       ; after block
  mov r11, qword ptr [rsp + 090h]                                ; indirect through r11 because operand pair (stack operand #26, stack operand #30) is not allowed with mov
  mov qword ptr [rsp + 0b0h], r11                                ; value initialization of variable declaration for resultPointer variable (_alloc return value)
  mov r11, qword ptr [rsp + 088h]                                ; indirect through r11 because operand pair (stack operand #29, stack operand #31) is not allowed with mov
  mov qword ptr [rsp + 098h], r11                                ; type initialization of variable declaration for resultPointer variable
  ; Line 762: __writeToAddress(resultPointer, 0);
  mov r15, qword ptr [rsp + 0b0h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r10, qword ptr [rsp + 098h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r15], 000h                                      ; __writeToAddress
  ; Line 763: __writeToAddress(resultPointer + 8, length);
  mov rdi, qword ptr [rsp + 0b0h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r12, qword ptr [rsp + 098h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp r12, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_concat$resultpointer$TypeMatch                       ; skip next block if copy of resultPointer is not sentinel
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov r13, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r13                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 0a0h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$_concat$resultpointer$TypeMatch:                          ; after block
  ; sentinel check of 8 type Integer expecting Integer
  mov r10, rdi                                                   ; assign value of copy of resultPointer to value of + operator result
  add r10, 008h                                                  ; compute (copy of resultPointer) + (8) (result in + operator result)
  mov rbx, qword ptr [rsp + 0160h]                               ; make a copy of length's value in case it changes before we use it
  mov rsi, qword ptr [rsp + 0150h]                               ; make a copy of length's type in case it changes before we use it
  ; sentinel check of __writeToAddress type NullFunction(Integer, Integer) expecting AnythingFunction
  ; Call __writeToAddress with 2 arguments
  mov qword ptr [r10], rbx                                       ; __writeToAddress
  ; Line 764: Integer cursor = resultPointer + 16 /* 0x10 */;
  mov r13, qword ptr [rsp + 0b0h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov rax, qword ptr [rsp + 098h]                                ; make a copy of resultPointer's type in case it changes before we use it
  ; sentinel check of copy of resultPointer type Integer expecting Integer
  cmp rax, 000h                                                  ; compare type of copy of resultPointer to <sentinel>
  jne func$_concat$resultpointer$TypeMatch$1                     ; skip next block if copy of resultPointer is not sentinel
    mov qword ptr [rsp + 090h], 000h                             ; move cursor variable's value into a mutable location
    mov qword ptr [rsp + 088h], 000h                             ; move cursor variable's type into a mutable location
    ; Error handling block for resultPointer
    ; Call __error with 1 arguments
    mov r14, offset operandTypeCheckFailureMessage               ; reading operandTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (operandTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 090h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0b0h], rax                              ; move copy of resultPointer's type out of rax
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rax, qword ptr [rsp + 070h]                              ; restoring slot (copy of resultPointer) to previous scope state for genuine block exit
  func$_concat$resultpointer$TypeMatch$1:                        ; after block
  ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
  mov rsi, r13                                                   ; assign value of copy of resultPointer to value of + operator result
  add rsi, 010h                                                  ; compute (copy of resultPointer) + (16 /* 0x10 */) (result in + operator result)
  ; sentinel check of + operator result type Integer expecting Integer
  mov qword ptr [rsp + 090h], rsi                                ; value initialization of variable declaration for cursor variable (+ operator result)
  mov qword ptr [rsp + 088h], 038h                               ; type initialization of variable declaration for cursor variable (Integer'38)
  ; Line 765: index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 0130h], 000h                              ; store value
  mov qword ptr [rsp + 0120h], 038h                              ; store type (Integer'38)
  func$_concat$while$top$2:                                      ; top of while
    mov r14, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov r15, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    mov r10, qword ptr [rsp + 0148h]                             ; make a copy of strings's value in case it changes before we use it
    mov rbx, qword ptr [rsp + 0140h]                             ; make a copy of strings's type in case it changes before we use it
    ; increment reference count for copy of strings if necessary
    mov rsi, rbx                                                 ; store copy of strings's type in testByte value slot
    mov rax, rsi                                                 ; move testByte to testByte
    mov rdi, 004h                                                ; read operand of mul (type table width in bytes) 
    mul rdi                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r12, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r12                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref$4                       ; if not a GarbageCollectable, skip incref
      inc qword ptr [r10]                                        ; increment reference count of copy of strings
    func$_concat$while$AfterGCIncref$4:                          ; after GarbageCollectable incref
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    push r10                                                     ; value of argument #1 (copy of strings)
    push rbx                                                     ; type of argument #1
    mov qword ptr [rsp + 088h], r14                              ; move copy of index's value out of r14
    lea r14, qword ptr [rsp + 090h]                              ; load address of return value's value
    push r14                                                     ; internal argument 6: pointer to return value slot's value
    lea r14, qword ptr [rsp + 088h]                              ; load address of return value's type
    push r14                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 0a8h], r10                              ; move copy of strings's value out of r10
    call func$len                                                ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$index$TypeMatch$2                     ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 060h], r15                            ; move copy of index's type out of r15
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 068h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r15, qword ptr [rsp + 060h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$index$TypeMatch$2:                        ; after block
    ; sentinel check of len return value type Integer expecting Integer
    cmp qword ptr [rsp + 070h], 000h                             ; compare type of len return value to <sentinel>
    jne func$_concat$while$lenStrings$TypeMatch$1                ; skip next block if len return value is not sentinel
      ; Error handling block for len(strings)
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 060h], rbx                            ; move copy of strings's type out of rbx
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 068h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rbx, qword ptr [rsp + 060h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$lenStrings$TypeMatch$1:                   ; after block
    mov rax, qword ptr [rsp + 080h]                              ; reading second value to compare (<DynamicSlot:Integer'38 ("len return value")>)
    xor rdi, rdi                                                 ; clear < operator result
    cmp qword ptr [rsp + 078h], rax                              ; compare copy of index with len return value
    setl dil                                                     ; store result in < operator result
    cmp rdi, 000h                                                ; compare < operator result to false
    jne func$_concat$while$body$2                                ; while condition
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, rbx                                                 ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 088h]                              ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$while$bottom$2                              ; break out of while
    func$_concat$while$body$2:                                   ; start of while
    ; Line 767: String segment = strings[index];
    mov r12, qword ptr [rsp + 0148h]                             ; make a copy of strings's value in case it changes before we use it
    mov r13, qword ptr [rsp + 0140h]                             ; make a copy of strings's type in case it changes before we use it
    ; increment reference count for copy of strings if necessary
    mov r14, r13                                                 ; store copy of strings's type in testByte value slot
    mov rax, r14                                                 ; move testByte to testByte
    mov r15, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r15                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r10, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r10                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_concat$while$AfterGCIncref$5                       ; if not a GarbageCollectable, skip incref
      mov qword ptr [rsp + 080h], 000h                           ; move segment variable's value into a mutable location
      mov qword ptr [rsp + 078h], 000h                           ; move segment variable's type into a mutable location
      inc qword ptr [r12]                                        ; increment reference count of copy of strings
    func$_concat$while$AfterGCIncref$5:                          ; after GarbageCollectable incref
    ; sentinel check of copy of strings type StringList expecting WhateverReadOnlyList
    cmp r13, 000h                                                ; compare type of copy of strings to <sentinel>
    jne func$_concat$while$strings$TypeMatch$1                   ; skip next block if copy of strings is not sentinel
      ; Error handling block for strings
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 070h], rbx                            ; move copy of strings's type out of rbx
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 070h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rbx, qword ptr [rsp + 070h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$strings$TypeMatch$1:                      ; after block
    mov rdi, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov qword ptr [rsp + 070h], r12                              ; move copy of strings's value out of r12
    mov r12, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch$4               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 060h], r13                            ; move copy of strings's type out of r13
      mov r13, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 068h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r13, qword ptr [rsp + 060h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch$4:                  ; after block
    mov rax, qword ptr [rsp + 070h]                              ; get copy of strings into register to dereference it
    mov r15, qword ptr [rax + 038h]                              ; list data is the second field in its block
    mov r10, qword ptr [r15 + 008h]                              ; read length from the list data block's metadata
    mov qword ptr [rsp + 070h], rbx                              ; move copy of strings's type out of rbx
    lea rbx, qword ptr [r15 + 020h]                              ; compute address of 0th entry in list data block
    cmp rdi, r10                                                 ; compare copy of index to length of list
    jge func$_concat$while$subscript$boundsError$2               ; index out of range (too high)
    cmp rdi, 000h                                                ; compare copy of index to 0 (integer)
    jge func$_concat$while$subscript$inBounds$2                  ; index not out of range (not negative)
    func$_concat$while$subscript$boundsError$2:                  ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov rsi, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push rsi                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 068h], rdi                            ; move copy of index's value out of rdi
      lea rdi, qword ptr [rsp + 070h]                            ; load address of return value's value
      push rdi                                                   ; internal argument 6: pointer to return value slot's value
      lea rdi, qword ptr [rsp + 068h]                            ; load address of return value's type
      push rdi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 088h], rax                            ; move copy of strings's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 048h]                            ; restoring slot (copy of strings) to previous scope state for genuine block exit
      mov rdi, qword ptr [rsp + 058h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$subscript$inBounds$2:                     ; valid index
    mov qword ptr [rsp + 060h], r12                              ; move copy of index's type out of r12
    mov r12, rdi                                                 ; assign value of copy of index to value of index into list * 16
    shl r12, 004h                                                ; multiply by 8*2
    mov qword ptr [rsp + 060h], r13                              ; move copy of strings's type out of r13
    mov r13, rbx                                                 ; assign value of base address of list to value of pointer to copy of strings[copy of index]
    add r13, r12                                                 ; compute address of specified list entry (result in pointer to copy of strings[copy of index])
    mov r14, qword ptr [r13 + 008h]                              ; value of copy of strings[copy of index]
    mov qword ptr [rsp + 058h], rax                              ; move copy of strings's value out of rax
    mov rax, qword ptr [r13]                                     ; type of copy of strings[copy of index]
    ; increment reference count for copy of copy of strings[copy of index] if necessary
    cmp rax, 039h                                                ; compare type of copy of copy of strings[copy of index] to String
    jne func$_concat$while$AfterStringIncref$2                   ; if not a String, skip incref
      mov r15, qword ptr [r14]                                   ; dereference string to get to reference count
      cmp r15, 0                                                 ; compare string reference count to 0
      jns func$_concat$while$StringIncref$2                      ; if reference count is negative (constant strings), skip incref
      jmp func$_concat$while$AfterStringIncref$2                 ; skip incref for string constants
      func$_concat$while$StringIncref$2:                         ; real String
        inc qword ptr [r14]                                      ; increment reference count of copy of copy of strings[copy of index]
    func$_concat$while$AfterStringIncref$2:                      ; after String incref
    ; sentinel check of copy of copy of strings[copy of index] type String expecting String
    cmp rax, 000h                                                ; compare type of copy of copy of strings[copy of index] to <sentinel>
    jne func$_concat$while$copyOfCopyOfStringsCopyOfIndex$TypeMatch ; skip next block if copy of copy of strings[copy of index] is not sentinel
      ; Error handling block for copy of copy of strings[copy of index]
      ; Call __error with 1 arguments
      mov r10, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 080h], rax                            ; move copy of copy of strings[copy of index]'s type out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 040h]                            ; restoring slot (copy of copy of strings[copy of index]) to previous scope state for genuine block exit
    func$_concat$while$copyOfCopyOfStringsCopyOfIndex$TypeMatch:  ; after block
    mov qword ptr [rsp + 080h], r14                              ; value initialization of variable declaration for segment variable (copy of copy of strings[copy of index])
    mov qword ptr [rsp + 078h], rax                              ; type initialization of variable declaration for segment variable
    ; increment reference count for segment variable if necessary
    cmp qword ptr [rsp + 078h], 039h                             ; compare type of segment variable to String
    jne func$_concat$while$AfterStringIncref$3                   ; if not a String, skip incref
      mov rsi, qword ptr [rsp + 080h]                            ; get segment variable into register to dereference it
      mov rdi, qword ptr [rsi]                                   ; dereference string to get to reference count
      cmp rdi, 0                                                 ; compare string reference count to 0
      jns func$_concat$while$StringIncref$3                      ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 080h], rsi                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$_concat$while$AfterStringIncref$3                 ; skip incref for string constants
      func$_concat$while$StringIncref$3:                         ; real String
        inc qword ptr [rsi]                                      ; increment reference count of segment variable
      mov qword ptr [rsp + 080h], rsi                            ; restoring slot (segment variable) to previous scope state for genuine block exit
    func$_concat$while$AfterStringIncref$3:                      ; after String incref
    ; Line 768: Integer segmentLength = _stringByteLength(segment);
    mov r12, qword ptr [rsp + 080h]                              ; make a copy of segment's value in case it changes before we use it
    mov r13, qword ptr [rsp + 078h]                              ; make a copy of segment's type in case it changes before we use it
    ; increment reference count for copy of segment if necessary
    cmp r13, 039h                                                ; compare type of copy of segment to String
    jne func$_concat$while$AfterStringIncref$4                   ; if not a String, skip incref
      mov qword ptr [rsp + 050h], 000h                           ; move segmentLength variable's value into a mutable location
      mov qword ptr [rsp + 048h], 000h                           ; move segmentLength variable's type into a mutable location
      mov qword ptr [rsp + 040h], r14                            ; move copy of copy of strings[copy of index]'s value out of r14
      mov r14, qword ptr [r12]                                   ; dereference string to get to reference count
      cmp r14, 0                                                 ; compare string reference count to 0
      jns func$_concat$while$StringIncref$4                      ; if reference count is negative (constant strings), skip incref
      mov r14, qword ptr [rsp + 040h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$_concat$while$AfterStringIncref$4                 ; skip incref for string constants
      func$_concat$while$StringIncref$4:                         ; real String
        inc qword ptr [r12]                                      ; increment reference count of copy of segment
      mov r14, qword ptr [rsp + 040h]                            ; restoring slot (copy of copy of strings[copy of index]) to previous scope state for genuine block exit
    func$_concat$while$AfterStringIncref$4:                      ; after String incref
    ; sentinel check of _stringByteLength type IntegerFunction(String) expecting AnythingFunction
    ; Call _stringByteLength with 1 arguments
    push r12                                                     ; value of argument #1 (copy of segment)
    push r13                                                     ; type of argument #1
    lea r10, qword ptr [rsp + 050h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 050h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 070h], rax                              ; move copy of copy of strings[copy of index]'s type out of rax
    call func$_stringByteLength                                  ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of _stringByteLength return value type Integer expecting Integer
    cmp qword ptr [rsp + 038h], 000h                             ; compare type of _stringByteLength return value to <sentinel>
    jne func$_concat$while$StringbytelengthReturnValue$TypeMatch$1 ; skip next block if _stringByteLength return value is not sentinel
      ; Error handling block for _stringByteLength return value
      ; Call __error with 1 arguments
      mov rbx, offset assignmentTypeCheckFailureMessage          ; reading assignmentTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (assignmentTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 038h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 038h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
    func$_concat$while$StringbytelengthReturnValue$TypeMatch$1:  ; after block
    mov r11, qword ptr [rsp + 040h]                              ; indirect through r11 because operand pair (stack operand #38, stack operand #40) is not allowed with mov
    mov qword ptr [rsp + 050h], r11                              ; value initialization of variable declaration for segmentLength variable (_stringByteLength return value)
    mov r11, qword ptr [rsp + 038h]                              ; indirect through r11 because operand pair (stack operand #39, stack operand #41) is not allowed with mov
    mov qword ptr [rsp + 048h], r11                              ; type initialization of variable declaration for segmentLength variable
    ; Line 769: if (segmentLength > 0) { ...
    mov rdi, qword ptr [rsp + 050h]                              ; make a copy of segmentLength's value in case it changes before we use it
    mov qword ptr [rsp + 040h], r12                              ; move copy of segment's value out of r12
    mov r12, qword ptr [rsp + 048h]                              ; make a copy of segmentLength's type in case it changes before we use it
    ; sentinel check of copy of segmentLength type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of segmentLength to <sentinel>
    jne func$_concat$while$segmentlength$TypeMatch               ; skip next block if copy of segmentLength is not sentinel
      ; Error handling block for segmentLength
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 038h], r13                            ; move copy of segment's type out of r13
      mov r13, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 030h], r14                            ; move copy of copy of strings[copy of index]'s value out of r14
      lea r14, qword ptr [rsp + 038h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 030h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r13, qword ptr [rsp + 038h]                            ; restoring slot (copy of segment) to previous scope state for genuine block exit
      mov r14, qword ptr [rsp + 020h]                            ; restoring slot (copy of copy of strings[copy of index]) to previous scope state for genuine block exit
    func$_concat$while$segmentlength$TypeMatch:                  ; after block
    ; sentinel check of 0 type Integer expecting Integer
    xor r10, r10                                                 ; clear > operator result
    cmp rdi, 000h                                                ; compare copy of segmentLength with 0
    setg r10b                                                    ; store result in > operator result
    ; sentinel check of > operator result type Boolean expecting Boolean
    cmp r10, 000h                                                ; compare > operator result to false
    je func$_concat$while$if$continuation                        ; segmentLength > 0
      ; Line 770: Integer segmentPointer = segment __as__ Integer;
      mov rdi, qword ptr [rsp + 080h]                            ; make a copy of segment's value in case it changes before we use it
      mov r12, qword ptr [rsp + 078h]                            ; make a copy of segment's type in case it changes before we use it
      ; increment reference count for copy of segment if necessary
      cmp r12, 039h                                              ; compare type of copy of segment to String
      jne func$_concat$while$while$if$9$AfterStringIncref        ; if not a String, skip incref
        mov qword ptr [rsp + 038h], 000h                         ; move segmentPointer variable's value into a mutable location
        mov qword ptr [rsp + 028h], 000h                         ; move segmentPointer variable's type into a mutable location
        mov qword ptr [rsp + 020h], r13                          ; move copy of segment's type out of r13
        mov r13, qword ptr [rdi]                                 ; dereference string to get to reference count
        cmp r13, 0                                               ; compare string reference count to 0
        jns func$_concat$while$while$if$9$StringIncref           ; if reference count is negative (constant strings), skip incref
        mov r13, qword ptr [rsp + 020h]                          ; restoring slot (???) to previous scope state for synthetic block exit
        jmp func$_concat$while$while$if$9$AfterStringIncref      ; skip incref for string constants
        func$_concat$while$while$if$9$StringIncref:              ; real String
          inc qword ptr [rdi]                                    ; increment reference count of copy of segment
        mov r13, qword ptr [rsp + 020h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$_concat$while$while$if$9$AfterStringIncref:           ; after String incref
      mov qword ptr [rsp + 020h], r14                            ; move copy of copy of strings[copy of index]'s value out of r14
      mov r14, rdi                                               ; force cast of copy of segment to Integer
      ; sentinel check of force cast of copy of segment to Integer type Integer expecting Integer
      mov qword ptr [rsp + 038h], r14                            ; value initialization of variable declaration for segmentPointer variable (force cast of copy of segment to Integer)
      mov qword ptr [rsp + 028h], 038h                           ; type initialization of variable declaration for segmentPointer variable (Integer'38)
      ; Line 771: _moveBytes(segmentPointer + 16 /* 0x10 */, cursor, segmentLength...
      mov r10, qword ptr [rsp + 038h]                            ; make a copy of segmentPointer's value in case it changes before we use it
      mov rbx, qword ptr [rsp + 028h]                            ; make a copy of segmentPointer's type in case it changes before we use it
      ; sentinel check of copy of segmentPointer type Integer expecting Integer
      cmp rbx, 000h                                              ; compare type of copy of segmentPointer to <sentinel>
      jne func$_concat$while$while$if$9$segmentpointer$TypeMatch ; skip next block if copy of segmentPointer is not sentinel
        ; Error handling block for segmentPointer
        ; Call __error with 1 arguments
        mov rsi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 038h], rdi                          ; move copy of segment's value out of rdi
        lea rdi, qword ptr [rsp + 048h]                          ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 030h]                          ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 050h], r10                          ; move copy of segmentPointer's value out of r10
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov r10, qword ptr [rsp + 010h]                          ; restoring slot (copy of segmentPointer) to previous scope state for genuine block exit
        mov rdi, qword ptr [rsp + 028h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$_concat$while$while$if$9$segmentpointer$TypeMatch:    ; after block
      ; sentinel check of 16 /* 0x10 */ type Integer expecting Integer
      mov r14, r10                                               ; assign value of copy of segmentPointer to value of + operator result
      add r14, 010h                                              ; compute (copy of segmentPointer) + (16 /* 0x10 */) (result in + operator result)
      mov rax, qword ptr [rsp + 090h]                            ; make a copy of cursor's value in case it changes before we use it
      mov r15, qword ptr [rsp + 088h]                            ; make a copy of cursor's type in case it changes before we use it
      mov r10, qword ptr [rsp + 050h]                            ; make a copy of segmentLength's value in case it changes before we use it
      mov rbx, qword ptr [rsp + 048h]                            ; make a copy of segmentLength's type in case it changes before we use it
      ; sentinel check of _moveBytes type NullFunction(Integer, Integer, Integer) expecting AnythingFunction
      ; Call _moveBytes with 3 arguments
      push r10                                                   ; value of argument #3 (copy of segmentLength)
      push rbx                                                   ; type of argument #3
      push rax                                                   ; value of argument #2 (copy of cursor)
      push r15                                                   ; type of argument #2
      push r14                                                   ; value of argument #1 (+ operator result)
      push 038h                                                  ; type of argument #1 (Integer'38)
      mov qword ptr [rsp + 058h], r12                            ; move copy of segment's type out of r12
      lea r12, qword ptr [rsp + 068h]                            ; load address of return value's value
      push r12                                                   ; internal argument 6: pointer to return value slot's value
      lea r12, qword ptr [rsp + 050h]                            ; load address of return value's type
      push r12                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 003h                                              ; internal argument 1: number of actual arguments
      call func$_moveBytes                                       ; jump to subroutine
      add rsp, 060h                                              ; release shadow space and arguments (result in stack pointer)
      ; Line 772: cursor += segmentLength;
      mov qword ptr [rsp + 038h], r13                            ; move copy of segment's type out of r13
      mov r13, qword ptr [rsp + 090h]                            ; make a copy of cursor's value in case it changes before we use it
      mov r14, qword ptr [rsp + 088h]                            ; make a copy of cursor's type in case it changes before we use it
      mov rax, qword ptr [rsp + 050h]                            ; make a copy of segmentLength's value in case it changes before we use it
      mov r15, qword ptr [rsp + 048h]                            ; make a copy of segmentLength's type in case it changes before we use it
      ; sentinel check of copy of cursor type Integer expecting Integer
      cmp r14, 000h                                              ; compare type of copy of cursor to <sentinel>
      jne func$_concat$while$while$if$9$copyOfCursor$TypeMatch   ; skip next block if copy of cursor is not sentinel
        ; Error handling block for copy of cursor
        ; Call __error with 1 arguments
        mov r10, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push r10                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        lea rbx, qword ptr [rsp + 028h]                          ; load address of return value's value
        push rbx                                                 ; internal argument 6: pointer to return value slot's value
        lea rbx, qword ptr [rsp + 028h]                          ; load address of return value's type
        push rbx                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 048h], rax                          ; move copy of segmentLength's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 008h]                          ; restoring slot (copy of segmentLength) to previous scope state for genuine block exit
      func$_concat$while$while$if$9$copyOfCursor$TypeMatch:      ; after block
      ; sentinel check of copy of segmentLength type Integer expecting Integer
      cmp r15, 000h                                              ; compare type of copy of segmentLength to <sentinel>
      jne func$_concat$while$while$if$9$copyOfSegmentlength$TypeMatch ; skip next block if copy of segmentLength is not sentinel
        ; Error handling block for copy of segmentLength
        ; Call __error with 1 arguments
        mov rsi, offset operandTypeCheckFailureMessage           ; reading operandTypeCheckFailureMessage for push
        push rsi                                                 ; value of argument #1 (operandTypeCheckFailureMessage)
        push 039h                                                ; type of argument #1 (String'39)
        mov qword ptr [rsp + 020h], rdi                          ; move copy of segment's value out of rdi
        lea rdi, qword ptr [rsp + 028h]                          ; load address of return value's value
        push rdi                                                 ; internal argument 6: pointer to return value slot's value
        lea rdi, qword ptr [rsp + 020h]                          ; load address of return value's type
        push rdi                                                 ; internal argument 5: pointer to return value slot's type
        sub rsp, 020h                                            ; allocate shadow space
        mov r9, 000h                                             ; internal argument 4: "this" pointer
        mov r8, 000h                                             ; internal argument 3: "this" pointer type
        mov rdx, 000h                                            ; internal argument 2: closure pointer
        mov rcx, 001h                                            ; internal argument 1: number of actual arguments
        mov qword ptr [rsp + 040h], rax                          ; move copy of segmentLength's value out of rax
        call func$__error                                        ; jump to subroutine
        add rsp, 040h                                            ; release shadow space and arguments (result in stack pointer)
        mov rax, qword ptr [rsp + 000h]                          ; restoring slot (copy of segmentLength) to previous scope state for genuine block exit
        mov rdi, qword ptr [rsp + 010h]                          ; restoring slot (copy of segment) to previous scope state for genuine block exit
      func$_concat$while$while$if$9$copyOfSegmentlength$TypeMatch:  ; after block
      mov r12, r13                                               ; assign value of copy of cursor to value of += operator result
      add r12, rax                                               ; += operator
      ; sentinel check of += operator result type Integer expecting Integer
      mov qword ptr [rsp + 090h], r12                            ; store value
      mov qword ptr [rsp + 088h], 038h                           ; store type (Integer'38)
      ; Decrement reference count for copy of segment (static type: String'39) via decrefMaybeString
      sub rsp, 20h                                               ; allocate shadow space for decref function
      mov rdx, qword ptr [rsp + 048h]                            ; arg #2: copy of segment's type
      mov rcx, rdi                                               ; arg #1: copy of segment's value
      call decrefMaybeString                                     ; call decref
      add rsp, 20h                                               ; free shadow space for decref
      mov r13, qword ptr [rsp + 038h]                            ; restoring slot (copy of segment) to previous scope state for genuine block exit
      mov r14, qword ptr [rsp + 020h]                            ; restoring slot (copy of copy of strings[copy of index]) to previous scope state for genuine block exit
    func$_concat$while$if$continuation:                          ; end of if
    ; Line 774: index += 1;
    mov rax, qword ptr [rsp + 0130h]                             ; make a copy of index's value in case it changes before we use it
    mov r15, qword ptr [rsp + 0120h]                             ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r15, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_concat$while$copyOfIndex$TypeMatch$5               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r10, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r10                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 060h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 078h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 038h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_concat$while$copyOfIndex$TypeMatch$5:                  ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov qword ptr [rsp + 050h], r12                              ; move += operator result's value out of r12
    mov r12, rax                                                 ; assign value of copy of index to value of += operator result
    mov qword ptr [rsp + 038h], r13                              ; move copy of segment's type out of r13
    mov r13, 001h                                                ; read second operand of add (1)
    add r12, r13                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 0130h], r12                             ; store value
    mov qword ptr [rsp + 0120h], 038h                            ; store type (Integer'38)
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 090h]                              ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 088h]                              ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of segment (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 058h]                              ; arg #2: copy of segment's type
    mov rcx, qword ptr [rsp + 060h]                              ; arg #1: copy of segment's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of copy of strings[copy of index] (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 050h]                              ; arg #2: copy of copy of strings[copy of index]'s type
    mov rcx, r14                                                 ; arg #1: copy of copy of strings[copy of index]'s value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for segment variable (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 098h]                              ; arg #2: segment variable's type
    mov rcx, qword ptr [rsp + 0a0h]                              ; arg #1: segment variable's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of strings (static type: StringList'3d) via decrefMaybeGC
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 080h]                              ; arg #2: copy of strings's type
    mov rcx, qword ptr [rsp + 078h]                              ; arg #1: copy of strings's value
    call decrefMaybeGC                                           ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    jmp func$_concat$while$top$2                                 ; return to top of while
  func$_concat$while$bottom$2:                                   ; bottom of while
  ; Line 776: return resultPointer __as__ String;
  mov r15, qword ptr [rsp + 0b0h]                                ; make a copy of resultPointer's value in case it changes before we use it
  mov r10, qword ptr [rsp + 098h]                                ; make a copy of resultPointer's type in case it changes before we use it
  mov rbx, r15                                                   ; force cast of copy of resultPointer to String
  ; sentinel check of force cast of copy of resultPointer to String type String expecting String
  mov qword ptr [rsp + 020h], r12                                ; move += operator result's value out of r12
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of _concat into register to dereference it
  mov qword ptr [r12], rbx                                       ; _concat return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of _concat into register to dereference it
  mov qword ptr [r13], 039h                                      ; type of _concat return value (String'39)
  ; increment reference count for force cast of copy of resultPointer to String if necessary
    mov qword ptr [rsp + 018h], r14                              ; move copy of copy of strings[copy of index]'s value out of r14
    mov r14, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp r14, 0                                                   ; compare string reference count to 0
    jns func$_concat$StringIncref                                ; if reference count is negative (constant strings), skip incref
    jmp func$_concat$AfterStringIncref                           ; skip incref for string constants
    func$_concat$StringIncref:                                   ; real String
      inc qword ptr [rbx]                                        ; increment reference count of force cast of copy of resultPointer to String
  func$_concat$AfterStringIncref:                                ; after String incref
  ; Decrement reference count for strings variable (static type: StringList'3d) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0160h]                               ; arg #2: strings variable's type
  mov rcx, qword ptr [rsp + 0168h]                               ; arg #1: strings variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for _listConstructor return value (static type: WhateverList'4e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 0188h]                               ; arg #2: _listConstructor return value's type
  mov rcx, qword ptr [rsp + 0198h]                               ; arg #1: _listConstructor return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  func$_concat$epilog: 
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 0188h                                                 ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; println
dq func$println$annotation
func$println:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 068h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0a8h]                                ; set up frame pointer
  ; Varargs parameter type check; expecting parameters to be Anything
  lea r10, qword ptr [rbp + 038h]                                ; get base address of varargs, where loop will start
  mov rax, rcx                                                   ; assign value of parameter count of println to value of pointer to last argument
  mov rbx, 010h                                                  ; read operand of mul (10 (integer)) 
  mul rbx                                                        ; end of loop is the number of arguments times the width of each argument (010h)...
  add rax, r10                                                   ; ...offset from the initial index (result in pointer to last argument)
  func$println$varargTypeChecks$Loop:                            ; top of loop
    mov qword ptr [rsp + 058h], 000h                             ; move pointer to indexth argument's type into a mutable location
    cmp r10, rax                                                 ; compare pointer to indexth argument to pointer to last argument
    je func$println$varargTypeChecks$TypesAllMatch               ; we have type-checked all the arguments
    mov rsi, qword ptr [r10]                                     ; load type of indexth argument into indexth argument
    mov rdi, rsi                                                 ; store indexth argument's type in testByte value slot
    mov qword ptr [rsp + 050h], rax                              ; move pointer to last argument's value out of rax
    mov rax, rdi                                                 ; move testByte to testByte
    mov r12, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r12                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r13, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r13                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 003h                                     ; check that vararg types is Anything
    jc func$println$varargTypeChecks$TypeMatch                   ; skip next block if the type matches
      ; Error handling block for vararg types
      ; Call __error with 1 arguments
      mov r14, offset parameterTypeCheckFailureMessage           ; reading parameterTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (parameterTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 078h], rcx                            ; move parameter count of println's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move pointer to indexth argument's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (pointer to indexth argument) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 038h]                            ; restoring slot (parameter count of println) to previous scope state for genuine block exit
    func$println$varargTypeChecks$TypeMatch:                     ; after block
    add r10, 010h                                                ; next argument (result in pointer to indexth argument)
    mov rax, qword ptr [rsp + 050h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$println$varargTypeChecks$Loop                       ; return to top of loop
    func$println$varargTypeChecks$TypesAllMatch:                 ; after loop
    mov rax, qword ptr [rsp + 050h]                              ; restoring slot (pointer to last argument) to previous scope state for genuine block exit
  ; Line 794: Boolean first = true;
  ; sentinel check of true type Boolean expecting Boolean
  mov qword ptr [rsp + 058h], 001h                               ; value initialization of variable declaration for first variable (true)
  mov qword ptr [rsp + 050h], 037h                               ; type initialization of variable declaration for first variable (Boolean'37)
  ; Line 795: Integer index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 048h], 000h                               ; value initialization of variable declaration for index variable (0)
  mov qword ptr [rsp + 040h], 038h                               ; type initialization of variable declaration for index variable (Integer'38)
  func$println$while$top:                                        ; top of while
    mov rax, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r12, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$println$while$index$TypeMatch                       ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 068h], rcx                            ; move parameter count of println's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 020h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of println) to previous scope state for genuine block exit
    func$println$while$index$TypeMatch:                          ; after block
    ; sentinel check of parameter count of println type Integer expecting Integer
    xor rdi, rdi                                                 ; clear < operator result
    cmp rax, rcx                                                 ; compare copy of index with parameter count of println
    setl dil                                                     ; store result in < operator result
    cmp rdi, 000h                                                ; compare < operator result to false
    jne func$println$while$body                                  ; while condition
    jmp func$println$while$bottom                                ; break out of while
    func$println$while$body:                                     ; start of while
    ; Line 797: if (first == false) { ...
    mov rax, qword ptr [rsp + 058h]                              ; make a copy of first's value in case it changes before we use it
    mov r12, qword ptr [rsp + 050h]                              ; make a copy of first's type in case it changes before we use it
    xor r13, r13                                                 ; zero value result of == (testing copy of first and false) to put the boolean in
    cmp rax, 000h                                                ; values equal?
    sete r13b                                                    ; put result in value result of == (testing copy of first and false)
    mov r14, 037h                                                ; value result of == (testing copy of first and false) is a Boolean'37
    xor r15, r15                                                 ; zero type result of == (testing copy of first and false) to put the boolean in
    cmp r12, 037h                                                ; types equal?
    sete r15b                                                    ; put result in type result of == (testing copy of first and false)
    mov r10, 037h                                                ; type result of == (testing copy of first and false) is a Boolean'37
    mov rbx, r13                                                 ; assign value of value result of == (testing copy of first and false) to value of == operator result
    and rbx, r15                                                 ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp rbx, 000h                                                ; compare == operator result to false
    je func$println$while$if$continuation                        ; first == false
      ; Line 798: __writeToHandle(__STD_OUTPUT_HANDLE, ' ');
      mov rdi, qword ptr __STD_OUTPUT_HANDLEValue                ; make a copy of __STD_OUTPUT_HANDLE's value in case it changes before we use it
      mov rax, qword ptr __STD_OUTPUT_HANDLEType                 ; make a copy of __STD_OUTPUT_HANDLE's type in case it changes before we use it
      ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
      ; Call __writeToHandle with 2 arguments
      mov r14, offset string$56                                  ; reading string for push
      push r14                                                   ; value of argument #2 (string)
      push 039h                                                  ; type of argument #2 (String'39)
      push rdi                                                   ; value of argument #1 (copy of __STD_OUTPUT_HANDLE)
      push rax                                                   ; type of argument #1
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 078h], rcx                            ; move parameter count of println's value out of rcx
      mov rcx, 002h                                              ; internal argument 1: number of actual arguments
      call func$__writeToHandle                                  ; jump to subroutine
      add rsp, 050h                                              ; release shadow space and arguments (result in stack pointer)
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of println) to previous scope state for genuine block exit
    func$println$while$if$continuation:                          ; end of if
    ; Line 800: __writeToHandle(__STD_OUTPUT_HANDLE, _stringify(parts[index]));
    mov r10, qword ptr __STD_OUTPUT_HANDLEValue                  ; make a copy of __STD_OUTPUT_HANDLE's value in case it changes before we use it
    mov rbx, qword ptr __STD_OUTPUT_HANDLEType                   ; make a copy of __STD_OUTPUT_HANDLE's type in case it changes before we use it
    ; sentinel check of parts type AnythingReadOnlyList expecting WhateverReadOnlyList
    mov rax, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r12, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$println$while$copyOfIndex$TypeMatch                 ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r13, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 068h], rcx                            ; move parameter count of println's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], r10                            ; move copy of __STD_OUTPUT_HANDLE's value out of r10
      mov qword ptr [rsp + 058h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 018h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 020h]                            ; restoring slot (copy of __STD_OUTPUT_HANDLE) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of println) to previous scope state for genuine block exit
    func$println$while$copyOfIndex$TypeMatch:                    ; after block
    lea r15, qword ptr [rbp + 038h]                              ; base address of varargs
    cmp rax, rcx                                                 ; compare copy of index to parameter count of println
    jge func$println$while$subscript$boundsError                 ; index out of range (too high)
    cmp rax, 000h                                                ; compare copy of index to 0 (integer)
    jge func$println$while$subscript$inBounds                    ; index not out of range (not negative)
    func$println$while$subscript$boundsError:                    ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 038h], r10                            ; move copy of __STD_OUTPUT_HANDLE's value out of r10
      mov r10, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push r10                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 038h], rbx                            ; move copy of __STD_OUTPUT_HANDLE's type out of rbx
      lea rbx, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 038h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 058h], rcx                            ; move parameter count of println's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 050h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 010h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov rbx, qword ptr [rsp + 028h]                            ; restoring slot (copy of __STD_OUTPUT_HANDLE) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 018h]                            ; restoring slot (parameter count of println) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 038h]                            ; restoring slot (copy of __STD_OUTPUT_HANDLE) to previous scope state for genuine block exit
    func$println$while$subscript$inBounds:                       ; valid index
    mov rsi, rax                                                 ; assign value of copy of index to value of index into list * 16
    shl rsi, 004h                                                ; multiply by 8*2
    mov rdi, r15                                                 ; assign value of base address of varargs to value of pointer to parts[copy of index]
    add rdi, rsi                                                 ; compute address of specified list entry (result in pointer to parts[copy of index])
    mov rax, qword ptr [rdi + 008h]                              ; value of parts[copy of index]
    mov r12, qword ptr [rdi]                                     ; type of parts[copy of index]
    ; increment reference count for copy of parts[copy of index] if necessary
    mov r13, r12                                                 ; store copy of parts[copy of index]'s type in testByte value slot
    mov qword ptr [rsp + 038h], rax                              ; move copy of parts[copy of index]'s value out of rax
    mov rax, r13                                                 ; move testByte to testByte
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$println$while$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
      mov qword ptr [rsp + 030h], r10                            ; move copy of __STD_OUTPUT_HANDLE's value out of r10
      mov r10, qword ptr [rsp + 038h]                            ; read slot into register for dereferencing
      inc qword ptr [r10]                                        ; increment reference count of copy of parts[copy of index]
      mov qword ptr [rsp + 038h], r10                            ; restoring slot (copy of parts[copy of index]) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of __STD_OUTPUT_HANDLE) to previous scope state for genuine block exit
    func$println$while$AfterGCIncref:                            ; after GarbageCollectable incref
    cmp r12, 039h                                                ; compare type of copy of parts[copy of index] to String
    jne func$println$while$AfterStringIncref                     ; if not a String, skip incref
      mov qword ptr [rsp + 030h], rbx                            ; move copy of __STD_OUTPUT_HANDLE's type out of rbx
      mov rbx, qword ptr [rsp + 038h]                            ; get copy of parts[copy of index] into register to dereference it
      mov r9, qword ptr [rbx]                                    ; dereference string to get to reference count
      cmp r9, 0                                                  ; compare string reference count to 0
      jns func$println$while$StringIncref                        ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 038h], rbx                            ; restoring slot (???) to previous scope state for synthetic block exit
      mov rbx, qword ptr [rsp + 030h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$println$while$AfterStringIncref                   ; skip incref for string constants
      func$println$while$StringIncref:                           ; real String
        inc qword ptr [rbx]                                      ; increment reference count of copy of parts[copy of index]
      mov qword ptr [rsp + 038h], rbx                            ; restoring slot (copy of parts[copy of index]) to previous scope state for genuine block exit
      mov rbx, qword ptr [rsp + 030h]                            ; restoring slot (copy of __STD_OUTPUT_HANDLE) to previous scope state for genuine block exit
    func$println$while$AfterStringIncref:                        ; after String incref
    ; sentinel check of _stringify type StringFunction(Anything) expecting AnythingFunction
    ; Call _stringify with 1 arguments
    push qword ptr [rsp + 038h]                                  ; value of argument #1 (copy of parts[copy of index])
    push r12                                                     ; type of argument #1
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov qword ptr [rsp + 060h], rcx                              ; move parameter count of println's value out of rcx
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of __STD_OUTPUT_HANDLE's value out of r10
    call func$_stringify                                         ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
    ; Call __writeToHandle with 2 arguments
    push qword ptr [rsp + 030h]                                  ; value of argument #2 (_stringify return value)
    push qword ptr [rsp + 030h]                                  ; type of argument #2
    push qword ptr [rsp + 028h]                                  ; value of argument #1 (copy of __STD_OUTPUT_HANDLE)
    push rbx                                                     ; type of argument #1
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$__writeToHandle                                    ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 801: first = false;
    ; sentinel check of false type Boolean expecting Boolean
    mov qword ptr [rsp + 058h], 000h                             ; store value
    mov qword ptr [rsp + 050h], 037h                             ; store type (Boolean'37)
    ; Line 802: index += 1;
    mov r15, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r10, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$println$while$copyOfIndex$TypeMatch$1               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], r10                            ; move copy of index's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 008h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$println$while$copyOfIndex$TypeMatch$1:                  ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov r13, r15                                                 ; assign value of copy of index to value of += operator result
    mov rax, 001h                                                ; read second operand of add (1)
    add r13, rax                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 048h], r13                              ; store value
    mov qword ptr [rsp + 040h], 038h                             ; store type (Integer'38)
    ; Decrement reference count for copy of parts[copy of index] (static type: Anything'49) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r12                                                 ; arg #2: copy of parts[copy of index]'s type
    mov rcx, qword ptr [rsp + 058h]                              ; arg #1: copy of parts[copy of index]'s value
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for _stringify return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 048h]                              ; arg #2: _stringify return value's type
    mov rcx, qword ptr [rsp + 050h]                              ; arg #1: _stringify return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    mov rcx, qword ptr [rsp + 020h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$println$while$top                                   ; return to top of while
  func$println$while$bottom:                                     ; bottom of while
  ; Line 804: __writeToHandle(__STD_OUTPUT_HANDLE, '\n');
  mov r10, qword ptr __STD_OUTPUT_HANDLEValue                    ; make a copy of __STD_OUTPUT_HANDLE's value in case it changes before we use it
  mov rbx, qword ptr __STD_OUTPUT_HANDLEType                     ; make a copy of __STD_OUTPUT_HANDLE's type in case it changes before we use it
  ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
  ; Call __writeToHandle with 2 arguments
  mov qword ptr [rsp + 058h], r12                                ; move copy of parts[copy of index]'s type out of r12
  mov r12, offset string$57                                      ; reading string for push
  push r12                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r10                                                       ; value of argument #1 (copy of __STD_OUTPUT_HANDLE)
  push rbx                                                       ; type of argument #1
  mov qword ptr [rsp + 068h], r13                                ; move += operator result's value out of r13
  lea r13, qword ptr [rsp + 070h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 068h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$__writeToHandle                                      ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from println
  ; sentinel check of null type Null expecting Null
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of println into register to dereference it
  mov qword ptr [r15], 000h                                      ; println return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of println into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of println return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 068h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _stderr
dq func$_stderr$annotation
func$_stderr:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 068h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 0a8h]                                ; set up frame pointer
  ; Varargs parameter type check; expecting parameters to be Anything
  lea r10, qword ptr [rbp + 038h]                                ; get base address of varargs, where loop will start
  mov rax, rcx                                                   ; assign value of parameter count of _stderr to value of pointer to last argument
  mov rbx, 010h                                                  ; read operand of mul (10 (integer)) 
  mul rbx                                                        ; end of loop is the number of arguments times the width of each argument (010h)...
  add rax, r10                                                   ; ...offset from the initial index (result in pointer to last argument)
  func$_stderr$varargTypeChecks$Loop:                            ; top of loop
    mov qword ptr [rsp + 058h], 000h                             ; move pointer to indexth argument's type into a mutable location
    cmp r10, rax                                                 ; compare pointer to indexth argument to pointer to last argument
    je func$_stderr$varargTypeChecks$TypesAllMatch               ; we have type-checked all the arguments
    mov rsi, qword ptr [r10]                                     ; load type of indexth argument into indexth argument
    mov rdi, rsi                                                 ; store indexth argument's type in testByte value slot
    mov qword ptr [rsp + 050h], rax                              ; move pointer to last argument's value out of rax
    mov rax, rdi                                                 ; move testByte to testByte
    mov r12, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r12                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r13, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r13                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 003h                                     ; check that vararg types is Anything
    jc func$_stderr$varargTypeChecks$TypeMatch                   ; skip next block if the type matches
      ; Error handling block for vararg types
      ; Call __error with 1 arguments
      mov r14, offset parameterTypeCheckFailureMessage           ; reading parameterTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (parameterTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 078h], rcx                            ; move parameter count of _stderr's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 070h], r10                            ; move pointer to indexth argument's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (pointer to indexth argument) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 038h]                            ; restoring slot (parameter count of _stderr) to previous scope state for genuine block exit
    func$_stderr$varargTypeChecks$TypeMatch:                     ; after block
    add r10, 010h                                                ; next argument (result in pointer to indexth argument)
    mov rax, qword ptr [rsp + 050h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_stderr$varargTypeChecks$Loop                       ; return to top of loop
    func$_stderr$varargTypeChecks$TypesAllMatch:                 ; after loop
    mov rax, qword ptr [rsp + 050h]                              ; restoring slot (pointer to last argument) to previous scope state for genuine block exit
  ; Line 808: Boolean first = true;
  ; sentinel check of true type Boolean expecting Boolean
  mov qword ptr [rsp + 058h], 001h                               ; value initialization of variable declaration for first variable (true)
  mov qword ptr [rsp + 050h], 037h                               ; type initialization of variable declaration for first variable (Boolean'37)
  ; Line 809: Integer index = 0;
  ; sentinel check of 0 type Integer expecting Integer
  mov qword ptr [rsp + 048h], 000h                               ; value initialization of variable declaration for index variable (0)
  mov qword ptr [rsp + 040h], 038h                               ; type initialization of variable declaration for index variable (Integer'38)
  func$_stderr$while$top:                                        ; top of while
    mov rax, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r12, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
    ; Call len with 1 arguments
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_stderr$while$index$TypeMatch                       ; skip next block if copy of index is not sentinel
      ; Error handling block for index
      ; Call __error with 1 arguments
      mov r15, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push r15                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r10                                                   ; internal argument 6: pointer to return value slot's value
      lea r10, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r10                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 068h], rcx                            ; move parameter count of _stderr's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 020h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of _stderr) to previous scope state for genuine block exit
    func$_stderr$while$index$TypeMatch:                          ; after block
    ; sentinel check of parameter count of _stderr type Integer expecting Integer
    xor rdi, rdi                                                 ; clear < operator result
    cmp rax, rcx                                                 ; compare copy of index with parameter count of _stderr
    setl dil                                                     ; store result in < operator result
    cmp rdi, 000h                                                ; compare < operator result to false
    jne func$_stderr$while$body                                  ; while condition
    jmp func$_stderr$while$bottom                                ; break out of while
    func$_stderr$while$body:                                     ; start of while
    ; Line 811: if (first == false) { ...
    mov rax, qword ptr [rsp + 058h]                              ; make a copy of first's value in case it changes before we use it
    mov r12, qword ptr [rsp + 050h]                              ; make a copy of first's type in case it changes before we use it
    xor r13, r13                                                 ; zero value result of == (testing copy of first and false) to put the boolean in
    cmp rax, 000h                                                ; values equal?
    sete r13b                                                    ; put result in value result of == (testing copy of first and false)
    mov r14, 037h                                                ; value result of == (testing copy of first and false) is a Boolean'37
    xor r15, r15                                                 ; zero type result of == (testing copy of first and false) to put the boolean in
    cmp r12, 037h                                                ; types equal?
    sete r15b                                                    ; put result in type result of == (testing copy of first and false)
    mov r10, 037h                                                ; type result of == (testing copy of first and false) is a Boolean'37
    mov rbx, r13                                                 ; assign value of value result of == (testing copy of first and false) to value of == operator result
    and rbx, r15                                                 ; && type temp and value temp
    ; sentinel check of == operator result type Boolean expecting Boolean
    cmp rbx, 000h                                                ; compare == operator result to false
    je func$_stderr$while$if$continuation                        ; first == false
      ; Line 812: __writeToHandle(__STD_ERROR_HANDLE, ' ');
      mov rdi, qword ptr __STD_ERROR_HANDLEValue                 ; make a copy of __STD_ERROR_HANDLE's value in case it changes before we use it
      mov rax, qword ptr __STD_ERROR_HANDLEType                  ; make a copy of __STD_ERROR_HANDLE's type in case it changes before we use it
      ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
      ; Call __writeToHandle with 2 arguments
      mov r14, offset string$56                                  ; reading string for push
      push r14                                                   ; value of argument #2 (string)
      push 039h                                                  ; type of argument #2 (String'39)
      push rdi                                                   ; value of argument #1 (copy of __STD_ERROR_HANDLE)
      push rax                                                   ; type of argument #1
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 058h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 078h], rcx                            ; move parameter count of _stderr's value out of rcx
      mov rcx, 002h                                              ; internal argument 1: number of actual arguments
      call func$__writeToHandle                                  ; jump to subroutine
      add rsp, 050h                                              ; release shadow space and arguments (result in stack pointer)
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of _stderr) to previous scope state for genuine block exit
    func$_stderr$while$if$continuation:                          ; end of if
    ; Line 814: __writeToHandle(__STD_ERROR_HANDLE, _stringify(parts[index]));
    mov r10, qword ptr __STD_ERROR_HANDLEValue                   ; make a copy of __STD_ERROR_HANDLE's value in case it changes before we use it
    mov rbx, qword ptr __STD_ERROR_HANDLEType                    ; make a copy of __STD_ERROR_HANDLE's type in case it changes before we use it
    ; sentinel check of parts type AnythingReadOnlyList expecting WhateverReadOnlyList
    mov rax, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r12, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r12, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_stderr$while$copyOfIndex$TypeMatch                 ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov r13, offset subscriptTypeCheckFailureMessage           ; reading subscriptTypeCheckFailureMessage for push
      push r13                                                   ; value of argument #1 (subscriptTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's value
      push r14                                                   ; internal argument 6: pointer to return value slot's value
      lea r14, qword ptr [rsp + 048h]                            ; load address of return value's type
      push r14                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 068h], rcx                            ; move parameter count of _stderr's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 060h], r10                            ; move copy of __STD_ERROR_HANDLE's value out of r10
      mov qword ptr [rsp + 058h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 018h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 020h]                            ; restoring slot (copy of __STD_ERROR_HANDLE) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 028h]                            ; restoring slot (parameter count of _stderr) to previous scope state for genuine block exit
    func$_stderr$while$copyOfIndex$TypeMatch:                    ; after block
    lea r15, qword ptr [rbp + 038h]                              ; base address of varargs
    cmp rax, rcx                                                 ; compare copy of index to parameter count of _stderr
    jge func$_stderr$while$subscript$boundsError                 ; index out of range (too high)
    cmp rax, 000h                                                ; compare copy of index to 0 (integer)
    jge func$_stderr$while$subscript$inBounds                    ; index not out of range (not negative)
    func$_stderr$while$subscript$boundsError:                    ; invalid index
      ; Error handling block for subscript bounds error
      ; Call __error with 1 arguments
      mov qword ptr [rsp + 038h], r10                            ; move copy of __STD_ERROR_HANDLE's value out of r10
      mov r10, offset boundsFailureMessage                       ; reading boundsFailureMessage for push
      push r10                                                   ; value of argument #1 (boundsFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      mov qword ptr [rsp + 038h], rbx                            ; move copy of __STD_ERROR_HANDLE's type out of rbx
      lea rbx, qword ptr [rsp + 040h]                            ; load address of return value's value
      push rbx                                                   ; internal argument 6: pointer to return value slot's value
      lea rbx, qword ptr [rsp + 038h]                            ; load address of return value's type
      push rbx                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 058h], rcx                            ; move parameter count of _stderr's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 050h], rax                            ; move copy of index's value out of rax
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov rax, qword ptr [rsp + 010h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
      mov rbx, qword ptr [rsp + 028h]                            ; restoring slot (copy of __STD_ERROR_HANDLE) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 018h]                            ; restoring slot (parameter count of _stderr) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 038h]                            ; restoring slot (copy of __STD_ERROR_HANDLE) to previous scope state for genuine block exit
    func$_stderr$while$subscript$inBounds:                       ; valid index
    mov rsi, rax                                                 ; assign value of copy of index to value of index into list * 16
    shl rsi, 004h                                                ; multiply by 8*2
    mov rdi, r15                                                 ; assign value of base address of varargs to value of pointer to parts[copy of index]
    add rdi, rsi                                                 ; compute address of specified list entry (result in pointer to parts[copy of index])
    mov rax, qword ptr [rdi + 008h]                              ; value of parts[copy of index]
    mov r12, qword ptr [rdi]                                     ; type of parts[copy of index]
    ; increment reference count for copy of parts[copy of index] if necessary
    mov r13, r12                                                 ; store copy of parts[copy of index]'s type in testByte value slot
    mov qword ptr [rsp + 038h], rax                              ; move copy of parts[copy of index]'s value out of rax
    mov rax, r13                                                 ; move testByte to testByte
    mov r14, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r14                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r15, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r15                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 004h                                     ; check that possibly GarbageCollectable value is GarbageCollectable
    jnc func$_stderr$while$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
      mov qword ptr [rsp + 030h], r10                            ; move copy of __STD_ERROR_HANDLE's value out of r10
      mov r10, qword ptr [rsp + 038h]                            ; read slot into register for dereferencing
      inc qword ptr [r10]                                        ; increment reference count of copy of parts[copy of index]
      mov qword ptr [rsp + 038h], r10                            ; restoring slot (copy of parts[copy of index]) to previous scope state for genuine block exit
      mov r10, qword ptr [rsp + 030h]                            ; restoring slot (copy of __STD_ERROR_HANDLE) to previous scope state for genuine block exit
    func$_stderr$while$AfterGCIncref:                            ; after GarbageCollectable incref
    cmp r12, 039h                                                ; compare type of copy of parts[copy of index] to String
    jne func$_stderr$while$AfterStringIncref                     ; if not a String, skip incref
      mov qword ptr [rsp + 030h], rbx                            ; move copy of __STD_ERROR_HANDLE's type out of rbx
      mov rbx, qword ptr [rsp + 038h]                            ; get copy of parts[copy of index] into register to dereference it
      mov r9, qword ptr [rbx]                                    ; dereference string to get to reference count
      cmp r9, 0                                                  ; compare string reference count to 0
      jns func$_stderr$while$StringIncref                        ; if reference count is negative (constant strings), skip incref
      mov qword ptr [rsp + 038h], rbx                            ; restoring slot (???) to previous scope state for synthetic block exit
      mov rbx, qword ptr [rsp + 030h]                            ; restoring slot (???) to previous scope state for synthetic block exit
      jmp func$_stderr$while$AfterStringIncref                   ; skip incref for string constants
      func$_stderr$while$StringIncref:                           ; real String
        inc qword ptr [rbx]                                      ; increment reference count of copy of parts[copy of index]
      mov qword ptr [rsp + 038h], rbx                            ; restoring slot (copy of parts[copy of index]) to previous scope state for genuine block exit
      mov rbx, qword ptr [rsp + 030h]                            ; restoring slot (copy of __STD_ERROR_HANDLE) to previous scope state for genuine block exit
    func$_stderr$while$AfterStringIncref:                        ; after String incref
    ; sentinel check of _stringify type StringFunction(Anything) expecting AnythingFunction
    ; Call _stringify with 1 arguments
    push qword ptr [rsp + 038h]                                  ; value of argument #1 (copy of parts[copy of index])
    push r12                                                     ; type of argument #1
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 040h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov qword ptr [rsp + 060h], rcx                              ; move parameter count of _stderr's value out of rcx
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    mov qword ptr [rsp + 058h], r10                              ; move copy of __STD_ERROR_HANDLE's value out of r10
    call func$_stringify                                         ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
    ; Call __writeToHandle with 2 arguments
    push qword ptr [rsp + 030h]                                  ; value of argument #2 (_stringify return value)
    push qword ptr [rsp + 030h]                                  ; type of argument #2
    push qword ptr [rsp + 028h]                                  ; value of argument #1 (copy of __STD_ERROR_HANDLE)
    push rbx                                                     ; type of argument #1
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 002h                                                ; internal argument 1: number of actual arguments
    call func$__writeToHandle                                    ; jump to subroutine
    add rsp, 050h                                                ; release shadow space and arguments (result in stack pointer)
    ; Line 815: first = false;
    ; sentinel check of false type Boolean expecting Boolean
    mov qword ptr [rsp + 058h], 000h                             ; store value
    mov qword ptr [rsp + 050h], 037h                             ; store type (Boolean'37)
    ; Line 816: index += 1;
    mov r15, qword ptr [rsp + 048h]                              ; make a copy of index's value in case it changes before we use it
    mov r10, qword ptr [rsp + 040h]                              ; make a copy of index's type in case it changes before we use it
    ; sentinel check of copy of index type Integer expecting Integer
    cmp r10, 000h                                                ; compare type of copy of index to <sentinel>
    jne func$_stderr$while$copyOfIndex$TypeMatch$1               ; skip next block if copy of index is not sentinel
      ; Error handling block for copy of index
      ; Call __error with 1 arguments
      mov rbx, offset operandTypeCheckFailureMessage             ; reading operandTypeCheckFailureMessage for push
      push rbx                                                   ; value of argument #1 (operandTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's value
      push rsi                                                   ; internal argument 6: pointer to return value slot's value
      lea rsi, qword ptr [rsp + 028h]                            ; load address of return value's type
      push rsi                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 048h], r10                            ; move copy of index's type out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 008h]                            ; restoring slot (copy of index) to previous scope state for genuine block exit
    func$_stderr$while$copyOfIndex$TypeMatch$1:                  ; after block
    ; sentinel check of 1 type Integer expecting Integer
    mov r13, r15                                                 ; assign value of copy of index to value of += operator result
    mov rax, 001h                                                ; read second operand of add (1)
    add r13, rax                                                 ; += operator
    ; sentinel check of += operator result type Integer expecting Integer
    mov qword ptr [rsp + 048h], r13                              ; store value
    mov qword ptr [rsp + 040h], 038h                             ; store type (Integer'38)
    ; Decrement reference count for _stringify return value (static type: String'39) via decrefMaybeString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, qword ptr [rsp + 048h]                              ; arg #2: _stringify return value's type
    mov rcx, qword ptr [rsp + 050h]                              ; arg #1: _stringify return value's value
    call decrefMaybeString                                       ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    ; Decrement reference count for copy of parts[copy of index] (static type: Anything'49) via decrefMaybeGCOrString
    sub rsp, 20h                                                 ; allocate shadow space for decref function
    mov rdx, r12                                                 ; arg #2: copy of parts[copy of index]'s type
    mov rcx, qword ptr [rsp + 058h]                              ; arg #1: copy of parts[copy of index]'s value
    call decrefMaybeGCOrString                                   ; call decref
    add rsp, 20h                                                 ; free shadow space for decref
    mov rcx, qword ptr [rsp + 020h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_stderr$while$top                                   ; return to top of while
  func$_stderr$while$bottom:                                     ; bottom of while
  ; Line 818: __writeToHandle(__STD_ERROR_HANDLE, '\n');
  mov r10, qword ptr __STD_ERROR_HANDLEValue                     ; make a copy of __STD_ERROR_HANDLE's value in case it changes before we use it
  mov rbx, qword ptr __STD_ERROR_HANDLEType                      ; make a copy of __STD_ERROR_HANDLE's type in case it changes before we use it
  ; sentinel check of __writeToHandle type NullFunction(Integer, String) expecting AnythingFunction
  ; Call __writeToHandle with 2 arguments
  mov qword ptr [rsp + 058h], r12                                ; move copy of parts[copy of index]'s type out of r12
  mov r12, offset string$57                                      ; reading string for push
  push r12                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r10                                                       ; value of argument #1 (copy of __STD_ERROR_HANDLE)
  push rbx                                                       ; type of argument #1
  mov qword ptr [rsp + 068h], r13                                ; move += operator result's value out of r13
  lea r13, qword ptr [rsp + 070h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 068h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$__writeToHandle                                      ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _stderr
  ; sentinel check of null type Null expecting Null
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of _stderr into register to dereference it
  mov qword ptr [r15], 000h                                      ; _stderr return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of _stderr into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of _stderr return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 068h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; _error
dq func$_error$annotation
func$_error:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Varargs parameter type check; expecting parameters to be Anything
  lea r10, qword ptr [rbp + 038h]                                ; get base address of varargs, where loop will start
  mov rax, rcx                                                   ; assign value of parameter count of _error to value of pointer to last argument
  mov rbx, 010h                                                  ; read operand of mul (10 (integer)) 
  mul rbx                                                        ; end of loop is the number of arguments times the width of each argument (010h)...
  add rax, r10                                                   ; ...offset from the initial index (result in pointer to last argument)
  func$_error$varargTypeChecks$Loop:                             ; top of loop
    mov qword ptr [rsp + 028h], 000h                             ; move pointer to indexth argument's type into a mutable location
    cmp r10, rax                                                 ; compare pointer to indexth argument to pointer to last argument
    je func$_error$varargTypeChecks$TypesAllMatch                ; we have type-checked all the arguments
    mov rsi, qword ptr [r10]                                     ; load type of indexth argument into indexth argument
    mov rdi, rsi                                                 ; store indexth argument's type in testByte value slot
    mov qword ptr [rsp + 020h], rax                              ; move pointer to last argument's value out of rax
    mov rax, rdi                                                 ; move testByte to testByte
    mov r12, 004h                                                ; read operand of mul (type table width in bytes) 
    mul r12                                                      ; adjust to the relative start of that type's entry in the type table
    add rax, 002h                                                ; adjust to the byte containing the bit to check against (result in testByte)
    mov r13, offset typeTable                                    ; read second operand of + (type table pointer)
    add rax, r13                                                 ; finally offset all of that by the start of the type table itself (result in testByte)
    bt qword ptr [rax], 003h                                     ; check that vararg types is Anything
    jc func$_error$varargTypeChecks$TypeMatch                    ; skip next block if the type matches
      ; Error handling block for vararg types
      ; Call __error with 1 arguments
      mov r14, offset parameterTypeCheckFailureMessage           ; reading parameterTypeCheckFailureMessage for push
      push r14                                                   ; value of argument #1 (parameterTypeCheckFailureMessage)
      push 039h                                                  ; type of argument #1 (String'39)
      lea r15, qword ptr [rsp + 028h]                            ; load address of return value's value
      push r15                                                   ; internal argument 6: pointer to return value slot's value
      lea r15, qword ptr [rsp + 028h]                            ; load address of return value's type
      push r15                                                   ; internal argument 5: pointer to return value slot's type
      sub rsp, 020h                                              ; allocate shadow space
      mov r9, 000h                                               ; internal argument 4: "this" pointer
      mov r8, 000h                                               ; internal argument 3: "this" pointer type
      mov rdx, 000h                                              ; internal argument 2: closure pointer
      mov qword ptr [rsp + 048h], rcx                            ; move parameter count of _error's value out of rcx
      mov rcx, 001h                                              ; internal argument 1: number of actual arguments
      mov qword ptr [rsp + 040h], r10                            ; move pointer to indexth argument's value out of r10
      call func$__error                                          ; jump to subroutine
      add rsp, 040h                                              ; release shadow space and arguments (result in stack pointer)
      mov r10, qword ptr [rsp + 000h]                            ; restoring slot (pointer to indexth argument) to previous scope state for genuine block exit
      mov rcx, qword ptr [rsp + 008h]                            ; restoring slot (parameter count of _error) to previous scope state for genuine block exit
    func$_error$varargTypeChecks$TypeMatch:                      ; after block
    add r10, 010h                                                ; next argument (result in pointer to indexth argument)
    mov rax, qword ptr [rsp + 020h]                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp func$_error$varargTypeChecks$Loop                        ; return to top of loop
    func$_error$varargTypeChecks$TypesAllMatch:                  ; after loop
    mov rax, qword ptr [rsp + 020h]                              ; restoring slot (pointer to last argument) to previous scope state for genuine block exit
  ; Line 823: assert(len(arguments) >= 1, 'insufficient arguments to __error')...
  ; sentinel check of len type IntegerFunction(WhateverReadOnlyList) expecting AnythingFunction
  ; Call len with 1 arguments
  ; sentinel check of parameter count of _error type Integer expecting Integer
  ; sentinel check of 1 type Integer expecting Integer
  xor r13, r13                                                   ; clear >= operator result
  cmp rcx, 001h                                                  ; compare parameter count of _error with 1
  setge r13b                                                     ; store result in >= operator result
  ; sentinel check of assert type NullFunction(Boolean, String) expecting AnythingFunction
  ; Call assert with 2 arguments
  mov r10, offset string$58                                      ; reading string for push
  push r10                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push r13                                                       ; value of argument #1 (>= operator result)
  push 037h                                                      ; type of argument #1 (Boolean'37)
  lea rbx, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rbx                                                       ; internal argument 6: pointer to return value slot's value
  lea rbx, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rbx                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 068h], rcx                                ; move parameter count of _error's value out of rcx
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  call func$assert                                               ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 824: stderr(arguments[0]);
  mov rsi, qword ptr stderrValue                                 ; make a copy of stderr's value in case it changes before we use it
  mov rdi, qword ptr stderrType                                  ; make a copy of stderr's type in case it changes before we use it
  ; sentinel check of arguments type AnythingReadOnlyList expecting WhateverReadOnlyList
  ; sentinel check of 0 type Integer expecting Integer
  lea r15, qword ptr [rbp + 038h]                                ; base address of varargs
  mov r10, 000h                                                  ; reading first operand of cmp (0) for a conditional jump
  cmp r10, qword ptr [rsp + 018h]                                ; compare 0 to parameter count of _error
  jge func$_error$subscript$boundsError                          ; index out of range (too high)
  jmp func$_error$subscript$inBounds                             ; index not out of range (not negative)
  func$_error$subscript$boundsError:                             ; invalid index
    ; Error handling block for subscript bounds error
    ; Call __error with 1 arguments
    mov rbx, offset boundsFailureMessage                         ; reading boundsFailureMessage for push
    push rbx                                                     ; value of argument #1 (boundsFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    mov qword ptr [rsp + 030h], rsi                              ; move copy of stderr's value out of rsi
    lea rsi, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 030h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 020h]                              ; restoring slot (copy of stderr) to previous scope state for genuine block exit
  func$_error$subscript$inBounds:                                ; valid index
  mov qword ptr [rsp + 028h], rdi                                ; move copy of stderr's type out of rdi
  mov rdi, 000h                                                  ; assign value of 0 to value of index into list * 16
  shl rdi, 004h                                                  ; multiply by 8*2
  mov rax, r15                                                   ; assign value of base address of varargs to value of pointer to arguments[0]
  add rax, rdi                                                   ; compute address of specified list entry (result in pointer to arguments[0])
  mov r12, qword ptr [rax + 008h]                                ; value of arguments[0]
  mov r13, qword ptr [rax]                                       ; type of arguments[0]
  ; increment reference count for copy of arguments[0] if necessary
  mov r14, r13                                                   ; store copy of arguments[0]'s type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc func$_error$AfterGCIncref                                  ; if not a GarbageCollectable, skip incref
    inc qword ptr [r12]                                          ; increment reference count of copy of arguments[0]
  func$_error$AfterGCIncref:                                     ; after GarbageCollectable incref
  cmp r13, 039h                                                  ; compare type of copy of arguments[0] to String
  jne func$_error$AfterStringIncref                              ; if not a String, skip incref
    mov rbx, qword ptr [r12]                                     ; dereference string to get to reference count
    cmp rbx, 0                                                   ; compare string reference count to 0
    jns func$_error$StringIncref                                 ; if reference count is negative (constant strings), skip incref
    jmp func$_error$AfterStringIncref                            ; skip incref for string constants
    func$_error$StringIncref:                                    ; real String
      inc qword ptr [r12]                                        ; increment reference count of copy of arguments[0]
  func$_error$AfterStringIncref:                                 ; after String incref
  ; sentinel check of copy of stderr type NullFunction expecting AnythingFunction
  cmp qword ptr [rsp + 028h], 000h                               ; compare type of copy of stderr to <sentinel>
  jne func$_error$copyOfStderr$TypeMatch                         ; skip next block if copy of stderr is not sentinel
    ; Error handling block for copy of stderr
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 020h], rsi                              ; move copy of stderr's value out of rsi
    mov rsi, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push rsi                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r9, qword ptr [rsp + 028h]                               ; load address of return value's value
    push r9                                                      ; internal argument 6: pointer to return value slot's value
    lea r9, qword ptr [rsp + 028h]                               ; load address of return value's type
    push r9                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov rsi, qword ptr [rsp + 020h]                              ; restoring slot (copy of stderr) to previous scope state for genuine block exit
  func$_error$copyOfStderr$TypeMatch:                            ; after block
  ; Call copy of stderr with 1 arguments
  mov rdi, qword ptr [rsi + 028h]                                ; read receiver pointer
  mov qword ptr [rsp + 020h], r12                                ; move copy of arguments[0]'s value out of r12
  mov r12, qword ptr [rsi + 020h]                                ; read receiver type
  push qword ptr [rsp + 020h]                                    ; value of argument #1 (copy of arguments[0])
  push r13                                                       ; type of argument #1
  mov qword ptr [rsp + 020h], r13                                ; move copy of arguments[0]'s type out of r13
  lea r13, qword ptr [rsp + 028h]                                ; load address of return value's value
  push r13                                                       ; internal argument 6: pointer to return value slot's value
  lea r13, qword ptr [rsp + 020h]                                ; load address of return value's type
  push r13                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, rdi                                                    ; internal argument 4: "this" pointer
  mov r8, r12                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call qword ptr [rsi + 038h]                                    ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Line 825: exit(1);
  ; sentinel check of exit type IntegerFunction(Integer) expecting AnythingFunction
  ; Call exit with 1 arguments
  push 001h                                                      ; value of argument #1 (1)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea r15, qword ptr [rsp + 038h]                                ; load address of return value's value
  push r15                                                       ; internal argument 6: pointer to return value slot's value
  lea r15, qword ptr [rsp + 030h]                                ; load address of return value's type
  push r15                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$exit                                                 ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from _error
  ; sentinel check of null type Null expecting Null
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of _error into register to dereference it
  mov qword ptr [rsi], 000h                                      ; _error return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of _error into register to dereference it
  mov qword ptr [rdi], 036h                                      ; type of _error return value (Null'36)
  ; Decrement reference count for copy of arguments[0] (static type: Anything'49) via decrefMaybeGCOrString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of arguments[0]'s type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of arguments[0]'s value
  call decrefMaybeGCOrString                                     ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Object
dq method$Object$Object$annotation
method$Object$Object:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset Object$vmt                                     ; reading vmt pointer for Object for push
  push r10                                                       ; value of argument #1 (vmt pointer for Object)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of Object's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for Object.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for Object.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'Object.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting Object
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that Object return value is Object
  jc method$Object$Object$objectReturnValue$TypeMatch            ; skip next block if the type matches
    ; Error handling block for Object return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$Object$objectReturnValue$TypeMatch:              ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of Object into register to dereference it
  mov qword ptr [rsi], rbx                                       ; Object return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of Object into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of Object return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Object$Object$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$Object$Object$AfterGCIncref:                            ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; constructor
dq method$__Object$constructor$annotation
method$Object$constructor:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of constructor to 0 (integer)
  je method$Object$constructor$parameterCountCheck$continuation  ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$constructor$parameterCountCheck$continuation:    ; end of parameter count check
  ; Implicit return from constructor
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of constructor into register to dereference it
  mov qword ptr [rdi], 000h                                      ; constructor return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of constructor into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of constructor return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test
dq method$Test$Test$annotation
method$Test$Test:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset Test$vmt                                       ; reading vmt pointer for Test for push
  push r10                                                       ; value of argument #1 (vmt pointer for Test)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 050h], rcx                                ; move parameter count of Test's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of string type String expecting String
  mov rdi, qword ptr [rsp + 020h]                                ; move "this" pointer to register to derefrence a field
  mov r11, offset string$59                                      ; indirect through r11 because operand pair (qword ptr [rdi + 048h], offset string$59) is not allowed with mov
  mov qword ptr [rdi + 048h], r11                                ; store string value in Test.field
  mov qword ptr [rdi + 040h], 039h                               ; store string type in Test.field (String'39)
  ; increment reference count for Test.field if necessary
  cmp qword ptr [rdi + 040h], 039h                               ; compare type of Test.field to String
  jne method$Test$Test$AfterStringIncref                         ; if not a String, skip incref
    mov r12, qword ptr [rdi + 048h]                              ; get Test.field into register to dereference it
    mov r13, qword ptr [r12]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$Test$Test$StringIncref                            ; if reference count is negative (constant strings), skip incref
    jmp method$Test$Test$AfterStringIncref                       ; skip incref for string constants
    method$Test$Test$StringIncref:                               ; real String
      mov r14, qword ptr [rdi + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [r14]                                        ; increment reference count of Test.field
  method$Test$Test$AfterStringIncref:                            ; after String incref
  mov r15, qword ptr [rdi + 028h]                                ; get vmt
  add r15, 040h                                                  ; add offset for dereference (result in code address for Test.constructor)
  mov r15, qword ptr [r15]                                       ; get call method
  mov r10, 03bh                                                  ; store code of __CodeAddress value in code address for Test.constructor's type slot
  mov qword ptr [rbp + 010h], r15                                ; copy address of 'Test.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting Test
  mov rax, qword ptr [rsp + 018h]                                ; store _classAllocator return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 001h                                       ; check that Test return value is Test
  jc method$Test$Test$testReturnValue$TypeMatch                  ; skip next block if the type matches
    ; Error handling block for Test return value
    ; Call __error with 1 arguments
    mov r9, offset returnValueTypeCheckFailureMessage            ; reading returnValueTypeCheckFailureMessage for push
    push r9                                                      ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r8, qword ptr [rsp + 030h]                               ; load address of return value's value
    push r8                                                      ; internal argument 6: pointer to return value slot's value
    lea r8, qword ptr [rsp + 020h]                               ; load address of return value's type
    push r8                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$testReturnValue$TypeMatch:                    ; after block
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of Test into register to dereference it
  mov qword ptr [r12], rdi                                       ; Test return value
  mov qword ptr [rsp + 020h], rdi                                ; move _classAllocator return value's value out of rdi
  mov rdi, qword ptr [rsp + 018h]                                ; reading type of _classAllocator return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test into register to dereference it
  mov qword ptr [r13], rdi                                       ; type of Test return value
  ; increment reference count for _classAllocator return value if necessary
  mov r14, rdi                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Test$Test$AfterGCIncref                             ; if not a GarbageCollectable, skip incref
    mov rbx, qword ptr [rsp + 020h]                              ; read slot into register for dereferencing
    inc qword ptr [rbx]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 020h], rbx                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$Test$Test$AfterGCIncref:                                ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rdi                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 010h]                                ; restore rcx (parameter count)
  mov r8, rdi                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 020h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; method
dq method$Test$method$annotation
method$Test$method:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of method to 0 (integer)
  je method$Test$method$parameterCountCheck$continuation         ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$method$parameterCountCheck$continuation:           ; end of parameter count check
  ; Line 22: return 'METHOD';
  ; sentinel check of string type String expecting String
  mov rdi, offset string$60                                      ; read second operand of mov (string) for MoveToDerefInstruction
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of method into register to dereference it
  mov qword ptr [r12], rdi                                       ; method return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of method into register to dereference it
  mov qword ptr [r13], 039h                                      ; type of method return value (String'39)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; mutateField
dq method$Test$mutateField$annotation
method$Test$mutateField:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of mutateField to 1 (integer)
  je method$Test$mutateField$parameterCountCheck$continuation    ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$mutateField$parameterCountCheck$continuation:      ; end of parameter count check
  ; Check type of parameter 0, newValue (expecting String)
  ; type check of newValue type String expecting String
  mov rbx, qword ptr [rbp + 038h]                                ; store newValue's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that newValue is String
  jc method$Test$mutateField$newvalue$TypeMatch                  ; skip next block if the type matches
    ; Error handling block for newValue
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$mutateField$newvalue$TypeMatch:                    ; after block
  ; Line 26: field = newValue;
  ; sentinel check of newValue type String expecting String
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of newValue to <sentinel>
  jne method$Test$mutateField$newvalue$TypeMatch$1               ; skip next block if newValue is not sentinel
    ; Error handling block for newValue
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$mutateField$newvalue$TypeMatch$1:                  ; after block
  mov rbx, r9                                                    ; move "this" pointer to register to derefrence a field
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 048h], qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rbx + 048h], r11                                ; store newValue value in Test.field
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 040h], qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rbx + 040h], r11                                ; store newValue type in Test.field
  ; increment reference count for Test.field if necessary
  cmp qword ptr [rbx + 040h], 039h                               ; compare type of Test.field to String
  jne method$Test$mutateField$AfterStringIncref                  ; if not a String, skip incref
    mov r10, qword ptr [rbx + 048h]                              ; get Test.field into register to dereference it
    mov rax, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns method$Test$mutateField$StringIncref                     ; if reference count is negative (constant strings), skip incref
    jmp method$Test$mutateField$AfterStringIncref                ; skip incref for string constants
    method$Test$mutateField$StringIncref:                        ; real String
      mov rsi, qword ptr [rbx + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [rsi]                                        ; increment reference count of Test.field
  method$Test$mutateField$AfterStringIncref:                     ; after String incref
  ; Implicit return from mutateField
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of mutateField into register to dereference it
  mov qword ptr [r13], 000h                                      ; mutateField return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of mutateField into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of mutateField return value (Null'36)
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, rbx                                                   ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass
dq method$Subclass$Subclass$annotation
method$Subclass$Subclass:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset Subclass$vmt                                   ; reading vmt pointer for Subclass for push
  push r10                                                       ; value of argument #1 (vmt pointer for Subclass)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 030h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 050h], rcx                                ; move parameter count of Subclass's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of string type String expecting String
  mov rdi, qword ptr [rsp + 020h]                                ; move "this" pointer to register to derefrence a field
  mov r11, offset string$59                                      ; indirect through r11 because operand pair (qword ptr [rdi + 048h], offset string$59) is not allowed with mov
  mov qword ptr [rdi + 048h], r11                                ; store string value in Subclass.field
  mov qword ptr [rdi + 040h], 039h                               ; store string type in Subclass.field (String'39)
  ; increment reference count for Subclass.field if necessary
  cmp qword ptr [rdi + 040h], 039h                               ; compare type of Subclass.field to String
  jne method$Subclass$Subclass$AfterStringIncref                 ; if not a String, skip incref
    mov r12, qword ptr [rdi + 048h]                              ; get Subclass.field into register to dereference it
    mov r13, qword ptr [r12]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$Subclass$Subclass$StringIncref                    ; if reference count is negative (constant strings), skip incref
    jmp method$Subclass$Subclass$AfterStringIncref               ; skip incref for string constants
    method$Subclass$Subclass$StringIncref:                       ; real String
      mov r14, qword ptr [rdi + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [r14]                                        ; increment reference count of Subclass.field
  method$Subclass$Subclass$AfterStringIncref:                    ; after String incref
  mov r15, qword ptr [rdi + 028h]                                ; get vmt
  add r15, 040h                                                  ; add offset for dereference (result in code address for Subclass.constructor)
  mov r15, qword ptr [r15]                                       ; get call method
  mov r10, 03bh                                                  ; store code of __CodeAddress value in code address for Subclass.constructor's type slot
  mov qword ptr [rbp + 010h], r15                                ; copy address of 'Subclass.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting Subclass
  mov rax, qword ptr [rsp + 018h]                                ; store _classAllocator return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that Subclass return value is Subclass
  jc method$Subclass$Subclass$subclassReturnValue$TypeMatch      ; skip next block if the type matches
    ; Error handling block for Subclass return value
    ; Call __error with 1 arguments
    mov r9, offset returnValueTypeCheckFailureMessage            ; reading returnValueTypeCheckFailureMessage for push
    push r9                                                      ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r8, qword ptr [rsp + 030h]                               ; load address of return value's value
    push r8                                                      ; internal argument 6: pointer to return value slot's value
    lea r8, qword ptr [rsp + 020h]                               ; load address of return value's type
    push r8                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$subclassReturnValue$TypeMatch:        ; after block
  mov r12, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass into register to dereference it
  mov qword ptr [r12], rdi                                       ; Subclass return value
  mov qword ptr [rsp + 020h], rdi                                ; move _classAllocator return value's value out of rdi
  mov rdi, qword ptr [rsp + 018h]                                ; reading type of _classAllocator return value
  mov r13, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass into register to dereference it
  mov qword ptr [r13], rdi                                       ; type of Subclass return value
  ; increment reference count for _classAllocator return value if necessary
  mov r14, rdi                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r14                                                   ; move testByte to testByte
  mov r15, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r15                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r10, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r10                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Subclass$Subclass$AfterGCIncref                     ; if not a GarbageCollectable, skip incref
    mov rbx, qword ptr [rsp + 020h]                              ; read slot into register for dereferencing
    inc qword ptr [rbx]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 020h], rbx                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$Subclass$Subclass$AfterGCIncref:                        ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rdi                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 010h]                                ; restore rcx (parameter count)
  mov r8, rdi                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 020h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; constructor
dq method$__Object$constructor$annotation
method$Subclass$constructor:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of constructor to 1 (integer)
  je method$Subclass$constructor$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$constructor$parameterCountCheck$continuation:  ; end of parameter count check
  ; Check type of parameter 0, initialValue (expecting String)
  ; type check of initialValue type String expecting String
  mov rbx, qword ptr [rbp + 038h]                                ; store initialValue's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that initialValue is String
  jc method$Subclass$constructor$initialvalue$TypeMatch          ; skip next block if the type matches
    ; Error handling block for initialValue
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$constructor$initialvalue$TypeMatch:            ; after block
  ; Line 32: field = initialValue;
  ; sentinel check of initialValue type String expecting String
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of initialValue to <sentinel>
  jne method$Subclass$constructor$initialvalue$TypeMatch$1       ; skip next block if initialValue is not sentinel
    ; Error handling block for initialValue
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$constructor$initialvalue$TypeMatch$1:          ; after block
  mov rbx, r9                                                    ; move "this" pointer to register to derefrence a field
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 048h], qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rbx + 048h], r11                                ; store initialValue value in Subclass.field
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 040h], qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rbx + 040h], r11                                ; store initialValue type in Subclass.field
  ; increment reference count for Subclass.field if necessary
  cmp qword ptr [rbx + 040h], 039h                               ; compare type of Subclass.field to String
  jne method$Subclass$constructor$AfterStringIncref              ; if not a String, skip incref
    mov r10, qword ptr [rbx + 048h]                              ; get Subclass.field into register to dereference it
    mov rax, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns method$Subclass$constructor$StringIncref                 ; if reference count is negative (constant strings), skip incref
    jmp method$Subclass$constructor$AfterStringIncref            ; skip incref for string constants
    method$Subclass$constructor$StringIncref:                    ; real String
      mov rsi, qword ptr [rbx + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [rsi]                                        ; increment reference count of Subclass.field
  method$Subclass$constructor$AfterStringIncref:                 ; after String incref
  ; Implicit return from constructor
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of constructor into register to dereference it
  mov qword ptr [r13], 000h                                      ; constructor return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of constructor into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of constructor return value (Null'36)
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, rbx                                                   ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA
dq method$BunnyA$BunnyA$annotation
method$BunnyA$BunnyA:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset BunnyA$vmt                                     ; reading vmt pointer for BunnyA for push
  push r10                                                       ; value of argument #1 (vmt pointer for BunnyA)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of BunnyA's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for BunnyA.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for BunnyA.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'BunnyA.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting BunnyA
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that BunnyA return value is BunnyA
  jc method$BunnyA$BunnyA$bunnyaReturnValue$TypeMatch            ; skip next block if the type matches
    ; Error handling block for BunnyA return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$bunnyaReturnValue$TypeMatch:              ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA into register to dereference it
  mov qword ptr [rsi], rbx                                       ; BunnyA return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of BunnyA return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyA$BunnyA$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$BunnyA$BunnyA$AfterGCIncref:                            ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; test
dq method$BunnyA$test$annotation
method$BunnyA$test:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of test to 0 (integer)
  je method$BunnyA$test$parameterCountCheck$continuation         ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$test$parameterCountCheck$continuation:           ; end of parameter count check
  ; Line 62: result = 'BunnyA::test';
  ; sentinel check of string type String expecting String
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, offset string$71                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$71) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov qword ptr resultType, 039h                                 ; store type (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$BunnyA$test$AfterStringIncref                       ; if not a String, skip incref
    mov rdi, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r12, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r12, 0                                                   ; compare string reference count to 0
    jns method$BunnyA$test$StringIncref                          ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, rdi                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$BunnyA$test$AfterStringIncref                     ; skip incref for string constants
    method$BunnyA$test$StringIncref:                             ; real String
      inc qword ptr [rdi]                                        ; increment reference count of result variable
  method$BunnyA$test$AfterStringIncref:                          ; after String incref
  ; Implicit return from test
  ; sentinel check of null type Null expecting Null
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of test into register to dereference it
  mov qword ptr [r15], 000h                                      ; test return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of test into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of test return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB
dq method$BunnyB$BunnyB$annotation
method$BunnyB$BunnyB:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset BunnyB$vmt                                     ; reading vmt pointer for BunnyB for push
  push r10                                                       ; value of argument #1 (vmt pointer for BunnyB)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of BunnyB's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for BunnyB.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for BunnyB.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'BunnyB.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting BunnyB
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that BunnyB return value is BunnyB
  jc method$BunnyB$BunnyB$bunnybReturnValue$TypeMatch            ; skip next block if the type matches
    ; Error handling block for BunnyB return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$bunnybReturnValue$TypeMatch:              ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB into register to dereference it
  mov qword ptr [rsi], rbx                                       ; BunnyB return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of BunnyB return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$BunnyB$AfterGCIncref                         ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$BunnyB$BunnyB$AfterGCIncref:                            ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; grab
dq method$BunnyB$grab$annotation
method$BunnyB$grab:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of grab to 0 (integer)
  je method$BunnyB$grab$parameterCountCheck$continuation         ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyB$grab$parameterCountCheck$continuation:           ; end of parameter count check
  ; Line 68: return test;
  mov rbx, qword ptr [r9 + 028h]                                 ; get vmt
  add rbx, 080h                                                  ; add offset for dereference (result in code address for BunnyB.test)
  mov rbx, qword ptr [rbx]                                       ; get call method
  mov rsi, 03bh                                                  ; store code of __CodeAddress value in code address for BunnyB.test's type slot
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  push rbx                                                       ; value of argument #2 (code address for BunnyB.test)
  push rsi                                                       ; type of argument #2
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 068h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 060h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r12, qword ptr [rsp + 018h]                                ; make a copy of test's value in case it changes before we use it
  mov r13, qword ptr [rsp + 010h]                                ; make a copy of test's type in case it changes before we use it
  ; sentinel check of copy of test type WhateverFunction expecting NullFunction
  cmp r13, 000h                                                  ; compare type of copy of test to <sentinel>
  jne method$BunnyB$grab$grabReturnValue$TypeMatch               ; skip next block if copy of test is not sentinel
    ; Error handling block for grab return value
    ; Call __error with 1 arguments
    mov r14, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$grab$grabReturnValue$TypeMatch:                  ; after block
  mov r10, qword ptr [rbp + 030h]                                ; get pointer to return value of grab into register to dereference it
  mov qword ptr [r10], r12                                       ; grab return value
  mov rax, qword ptr [rbp + 028h]                                ; get pointer to return value type of grab into register to dereference it
  mov qword ptr [rax], r13                                       ; type of grab return value
  ; increment reference count for copy of test if necessary
  mov rbx, r13                                                   ; store copy of test's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$grab$AfterGCIncref                           ; if not a GarbageCollectable, skip incref
    inc qword ptr [r12]                                          ; increment reference count of copy of test
  method$BunnyB$grab$AfterGCIncref:                              ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 020h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; test
dq method$BunnyA$test$annotation
method$BunnyB$test:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 018h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of test to 0 (integer)
  je method$BunnyB$test$parameterCountCheck$continuation         ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$test$parameterCountCheck$continuation:           ; end of parameter count check
  ; Line 72: result = 'BunnyB::test';
  ; sentinel check of string type String expecting String
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, offset string$72                                      ; indirect through r11 because operand pair (qword ptr resultValue, offset string$72) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov qword ptr resultType, 039h                                 ; store type (String'39)
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$BunnyB$test$AfterStringIncref                       ; if not a String, skip incref
    mov rdi, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r12, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r12, 0                                                   ; compare string reference count to 0
    jns method$BunnyB$test$StringIncref                          ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, rdi                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$BunnyB$test$AfterStringIncref                     ; skip incref for string constants
    method$BunnyB$test$StringIncref:                             ; real String
      inc qword ptr [rdi]                                        ; increment reference count of result variable
  method$BunnyB$test$AfterStringIncref:                          ; after String incref
  ; Implicit return from test
  ; sentinel check of null type Null expecting Null
  mov r15, qword ptr [rbp + 030h]                                ; get pointer to return value of test into register to dereference it
  mov qword ptr [r15], 000h                                      ; test return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of test into register to dereference it
  mov qword ptr [r10], 036h                                      ; type of test return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 018h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot
dq method$CarrotRoot$CarrotRoot$annotation
method$CarrotRoot$CarrotRoot:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset CarrotRoot$vmt                                 ; reading vmt pointer for CarrotRoot for push
  push r10                                                       ; value of argument #1 (vmt pointer for CarrotRoot)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of CarrotRoot's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for CarrotRoot.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotRoot.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'CarrotRoot.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting CarrotRoot
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 005h                                       ; check that CarrotRoot return value is CarrotRoot
  jc method$CarrotRoot$CarrotRoot$carrotrootReturnValue$TypeMatch ; skip next block if the type matches
    ; Error handling block for CarrotRoot return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$carrotrootReturnValue$TypeMatch:  ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot into register to dereference it
  mov qword ptr [rsi], rbx                                       ; CarrotRoot return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of CarrotRoot return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotRoot$CarrotRoot$AfterGCIncref                 ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$CarrotRoot$CarrotRoot$AfterGCIncref:                    ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; foo
dq method$CarrotRoot$foo$annotation
method$CarrotRoot$foo:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of foo to 0 (integer)
  je method$CarrotRoot$foo$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$foo$parameterCountCheck$continuation:        ; end of parameter count check
  ; Line 86: result = concat(result, 'a');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne method$CarrotRoot$foo$AfterStringIncref                    ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$CarrotRoot$foo$StringIncref                       ; if reference count is negative (constant strings), skip incref
    jmp method$CarrotRoot$foo$AfterStringIncref                  ; skip incref for string constants
    method$CarrotRoot$foo$StringIncref:                          ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of result
  method$CarrotRoot$foo$AfterStringIncref:                       ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$CarrotRoot$foo$copyOfConcat$TypeMatch               ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$foo$copyOfConcat$TypeMatch:                  ; after block
  ; Call copy of concat with 2 arguments
  mov r10, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 028h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$74                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (copy of result)
  push r12                                                       ; type of argument #1
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  lea rsi, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 038h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r10                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 058h], rdi                                ; move copy of result's value out of rdi
  mov rdi, qword ptr [rsp + 078h]                                ; reading copy of concat to dereference it
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$CarrotRoot$foo$copyOfConcatReturnValue$TypeMatch    ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for copy of concat return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r12                              ; move copy of result's type out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 028h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  method$CarrotRoot$foo$copyOfConcatReturnValue$TypeMatch:       ; after block
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (qword ptr resultValue, stack operand #2) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr resultType, stack operand #4) is not allowed with mov
  mov qword ptr resultType, r11                                  ; store type
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$CarrotRoot$foo$AfterStringIncref$1                  ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$CarrotRoot$foo$StringIncref$1                     ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$CarrotRoot$foo$AfterStringIncref$1                ; skip incref for string constants
    method$CarrotRoot$foo$StringIncref$1:                        ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
  method$CarrotRoot$foo$AfterStringIncref$1:                     ; after String incref
  ; Implicit return from foo
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of foo into register to dereference it
  mov qword ptr [rbx], 000h                                      ; foo return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of foo into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of foo return value (Null'36)
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r12                                                   ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA
dq method$CarrotBranchA$CarrotBranchA$annotation
method$CarrotBranchA$CarrotBranchA:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset CarrotBranchA$vmt                              ; reading vmt pointer for CarrotBranchA for push
  push r10                                                       ; value of argument #1 (vmt pointer for CarrotBranchA)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of CarrotBranchA's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for CarrotBranchA.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotBranchA.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'CarrotBranchA.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting CarrotBranchA
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 006h                                       ; check that CarrotBranchA return value is CarrotBranchA
  jc method$CarrotBranchA$CarrotBranchA$carrotbranchaReturnValue$TypeMatch ; skip next block if the type matches
    ; Error handling block for CarrotBranchA return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$carrotbranchaReturnValue$TypeMatch:  ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA into register to dereference it
  mov qword ptr [rsi], rbx                                       ; CarrotBranchA return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of CarrotBranchA return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchA$CarrotBranchA$AfterGCIncref           ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$CarrotBranchA$CarrotBranchA$AfterGCIncref:              ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; bar
dq method$CarrotBranchA$bar$annotation
method$CarrotBranchA$bar:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of bar to 0 (integer)
  je method$CarrotBranchA$bar$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$bar$parameterCountCheck$continuation:     ; end of parameter count check
  ; Line 92: result = concat(result, 'b');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne method$CarrotBranchA$bar$AfterStringIncref                 ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchA$bar$StringIncref                    ; if reference count is negative (constant strings), skip incref
    jmp method$CarrotBranchA$bar$AfterStringIncref               ; skip incref for string constants
    method$CarrotBranchA$bar$StringIncref:                       ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of result
  method$CarrotBranchA$bar$AfterStringIncref:                    ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$CarrotBranchA$bar$copyOfConcat$TypeMatch            ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$bar$copyOfConcat$TypeMatch:               ; after block
  ; Call copy of concat with 2 arguments
  mov r10, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 028h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$75                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (copy of result)
  push r12                                                       ; type of argument #1
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  lea rsi, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 038h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r10                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 058h], rdi                                ; move copy of result's value out of rdi
  mov rdi, qword ptr [rsp + 078h]                                ; reading copy of concat to dereference it
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$CarrotBranchA$bar$copyOfConcatReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for copy of concat return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r12                              ; move copy of result's type out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 028h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  method$CarrotBranchA$bar$copyOfConcatReturnValue$TypeMatch:    ; after block
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (qword ptr resultValue, stack operand #2) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr resultType, stack operand #4) is not allowed with mov
  mov qword ptr resultType, r11                                  ; store type
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$CarrotBranchA$bar$AfterStringIncref$1               ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchA$bar$StringIncref$1                  ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$CarrotBranchA$bar$AfterStringIncref$1             ; skip incref for string constants
    method$CarrotBranchA$bar$StringIncref$1:                     ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
  method$CarrotBranchA$bar$AfterStringIncref$1:                  ; after String incref
  ; Implicit return from bar
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of bar into register to dereference it
  mov qword ptr [rbx], 000h                                      ; bar return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of bar into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of bar return value (Null'36)
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r12                                                   ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA
dq method$CarrotLeafA$CarrotLeafA$annotation
method$CarrotLeafA$CarrotLeafA:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset CarrotLeafA$vmt                                ; reading vmt pointer for CarrotLeafA for push
  push r10                                                       ; value of argument #1 (vmt pointer for CarrotLeafA)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of CarrotLeafA's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for CarrotLeafA.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotLeafA.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'CarrotLeafA.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting CarrotLeafA
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 001h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 007h                                       ; check that CarrotLeafA return value is CarrotLeafA
  jc method$CarrotLeafA$CarrotLeafA$carrotleafaReturnValue$TypeMatch ; skip next block if the type matches
    ; Error handling block for CarrotLeafA return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$carrotleafaReturnValue$TypeMatch:  ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA into register to dereference it
  mov qword ptr [rsi], rbx                                       ; CarrotLeafA return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of CarrotLeafA return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$AfterGCIncref               ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$AfterGCIncref:                  ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; barImpl
dq method$CarrotLeafA$barImpl$annotation
method$CarrotLeafA$barImpl:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of barImpl to 0 (integer)
  je method$CarrotLeafA$barImpl$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$barImpl$parameterCountCheck$continuation:   ; end of parameter count check
  ; Line 100: result = concat(result, 'c');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne method$CarrotLeafA$barImpl$AfterStringIncref               ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$CarrotLeafA$barImpl$StringIncref                  ; if reference count is negative (constant strings), skip incref
    jmp method$CarrotLeafA$barImpl$AfterStringIncref             ; skip incref for string constants
    method$CarrotLeafA$barImpl$StringIncref:                     ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of result
  method$CarrotLeafA$barImpl$AfterStringIncref:                  ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$CarrotLeafA$barImpl$copyOfConcat$TypeMatch          ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$barImpl$copyOfConcat$TypeMatch:             ; after block
  ; Call copy of concat with 2 arguments
  mov r10, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 028h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$76                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (copy of result)
  push r12                                                       ; type of argument #1
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  lea rsi, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 038h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r10                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 058h], rdi                                ; move copy of result's value out of rdi
  mov rdi, qword ptr [rsp + 078h]                                ; reading copy of concat to dereference it
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$CarrotLeafA$barImpl$copyOfConcatReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for copy of concat return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r12                              ; move copy of result's type out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 028h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  method$CarrotLeafA$barImpl$copyOfConcatReturnValue$TypeMatch:  ; after block
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (qword ptr resultValue, stack operand #2) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr resultType, stack operand #4) is not allowed with mov
  mov qword ptr resultType, r11                                  ; store type
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$CarrotLeafA$barImpl$AfterStringIncref$1             ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$CarrotLeafA$barImpl$StringIncref$1                ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$CarrotLeafA$barImpl$AfterStringIncref$1           ; skip incref for string constants
    method$CarrotLeafA$barImpl$StringIncref$1:                   ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
  method$CarrotLeafA$barImpl$AfterStringIncref$1:                ; after String incref
  ; Implicit return from barImpl
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of barImpl into register to dereference it
  mov qword ptr [rbx], 000h                                      ; barImpl return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of barImpl into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of barImpl return value (Null'36)
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r12                                                   ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; constructor
dq method$__Object$constructor$annotation
method$CarrotLeafA$constructor:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of constructor to 0 (integer)
  je method$CarrotLeafA$constructor$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$constructor$parameterCountCheck$continuation:  ; end of parameter count check
  ; Line 104: bar = barImpl;
  mov rbx, qword ptr [r9 + 028h]                                 ; get vmt
  add rbx, 0c0h                                                  ; add offset for dereference (result in code address for CarrotLeafA.barImpl)
  mov rbx, qword ptr [rbx]                                       ; get call method
  mov rsi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotLeafA.barImpl's type slot
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  push rbx                                                       ; value of argument #2 (code address for CarrotLeafA.barImpl)
  push rsi                                                       ; type of argument #2
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 068h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 060h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r12, qword ptr [rsp + 018h]                                ; make a copy of barImpl's value in case it changes before we use it
  mov r13, qword ptr [rsp + 010h]                                ; make a copy of barImpl's type in case it changes before we use it
  ; sentinel check of copy of barImpl type WhateverFunction expecting NullFunction
  cmp r13, 000h                                                  ; compare type of copy of barImpl to <sentinel>
  jne method$CarrotLeafA$constructor$copyOfBarimpl$TypeMatch     ; skip next block if copy of barImpl is not sentinel
    ; Error handling block for copy of barImpl
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$constructor$copyOfBarimpl$TypeMatch:        ; after block
  mov rbx, qword ptr [rsp + 008h]                                ; move "this" pointer to register to derefrence a field
  mov qword ptr [rbx + 048h], r12                                ; store copy of barImpl value in CarrotLeafA.bar
  mov qword ptr [rbx + 040h], r13                                ; store copy of barImpl type in CarrotLeafA.bar
  ; Implicit return from constructor
  ; sentinel check of null type Null expecting Null
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of constructor into register to dereference it
  mov qword ptr [rsi], 000h                                      ; constructor return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of constructor into register to dereference it
  mov qword ptr [rdi], 036h                                      ; type of constructor return value (Null'36)
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 020h]                                ; arg #2: this variable's type
  mov rcx, rbx                                                   ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB
dq method$CarrotBranchB$CarrotBranchB$annotation
method$CarrotBranchB$CarrotBranchB:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset CarrotBranchB$vmt                              ; reading vmt pointer for CarrotBranchB for push
  push r10                                                       ; value of argument #1 (vmt pointer for CarrotBranchB)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of CarrotBranchB's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for CarrotBranchB.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotBranchB.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'CarrotBranchB.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting CarrotBranchB
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 000h                                       ; check that CarrotBranchB return value is CarrotBranchB
  jc method$CarrotBranchB$CarrotBranchB$carrotbranchbReturnValue$TypeMatch ; skip next block if the type matches
    ; Error handling block for CarrotBranchB return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$carrotbranchbReturnValue$TypeMatch:  ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB into register to dereference it
  mov qword ptr [rsi], rbx                                       ; CarrotBranchB return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of CarrotBranchB return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$AfterGCIncref           ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$AfterGCIncref:              ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; fooImpl
dq method$CarrotBranchB$fooImpl$annotation
method$CarrotBranchB$fooImpl:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of fooImpl to 0 (integer)
  je method$CarrotBranchB$fooImpl$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$fooImpl$parameterCountCheck$continuation:  ; end of parameter count check
  ; Line 112: result = concat(result, 'd');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne method$CarrotBranchB$fooImpl$AfterStringIncref             ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchB$fooImpl$StringIncref                ; if reference count is negative (constant strings), skip incref
    jmp method$CarrotBranchB$fooImpl$AfterStringIncref           ; skip incref for string constants
    method$CarrotBranchB$fooImpl$StringIncref:                   ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of result
  method$CarrotBranchB$fooImpl$AfterStringIncref:                ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$CarrotBranchB$fooImpl$copyOfConcat$TypeMatch        ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$fooImpl$copyOfConcat$TypeMatch:           ; after block
  ; Call copy of concat with 2 arguments
  mov r10, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 028h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$77                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (copy of result)
  push r12                                                       ; type of argument #1
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  lea rsi, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 038h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r10                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 058h], rdi                                ; move copy of result's value out of rdi
  mov rdi, qword ptr [rsp + 078h]                                ; reading copy of concat to dereference it
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$CarrotBranchB$fooImpl$copyOfConcatReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for copy of concat return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r12                              ; move copy of result's type out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 028h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  method$CarrotBranchB$fooImpl$copyOfConcatReturnValue$TypeMatch:  ; after block
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (qword ptr resultValue, stack operand #2) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr resultType, stack operand #4) is not allowed with mov
  mov qword ptr resultType, r11                                  ; store type
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$CarrotBranchB$fooImpl$AfterStringIncref$1           ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchB$fooImpl$StringIncref$1              ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$CarrotBranchB$fooImpl$AfterStringIncref$1         ; skip incref for string constants
    method$CarrotBranchB$fooImpl$StringIncref$1:                 ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
  method$CarrotBranchB$fooImpl$AfterStringIncref$1:              ; after String incref
  ; Implicit return from fooImpl
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of fooImpl into register to dereference it
  mov qword ptr [rbx], 000h                                      ; fooImpl return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of fooImpl into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of fooImpl return value (Null'36)
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r12                                                   ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; bar
dq method$CarrotBranchA$bar$annotation
method$CarrotBranchB$bar:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of bar to 0 (integer)
  je method$CarrotBranchB$bar$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$bar$parameterCountCheck$continuation:     ; end of parameter count check
  ; Line 116: result = concat(result, 'e');
  mov rbx, qword ptr concatValue                                 ; make a copy of concat's value in case it changes before we use it
  mov rsi, qword ptr concatType                                  ; make a copy of concat's type in case it changes before we use it
  mov rdi, qword ptr resultValue                                 ; make a copy of result's value in case it changes before we use it
  mov r12, qword ptr resultType                                  ; make a copy of result's type in case it changes before we use it
  ; increment reference count for copy of result if necessary
  cmp r12, 039h                                                  ; compare type of copy of result to String
  jne method$CarrotBranchB$bar$AfterStringIncref                 ; if not a String, skip incref
    mov r13, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r13, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchB$bar$StringIncref                    ; if reference count is negative (constant strings), skip incref
    jmp method$CarrotBranchB$bar$AfterStringIncref               ; skip incref for string constants
    method$CarrotBranchB$bar$StringIncref:                       ; real String
      inc qword ptr [rdi]                                        ; increment reference count of copy of result
  method$CarrotBranchB$bar$AfterStringIncref:                    ; after String incref
  ; sentinel check of copy of concat type StringFunction expecting AnythingFunction
  cmp rsi, 000h                                                  ; compare type of copy of concat to <sentinel>
  jne method$CarrotBranchB$bar$copyOfConcat$TypeMatch            ; skip next block if copy of concat is not sentinel
    ; Error handling block for copy of concat
    ; Call __error with 1 arguments
    mov r14, offset subroutineCallTypeCheckFailureMessage        ; reading subroutineCallTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (subroutineCallTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 038h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$bar$copyOfConcat$TypeMatch:               ; after block
  ; Call copy of concat with 2 arguments
  mov r10, qword ptr [rbx + 028h]                                ; read receiver pointer
  mov rax, qword ptr [rbx + 020h]                                ; read receiver type
  mov qword ptr [rsp + 028h], rbx                                ; move copy of concat's value out of rbx
  mov rbx, offset string$78                                      ; reading string for push
  push rbx                                                       ; value of argument #2 (string)
  push 039h                                                      ; type of argument #2 (String'39)
  push rdi                                                       ; value of argument #1 (copy of result)
  push r12                                                       ; type of argument #1
  mov qword ptr [rsp + 038h], rsi                                ; move copy of concat's type out of rsi
  lea rsi, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 038h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, r10                                                    ; internal argument 4: "this" pointer
  mov r8, rax                                                    ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 002h                                                  ; internal argument 1: number of actual arguments
  mov qword ptr [rsp + 058h], rdi                                ; move copy of result's value out of rdi
  mov rdi, qword ptr [rsp + 078h]                                ; reading copy of concat to dereference it
  call qword ptr [rdi + 038h]                                    ; jump to subroutine
  add rsp, 050h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of copy of concat return value type String expecting String
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of copy of concat return value to <sentinel>
  jne method$CarrotBranchB$bar$copyOfConcatReturnValue$TypeMatch ; skip next block if copy of concat return value is not sentinel
    ; Error handling block for copy of concat return value
    ; Call __error with 1 arguments
    mov qword ptr [rsp + 028h], r12                              ; move copy of result's type out of r12
    mov r12, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r12, qword ptr [rsp + 028h]                              ; restoring slot (copy of result) to previous scope state for genuine block exit
  method$CarrotBranchB$bar$copyOfConcatReturnValue$TypeMatch:    ; after block
  ; Decrement reference count for result variable (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr resultType                                  ; arg #2: result variable's type
  mov rcx, qword ptr resultValue                                 ; arg #1: result variable's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov r11, qword ptr [rsp + 020h]                                ; indirect through r11 because operand pair (qword ptr resultValue, stack operand #2) is not allowed with mov
  mov qword ptr resultValue, r11                                 ; store value
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr resultType, stack operand #4) is not allowed with mov
  mov qword ptr resultType, r11                                  ; store type
  ; increment reference count for result variable if necessary
  cmp qword ptr resultType, 039h                                 ; compare type of result variable to String
  jne method$CarrotBranchB$bar$AfterStringIncref$1               ; if not a String, skip incref
    mov r14, qword ptr resultValue                               ; get result variable into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$CarrotBranchB$bar$StringIncref$1                  ; if reference count is negative (constant strings), skip incref
    mov qword ptr resultValue, r14                               ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$CarrotBranchB$bar$AfterStringIncref$1             ; skip incref for string constants
    method$CarrotBranchB$bar$StringIncref$1:                     ; real String
      inc qword ptr [r14]                                        ; increment reference count of result variable
  method$CarrotBranchB$bar$AfterStringIncref$1:                  ; after String incref
  ; Implicit return from bar
  ; sentinel check of null type Null expecting Null
  mov rbx, qword ptr [rbp + 030h]                                ; get pointer to return value of bar into register to dereference it
  mov qword ptr [rbx], 000h                                      ; bar return value
  mov rsi, qword ptr [rbp + 028h]                                ; get pointer to return value type of bar into register to dereference it
  mov qword ptr [rsi], 036h                                      ; type of bar return value (Null'36)
  ; Decrement reference count for copy of result (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r12                                                   ; arg #2: copy of result's type
  mov rcx, qword ptr [rsp + 028h]                                ; arg #1: copy of result's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  ; Decrement reference count for copy of concat return value (static type: String'39) via decrefMaybeString
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: copy of concat return value's type
  mov rcx, qword ptr [rsp + 040h]                                ; arg #1: copy of concat return value's value
  call decrefMaybeString                                         ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; constructor
dq method$__Object$constructor$annotation
method$CarrotBranchB$constructor:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of constructor to 0 (integer)
  je method$CarrotBranchB$constructor$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$constructor$parameterCountCheck$continuation:  ; end of parameter count check
  ; Line 120: foo = fooImpl;
  mov rbx, qword ptr [r9 + 028h]                                 ; get vmt
  add rbx, 0a0h                                                  ; add offset for dereference (result in code address for CarrotBranchB.fooImpl)
  mov rbx, qword ptr [rbx]                                       ; get call method
  mov rsi, 03bh                                                  ; store code of __CodeAddress value in code address for CarrotBranchB.fooImpl's type slot
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  push rbx                                                       ; value of argument #2 (code address for CarrotBranchB.fooImpl)
  push rsi                                                       ; type of argument #2
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rdi                                                       ; internal argument 6: pointer to return value slot's value
  lea rdi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rdi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 068h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 060h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  mov r12, qword ptr [rsp + 018h]                                ; make a copy of fooImpl's value in case it changes before we use it
  mov r13, qword ptr [rsp + 010h]                                ; make a copy of fooImpl's type in case it changes before we use it
  ; sentinel check of copy of fooImpl type WhateverFunction expecting NullFunction
  cmp r13, 000h                                                  ; compare type of copy of fooImpl to <sentinel>
  jne method$CarrotBranchB$constructor$copyOfFooimpl$TypeMatch   ; skip next block if copy of fooImpl is not sentinel
    ; Error handling block for copy of fooImpl
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$constructor$copyOfFooimpl$TypeMatch:      ; after block
  mov rbx, qword ptr [rsp + 008h]                                ; move "this" pointer to register to derefrence a field
  mov qword ptr [rbx + 048h], r12                                ; store copy of fooImpl value in CarrotBranchB.foo
  mov qword ptr [rbx + 040h], r13                                ; store copy of fooImpl type in CarrotBranchB.foo
  ; Implicit return from constructor
  ; sentinel check of null type Null expecting Null
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of constructor into register to dereference it
  mov qword ptr [rsi], 000h                                      ; constructor return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of constructor into register to dereference it
  mov qword ptr [rdi], 036h                                      ; type of constructor return value (Null'36)
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 020h]                                ; arg #2: this variable's type
  mov rcx, rbx                                                   ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A
dq method$A$A$annotation
method$A$A:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset A$vmt                                          ; reading vmt pointer for A for push
  push r10                                                       ; value of argument #1 (vmt pointer for A)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 028h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 048h], rcx                                ; move parameter count of A's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  mov rbx, qword ptr [rsp + 018h]                                ; get _classAllocator return value into register to dereference it
  mov rsi, qword ptr [rbx + 028h]                                ; get vmt
  add rsi, 040h                                                  ; add offset for dereference (result in code address for A.constructor)
  mov rsi, qword ptr [rsi]                                       ; get call method
  mov rdi, 03bh                                                  ; store code of __CodeAddress value in code address for A.constructor's type slot
  mov qword ptr [rbp + 010h], rsi                                ; copy address of 'A.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting A
  mov r12, qword ptr [rsp + 010h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 001h                                       ; check that A return value is A
  jc method$A$A$aReturnValue$TypeMatch                           ; skip next block if the type matches
    ; Error handling block for A return value
    ; Call __error with 1 arguments
    mov r15, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push r15                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r10, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r10                                                     ; internal argument 6: pointer to return value slot's value
    lea r10, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r10                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$aReturnValue$TypeMatch:                             ; after block
  mov rsi, qword ptr [rbp + 030h]                                ; get pointer to return value of A into register to dereference it
  mov qword ptr [rsi], rbx                                       ; A return value
  mov qword ptr [rsp + 018h], rbx                                ; move _classAllocator return value's value out of rbx
  mov rbx, qword ptr [rsp + 010h]                                ; reading type of _classAllocator return value
  mov rdi, qword ptr [rbp + 028h]                                ; get pointer to return value type of A into register to dereference it
  mov qword ptr [rdi], rbx                                       ; type of A return value
  ; increment reference count for _classAllocator return value if necessary
  mov r12, rbx                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r12                                                   ; move testByte to testByte
  mov r13, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r13                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r14, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r14                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$A$A$AfterGCIncref                                   ; if not a GarbageCollectable, skip incref
    mov r15, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [r15]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 018h], r15                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$A$A$AfterGCIncref:                                      ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, rbx                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 008h]                                ; restore rcx (parameter count)
  mov r8, rbx                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 018h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; foo
dq method$CarrotRoot$foo$annotation
method$A$foo:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of foo to 0 (integer)
  je method$A$foo$parameterCountCheck$continuation               ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$foo$parameterCountCheck$continuation:                 ; end of parameter count check
  ; Line 139: return 1;
  ; sentinel check of 1 type Integer expecting Integer
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of foo into register to dereference it
  mov qword ptr [rdi], 001h                                      ; foo return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of foo into register to dereference it
  mov qword ptr [r12], 038h                                      ; type of foo return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B
dq method$B$B$annotation
method$B$B:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 048h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 088h]                                ; set up frame pointer
  ; Call _classAllocator with 1 arguments
  mov r10, offset B$vmt                                          ; reading vmt pointer for B for push
  push r10                                                       ; value of argument #1 (vmt pointer for B)
  push 038h                                                      ; type of argument #1 (Integer'38)
  lea rax, qword ptr [rsp + 040h]                                ; load address of return value's value
  push rax                                                       ; internal argument 6: pointer to return value slot's value
  lea rax, qword ptr [rsp + 040h]                                ; load address of return value's type
  push rax                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov qword ptr [rsp + 060h], rcx                                ; move parameter count of B's value out of rcx
  mov rcx, 001h                                                  ; internal argument 1: number of actual arguments
  call func$_classAllocator                                      ; jump to subroutine
  add rsp, 040h                                                  ; release shadow space and arguments (result in stack pointer)
  ; Call _createMethodPointer with 3 arguments
  push 008h                                                      ; value of argument #3 (code of IntegerFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$A$foo                                          ; reading foo for push
  push rbx                                                       ; value of argument #2 (foo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push qword ptr [rsp + 050h]                                    ; value of argument #1 (_classAllocator return value)
  push qword ptr [rsp + 050h]                                    ; type of argument #1
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 048h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting Whatever
  cmp qword ptr [rsp + 010h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$B$B$CreatemethodpointerReturnValue$TypeMatch        ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for _createMethodPointer return value
    ; Call __error with 1 arguments
    mov rdi, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$CreatemethodpointerReturnValue$TypeMatch:           ; after block
  mov r13, qword ptr [rsp + 030h]                                ; move "this" pointer to register to derefrence a field
  mov r11, qword ptr [rsp + 018h]                                ; indirect through r11 because operand pair (qword ptr [r13 + 048h], stack operand #4) is not allowed with mov
  mov qword ptr [r13 + 048h], r11                                ; store _createMethodPointer return value value in B.foo
  mov r11, qword ptr [rsp + 010h]                                ; indirect through r11 because operand pair (qword ptr [r13 + 040h], stack operand #5) is not allowed with mov
  mov qword ptr [r13 + 040h], r11                                ; store _createMethodPointer return value type in B.foo
  ; increment reference count for B.foo if necessary
  cmp qword ptr [r13 + 040h], 039h                               ; compare type of B.foo to String
  jne method$B$B$AfterStringIncref                               ; if not a String, skip incref
    mov r14, qword ptr [r13 + 048h]                              ; get B.foo into register to dereference it
    mov r15, qword ptr [r14]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$B$B$StringIncref                                  ; if reference count is negative (constant strings), skip incref
    jmp method$B$B$AfterStringIncref                             ; skip incref for string constants
    method$B$B$StringIncref:                                     ; real String
      mov r10, qword ptr [r13 + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [r10]                                        ; increment reference count of B.foo
  method$B$B$AfterStringIncref:                                  ; after String incref
  mov rax, qword ptr [r13 + 028h]                                ; get vmt
  add rax, 040h                                                  ; add offset for dereference (result in code address for B.constructor)
  mov rax, qword ptr [rax]                                       ; get call method
  mov rbx, 03bh                                                  ; store code of __CodeAddress value in code address for B.constructor's type slot
  mov qword ptr [rbp + 010h], rax                                ; copy address of 'B.constructor' method for use with "jmp" below
  ; type check of _classAllocator return value type __Object expecting B
  mov rsi, qword ptr [rsp + 028h]                                ; store _classAllocator return value's type in testByte value slot
  mov rax, rsi                                                   ; move testByte to testByte
  mov rdi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rdi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov r12, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, r12                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 002h                                       ; check that B return value is B
  jc method$B$B$bReturnValue$TypeMatch                           ; skip next block if the type matches
    ; Error handling block for B return value
    ; Call __error with 1 arguments
    mov r9, offset returnValueTypeCheckFailureMessage            ; reading returnValueTypeCheckFailureMessage for push
    push r9                                                      ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r8, qword ptr [rsp + 040h]                               ; load address of return value's value
    push r8                                                      ; internal argument 6: pointer to return value slot's value
    lea r8, qword ptr [rsp + 030h]                               ; load address of return value's type
    push r8                                                      ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$bReturnValue$TypeMatch:                             ; after block
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of B into register to dereference it
  mov qword ptr [r14], r13                                       ; B return value
  mov qword ptr [rsp + 030h], r13                                ; move _classAllocator return value's value out of r13
  mov r13, qword ptr [rsp + 028h]                                ; reading type of _classAllocator return value
  mov r15, qword ptr [rbp + 028h]                                ; get pointer to return value type of B into register to dereference it
  mov qword ptr [r15], r13                                       ; type of B return value
  ; increment reference count for _classAllocator return value if necessary
  mov r10, r13                                                   ; store _classAllocator return value's type in testByte value slot
  mov rax, r10                                                   ; move testByte to testByte
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$B$B$AfterGCIncref                                   ; if not a GarbageCollectable, skip incref
    mov rdi, qword ptr [rsp + 030h]                              ; read slot into register for dereferencing
    inc qword ptr [rdi]                                          ; increment reference count of _classAllocator return value
    mov qword ptr [rsp + 030h], rdi                              ; restoring slot (_classAllocator return value) to previous scope state for genuine block exit
  method$B$B$AfterGCIncref:                                      ; after GarbageCollectable incref
  ; Decrement reference count for _classAllocator return value (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r13                                                   ; arg #2: _classAllocator return value's type
  mov rcx, qword ptr [rsp + 050h]                                ; arg #1: _classAllocator return value's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; generateFinalSlotManagerCleanup!
  mov rcx, qword ptr [rsp + 020h]                                ; restore rcx (parameter count)
  mov r8, r13                                                    ; restore r8 (this type)
  mov r9, qword ptr [rsp + 030h]                                 ; restore r9 (this value)
  ; Epilog
  add rsp, 048h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  lea r11, qword ptr [rsp + 018h]                                ; give 'constructor' the location of our fake return type
  mov qword ptr [rsp + 028h], r11                                ; give 'constructor' the location of our fake return type
  lea r11, qword ptr [rsp + 020h]                                ; give 'constructor' the location of our fake return value
  mov qword ptr [rsp + 030h], r11                                ; give 'constructor' the location of our fake return value
  jmp qword ptr [rsp + 010h]                                     ; tail recurse into actual constructor

; setFoo
dq method$B$setFoo$annotation
method$B$setFoo:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 001h                                                  ; compare parameter count of setFoo to 1 (integer)
  je method$B$setFoo$parameterCountCheck$continuation            ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$setFoo$parameterCountCheck$continuation:              ; end of parameter count check
  ; Check type of parameter 0, v (expecting IntegerFunction)
  ; type check of v type IntegerFunction expecting IntegerFunction
  mov rbx, qword ptr [rbp + 038h]                                ; store v's type in testByte value slot
  mov rax, rbx                                                   ; move testByte to testByte
  mov rsi, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rsi                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 003h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rdi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rdi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 003h                                       ; check that v is IntegerFunction
  jc method$B$setFoo$v$TypeMatch                                 ; skip next block if the type matches
    ; Error handling block for v
    ; Call __error with 1 arguments
    mov r12, offset parameterTypeCheckFailureMessage             ; reading parameterTypeCheckFailureMessage for push
    push r12                                                     ; value of argument #1 (parameterTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r13                                                     ; internal argument 6: pointer to return value slot's value
    lea r13, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r13                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$setFoo$v$TypeMatch:                                   ; after block
  ; Line 146: foo = v;
  ; sentinel check of v type IntegerFunction expecting Whatever
  cmp qword ptr [rbp + 038h], 000h                               ; compare type of v to <sentinel>
  jne method$B$setFoo$v$TypeMatch$1                              ; skip next block if v is not sentinel
    ; Error handling block for v
    ; Call __error with 1 arguments
    mov r14, offset assignmentTypeCheckFailureMessage            ; reading assignmentTypeCheckFailureMessage for push
    push r14                                                     ; value of argument #1 (assignmentTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r15                                                     ; internal argument 6: pointer to return value slot's value
    lea r15, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r15                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$setFoo$v$TypeMatch$1:                                 ; after block
  mov rbx, r9                                                    ; move "this" pointer to register to derefrence a field
  mov r11, qword ptr [rbp + 040h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 048h], qword ptr [rbp + 040h]) is not allowed with mov
  mov qword ptr [rbx + 048h], r11                                ; store v value in B.foo
  mov r11, qword ptr [rbp + 038h]                                ; indirect through r11 because operand pair (qword ptr [rbx + 040h], qword ptr [rbp + 038h]) is not allowed with mov
  mov qword ptr [rbx + 040h], r11                                ; store v type in B.foo
  ; increment reference count for B.foo if necessary
  cmp qword ptr [rbx + 040h], 039h                               ; compare type of B.foo to String
  jne method$B$setFoo$AfterStringIncref                          ; if not a String, skip incref
    mov r10, qword ptr [rbx + 048h]                              ; get B.foo into register to dereference it
    mov rax, qword ptr [r10]                                     ; dereference string to get to reference count
    cmp rax, 0                                                   ; compare string reference count to 0
    jns method$B$setFoo$StringIncref                             ; if reference count is negative (constant strings), skip incref
    jmp method$B$setFoo$AfterStringIncref                        ; skip incref for string constants
    method$B$setFoo$StringIncref:                                ; real String
      mov rsi, qword ptr [rbx + 048h]                            ; read slot into register for dereferencing
      inc qword ptr [rsi]                                        ; increment reference count of B.foo
  method$B$setFoo$AfterStringIncref:                             ; after String incref
  ; Implicit return from setFoo
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of setFoo into register to dereference it
  mov qword ptr [r13], 000h                                      ; setFoo return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of setFoo into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of setFoo return value (Null'36)
  ; Decrement reference count for this variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, rbx                                                   ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; six
dq func$six$annotation
func$six:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of six to 0 (integer)
  je func$six$parameterCountCheck$continuation                   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  func$six$parameterCountCheck$continuation:                     ; end of parameter count check
  ; Line 150: return 6;
  ; sentinel check of 6 type Integer expecting Integer
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of six into register to dereference it
  mov qword ptr [rdi], 006h                                      ; six return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of six into register to dereference it
  mov qword ptr [r12], 038h                                      ; type of six return value (Integer'38)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __Object$constructor$getter
dq method$__Object$__Object$constructor$getter$annotation
method$__Object$__Object$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __Object$constructor$getter to 0 (integer)
  je method$__Object$__Object$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$__Object$__Object$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$__Object$__Object$constructor$getter$OBject$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for __Object$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$__Object$constructor$getter$OBject$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of __Object$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; __Object$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of __Object$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of __Object$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$__Object$__Object$constructor$getter$AfterGCIncref  ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$__Object$__Object$constructor$getter$AfterGCIncref:     ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __Object$constructor$setter
dq method$__Object$__Object$constructor$setter$annotation
method$__Object$__Object$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __Object$constructor$setter to 0 (integer)
  je method$__Object$__Object$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$__Object$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from __Object$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of __Object$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; __Object$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of __Object$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of __Object$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __Object$toString$getter
dq method$__Object$__Object$toString$getter$annotation
method$__Object$__Object$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __Object$toString$getter to 0 (integer)
  je method$__Object$__Object$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$__Object$__Object$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$__Object$__Object$toString$getter$OBject$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for __Object$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$__Object$toString$getter$OBject$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of __Object$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; __Object$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of __Object$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of __Object$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$__Object$__Object$toString$getter$AfterGCIncref     ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$__Object$__Object$toString$getter$AfterGCIncref:        ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: __Object'3c) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; __Object$toString$setter
dq method$__Object$__Object$toString$setter$annotation
method$__Object$__Object$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of __Object$toString$setter to 0 (integer)
  je method$__Object$__Object$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$__Object$__Object$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from __Object$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of __Object$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; __Object$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of __Object$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of __Object$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$constructor$getter
dq method$CarrotRoot$CarrotRoot$constructor$getter$annotation
method$CarrotRoot$CarrotRoot$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$constructor$getter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotRoot$CarrotRoot$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotRoot$CarrotRoot$constructor$getter$carrotroot$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotRoot$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$constructor$getter$carrotroot$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotRoot$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotRoot$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotRoot$CarrotRoot$constructor$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotRoot$CarrotRoot$constructor$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotRoot'43) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$constructor$setter
dq method$CarrotRoot$CarrotRoot$constructor$setter$annotation
method$CarrotRoot$CarrotRoot$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$constructor$setter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotRoot$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotRoot$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotRoot$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$toString$getter
dq method$CarrotRoot$CarrotRoot$toString$getter$annotation
method$CarrotRoot$CarrotRoot$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$toString$getter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotRoot$CarrotRoot$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotRoot$CarrotRoot$toString$getter$carrotroot$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotRoot$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$toString$getter$carrotroot$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotRoot$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotRoot$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotRoot$CarrotRoot$toString$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotRoot$CarrotRoot$toString$getter$AfterGCIncref:    ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotRoot'43) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$toString$setter
dq method$CarrotRoot$CarrotRoot$toString$setter$annotation
method$CarrotRoot$CarrotRoot$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$toString$setter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotRoot$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotRoot$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotRoot$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$foo$getter
dq method$CarrotRoot$CarrotRoot$foo$getter$annotation
method$CarrotRoot$CarrotRoot$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$foo$getter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$foo$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotRoot$CarrotRoot$foo$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotRoot$foo                                 ; reading foo for push
  push rbx                                                       ; value of argument #2 (foo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotRoot$CarrotRoot$foo$getter$carrotroot$foo$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotRoot$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$foo$getter$carrotroot$foo$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$foo$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotRoot$foo$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$foo$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotRoot$foo$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotRoot$CarrotRoot$foo$getter$AfterGCIncref      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotRoot$CarrotRoot$foo$getter$AfterGCIncref:         ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotRoot'43) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotRoot$foo$setter
dq method$CarrotRoot$CarrotRoot$foo$setter$annotation
method$CarrotRoot$CarrotRoot$foo$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotRoot$foo$setter to 0 (integer)
  je method$CarrotRoot$CarrotRoot$foo$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotRoot$CarrotRoot$foo$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotRoot$foo$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotRoot$foo$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotRoot$foo$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotRoot$foo$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotRoot$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$constructor$getter
dq method$CarrotBranchA$CarrotBranchA$constructor$getter$annotation
method$CarrotBranchA$CarrotBranchA$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$constructor$getter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchA$CarrotBranchA$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchA$CarrotBranchA$constructor$getter$carrotbrancha$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchA$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$constructor$getter$carrotbrancha$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchA$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchA$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchA$CarrotBranchA$constructor$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchA$CarrotBranchA$constructor$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$constructor$setter
dq method$CarrotBranchA$CarrotBranchA$constructor$setter$annotation
method$CarrotBranchA$CarrotBranchA$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$constructor$setter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchA$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchA$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchA$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$bar$getter
dq method$CarrotBranchA$CarrotBranchA$bar$getter$annotation
method$CarrotBranchA$CarrotBranchA$bar$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$bar$getter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$bar$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchA$CarrotBranchA$bar$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotBranchA$bar                              ; reading bar for push
  push rbx                                                       ; value of argument #2 (bar)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchA$CarrotBranchA$bar$getter$carrotbrancha$bar$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchA$bar$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$bar$getter$carrotbrancha$bar$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$bar$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchA$bar$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$bar$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchA$bar$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchA$CarrotBranchA$bar$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchA$CarrotBranchA$bar$getter$AfterGCIncref:   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$bar$setter
dq method$CarrotBranchA$CarrotBranchA$bar$setter$annotation
method$CarrotBranchA$CarrotBranchA$bar$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$bar$setter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$bar$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$bar$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchA$bar$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$bar$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchA$bar$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$bar$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchA$bar$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$toString$getter
dq method$CarrotBranchA$CarrotBranchA$toString$getter$annotation
method$CarrotBranchA$CarrotBranchA$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$toString$getter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchA$CarrotBranchA$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchA$CarrotBranchA$toString$getter$carrotbrancha$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchA$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$toString$getter$carrotbrancha$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchA$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchA$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchA$CarrotBranchA$toString$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchA$CarrotBranchA$toString$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$toString$setter
dq method$CarrotBranchA$CarrotBranchA$toString$setter$annotation
method$CarrotBranchA$CarrotBranchA$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$toString$setter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchA$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchA$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchA$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$foo$getter
dq method$CarrotBranchA$CarrotBranchA$foo$getter$annotation
method$CarrotBranchA$CarrotBranchA$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$foo$getter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$foo$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchA$CarrotBranchA$foo$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotRoot$foo                                 ; reading foo for push
  push rbx                                                       ; value of argument #2 (foo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchA$CarrotBranchA$foo$getter$carrotbrancha$foo$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchA$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$foo$getter$carrotbrancha$foo$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$foo$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchA$foo$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$foo$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchA$foo$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchA$CarrotBranchA$foo$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchA$CarrotBranchA$foo$getter$AfterGCIncref:   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchA'44) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchA$foo$setter
dq method$CarrotBranchA$CarrotBranchA$foo$setter$annotation
method$CarrotBranchA$CarrotBranchA$foo$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchA$foo$setter to 0 (integer)
  je method$CarrotBranchA$CarrotBranchA$foo$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchA$CarrotBranchA$foo$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchA$foo$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchA$foo$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchA$foo$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchA$foo$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchA$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$constructor$getter
dq method$CarrotLeafA$CarrotLeafA$constructor$getter$annotation
method$CarrotLeafA$CarrotLeafA$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$constructor$getter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotLeafA$constructor                        ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotLeafA$CarrotLeafA$constructor$getter$carrotleafa$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotLeafA$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$constructor$getter$carrotleafa$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotLeafA$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotLeafA$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$constructor$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotLeafA$CarrotLeafA$constructor$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$constructor$setter
dq method$CarrotLeafA$CarrotLeafA$constructor$setter$annotation
method$CarrotLeafA$CarrotLeafA$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$constructor$setter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotLeafA$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotLeafA$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotLeafA$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$bar$getter
dq method$CarrotLeafA$CarrotLeafA$bar$getter$annotation
method$CarrotLeafA$CarrotLeafA$bar$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$bar$getter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$bar$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$bar$getter$parameterCountCheck$continuation:  ; end of parameter count check
  mov rbx, qword ptr [r9 + 048h]                                 ; fetch value of CarrotLeafA.bar
  mov rsi, qword ptr [r9 + 040h]                                 ; fetch type of CarrotLeafA.bar
  ; sentinel check of CarrotLeafA.bar type NullFunction expecting NullFunction
  cmp rsi, 000h                                                  ; compare type of CarrotLeafA.bar to <sentinel>
  jne method$CarrotLeafA$CarrotLeafA$bar$getter$carrotleafa$bar$getterReturnValue$TypeMatch ; skip next block if CarrotLeafA.bar is not sentinel
    ; Error handling block for CarrotLeafA$bar$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$bar$getter$carrotleafa$bar$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$bar$getter into register to dereference it
  mov qword ptr [r13], rbx                                       ; CarrotLeafA$bar$getter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$bar$getter into register to dereference it
  mov qword ptr [r14], rsi                                       ; type of CarrotLeafA$bar$getter return value
  ; increment reference count for CarrotLeafA.bar if necessary
  mov r15, rsi                                                   ; store CarrotLeafA.bar's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 018h], rbx                                ; move CarrotLeafA.bar's value out of rbx
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$bar$getter$AfterGCIncref    ; if not a GarbageCollectable, skip incref
    mov qword ptr [rsp + 010h], rsi                              ; move CarrotLeafA.bar's type out of rsi
    mov rsi, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [rsi]                                          ; increment reference count of CarrotLeafA.bar
    mov qword ptr [rsp + 018h], rsi                              ; restoring slot (CarrotLeafA.bar) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 010h]                              ; restoring slot (CarrotLeafA.bar) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$bar$getter$AfterGCIncref:       ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, r9                                                    ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  mov qword ptr [rsp + 030h], r9                                 ; move this variable's value out of r9
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$bar$setter
dq method$CarrotLeafA$CarrotLeafA$bar$setter$annotation
method$CarrotLeafA$CarrotLeafA$bar$setter:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$bar$setter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$bar$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$bar$setter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Implicit return from CarrotLeafA$bar$setter
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$bar$setter into register to dereference it
  mov qword ptr [rdi], 000h                                      ; CarrotLeafA$bar$setter return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$bar$setter into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of CarrotLeafA$bar$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$toString$getter
dq method$CarrotLeafA$CarrotLeafA$toString$getter$annotation
method$CarrotLeafA$CarrotLeafA$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$toString$getter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotLeafA$CarrotLeafA$toString$getter$carrotleafa$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotLeafA$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$toString$getter$carrotleafa$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotLeafA$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotLeafA$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$toString$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotLeafA$CarrotLeafA$toString$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$toString$setter
dq method$CarrotLeafA$CarrotLeafA$toString$setter$annotation
method$CarrotLeafA$CarrotLeafA$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$toString$setter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotLeafA$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotLeafA$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotLeafA$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$foo$getter
dq method$CarrotLeafA$CarrotLeafA$foo$getter$annotation
method$CarrotLeafA$CarrotLeafA$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$foo$getter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$foo$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$foo$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotRoot$foo                                 ; reading foo for push
  push rbx                                                       ; value of argument #2 (foo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotLeafA$CarrotLeafA$foo$getter$carrotleafa$foo$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotLeafA$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$foo$getter$carrotleafa$foo$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$foo$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotLeafA$foo$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$foo$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotLeafA$foo$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$foo$getter$AfterGCIncref    ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotLeafA$CarrotLeafA$foo$getter$AfterGCIncref:       ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$foo$setter
dq method$CarrotLeafA$CarrotLeafA$foo$setter$annotation
method$CarrotLeafA$CarrotLeafA$foo$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$foo$setter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$foo$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$foo$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotLeafA$foo$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$foo$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotLeafA$foo$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$foo$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotLeafA$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$barImpl$getter
dq method$CarrotLeafA$CarrotLeafA$barImpl$getter$annotation
method$CarrotLeafA$CarrotLeafA$barImpl$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$barImpl$getter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$barImpl$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotLeafA$CarrotLeafA$barImpl$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotLeafA$barImpl                            ; reading barImpl for push
  push rbx                                                       ; value of argument #2 (barImpl)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotLeafA$CarrotLeafA$barImpl$getter$carrotleafa$barimpl$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotLeafA$barImpl$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$barImpl$getter$carrotleafa$barimpl$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$barImpl$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotLeafA$barImpl$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$barImpl$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotLeafA$barImpl$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotLeafA$CarrotLeafA$barImpl$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotLeafA$CarrotLeafA$barImpl$getter$AfterGCIncref:   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotLeafA'45) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotLeafA$barImpl$setter
dq method$CarrotLeafA$CarrotLeafA$barImpl$setter$annotation
method$CarrotLeafA$CarrotLeafA$barImpl$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotLeafA$barImpl$setter to 0 (integer)
  je method$CarrotLeafA$CarrotLeafA$barImpl$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotLeafA$CarrotLeafA$barImpl$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotLeafA$barImpl$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotLeafA$barImpl$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotLeafA$barImpl$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotLeafA$barImpl$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotLeafA$barImpl$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$constructor$getter
dq method$CarrotBranchB$CarrotBranchB$constructor$getter$annotation
method$CarrotBranchB$CarrotBranchB$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$constructor$getter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotBranchB$constructor                      ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchB$CarrotBranchB$constructor$getter$carrotbranchb$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchB$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$constructor$getter$carrotbranchb$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchB$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchB$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$constructor$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchB$CarrotBranchB$constructor$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$constructor$setter
dq method$CarrotBranchB$CarrotBranchB$constructor$setter$annotation
method$CarrotBranchB$CarrotBranchB$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$constructor$setter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchB$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchB$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchB$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$fooImpl$getter
dq method$CarrotBranchB$CarrotBranchB$fooImpl$getter$annotation
method$CarrotBranchB$CarrotBranchB$fooImpl$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$fooImpl$getter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$fooImpl$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$fooImpl$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotBranchB$fooImpl                          ; reading fooImpl for push
  push rbx                                                       ; value of argument #2 (fooImpl)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchB$CarrotBranchB$fooImpl$getter$carrotbranchb$fooimpl$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchB$fooImpl$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$fooImpl$getter$carrotbranchb$fooimpl$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$fooImpl$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchB$fooImpl$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$fooImpl$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchB$fooImpl$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$fooImpl$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchB$CarrotBranchB$fooImpl$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$fooImpl$setter
dq method$CarrotBranchB$CarrotBranchB$fooImpl$setter$annotation
method$CarrotBranchB$CarrotBranchB$fooImpl$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$fooImpl$setter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$fooImpl$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$fooImpl$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchB$fooImpl$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$fooImpl$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchB$fooImpl$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$fooImpl$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchB$fooImpl$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$bar$getter
dq method$CarrotBranchB$CarrotBranchB$bar$getter$annotation
method$CarrotBranchB$CarrotBranchB$bar$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$bar$getter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$bar$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$bar$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$CarrotBranchB$bar                              ; reading bar for push
  push rbx                                                       ; value of argument #2 (bar)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchB$CarrotBranchB$bar$getter$carrotbranchb$bar$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchB$bar$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$bar$getter$carrotbranchb$bar$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$bar$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchB$bar$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$bar$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchB$bar$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$bar$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchB$CarrotBranchB$bar$getter$AfterGCIncref:   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$bar$setter
dq method$CarrotBranchB$CarrotBranchB$bar$setter$annotation
method$CarrotBranchB$CarrotBranchB$bar$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$bar$setter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$bar$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$bar$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchB$bar$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$bar$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchB$bar$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$bar$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchB$bar$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$toString$getter
dq method$CarrotBranchB$CarrotBranchB$toString$getter$annotation
method$CarrotBranchB$CarrotBranchB$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$toString$getter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$CarrotBranchB$CarrotBranchB$toString$getter$carrotbranchb$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for CarrotBranchB$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$toString$getter$carrotbranchb$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; CarrotBranchB$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of CarrotBranchB$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$toString$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$CarrotBranchB$CarrotBranchB$toString$getter$AfterGCIncref:  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$toString$setter
dq method$CarrotBranchB$CarrotBranchB$toString$setter$annotation
method$CarrotBranchB$CarrotBranchB$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$toString$setter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from CarrotBranchB$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; CarrotBranchB$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of CarrotBranchB$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$foo$getter
dq method$CarrotBranchB$CarrotBranchB$foo$getter$annotation
method$CarrotBranchB$CarrotBranchB$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$foo$getter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$foo$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$foo$getter$parameterCountCheck$continuation:  ; end of parameter count check
  mov rbx, qword ptr [r9 + 048h]                                 ; fetch value of CarrotBranchB.foo
  mov rsi, qword ptr [r9 + 040h]                                 ; fetch type of CarrotBranchB.foo
  ; sentinel check of CarrotBranchB.foo type NullFunction expecting NullFunction
  cmp rsi, 000h                                                  ; compare type of CarrotBranchB.foo to <sentinel>
  jne method$CarrotBranchB$CarrotBranchB$foo$getter$carrotbranchb$foo$getterReturnValue$TypeMatch ; skip next block if CarrotBranchB.foo is not sentinel
    ; Error handling block for CarrotBranchB$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$foo$getter$carrotbranchb$foo$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$foo$getter into register to dereference it
  mov qword ptr [r13], rbx                                       ; CarrotBranchB$foo$getter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$foo$getter into register to dereference it
  mov qword ptr [r14], rsi                                       ; type of CarrotBranchB$foo$getter return value
  ; increment reference count for CarrotBranchB.foo if necessary
  mov r15, rsi                                                   ; store CarrotBranchB.foo's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 018h], rbx                                ; move CarrotBranchB.foo's value out of rbx
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$CarrotBranchB$CarrotBranchB$foo$getter$AfterGCIncref ; if not a GarbageCollectable, skip incref
    mov qword ptr [rsp + 010h], rsi                              ; move CarrotBranchB.foo's type out of rsi
    mov rsi, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [rsi]                                          ; increment reference count of CarrotBranchB.foo
    mov qword ptr [rsp + 018h], rsi                              ; restoring slot (CarrotBranchB.foo) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 010h]                              ; restoring slot (CarrotBranchB.foo) to previous scope state for genuine block exit
  method$CarrotBranchB$CarrotBranchB$foo$getter$AfterGCIncref:   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: CarrotBranchB'46) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, r9                                                    ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  mov qword ptr [rsp + 030h], r9                                 ; move this variable's value out of r9
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; CarrotBranchB$foo$setter
dq method$CarrotBranchB$CarrotBranchB$foo$setter$annotation
method$CarrotBranchB$CarrotBranchB$foo$setter:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of CarrotBranchB$foo$setter to 0 (integer)
  je method$CarrotBranchB$CarrotBranchB$foo$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$CarrotBranchB$CarrotBranchB$foo$setter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Implicit return from CarrotBranchB$foo$setter
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of CarrotBranchB$foo$setter into register to dereference it
  mov qword ptr [rdi], 000h                                      ; CarrotBranchB$foo$setter return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of CarrotBranchB$foo$setter into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of CarrotBranchB$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$constructor$getter
dq method$A$A$constructor$getter$annotation
method$A$A$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$constructor$getter to 0 (integer)
  je method$A$A$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$A$A$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$A$A$constructor$getter$a$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for A$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$constructor$getter$a$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of A$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; A$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of A$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$A$A$constructor$getter$AfterGCIncref                ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$A$A$constructor$getter$AfterGCIncref:                   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: A'47) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$constructor$setter
dq method$A$A$constructor$setter$annotation
method$A$A$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$constructor$setter to 0 (integer)
  je method$A$A$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from A$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of A$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; A$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of A$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$toString$getter
dq method$A$A$toString$getter$annotation
method$A$A$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$toString$getter to 0 (integer)
  je method$A$A$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$A$A$toString$getter$parameterCountCheck$continuation:   ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$A$A$toString$getter$a$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for A$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$toString$getter$a$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of A$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; A$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of A$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$A$A$toString$getter$AfterGCIncref                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$A$A$toString$getter$AfterGCIncref:                      ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: A'47) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$toString$setter
dq method$A$A$toString$setter$annotation
method$A$A$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$toString$setter to 0 (integer)
  je method$A$A$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$toString$setter$parameterCountCheck$continuation:   ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from A$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of A$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; A$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of A$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$foo$getter
dq method$A$A$foo$getter$annotation
method$A$A$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$foo$getter to 0 (integer)
  je method$A$A$foo$getter$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$A$A$foo$getter$parameterCountCheck$continuation:        ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 008h                                                      ; value of argument #3 (code of IntegerFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$A$foo                                          ; reading foo for push
  push rbx                                                       ; value of argument #2 (foo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting IntegerFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$A$A$foo$getter$a$foo$getterReturnValue$TypeMatch    ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for A$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$foo$getter$a$foo$getterReturnValue$TypeMatch:       ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of A$foo$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; A$foo$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$foo$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of A$foo$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$A$A$foo$getter$AfterGCIncref                        ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$A$A$foo$getter$AfterGCIncref:                           ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: A'47) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; A$foo$setter
dq method$A$A$foo$setter$annotation
method$A$A$foo$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of A$foo$setter to 0 (integer)
  je method$A$A$foo$setter$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$A$A$foo$setter$parameterCountCheck$continuation:        ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from A$foo$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of A$foo$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; A$foo$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of A$foo$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of A$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$setFoo$getter
dq method$B$B$setFoo$getter$annotation
method$B$B$setFoo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$setFoo$getter to 0 (integer)
  je method$B$B$setFoo$getter$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$B$setFoo$getter$parameterCountCheck$continuation:     ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 02fh                                                      ; value of argument #3 (code of NullFunction(IntegerFunction))
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$B$setFoo                                       ; reading setFoo for push
  push rbx                                                       ; value of argument #2 (setFoo)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction(IntegerFunction)
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$B$B$setFoo$getter$b$setfoo$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for B$setFoo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$setFoo$getter$b$setfoo$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of B$setFoo$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; B$setFoo$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$setFoo$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of B$setFoo$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$B$B$setFoo$getter$AfterGCIncref                     ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$B$B$setFoo$getter$AfterGCIncref:                        ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$setFoo$setter
dq method$B$B$setFoo$setter$annotation
method$B$B$setFoo$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$setFoo$setter to 0 (integer)
  je method$B$B$setFoo$setter$parameterCountCheck$continuation   ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$setFoo$setter$parameterCountCheck$continuation:     ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from B$setFoo$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of B$setFoo$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; B$setFoo$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$setFoo$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of B$setFoo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$constructor$getter
dq method$B$B$constructor$getter$annotation
method$B$B$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$constructor$getter to 0 (integer)
  je method$B$B$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$B$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$B$B$constructor$getter$b$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for B$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$constructor$getter$b$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of B$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; B$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of B$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$B$B$constructor$getter$AfterGCIncref                ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$B$B$constructor$getter$AfterGCIncref:                   ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$constructor$setter
dq method$B$B$constructor$setter$annotation
method$B$B$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$constructor$setter to 0 (integer)
  je method$B$B$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from B$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of B$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; B$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of B$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$toString$getter
dq method$B$B$toString$getter$annotation
method$B$B$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$toString$getter to 0 (integer)
  je method$B$B$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$B$toString$getter$parameterCountCheck$continuation:   ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$B$B$toString$getter$b$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for B$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$toString$getter$b$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of B$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; B$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of B$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$B$B$toString$getter$AfterGCIncref                   ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$B$B$toString$getter$AfterGCIncref:                      ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$toString$setter
dq method$B$B$toString$setter$annotation
method$B$B$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$toString$setter to 0 (integer)
  je method$B$B$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$toString$setter$parameterCountCheck$continuation:   ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from B$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of B$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; B$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of B$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$foo$getter
dq method$B$B$foo$getter$annotation
method$B$B$foo$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$foo$getter to 0 (integer)
  je method$B$B$foo$getter$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$B$foo$getter$parameterCountCheck$continuation:        ; end of parameter count check
  mov rbx, qword ptr [r9 + 048h]                                 ; fetch value of B.foo
  mov rsi, qword ptr [r9 + 040h]                                 ; fetch type of B.foo
  ; sentinel check of B.foo type Whatever expecting Whatever
  cmp rsi, 000h                                                  ; compare type of B.foo to <sentinel>
  jne method$B$B$foo$getter$b$foo$getterReturnValue$TypeMatch    ; skip next block if B.foo is not sentinel
    ; Error handling block for B$foo$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$B$B$foo$getter$b$foo$getterReturnValue$TypeMatch:       ; after block
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of B$foo$getter into register to dereference it
  mov qword ptr [r13], rbx                                       ; B$foo$getter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$foo$getter into register to dereference it
  mov qword ptr [r14], rsi                                       ; type of B$foo$getter return value
  ; increment reference count for B.foo if necessary
  mov r15, rsi                                                   ; store B.foo's type in testByte value slot
  mov rax, r15                                                   ; move testByte to testByte
  mov r10, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul r10                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov qword ptr [rsp + 018h], rbx                                ; move B.foo's value out of rbx
  mov rbx, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rbx                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$B$B$foo$getter$AfterGCIncref                        ; if not a GarbageCollectable, skip incref
    mov qword ptr [rsp + 010h], rsi                              ; move B.foo's type out of rsi
    mov rsi, qword ptr [rsp + 018h]                              ; read slot into register for dereferencing
    inc qword ptr [rsi]                                          ; increment reference count of B.foo
    mov qword ptr [rsp + 018h], rsi                              ; restoring slot (B.foo) to previous scope state for genuine block exit
    mov rsi, qword ptr [rsp + 010h]                              ; restoring slot (B.foo) to previous scope state for genuine block exit
  method$B$B$foo$getter$AfterGCIncref:                           ; after GarbageCollectable incref
  cmp rsi, 039h                                                  ; compare type of B.foo to String
  jne method$B$B$foo$getter$AfterStringIncref                    ; if not a String, skip incref
    mov rdi, qword ptr [rsp + 018h]                              ; get B.foo into register to dereference it
    mov r12, qword ptr [rdi]                                     ; dereference string to get to reference count
    cmp r12, 0                                                   ; compare string reference count to 0
    jns method$B$B$foo$getter$StringIncref                       ; if reference count is negative (constant strings), skip incref
    mov qword ptr [rsp + 018h], rdi                              ; restoring slot (???) to previous scope state for synthetic block exit
    jmp method$B$B$foo$getter$AfterStringIncref                  ; skip incref for string constants
    method$B$B$foo$getter$StringIncref:                          ; real String
      inc qword ptr [rdi]                                        ; increment reference count of B.foo
    mov qword ptr [rsp + 018h], rdi                              ; restoring slot (B.foo) to previous scope state for genuine block exit
  method$B$B$foo$getter$AfterStringIncref:                       ; after String incref
  ; Decrement reference count for this variable (static type: B'48) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, r9                                                    ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  mov qword ptr [rsp + 030h], r9                                 ; move this variable's value out of r9
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; B$foo$setter
dq method$B$B$foo$setter$annotation
method$B$B$foo$setter:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of B$foo$setter to 0 (integer)
  je method$B$B$foo$setter$parameterCountCheck$continuation      ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$B$B$foo$setter$parameterCountCheck$continuation:        ; end of parameter count check
  ; Implicit return from B$foo$setter
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of B$foo$setter into register to dereference it
  mov qword ptr [rdi], 000h                                      ; B$foo$setter return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of B$foo$setter into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of B$foo$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$constructor$getter
dq method$BunnyA$BunnyA$constructor$getter$annotation
method$BunnyA$BunnyA$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$constructor$getter to 0 (integer)
  je method$BunnyA$BunnyA$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyA$BunnyA$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyA$BunnyA$constructor$getter$bunnya$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyA$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$constructor$getter$bunnya$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyA$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyA$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyA$BunnyA$constructor$getter$AfterGCIncref      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyA$BunnyA$constructor$getter$AfterGCIncref:         ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyA'41) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$constructor$setter
dq method$BunnyA$BunnyA$constructor$setter$annotation
method$BunnyA$BunnyA$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$constructor$setter to 0 (integer)
  je method$BunnyA$BunnyA$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyA$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyA$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyA$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$test$getter
dq method$BunnyA$BunnyA$test$getter$annotation
method$BunnyA$BunnyA$test$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$test$getter to 0 (integer)
  je method$BunnyA$BunnyA$test$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyA$BunnyA$test$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$BunnyA$test                                    ; reading test for push
  push rbx                                                       ; value of argument #2 (test)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyA$BunnyA$test$getter$bunnya$test$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyA$test$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$test$getter$bunnya$test$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$test$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyA$test$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$test$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyA$test$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyA$BunnyA$test$getter$AfterGCIncref             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyA$BunnyA$test$getter$AfterGCIncref:                ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyA'41) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$test$setter
dq method$BunnyA$BunnyA$test$setter$annotation
method$BunnyA$BunnyA$test$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$test$setter to 0 (integer)
  je method$BunnyA$BunnyA$test$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$test$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyA$test$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$test$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyA$test$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$test$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyA$test$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$toString$getter
dq method$BunnyA$BunnyA$toString$getter$annotation
method$BunnyA$BunnyA$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$toString$getter to 0 (integer)
  je method$BunnyA$BunnyA$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyA$BunnyA$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyA$BunnyA$toString$getter$bunnya$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyA$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$toString$getter$bunnya$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyA$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyA$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyA$BunnyA$toString$getter$AfterGCIncref         ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyA$BunnyA$toString$getter$AfterGCIncref:            ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyA'41) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyA$toString$setter
dq method$BunnyA$BunnyA$toString$setter$annotation
method$BunnyA$BunnyA$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyA$toString$setter to 0 (integer)
  je method$BunnyA$BunnyA$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyA$BunnyA$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyA$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyA$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyA$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyA$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyA$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$constructor$getter
dq method$BunnyB$BunnyB$constructor$getter$annotation
method$BunnyB$BunnyB$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$constructor$getter to 0 (integer)
  je method$BunnyB$BunnyB$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyB$BunnyB$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyB$BunnyB$constructor$getter$bunnyb$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyB$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$constructor$getter$bunnyb$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyB$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyB$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$BunnyB$constructor$getter$AfterGCIncref      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyB$BunnyB$constructor$getter$AfterGCIncref:         ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$constructor$setter
dq method$BunnyB$BunnyB$constructor$setter$annotation
method$BunnyB$BunnyB$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$constructor$setter to 0 (integer)
  je method$BunnyB$BunnyB$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyB$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyB$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyB$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$grab$getter
dq method$BunnyB$BunnyB$grab$getter$annotation
method$BunnyB$BunnyB$grab$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$grab$getter to 0 (integer)
  je method$BunnyB$BunnyB$grab$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyB$BunnyB$grab$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 027h                                                      ; value of argument #3 (code of NullFunctionFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$BunnyB$grab                                    ; reading grab for push
  push rbx                                                       ; value of argument #2 (grab)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunctionFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyB$BunnyB$grab$getter$bunnyb$grab$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyB$grab$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$grab$getter$bunnyb$grab$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$grab$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyB$grab$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$grab$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyB$grab$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$BunnyB$grab$getter$AfterGCIncref             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyB$BunnyB$grab$getter$AfterGCIncref:                ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$grab$setter
dq method$BunnyB$BunnyB$grab$setter$annotation
method$BunnyB$BunnyB$grab$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$grab$setter to 0 (integer)
  je method$BunnyB$BunnyB$grab$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$grab$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyB$grab$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$grab$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyB$grab$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$grab$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyB$grab$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$test$getter
dq method$BunnyB$BunnyB$test$getter$annotation
method$BunnyB$BunnyB$test$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$test$getter to 0 (integer)
  je method$BunnyB$BunnyB$test$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyB$BunnyB$test$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$BunnyB$test                                    ; reading test for push
  push rbx                                                       ; value of argument #2 (test)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyB$BunnyB$test$getter$bunnyb$test$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyB$test$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$test$getter$bunnyb$test$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$test$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyB$test$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$test$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyB$test$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$BunnyB$test$getter$AfterGCIncref             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyB$BunnyB$test$getter$AfterGCIncref:                ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$test$setter
dq method$BunnyB$BunnyB$test$setter$annotation
method$BunnyB$BunnyB$test$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$test$setter to 0 (integer)
  je method$BunnyB$BunnyB$test$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$test$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyB$test$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$test$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyB$test$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$test$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyB$test$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$toString$getter
dq method$BunnyB$BunnyB$toString$getter$annotation
method$BunnyB$BunnyB$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$toString$getter to 0 (integer)
  je method$BunnyB$BunnyB$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$BunnyB$BunnyB$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$BunnyB$BunnyB$toString$getter$bunnyb$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for BunnyB$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$toString$getter$bunnyb$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; BunnyB$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of BunnyB$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$BunnyB$BunnyB$toString$getter$AfterGCIncref         ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$BunnyB$BunnyB$toString$getter$AfterGCIncref:            ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: BunnyB'42) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; BunnyB$toString$setter
dq method$BunnyB$BunnyB$toString$setter$annotation
method$BunnyB$BunnyB$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of BunnyB$toString$setter to 0 (integer)
  je method$BunnyB$BunnyB$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$BunnyB$BunnyB$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from BunnyB$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of BunnyB$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; BunnyB$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of BunnyB$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of BunnyB$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Object$constructor$getter
dq method$Object$Object$constructor$getter$annotation
method$Object$Object$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Object$constructor$getter to 0 (integer)
  je method$Object$Object$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Object$Object$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Object$constructor                             ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Object$Object$constructor$getter$object$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Object$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$Object$constructor$getter$object$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Object$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Object$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Object$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Object$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Object$Object$constructor$getter$AfterGCIncref      ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Object$Object$constructor$getter$AfterGCIncref:         ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Object'3e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Object$constructor$setter
dq method$Object$Object$constructor$setter$annotation
method$Object$Object$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Object$constructor$setter to 0 (integer)
  je method$Object$Object$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$Object$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Object$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Object$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Object$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Object$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Object$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Object$toString$getter
dq method$Object$Object$toString$getter$annotation
method$Object$Object$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Object$toString$getter to 0 (integer)
  je method$Object$Object$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Object$Object$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Object$Object$toString$getter$object$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Object$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$Object$toString$getter$object$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Object$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Object$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Object$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Object$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Object$Object$toString$getter$AfterGCIncref         ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Object$Object$toString$getter$AfterGCIncref:            ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Object'3e) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Object$toString$setter
dq method$Object$Object$toString$setter$annotation
method$Object$Object$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Object$toString$setter to 0 (integer)
  je method$Object$Object$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Object$Object$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Object$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Object$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Object$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Object$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Object$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$mutateField$getter
dq method$Test$Test$mutateField$getter$annotation
method$Test$Test$mutateField$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$mutateField$getter to 0 (integer)
  je method$Test$Test$mutateField$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$mutateField$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 00ah                                                      ; value of argument #3 (code of NullFunction(String))
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Test$mutateField                               ; reading mutateField for push
  push rbx                                                       ; value of argument #2 (mutateField)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction(String)
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Test$Test$mutateField$getter$test$mutatefield$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Test$mutateField$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$mutateField$getter$test$mutatefield$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$mutateField$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Test$mutateField$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$mutateField$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Test$mutateField$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Test$Test$mutateField$getter$AfterGCIncref          ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Test$Test$mutateField$getter$AfterGCIncref:             ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$mutateField$setter
dq method$Test$Test$mutateField$setter$annotation
method$Test$Test$mutateField$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$mutateField$setter to 0 (integer)
  je method$Test$Test$mutateField$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$mutateField$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Test$mutateField$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$mutateField$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Test$mutateField$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$mutateField$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Test$mutateField$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$constructor$getter
dq method$Test$Test$constructor$getter$annotation
method$Test$Test$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$constructor$getter to 0 (integer)
  je method$Test$Test$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 003h                                                      ; value of argument #3 (code of NullFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Object$constructor                             ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Test$Test$constructor$getter$test$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Test$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$constructor$getter$test$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Test$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Test$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Test$Test$constructor$getter$AfterGCIncref          ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Test$Test$constructor$getter$AfterGCIncref:             ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$constructor$setter
dq method$Test$Test$constructor$setter$annotation
method$Test$Test$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$constructor$setter to 0 (integer)
  je method$Test$Test$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Test$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Test$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Test$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$method$getter
dq method$Test$Test$method$getter$annotation
method$Test$Test$method$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$method$getter to 0 (integer)
  je method$Test$Test$method$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$method$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Test$method                                    ; reading method for push
  push rbx                                                       ; value of argument #2 (method)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Test$Test$method$getter$test$method$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Test$method$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$method$getter$test$method$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$method$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Test$method$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$method$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Test$method$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Test$Test$method$getter$AfterGCIncref               ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Test$Test$method$getter$AfterGCIncref:                  ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$method$setter
dq method$Test$Test$method$setter$annotation
method$Test$Test$method$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$method$setter to 0 (integer)
  je method$Test$Test$method$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$method$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Test$method$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$method$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Test$method$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$method$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Test$method$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$toString$getter
dq method$Test$Test$toString$getter$annotation
method$Test$Test$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$toString$getter to 0 (integer)
  je method$Test$Test$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Test$Test$toString$getter$test$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Test$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$toString$getter$test$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Test$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Test$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Test$Test$toString$getter$AfterGCIncref             ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Test$Test$toString$getter$AfterGCIncref:                ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$toString$setter
dq method$Test$Test$toString$setter$annotation
method$Test$Test$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$toString$setter to 0 (integer)
  je method$Test$Test$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Test$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Test$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Test$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$field$getter
dq method$Test$Test$field$getter$annotation
method$Test$Test$field$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$field$getter to 0 (integer)
  je method$Test$Test$field$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$field$getter$parameterCountCheck$continuation:  ; end of parameter count check
  mov rbx, qword ptr [r9 + 048h]                                 ; fetch value of Test.field
  mov rsi, qword ptr [r9 + 040h]                                 ; fetch type of Test.field
  ; sentinel check of Test.field type String expecting String
  cmp rsi, 000h                                                  ; compare type of Test.field to <sentinel>
  jne method$Test$Test$field$getter$test$field$getterReturnValue$TypeMatch ; skip next block if Test.field is not sentinel
    ; Error handling block for Test$field$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Test$Test$field$getter$test$field$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$field$getter into register to dereference it
  mov qword ptr [r13], rbx                                       ; Test$field$getter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$field$getter into register to dereference it
  mov qword ptr [r14], rsi                                       ; type of Test$field$getter return value
  ; increment reference count for Test.field if necessary
  cmp rsi, 039h                                                  ; compare type of Test.field to String
  jne method$Test$Test$field$getter$AfterStringIncref            ; if not a String, skip incref
    mov r15, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$Test$Test$field$getter$StringIncref               ; if reference count is negative (constant strings), skip incref
    jmp method$Test$Test$field$getter$AfterStringIncref          ; skip incref for string constants
    method$Test$Test$field$getter$StringIncref:                  ; real String
      inc qword ptr [rbx]                                        ; increment reference count of Test.field
  method$Test$Test$field$getter$AfterStringIncref:               ; after String incref
  ; Decrement reference count for this variable (static type: Test'3f) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, r9                                                    ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  mov qword ptr [rsp + 030h], r9                                 ; move this variable's value out of r9
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Test$field$setter
dq method$Test$Test$field$setter$annotation
method$Test$Test$field$setter:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Test$field$setter to 0 (integer)
  je method$Test$Test$field$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Test$Test$field$setter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Implicit return from Test$field$setter
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of Test$field$setter into register to dereference it
  mov qword ptr [rdi], 000h                                      ; Test$field$setter return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of Test$field$setter into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of Test$field$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$mutateField$getter
dq method$Subclass$Subclass$mutateField$getter$annotation
method$Subclass$Subclass$mutateField$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$mutateField$getter to 0 (integer)
  je method$Subclass$Subclass$mutateField$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$mutateField$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 00ah                                                      ; value of argument #3 (code of NullFunction(String))
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Test$mutateField                               ; reading mutateField for push
  push rbx                                                       ; value of argument #2 (mutateField)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction(String)
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Subclass$Subclass$mutateField$getter$subclass$mutatefield$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Subclass$mutateField$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$mutateField$getter$subclass$mutatefield$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$mutateField$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Subclass$mutateField$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$mutateField$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Subclass$mutateField$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Subclass$Subclass$mutateField$getter$AfterGCIncref  ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Subclass$Subclass$mutateField$getter$AfterGCIncref:     ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$mutateField$setter
dq method$Subclass$Subclass$mutateField$setter$annotation
method$Subclass$Subclass$mutateField$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$mutateField$setter to 0 (integer)
  je method$Subclass$Subclass$mutateField$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$mutateField$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Subclass$mutateField$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$mutateField$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Subclass$mutateField$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$mutateField$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Subclass$mutateField$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$constructor$getter
dq method$Subclass$Subclass$constructor$getter$annotation
method$Subclass$Subclass$constructor$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$constructor$getter to 0 (integer)
  je method$Subclass$Subclass$constructor$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$constructor$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 00ah                                                      ; value of argument #3 (code of NullFunction(String))
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Subclass$constructor                           ; reading constructor for push
  push rbx                                                       ; value of argument #2 (constructor)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting NullFunction(String)
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Subclass$Subclass$constructor$getter$subclass$constructor$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Subclass$constructor$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$constructor$getter$subclass$constructor$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$constructor$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Subclass$constructor$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$constructor$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Subclass$constructor$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Subclass$Subclass$constructor$getter$AfterGCIncref  ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Subclass$Subclass$constructor$getter$AfterGCIncref:     ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$constructor$setter
dq method$Subclass$Subclass$constructor$setter$annotation
method$Subclass$Subclass$constructor$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$constructor$setter to 0 (integer)
  je method$Subclass$Subclass$constructor$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$constructor$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Subclass$constructor$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$constructor$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Subclass$constructor$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$constructor$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Subclass$constructor$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$method$getter
dq method$Subclass$Subclass$method$getter$annotation
method$Subclass$Subclass$method$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$method$getter to 0 (integer)
  je method$Subclass$Subclass$method$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$method$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$Test$method                                    ; reading method for push
  push rbx                                                       ; value of argument #2 (method)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Subclass$Subclass$method$getter$subclass$method$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Subclass$method$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$method$getter$subclass$method$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$method$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Subclass$method$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$method$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Subclass$method$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Subclass$Subclass$method$getter$AfterGCIncref       ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Subclass$Subclass$method$getter$AfterGCIncref:          ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$method$setter
dq method$Subclass$Subclass$method$setter$annotation
method$Subclass$Subclass$method$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$method$setter to 0 (integer)
  je method$Subclass$Subclass$method$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$method$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Subclass$method$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$method$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Subclass$method$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$method$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Subclass$method$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$toString$getter
dq method$Subclass$Subclass$toString$getter$annotation
method$Subclass$Subclass$toString$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 038h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 078h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$toString$getter to 0 (integer)
  je method$Subclass$Subclass$toString$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 038h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 058h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 050h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 018h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 010h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$toString$getter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Call _createMethodPointer with 3 arguments
  push 016h                                                      ; value of argument #3 (code of StringFunction())
  push 038h                                                      ; type of argument #3 (Integer'38)
  mov rbx, method$__Object$toString                              ; reading toString for push
  push rbx                                                       ; value of argument #2 (toString)
  push 03bh                                                      ; type of argument #2 (__CodeAddress'3b)
  push r9                                                        ; value of argument #1 (this variable)
  push r8                                                        ; type of argument #1
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's value
  push rsi                                                       ; internal argument 6: pointer to return value slot's value
  lea rsi, qword ptr [rsp + 058h]                                ; load address of return value's type
  push rsi                                                       ; internal argument 5: pointer to return value slot's type
  sub rsp, 020h                                                  ; allocate shadow space
  mov qword ptr [rsp + 078h], r9                                 ; move this variable's value out of r9
  mov r9, 000h                                                   ; internal argument 4: "this" pointer
  mov qword ptr [rsp + 070h], r8                                 ; move this variable's type out of r8
  mov r8, 000h                                                   ; internal argument 3: "this" pointer type
  mov rdx, 000h                                                  ; internal argument 2: closure pointer
  mov rcx, 003h                                                  ; internal argument 1: number of actual arguments
  call func$_createMethodPointer                                 ; jump to subroutine
  add rsp, 060h                                                  ; release shadow space and arguments (result in stack pointer)
  ; sentinel check of _createMethodPointer return value type WhateverFunction expecting StringFunction()
  cmp qword ptr [rsp + 020h], 000h                               ; compare type of _createMethodPointer return value to <sentinel>
  jne method$Subclass$Subclass$toString$getter$subclass$tostring$getterReturnValue$TypeMatch ; skip next block if _createMethodPointer return value is not sentinel
    ; Error handling block for Subclass$toString$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 018h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$toString$getter$subclass$tostring$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rsp + 028h]                                ; read second operand of mov (_createMethodPointer return value) for MoveToDerefInstruction
  mov r14, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$toString$getter into register to dereference it
  mov qword ptr [r14], r13                                       ; Subclass$toString$getter return value
  mov r15, qword ptr [rsp + 020h]                                ; reading type of _createMethodPointer return value
  mov r10, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$toString$getter into register to dereference it
  mov qword ptr [r10], r15                                       ; type of Subclass$toString$getter return value
  ; increment reference count for _createMethodPointer return value if necessary
  mov rax, r15                                                   ; store _createMethodPointer return value's type in testByte value slot
  mov rbx, 004h                                                  ; read operand of mul (type table width in bytes) 
  mul rbx                                                        ; adjust to the relative start of that type's entry in the type table
  add rax, 002h                                                  ; adjust to the byte containing the bit to check against (result in testByte)
  mov rsi, offset typeTable                                      ; read second operand of + (type table pointer)
  add rax, rsi                                                   ; finally offset all of that by the start of the type table itself (result in testByte)
  bt qword ptr [rax], 004h                                       ; check that possibly GarbageCollectable value is GarbageCollectable
  jnc method$Subclass$Subclass$toString$getter$AfterGCIncref     ; if not a GarbageCollectable, skip incref
    inc qword ptr [r13]                                          ; increment reference count of _createMethodPointer return value
  method$Subclass$Subclass$toString$getter$AfterGCIncref:        ; after GarbageCollectable incref
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, qword ptr [rsp + 030h]                                ; arg #2: this variable's type
  mov rcx, qword ptr [rsp + 038h]                                ; arg #1: this variable's value
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 038h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$toString$setter
dq method$Subclass$Subclass$toString$setter$annotation
method$Subclass$Subclass$toString$setter:
  ; Prolog
  push r14                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 058h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$toString$setter to 0 (integer)
  je method$Subclass$Subclass$toString$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$toString$setter$parameterCountCheck$continuation:  ; end of parameter count check
    ; Error handling block for method_assigning
    ; Call __error with 1 arguments
    mov rbx, offset assignToMethodMessage                        ; reading assignToMethodMessage for push
    push rbx                                                     ; value of argument #1 (assignToMethodMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rsi                                                     ; internal argument 6: pointer to return value slot's value
    lea rsi, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rsi                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  ; Implicit return from Subclass$toString$setter
  ; sentinel check of null type Null expecting Null
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$toString$setter into register to dereference it
  mov qword ptr [r13], 000h                                      ; Subclass$toString$setter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$toString$setter into register to dereference it
  mov qword ptr [r14], 036h                                      ; type of Subclass$toString$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop r13                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r14                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$field$getter
dq method$Subclass$Subclass$field$getter$annotation
method$Subclass$Subclass$field$getter:
  ; Prolog
  push r15                                                       ; save non-volatile registers
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push r13                                                       ; save non-volatile registers
  push r14                                                       ; save non-volatile registers
  sub rsp, 028h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 068h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$field$getter to 0 (integer)
  je method$Subclass$Subclass$field$getter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 028h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$field$getter$parameterCountCheck$continuation:  ; end of parameter count check
  mov rbx, qword ptr [r9 + 048h]                                 ; fetch value of Subclass.field
  mov rsi, qword ptr [r9 + 040h]                                 ; fetch type of Subclass.field
  ; sentinel check of Subclass.field type String expecting String
  cmp rsi, 000h                                                  ; compare type of Subclass.field to <sentinel>
  jne method$Subclass$Subclass$field$getter$subclass$field$getterReturnValue$TypeMatch ; skip next block if Subclass.field is not sentinel
    ; Error handling block for Subclass$field$getter return value
    ; Call __error with 1 arguments
    mov rdi, offset returnValueTypeCheckFailureMessage           ; reading returnValueTypeCheckFailureMessage for push
    push rdi                                                     ; value of argument #1 (returnValueTypeCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's value
    push r12                                                     ; internal argument 6: pointer to return value slot's value
    lea r12, qword ptr [rsp + 028h]                              ; load address of return value's type
    push r12                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov qword ptr [rsp + 048h], r9                               ; move this variable's value out of r9
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov qword ptr [rsp + 040h], r8                               ; move this variable's type out of r8
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
    mov r9, qword ptr [rsp + 008h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
    mov r8, qword ptr [rsp + 000h]                               ; restoring slot (this variable) to previous scope state for genuine block exit
  method$Subclass$Subclass$field$getter$subclass$field$getterReturnValue$TypeMatch:  ; after block
  mov r13, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$field$getter into register to dereference it
  mov qword ptr [r13], rbx                                       ; Subclass$field$getter return value
  mov r14, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$field$getter into register to dereference it
  mov qword ptr [r14], rsi                                       ; type of Subclass$field$getter return value
  ; increment reference count for Subclass.field if necessary
  cmp rsi, 039h                                                  ; compare type of Subclass.field to String
  jne method$Subclass$Subclass$field$getter$AfterStringIncref    ; if not a String, skip incref
    mov r15, qword ptr [rbx]                                     ; dereference string to get to reference count
    cmp r15, 0                                                   ; compare string reference count to 0
    jns method$Subclass$Subclass$field$getter$StringIncref       ; if reference count is negative (constant strings), skip incref
    jmp method$Subclass$Subclass$field$getter$AfterStringIncref  ; skip incref for string constants
    method$Subclass$Subclass$field$getter$StringIncref:          ; real String
      inc qword ptr [rbx]                                        ; increment reference count of Subclass.field
  method$Subclass$Subclass$field$getter$AfterStringIncref:       ; after String incref
  ; Decrement reference count for this variable (static type: Subclass'40) via decrefMaybeGC
  sub rsp, 20h                                                   ; allocate shadow space for decref function
  mov rdx, r8                                                    ; arg #2: this variable's type
  mov rcx, r9                                                    ; arg #1: this variable's value
  mov qword ptr [rsp + 038h], r8                                 ; move this variable's type out of r8
  mov qword ptr [rsp + 030h], r9                                 ; move this variable's value out of r9
  call decrefMaybeGC                                             ; call decref
  add rsp, 20h                                                   ; free shadow space for decref
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 028h                                                  ; free space for stack
  pop r14                                                        ; restore non-volatile registers
  pop r13                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rbp                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  pop r15                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine

; Subclass$field$setter
dq method$Subclass$Subclass$field$setter$annotation
method$Subclass$Subclass$field$setter:
  ; Prolog
  push rbx                                                       ; save non-volatile registers
  push rsi                                                       ; save non-volatile registers
  push rdi                                                       ; save non-volatile registers
  push r12                                                       ; save non-volatile registers
  push rbp                                                       ; save non-volatile registers
  sub rsp, 020h                                                  ; allocate space for stack and align to 16 byte boundary
  lea rbp, qword ptr [rsp + 048h]                                ; set up frame pointer
  ; Check parameter count
  cmp rcx, 000h                                                  ; compare parameter count of Subclass$field$setter to 0 (integer)
  je method$Subclass$Subclass$field$setter$parameterCountCheck$continuation ; check number of parameters is as expected
    ; Error handling block for parameter count
    ; Call __error with 1 arguments
    mov r10, offset parameterCountCheckFailureMessage            ; reading parameterCountCheckFailureMessage for push
    push r10                                                     ; value of argument #1 (parameterCountCheckFailureMessage)
    push 039h                                                    ; type of argument #1 (String'39)
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's value
    push rax                                                     ; internal argument 6: pointer to return value slot's value
    lea rax, qword ptr [rsp + 018h]                              ; load address of return value's type
    push rax                                                     ; internal argument 5: pointer to return value slot's type
    sub rsp, 020h                                                ; allocate shadow space
    mov r9, 000h                                                 ; internal argument 4: "this" pointer
    mov r8, 000h                                                 ; internal argument 3: "this" pointer type
    mov rdx, 000h                                                ; internal argument 2: closure pointer
    mov rcx, 001h                                                ; internal argument 1: number of actual arguments
    call func$__error                                            ; jump to subroutine
    add rsp, 040h                                                ; release shadow space and arguments (result in stack pointer)
  method$Subclass$Subclass$field$setter$parameterCountCheck$continuation:  ; end of parameter count check
  ; Implicit return from Subclass$field$setter
  ; sentinel check of null type Null expecting Null
  mov rdi, qword ptr [rbp + 030h]                                ; get pointer to return value of Subclass$field$setter into register to dereference it
  mov qword ptr [rdi], 000h                                      ; Subclass$field$setter return value
  mov r12, qword ptr [rbp + 028h]                                ; get pointer to return value type of Subclass$field$setter into register to dereference it
  mov qword ptr [r12], 036h                                      ; type of Subclass$field$setter return value (Null'36)
  mov rax, qword ptr [rbp + 030h]                                ; report address of return value
  ; Epilog
  add rsp, 020h                                                  ; free space for stack
  pop rbp                                                        ; restore non-volatile registers
  pop r12                                                        ; restore non-volatile registers
  pop rdi                                                        ; restore non-volatile registers
  pop rsi                                                        ; restore non-volatile registers
  pop rbx                                                        ; restore non-volatile registers
  ret                                                            ; return from subroutine
end

