import 'core.syd';
import 'syd-types.syd';
import 'syd-operands.syd';

enum ip { DecrefMaybeGCOrString DecrefMaybeGC DecrefMaybeString DecrefString }

class SlotContext extends Object {
  // returns the root SlotContext
  SlotContext slotScope() {
    abstract();
  }

  String lookupInternalProcedureLabel(ip procedure) {
    abstract();
  }
}

class Slot extends Object {
  Type staticType;
  String debugName;

  Null willRead(SlotContext scope, Object client) { }

  Null willWrite(SlotContext scope, Object client) { }
  
  Null didRead(SlotContext scope, Object client) { }

  Null didWrite(SlotContext scope, Object client) { }

  // if false, it is not valid to call willWrite/didWrite on it
  Boolean isMutable() {
    abstract();
  }

  // Whether the slot represents something that can be used yet.
  // This is only used for references to constructors, between the fwdclass declaration and the corresponding class declaration.
  // In all other cases it just returns true.
  Boolean isDefined() {
    return true;
  }

  Operand value(SlotContext scope) {
    abstract();
  }

  Operand dynamicType(SlotContext scope) {
    return staticType.asOperand();
  }

  Boolean canStaticallyProveTypeCompatibilityWith(Type type) {
    return staticType.isSubtypeOf(type);
  }

  String toString() {
    return concat('<', className, ':', staticType, ' ("', debugName, '")>');
  }

  Null constructor(Type staticTypeArg, String debugNameArg) {
    super.constructor();
    staticType = staticTypeArg;
    debugName = debugNameArg;
  }
}

class ParameterSlot extends Slot {
  Integer offset;

  Boolean isMutable() {
    return false;
  }

  Operand value(SlotContext scope) {
    return AddressComputationOperand(rbp, null, 1, offset, 'qword');
  }

  Operand dynamicType(SlotContext scope) {
    return AddressComputationOperand(rbp, null, 1, offset - 0x08, 'qword');
  }

  Null constructor(Type staticTypeArg, Integer parameterNumber, String debugNameArg) {
    super.constructor(staticTypeArg, debugNameArg);
    offset = parameterNumber * 0x10 + 0x08
           + 0x10  // return value pointer (and type) 
           + 0x20  // shadow space 
           + 0x08; // return address
  }
}

class ReturnValuePointerSlot extends Slot {
  Boolean isMutable() {
    return false;
  }

  Operand value(SlotContext scope) {
    return AddressComputationOperand(rbp, null, 1, 0x20 /* shadow space */ + 0x08 /* return address */ + 0x08 /* return value type pointer */, 'qword');
  }

  Operand epilogValue(SlotContext scope) {
    return AddressComputationOperand(rsp, null, 1, 0x20 /* shadow space */ + 0x08 /* return address */ + 0x08 /* return value type pointer */, 'qword');
  }
}

class ReturnValueTypePointerSlot extends Slot {
  Boolean isMutable() {
    return false;
  }

  Operand value(SlotContext scope) {
    return AddressComputationOperand(rbp, null, 1, 0x20 /* shadow space */ + 0x08 /* return address */, 'qword');
  }

  Operand epilogValue(SlotContext scope) {
    return AddressComputationOperand(rsp, null, 1, 0x20 /* shadow space */ + 0x08 /* return address */, 'qword');
  }
}

class OperandSlot extends Slot {
  Operand operand;

  Boolean isMutable() {
    return true;
  }

  Operand value(SlotContext scope) {
    return operand;
  }

  Null constructor(Type typeArg, Operand operandArg, String debugNameArg) {
    super.constructor(typeArg, debugNameArg);
    operand = operandArg;
  }
}

// uses the r9/r8 shadow space (assumes rsp is its initial value)
class FakeReturnValueSlot extends Slot {
  Boolean isMutable() {
    return true;
  }

  Operand value(SlotContext scope) {
    return AddressComputationOperand(rsp, null, 1, 0x08 /* skip return address */ + 0x18 /* skip three shadow slots */, 'qword');
  }

  Operand dynamicType(SlotContext scope) {
    return AddressComputationOperand(rsp, null, 1, 0x08 /* skip return address */ + 0x10 /* skip two shadow slots */, 'qword');
  }
}

// uses the rdx shadow space
class TailRecursionCodePointerSlot extends Slot {
  Boolean isMutable() {
    return true;
  }

  Operand value(SlotContext scope) {
    return AddressComputationOperand(rbp, null, 1, 0x08 /* skip return address */ + 0x08 /* skip one shadow slots */, 'qword');
  }
  
  Operand epilogValue() {
    return AddressComputationOperand(rsp, null, 1, 0x08 /* skip return address */ + 0x08 /* skip one shadow slots */, 'qword');
  }
}

// Used to represent specific registers, e.g. rbp, when generating
// instructions that are basically just hard-coded assembly. For
// example, when generating the prolog.
class RegisterSlot extends OperandSlot {
  Boolean isMutable() {
    return true;
  }

  Null constructor(Type typeArg, Register64Operand operandArg, String debugNameArg) {
    super.constructor(typeArg, operandArg, debugNameArg);
  }
}

// pointerSlot points to the value
class DerefSlot extends Slot {
  Slot pointerSlot;

  Boolean isMutable() {
    return true;
  }

  Operand value(SlotContext scope) {
    assert(pointerSlot.value(scope) is Register64Operand, concat('DerefSlot expects a pointer that becomes an Register64Operand, operand is ', pointerSlot.value(scope)));
    return (pointerSlot.value(scope) as Register64Operand).dereference();
  }

  Null constructor(Type typeArg, Slot pointerSlotArg, String debugNameArg) {
    super.constructor(typeArg, debugNameArg);
    pointerSlot = pointerSlotArg;
  }
}

class VarArgsParameterSlot extends Slot {
  Integer offset;
  Slot argumentCount;

  Boolean isMutable() {
    return false;
  }

  Operand value(SlotContext scope) {
    throw('dereferencing a varargs parameter is not implemented');
  }

  // points to type of first argument, value is 8 bytes later, next argument type 8 bytes after that, etc
  Slot baseAddress(IntegerType integerType) {
    return OperandSlot(integerType, AddressComputationOperand(rbp, null, 1, offset, 'qword'), concat(debugName, ' base address'));
  }

  Slot length() {
    return argumentCount;
  }

  Null constructor(ReadOnlyListType staticTypeArg, Slot argumentCountArg, String debugNameArg) {
    super.constructor(staticTypeArg, debugNameArg);
    offset = 0x08 // return value pointer 
           + 0x08 // return type pointer
           + 0x20 // shadow space 
           + 0x08; // return address
    argumentCount = argumentCountArg;
  }
}

// subclasses of ImmediateSlot must always return
// compile-type constants (immediates) from asOperand
class ImmediateSlot extends Slot {
  Boolean isMutable() {
    return false;
  } 
}

class CompileTimeIntegerSlot extends ImmediateSlot {
  Integer numericValue() {
    abstract();
  }

  Operand value(SlotContext scope) {
    return ImmediateIntegerOperand(numericValue());
  }
}

class ImmediateIntegerSlot extends CompileTimeIntegerSlot {
  Integer number;

  Integer numericValue() {
    return number;
  }

  Null constructor(Type typeArg, Integer numberArg, String debugNameArg) {
    super.constructor(typeArg, debugNameArg);
    number = numberArg;
  }
}

class CompileTimeLabelSlot extends ImmediateSlot {
  String labelValue() {
    abstract();
  }
}

class ImmediateDataLabelSlot extends CompileTimeLabelSlot {
  String label;

  String labelValue() {
    return label;
  }

  Operand value(SlotContext scope) {
    return DataAddressOperand(labelValue());
  }

  Null constructor(Type typeArg, String labelArg, String debugNameArg) {
    super.constructor(typeArg, debugNameArg);
    label = labelArg;
  }
}

class CodeLabelSlot extends CompileTimeLabelSlot {
  String label;

  String labelValue() {
    return label;
  }

  Operand value(SlotContext scope) {
    return CodeAddressOperand(labelValue());
  }

  Null constructor(Type typeArg, String labelArg, String debugNameArg) {
    super.constructor(typeArg, debugNameArg);
    label = labelArg;
  }
}
