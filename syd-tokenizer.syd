import 'core.syd';

// Tokenizer

enum ts {
  Top
  Identifier 
  SingleQuoteString 
  SingleQuoteStringCR 
  SingleQuoteStringEscape 
  DoubleQuoteString 
  DoubleQuoteStringCR 
  DoubleQuoteStringEscape
  Zero
  Integer
  HexStart
  Hex

  Plus
  Minus
  Asterisk
  Slash 
  Modulus
  Equals
  Bang
  LessThan 
  GreaterThan 
  Ampersand 
  Caret
  VerticalBar 

  LineComment 
  BlockComment
  BlockCommentCR
  BlockCommentAsterisk
  CR 
}

enum tt {
  Identifier // String
  String // String
  Integer // Integer
  OpenBrace
  CloseBrace
  OpenBracket
  CloseBracket
  OpenParen
  CloseParen
  Period
  Comma
  Semicolon

  Plus
  PlusEquals
  Minus
  MinusEquals
  Asterisk
  AsteriskEquals
  Slash
  SlashEquals
  Modulus
  ModulusEquals
  Equals
  EqualsEquals
  Bang
  BangEquals
  LessThan
  LessThanLessThan
  LessThanEquals
  GreaterThan
  GreaterThanGreaterThan
  GreaterThanEquals
  Ampersand
  AmpersandEquals
  AmpersandAmpersand
  Caret
  CaretEquals
  VerticalBar
  VerticalBarEquals
  VerticalBarVerticalBar
  Tilde

  Eof
}

Integer tkLine = 1;
Integer tkCol = 2;
Integer tkFile = 3;
Integer tkData = 4;

String describeToken(AnythingList token) {
  String description;
  if (token[0] == ttIdentifier) {
    description = concat('identifier "', token[tkData], '"');
  } else if (token[0] == ttString) {
    description = concat('string literal');
  } else if (token[0] == ttInteger) {
    description = concat('integer literal "', token[tkData], '"');
  } else if (token[0] == ttOpenBrace) {
    description = '"{"';
  } else if (token[0] == ttCloseBrace) {
    description = '"}"';
  } else if (token[0] == ttOpenBracket) {
    description = '"["';
  } else if (token[0] == ttCloseBracket) {
    description = '"]"';
  } else if (token[0] == ttOpenParen) {
    description = '"("';
  } else if (token[0] == ttCloseParen) {
    description = '")"';
  } else if (token[0] == ttPeriod) {
    description = '"."';
  } else if (token[0] == ttComma) {
    description = '","';
  } else if (token[0] == ttSemicolon) {
    description = '";"';

  } else if (token[0] == ttPlus) {
    description = '"+"';
  } else if (token[0] == ttPlusEquals) {
    description = '"+="';
  } else if (token[0] == ttMinus) {
    description = '"-"';
  } else if (token[0] == ttMinusEquals) {
    description = '"-="';
  } else if (token[0] == ttAsterisk) {
    description = '"*"';
  } else if (token[0] == ttAsteriskEquals) {
    description = '"*="';
  } else if (token[0] == ttSlash) {
    description = '"/"';
  } else if (token[0] == ttSlashEquals) {
    description = '"/="';
  } else if (token[0] == ttModulus) {
    description = '"%"';
  } else if (token[0] == ttModulusEquals) {
    description = '"%="';
  } else if (token[0] == ttEquals) {
    description = '"="';
  } else if (token[0] == ttEqualsEquals) {
    description = '"=="';
  } else if (token[0] == ttBang) {
    description = '"!"';
  } else if (token[0] == ttBangEquals) {
    description = '"!="';
  } else if (token[0] == ttLessThan) {
    description = '"<"';
  } else if (token[0] == ttLessThanLessThan) {
    description = '"<<"';
  } else if (token[0] == ttLessThanEquals) {
    description = '"<="';
  } else if (token[0] == ttGreaterThan) {
    description = '">"';
  } else if (token[0] == ttGreaterThanGreaterThan) {
    description = '">>"';
  } else if (token[0] == ttGreaterThanEquals) {
    description = '">="';
  } else if (token[0] == ttAmpersand) {
    description = '"&"';
  } else if (token[0] == ttAmpersandEquals) {
    description = '"&="';
  } else if (token[0] == ttAmpersandAmpersand) {
    description = '"&&"';
  } else if (token[0] == ttCaret) {
    description = '"^"';
  } else if (token[0] == ttCaretEquals) {
    description = '"^="';
  } else if (token[0] == ttVerticalBar) {
    description = '"|"';
  } else if (token[0] == ttVerticalBarEquals) {
    description = '"|="';
  } else if (token[0] == ttVerticalBarVerticalBar) {
    description = '"||"';
  } else if (token[0] == ttTilde) {
    description = '"~"';

  } else if (token[0] == ttEof) {
    description = 'end of file';
  } else {
    assert(false, concat('don\t know how to describe ', token));
    description = concat(token);
  }
  return description;
}

AnythingListList tokenize(IntegerIterable source, String filename) {
  println(concat('tokenizing "', filename, '"...'));
  Integer lineNo = 1;
  Integer colNo = 0;
  Integer lastInterestingLineNo = -1;
  Integer lastInterestingColNo = -1;
  ts state = tsTop;
  Anything buffer;
  AnythingListList tokens = [];
  for (ch in source) {
    colNo += 1;
    while (true) {
      if (state == tsTop) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) {
          state = tsCR;
          break;
        } else if (ch == 0x20) { // space
          break;
        } else if (ch == 0x21) { // !
          state = tsBang;
          break;
        } else if (ch == 0x22) { // "
          state = tsDoubleQuoteString;
          buffer = [];
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x25) { // %
          state = tsModulus;
          break;
        } else if (ch == 0x26) { // &
          state = tsAmpersand;
          break;
        } else if (ch == 0x27) { // '
          state = tsSingleQuoteString;
          buffer = [];
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          break;
        } else if (ch == 0x28) { // (
          append(tokens, [ttOpenParen, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x29) { // )
          append(tokens, [ttCloseParen, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x2a) { // *
          state = tsAsterisk;
          break;
        } else if (ch == 0x2b) { // +
          state = tsPlus;
          break;
        } else if (ch == 0x2c) { // ,
          append(tokens, [ttComma, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x2d) { // -
          state = tsMinus;
          break;
        } else if (ch == 0x2e) { // .
          append(tokens, [ttPeriod, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x2f) { // /
          state = tsSlash;
          break;
        } else if (ch == 0x30) { // 0
          state = tsZero;
          break;
        } else if (ch >= 0x31 && ch <= 0x39) { // 1-9
          state = tsInteger;
          buffer = ch - 0x30;
          break;
        } else if (ch == 0x3b) { // ;
          append(tokens, [ttSemicolon, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x3c) { // <
          state = tsLessThan;
          break;
        } else if (ch == 0x3d) { // =
          state = tsEquals;
          break;
        } else if (ch == 0x3e) { // >
          state = tsGreaterThan;
          break;
        } else if ((ch >= 0x41 && ch <= 0x5a) || // A-Z
                   (ch >= 0x61 && ch <= 0x7a) || // a-z
                   (ch == 0x5f)) { // _
          state = tsIdentifier;
          buffer = [chr(ch)];
          break;
        } else if (ch == 0x5b) { // [
          append(tokens, [ttOpenBracket, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x5d) { // ]
          append(tokens, [ttCloseBracket, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x5e) { // ^
          state = tsCaret;
          break;
        } else if (ch == 0x7b) { // {
          append(tokens, [ttOpenBrace, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x7c) { // |
          state = tsVerticalBar;
          break;
        } else if (ch == 0x7d) { // }
          append(tokens, [ttCloseBrace, lineNo, colNo, filename]);
          break;
        } else if (ch == 0x7e) { // ~
          append(tokens, [ttTilde, lineNo, colNo, filename]);
          break;
        } else {
          throw(concat('unexpected character U+', padLeft(hex(ch), 4, "0"), ' at line ', lineNo, ' column ', colNo, ' in ', filename, ': ', chr(ch)));
          break;
        }
      } else if (state == tsIdentifier) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x5a) || // A-Z
            (ch >= 0x61 && ch <= 0x7a) || // a-z
            (ch == 0x5f)) {
          append(cast(buffer), chr(ch));
          break;
        } else {
          append(tokens, [ttIdentifier, lineNo, colNo - 1, filename, joinList(cast(buffer))]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsSingleQuoteString) {
        if (ch == 0x27) { // '
          append(tokens, [ttString, lineNo, colNo, filename, joinList(cast(buffer))]);
          state = tsTop; 
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = tsSingleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsSingleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsSingleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsSingleQuoteString;
        // no break, reprocess in tsSingleQuoteString
      } else if (state == tsSingleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = tsSingleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = tsSingleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsSingleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsDoubleQuoteString) {
        if (ch == 0x22) { // "
          append(tokens, [ttString, lineNo, colNo, filename, joinList(cast(buffer))]);
          state = tsTop;
          lastInterestingLineNo = -1;
          lastInterestingColNo = -1;
          break;
        } else if (ch == 0x5c) { // \
          state = tsDoubleQuoteStringEscape;
          break;
        } else {
          append(cast(buffer), chr(ch));
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsDoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsDoubleQuoteStringCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsDoubleQuoteString;
        // no break, reprocess in tsDoubleQuoteString
      } else if (state == tsDoubleQuoteStringEscape) {
        if (ch == 0x6e) { // n
          append(cast(buffer), '\n');
          state = tsDoubleQuoteString;
          break;
        } else {
          append(cast(buffer), chr(ch));
          state = tsDoubleQuoteString;
          if (ch == 0x0a) { // LF
            lineNo += 1;
            colNo = 0;
          } else if (ch == 0x0d) { // CR
            state = tsDoubleQuoteStringCR;
          }
          break;
        }
      } else if (state == tsZero) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          state = tsInteger;
          buffer = 0;
          // no break, reprocess in tsInteger
        } else if (ch == 0x58 || ch == 0x78) { // x, X
          state = tsHexStart;
          break;
        } else {
          append(tokens, [ttInteger, lineNo, colNo - 1, filename, 0]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsInteger) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 10 + ch - 0x30;
          break;
        } else {
          append(tokens, [ttInteger, lineNo, colNo - 1, filename, buffer]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsHexStart) {
        if ((ch >= 0x30 && ch <= 0x39) || // 0-9
            (ch >= 0x41 && ch <= 0x46) || // A-F
            (ch >= 0x61 && ch <= 0x66)) { // a-f
          state = tsHex;
          buffer = 0;
          // no break, reprocess in tsHex
        } else {
          throw(concat('unexpected character ', padLeft(hex(ch), 4, "0"), ' in hex literal at line ', lineNo, ' column ', colNo, ' in ', filename, ': ', chr(ch)));
        }
      } else if (state == tsHex) {
        if (ch >= 0x30 && ch <= 0x39) { // 0-9
          buffer = cast(buffer) * 0x10 + ch - 0x30;
          break;
        } else if (ch >= 0x41 && ch <= 0x46) { // A-F
          buffer = (cast(buffer) * 0x10 + ch - 0x41) + 10;
          break;
        } else if (ch >= 0x61 && ch <= 0x66) { // a-f
          buffer = (cast(buffer) * 0x10 + ch - 0x61) + 10;
          break;
        } else {
          append(tokens, [ttInteger, lineNo, colNo - 1, filename, buffer]);
          state = tsTop;
          // no break, reprocess in tsTop
        }

      } else if (state == tsPlus) {
        if (ch == 0x3d) { // =
          append(tokens, [ttPlusEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttPlus, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsMinus) {
        if (ch == 0x3d) { // =
          append(tokens, [ttMinusEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttMinus, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsAsterisk) {
        if (ch == 0x3d) { // =
          append(tokens, [ttAsteriskEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttAsterisk, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsSlash) {
        if (ch == 0x2a) { // *
          lastInterestingLineNo = lineNo;
          lastInterestingColNo = colNo;
          state = tsBlockComment;
          break;
        } else if (ch == 0x2f) { // /
          state = tsLineComment;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, [ttSlashEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttSlash, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsModulus) {
        if (ch == 0x3d) { // =
          append(tokens, [ttModulusEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttModulus, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsEquals) {
        if (ch == 0x3d) { // =
          append(tokens, [ttEqualsEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttEquals, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsBang) {
        if (ch == 0x3d) { // =
          append(tokens, [ttBangEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttBang, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsLessThan) {
        if (ch == 0x3c) { // <
          append(tokens, [ttLessThanLessThan, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, [ttLessThanEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttLessThan, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsGreaterThan) {
        if (ch == 0x3d) { // =
          append(tokens, [ttGreaterThanEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else if (ch == 0x3e) { // >
          append(tokens, [ttGreaterThanGreaterThan, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttGreaterThan, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsAmpersand) {
        if (ch == 0x26) { // &
          append(tokens, [ttAmpersandAmpersand, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, [ttAmpersandEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttAmpersand, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsCaret) {
        if (ch == 0x3d) { // =
          append(tokens, [ttCaretEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttCaret, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsVerticalBar) {
        if (ch == 0x7c) { // |
          append(tokens, [ttVerticalBarVerticalBar, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else if (ch == 0x3d) { // =
          append(tokens, [ttVerticalBarEquals, lineNo, colNo, filename]);
          state = tsTop;
          break;
        } else {
          append(tokens, [ttVerticalBar, lineNo, colNo - 1, filename]);
          state = tsTop;
          // no break, reprocess in tsTop
        }
      } else if (state == tsLineComment) {
        if (ch == 0x0a) {
          state = tsTop;
          // no break, reprocess in tsTop
        } else if (ch == 0x0d) {
          state = tsCR;
          break;
        } else {
          // Ignore until end of line.
          break;
        }
      } else if (state == tsBlockComment) {
        if (ch == 0x0a) { // LF
          lineNo += 1;
          colNo = 0;
          break;
        } else if (ch == 0x0d) { // CR
          state = tsBlockCommentCR;
          break;
        } else if (ch == 0x2a) { // *
          state = tsBlockCommentAsterisk;
          break;
        } else {
          // Ignore until end of block.
          break;
        }
      } else if (state == tsBlockCommentCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsBlockComment;
        // no break, reprocess in tsBlockComment
      } else if (state == tsBlockCommentAsterisk) {
        if (ch == 0x2f) { // /
          state = tsTop;
          break;
        } else {
          state = tsBlockComment;
          // no break, reprocess in tsBlockComment
        }
      } else if (state == tsCR) {
        if (ch != 0x0a) {
          lineNo += 1;
          colNo = 0;
        }
        state = tsTop;
        // no break, reprocess in tsTop
      } else {
        throw(concat('unknown state ', state));
      }
    }
  }
  // Handle EOF
  if (state == tsTop) {
    // no effect
  } else if (state == tsIdentifier) {
    append(tokens, [ttIdentifier, joinList(cast(buffer))]);
  } else if (state == tsSingleQuoteString) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsSingleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsSingleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsDoubleQuoteString) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsDoubleQuoteStringCR) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsDoubleQuoteStringEscape) {
    throw(concat('unterminated string at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsZero) {
    append(tokens, [ttInteger, lineNo, colNo, filename, 0]);
  } else if (state == tsInteger) {
    append(tokens, [ttInteger, lineNo, colNo, filename, buffer]);
  } else if (state == tsHexStart) {
    throw(concat('incomplete hex literal at end of ', filename));
  } else if (state == tsHex) {
    append(tokens, [ttInteger, lineNo, colNo, filename, buffer]);

  } else if (state == tsPlus) {
    append(tokens, [ttPlus, lineNo, colNo, filename]);
  } else if (state == tsMinus) {
    append(tokens, [ttMinus, lineNo, colNo, filename]);
  } else if (state == tsAsterisk) {
    append(tokens, [ttAsterisk, lineNo, colNo, filename]);
  } else if (state == tsSlash) {
    append(tokens, [ttSlash, lineNo, colNo, filename]);
  } else if (state == tsModulus) {
    append(tokens, [ttModulus, lineNo, colNo, filename]);
  } else if (state == tsEquals) {
    append(tokens, [ttEquals, lineNo, colNo, filename]);
  } else if (state == tsBang) {
    append(tokens, [ttBang, lineNo, colNo, filename]);
  } else if (state == tsLessThan) {
    append(tokens, [ttLessThan, lineNo, colNo, filename]);
  } else if (state == tsGreaterThan) {
    append(tokens, [ttGreaterThan, lineNo, colNo, filename]);
  } else if (state == tsAmpersand) {
    append(tokens, [ttAmpersand, lineNo, colNo, filename]);
  } else if (state == tsCaret) {
    append(tokens, [ttCaret, lineNo, colNo, filename]);
  } else if (state == tsVerticalBar) {
    append(tokens, [ttVerticalBar, lineNo, colNo, filename]);

  } else if (state == tsLineComment) {
    // file terminated with line comment
  } else if (state == tsBlockComment) {
    throw(concat('unterminated block comment at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsBlockCommentCR) {
    throw(concat('unterminated block comment at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsBlockCommentAsterisk) {
    throw(concat('unterminated block comment at end of file started on line ', lastInterestingLineNo, ' column ', lastInterestingColNo, ' in ', filename));
  } else if (state == tsCR) {
    // file terminated with newline
  } else {
    throw(concat('unknown state ', state));
  }
  append(tokens, [ttEof, lineNo, colNo, filename]);
  return tokens;
}

class TokenConsumer {
  AnythingListList tokens;
  Integer index;

  Boolean isNext(tt tokenType) {
    return tokens[index][0] == tokenType;
  }
  
  Boolean isNext2(tt tokenType1, tt tokenType2) {
    return index + 1 < len(tokens)
        && tokens[index    ][0] == tokenType1
        && tokens[index + 1][0] == tokenType2;
  }
  
  Boolean isNextIdentifier(String identifier) {
    AnythingList token = tokens[index];
    return token[0] == ttIdentifier && token[tkData] == identifier;
  }
  
  String butFound(String what, String description) {
    AnythingList token = tokens[index];
    Integer line = cast(token[tkLine]);
    Integer column = cast(token[tkCol]);
    String file = cast(token[tkFile]);
    return concat('Expected ', what, ' but found ', description, ' at line ', line, ' column ', column, ' in ', file);
  }
  
  String expected(String what) {
    return butFound(what, describeToken(tokens[index]));
  }

  String readIdentifier() {
    if (!isNext(ttIdentifier)) {
      throw(concat(expected('identifier')));
    }
    String result = cast(tokens[index][tkData]);
    index = index + 1;
    return result;
  }
  
  String readString() {
    if (!isNext(ttString)) {
      throw(concat(expected('string literal')));
    }
    String result = cast(tokens[index][tkData]);
    index = index + 1;
    return result;
  }
  
  Integer readInteger() {
    if (!isNext(ttInteger)) {
      throw(concat(expected('integer literal')));
    }
    Integer result = cast(tokens[index][tkData]);
    index = index + 1;
    return result;
  }
  
  Null expectIdentifier(String identifier) {
    if (!isNext(ttIdentifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    if (!isNextIdentifier(identifier)) {
      throw(concat(expected(concat('"', identifier, '"'))));
    }
    index = index + 1;
  }
  
  Null expectPunctuation(tt punctuation) {
    if (!isNext(punctuation)) {
      throw(concat(expected(describeToken([punctuation, -1, -1]))));
    }
    index = index + 1;
  }
  
  Null constructor(AnythingListList tokensArg) {
    tokens = tokensArg;
    index = 0;
  }
}