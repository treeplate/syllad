// Standard Library
println('Syllad core library 1.0 loaded.');

String intToStr(Integer value) {
  if (value == 0) {
    return '0';
  }
  StringList buffer = [];
  Integer newValue = value; // parameters are final
  while (newValue > 0) {
    Integer digit = newValue % 10;
    newValue = newValue / 10;
    append(buffer, chr(0x30 + digit));
  }
  Integer index = len(buffer);
  StringList flippedBuffer = [];
  while (index > 0) {
    index -= 1;
    append(flippedBuffer, buffer[index]);
  }
  return joinList(flippedBuffer);
}

String join(StringList items, String joiner) {
  StringList result = [];
  Integer index = 0;
  while (index < len(items)) {
    if (index > 0) {
      append(result, joiner);
    }
    append(result, items[index]);
    index += 1;
  }
  return joinList(result);
}

AnythingList map(AnythingList items, AnythingFunction callback) {
  AnythingList result = [];
  Integer index = 0;
  while (index < len(items)) {
    append(result, callback(items[index]));
    index += 1;
  }
  return result;
}

Boolean contains(AnythingList list, Anything item) {
  for (entry in list) {
    if (entry == item) {
      return true;
    }
  }
  return false;
}

// OBJECTS

class Object {
  Null abstract() {
    throw(concat('called abstract method on ', className));
  }

  Null constructor() { }

  String toString() {
    return concat('<', className, '>');
  }
}

/*
Integer vmtSignature = 0;
Integer vmtClassName = 1;
Integer vmtParent = 2;
Integer vmtFirstMethod = 3;
Integer getClass = vmtFirstMethod + 0; // (this) -> Anything
Integer toString = vmtFirstMethod + 1; // (this) -> String
Integer TObject_vmt = 0;
Integer TObject_instanceSize = TObject_vmt + 1;
Anything TObject_getClass(AnythingList this) {
  return this[TObject_vmt];
}
String TObject_toString(AnythingList this) {
  return concat("<", cast(cast(this[TObject_vmt])[vmtClassName]), ">");
}
AnythingList TObject = [
  'VMT',
  'TObject',
  null, // vmtParent
  TObject_getClass,
  TObject_toString,
];
AnythingList TObject_constructor(AnythingList vmt) {
  assert(vmt != null, 'no vmt passed to TObject constructor');
  assert(len(vmt) >= len(TObject), 'vmt incomplete');
  assert(vmt[vmtSignature] == TObject[vmtSignature], 'vmt signature invalid');
  assert(vmt == TObject || vmt[vmtClassName] != TObject[vmtClassName], 'vmt lacks valid class name');
  assert(vmt == TObject || vmt[vmtParent] != null, 'vmt lacks valid parent vmt pointer');
  AnythingList instance = [];
  append(instance, vmt);
  return instance;
}

AnythingFunction method(AnythingList object, Integer methodId) {
  assert(object != null, 'object is null while calling a method on it');
  assert(len(object) >= TObject_instanceSize, 'invalid object instance size');
  assert(object[TObject_vmt] != null, 'object has no vmt');
  assert(len(cast(object[TObject_vmt])) >= len(TObject), 'object vmt is invalid');
  assert(cast(object[TObject_vmt])[vmtSignature] == TObject[vmtSignature], 'object vmt signature is invalid');
  assert(methodId >= vmtFirstMethod, concat('methodId ', methodId, ' is invalid'));
  assert(methodId < len(cast(object[TObject_vmt])), concat('methodId ', methodId, ' is invalid'));
  Anything result = cast(object[TObject_vmt])[methodId];
  if (result == null) {
    throw(concat('Cannot call abstract method #', methodId, ' on ', cast(object[TObject_vmt])[vmtClassName], '.'));
  }
  return cast(result);
}

AnythingList extend(AnythingList parentVmt, String className) {
  assert(parentVmt != null, 'must specify parent vmt to extend');
  assert(parentVmt[vmtSignature] == TObject[vmtSignature], concat('invalid vmt signature when declaring ', className, '; parent vmt was: ', parentVmt));
  AnythingList vmt = copy(parentVmt);
  vmt[vmtClassName] = className;
  vmt[vmtParent] = parentVmt;
  return vmt;
}

Boolean is(AnythingList object, AnythingList class) {
  assert(object != null, concat('object, ', object, ', is null'));
  assert(len(object) >= TObject_instanceSize, 'invalid object instance size');
  assert(object[TObject_vmt] != null, 'object has no vmt');
  assert(len(cast(object[TObject_vmt])) >= len(TObject), 'object vmt is invalid');
  assert(cast(object[TObject_vmt])[vmtSignature] == TObject[vmtSignature], 'object vmt signature is invalid');
  assert(class != null, 'must specify class to compare to');
  assert(class[vmtSignature] == TObject[vmtSignature], concat('class vmt signature is invalid in is check'));
  Anything vmt = object[TObject_vmt];
  while (vmt != null) {
    if (vmt == class) {
      return true;
    }
    vmt = cast(vmt)[vmtParent];
  }
  return false;
}
*/

// COLLECTIONS

// This is a port of the xor variant of djb2, from http://www.cse.yorku.ca/~oz/hash.html
// The original assumed 8-bit characters; this version uses scalar values which are 21 bits,
// whether this makes any sense or not is unclear.
Integer hashString(String data) {
  Integer result = 5381;
  Integer c;
  for (c in scalarValues(data)) {
    result = ((result << 5) + result) ^ c;
  }
  return result;
}

Integer hashAnything(Anything data) {
  return hashString(concat(data));
}

class Map {
  AnythingListListList table = [];
  Integer length = 0;

  Null constructor() { }

  // protected
  Null nonGrowingSet(Anything key, Anything value) {
    assert(len(table) > 0, 'Cannot set without growing in an empty Map.');
    Integer hashCode = hashAnything(key);
    Integer entryIndex = hashCode % len(table);
    AnythingListListList table = table;
    AnythingListList entry = table[entryIndex];
    if (entry == null) {
      table[entryIndex] = [[key, value]];
      length += 1;
      return;
    }
    for (record in entry) {
      if (record[0] == key) {
        record[1] = value;
        return;
      }
    }
    append(entry, [key, value]);
    length += 1;
  }

  // protected
  Null grow() {
    AnythingListListList oldTable = table;
    AnythingListListList newTable = [];
    Integer oldSize = len(oldTable);
    Integer newSize = oldSize * 2 + 1;
    Integer index = 0;
    while (index < newSize) {
      append(newTable, null);
      index += 1;
    }
    table = newTable;
    for (entry in oldTable) {
      if (entry != null) {
        for (record in entry) {
          nonGrowingSet(record[0], record[1]);
        }
      }
    }
  }

  Null set(Anything key, Anything value) {
    if (len(table) <= length /* *1.3 */) {
      grow();
    }
    nonGrowingSet(key, value);
  }

  Anything get(Anything key) {
    if (len(table) == 0) {
      return null;
    }
    Integer hashCode = hashAnything(key);
    AnythingListList entry = table[hashCode % len(table)];
    if (entry == null) {
      return null;
    }
    for (record in entry) {
      if (record[0] == key) {
        return record[1];
      }
    }
    return null;
  }

  AnythingList keys() {
    AnythingList result = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry) {
          append(result, record[0]);
        }
      }
    }
    return result;
  }

  AnythingList values() {
    AnythingList result = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry) {
          append(result, record[1]);
        }
      }
    }
    return result;
  }

  String toString() {
    StringList items = [];
    for (entry in table) {
      if (entry != null) {
        for (record in entry) {
          if (len(items) > 0) {
            append(items, ', ');
          }
          append(items, concat(record[0], ', ', record[1]));
        }
      }
    }
    return concat(
      '{',
      joinList(items),
      '}',
    );
  }
}

/*
// class TMap
AnythingList TMap = extend(TObject, 'TMap');
Integer TMap_table = TObject_instanceSize;
Integer TMap_length = TObject_instanceSize + 1;
Integer TMap_instanceSize = TMap_length + 1;
Integer set = len(TMap);
Integer get = len(TMap) + 1;
Integer grow = len(TMap) + 2; // protected
Integer nonGrowingSet = len(TMap) + 3; // protected
Integer keys = len(TMap) + 4;
Integer values = len(TMap) + 5;
Null TMap_set(AnythingList this, Anything key, Anything value) {
  if (len(cast(this[TMap_table])) <= cast(this[TMap_length]) * 1.3) {
    method(this, grow)(this);
  }
  method(this, nonGrowingSet)(this, key, value);
}
append(TMap, TMap_set);
Anything TMap_get(AnythingList this, Anything key) {
  if (len(cast(this[TMap_table])) == 0) {
    return null;
  }
  Integer hashCode = hashAnything(key);
  AnythingListList entry = cast(cast(this[TMap_table])[hashCode % len(cast(this[TMap_table]))]);
  if (entry == null) {
    return null;
  }
  for (record in entry) {
    if (record[0] == key) {
      return record[1];
    }
  }
  return null;
}
append(TMap, TMap_get);
Null TMap_grow(AnythingList this) {
  AnythingListListList oldTable = cast(this[TMap_table]);
  AnythingListListList newTable = [];
  Integer oldSize = len(oldTable);
  Integer newSize = oldSize * 2 + 1;
  Integer index = 0;
  while (index < newSize) {
    append(newTable, null);
    index += 1;
  }
  this[TMap_table] = newTable;
  for (entry in oldTable) {
    if (entry != null) {
      for (record in entry) {
        method(this, nonGrowingSet)(this, record[0], record[1]);
      }
    }
  }
}
append(TMap, TMap_grow);
Null TMap_nonGrowingSet(AnythingList this, Anything key, Anything value) {
  assert(len(cast(this[TMap_table])) > 0);
  Integer hashCode = hashAnything(key);
  Integer entryIndex = hashCode % len(cast(this[TMap_table]));
  AnythingListListList table = cast(this[TMap_table]);
  AnythingListList entry = cast(table[entryIndex]);
  if (entry == null) {
    table[entryIndex] = [[key, value]];
    this[TMap_length] = cast(this[TMap_length]) + 1;
    return;
  }
  for (record in entry) {
    if (record[0] == key) {
      record[1] = value;
      return;
    }
  }
  append(entry, [key, value]);
  this[TMap_length] = cast(this[TMap_length]) + 1;
}
append(TMap, TMap_nonGrowingSet);
AnythingList TMap_keys(AnythingList this) {
  AnythingList result = [];
  for (entry in cast(this[TMap_table])) {
    if (entry != null) {
      for (record in cast(entry)) {
        append(result, cast(record)[0]);
      }
    }
  }
  return result;
}
TMap[keys] = TMap_keys;
AnythingList TMap_values(AnythingList this) {
  AnythingList result = [];
  for (entry in cast(this[TMap_table])) {
    if (entry != null) {
      for (record in cast(entry)) {
        append(result, cast(record)[1]);
      }
    }
  }
  return result;
}
TMap[values] = TMap_values;
String TMap_toString(AnythingList this) {
  AnythingListListList table = cast(this[TMap_table]);
  StringList items = [];
  for (entry in table) {
    if (entry != null) {
      for (record in entry) {
        if (len(items) > 0) {
          append(items, ', ');
        }
        append(items, concat(record[0], ', ', record[1]));
      }
    }
  }
  return concat(
    '{',
    joinList(items),
    '}',
  );
}
TMap[toString] = TMap_toString;
AnythingList TMap_constructor(AnythingList vmt) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TMap));
  append(instance, []);
  append(instance, 0);
  return instance;
}
*/