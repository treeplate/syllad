import 'syd-tokenizer.syd';
import 'syd-ast.syd';

println('syllad self-hosting compiler');
Integer a = 0; Integer b; a = b;
println(a);
/*
// syllad spec:
// functions 'print', 'charsOf',
// 'addLists', 'parseInt',
// 'concat', 'len', 'input',
// 'iterator', 'next', 'current',
// 'append', 'stringTimes'
// 'first', 'last', 'single'
// 'copy', 'scalarValues',
// 'assert', 'exit',
// 'readFile', 'readFileBytes',
// 'println', 'throw', 'hex',
// 'chr', 'cast'
// 'padLeft', 'joinList'
// while loop
// for-in loops
// classical if-else
// classical variables, but with no 'var' or 'final' or 'const'
// enums (enum X {a b c}  ...  X state = Xa; ... state = Xb;   if(state == Xa) { ... })
// values are functions or true or false or null or int literal or list literal (e.g. [1, 2]) or string literal ('' or "", newlines ok, single-character escapes)
// types, or <t>, are:
// Anything, Integer, String, Boolean, <t>List, <t>Iterable, <t>Iterator, Null, <t> (enums)
// operators: [], <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, <<

// WISHLIST
// P1 (blocking progress):
//   performance
//   some errors with line numbers are... inaccurate
//   errors don't specify the file name
// P2 (making things much harder):
//   scary: Integer a = 0; Integer b; a = b; // sets an Integer variable to a non-Integer type (unsound type safety)
//   scary: this should be true (but isn't): 2-3+4 == (2-3)+4
//   not all errors say where the error happened (missing stack traces on asserts, e.g.)
//   imports should only be at start of files
// P3 (nice-to-haves for which i've found workarounds):
//   utf8 decoder (so that i can get scalarValues out of readFileBytes)
//   language reference
//   functions to have named arguments with default values
//   a way to call function references: AnythingList f = [print, concat]; f[0](f[1](['hello', 'world']));
//   some way to call syscalls / OS functions
//   switch (especially if the compiler can report missing enum values)
//   no way to catch exceptions
//   try-finally
//   typed empty list constructor
//   constants
//   scary: for declares the identifier in parent scope; for, if, while blocks do not introduce new scope
//   scary: true and false can be reassigned
//   string interpolation
//   structs


// Concrete Types
//  * Anything
//  * Null (is Anything)
//  * Integer (is Anything)
//  * Boolean (is Anything)
//  * String (is Anything)
//  * <T>Iterable (is Anything)
//  * <T>List (is a <T>Iterable)
//  * <T>Iterator (is Anything)
//  * <T> (defined using "enum" keyword) (is Anything)
//  * functions, with signatures (is Anything)

// lvalues:
//  * Can be assigned.
//  * Can have [] subscript applied
//  <identifier> // if declared
//  <lvalue:List> "[" <expression:Integer> "]" // returns the setter for that index in the list

// statements
//  enum <identifier> { <identifier>* } // declares a type and a bunch of values
//  <Type:R> <identifier> (  ) { <statement>* } // returns must have R return type
//  <Type:T> <identifier> [= <expression:T>];
//  <lvalue:T> = <expression:T>;
//  <expression>;
//  while (<expression:Boolean>) { <statements>* }
//  for (<identifier:T> in <expression:TIterable>) { <statement>* }      // declares the identifier in parent scope, does not introduce new scope
//  if (<expression:Boolean) { <statement>* } [ else <if> ]* [ else { <statement>* } ]
//  return [<expression:R>], break, continue

// expression:T
//  <identifier:T>
//  <literal:T>
//  <expression:T> <2-ary operator:T> <expression:T> // operators: <, >, +, -, /, *, &, &&, |, ^, ||, >=, <=, >>, << (precedence matches C++)
//  <expression:function>( [ <expression> [ , <expression> ]* ] ) // expressions must match signature of function
//  <unaryoperator:T> <expression:T>

// literals
//  <integer>, <String>, true, false, null
//  "[" <expression> [ , <expressions> ]* "]"


// Types

// class TNullType
AnythingList TNullType = extend(TObject, 'TNullType');
Integer TNullType_instanceSize = TObject_instanceSize;
AnythingList TNullType_constructor(AnythingList vmt) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TNullType));
  return instance;
}

// class TIntegerType
AnythingList TIntegerType = extend(TObject, 'TIntegerType');
Integer TIntegerType_instanceSize = TObject_instanceSize;
AnythingList TIntegerType_constructor(AnythingList vmt) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TIntegerType));
  return instance;
}

// class TBooleanType
AnythingList TBooleanType = extend(TObject, 'TBooleanType');
Integer TTBooleanType_instanceSize = TObject_instanceSize;
AnythingList TBooleanType_constructor(AnythingList vmt) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TBooleanType));
  return instance;
}

// class TStringType
AnythingList TStringType = extend(TObject, 'TStringType');
Integer TStringType_instanceSize = TObject_instanceSize;
AnythingList TStringType_constructor(AnythingList vmt) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TStringType));
  return instance;
}

// class TEnumType
AnythingList TEnumType = extend(TObject, 'TEnumType');
Integer TEnumType_typeName = TObject_instanceSize;
Integer TEnumType_values = TEnumType_typeName + 1;
Integer TEnumType_instanceSize = TEnumType_values + 1;
String TEnumType_toString(AnythingList this) {
  return concat('<enum ', cast(this[TEnumType_typeName]), '>');
}
TEnumType[toString] = TEnumType_toString;
AnythingList TEnumType_constructor(AnythingList vmt, String name, StringList values) {
  AnythingList instance = TObject_constructor(vmt);
  assert(is(instance, TEnumType));
  append(instance, name); // TEnumType_typeName
  append(instance, values); // TEnumType_values
  return instance;
}

// XXX TODO more types:
//  * <T>Iterable (is Anything)
//  * <T>List (is a <T>Iterable)
//  * <T>Iterator (is Anything)
//  * <T> (defined using "enum" keyword) (is Anything)
//  * functions, with signatures (is Anything)


// Parser

// forward declaration
AnythingListFunction parseExpression;

AnythingList parseExpressionLeaves(AnythingList source) {
  // bool literals
  if (cast(method(source, isNext)(source, ttIdentifier))) {
    String identifier = cast(method(source, readIdentifier)(source));
    return TVariableExpression_constructor(TVariableExpression, identifier);
  }
  if (cast(method(source, isNext)(source, ttString))) {
    String value = cast(method(source, readString)(source));
    return TStringLiteralExpression_constructor(TStringLiteralExpression, value);
  }
  if (cast(method(source, isNext)(source, ttInteger))) {
    Integer value = cast(method(source, readInteger)(source));
    return TIntegerLiteralExpression_constructor(TIntegerLiteralExpression, value);
  }
  if (cast(method(source, isNext)(source, ttOpenBracket))) {
    method(source, expectPunctuation)(source, ttOpenBracket);
    AnythingListList values = [];
    while (!cast(method(source, isNext)(source, ttCloseBracket))) {
      append(values, parseExpression(source));
      if (!cast(method(source, isNext)(source, ttCloseBracket))) {
        method(source, expectPunctuation)(source, ttComma);
      }
    }
    method(source, expectPunctuation)(source, ttCloseBracket);
    return TListLiteralExpression_constructor(TListLiteralExpression, values);
  }
  if (cast(method(source, isNext)(source, ttOpenParen))) {
    method(source, expectPunctuation)(source, ttOpenParen);
    AnythingList expression = parseExpression(source);
    method(source, expectPunctuation)(source, ttCloseParen);
    return expression;
  }
  throw(cast(method(source, expected)(source, 'expression')));
}

AnythingList parseUnaryExpression(AnythingList source) {
  if (cast(method(source, isNext)(source, ttMinus))) {
    method(source, expectPunctuation)(source, ttMinus);
    return TIntegerNegationExpression_constructor(TIntegerNegationExpression, parseUnaryExpression(source));
  }
  if (cast(method(source, isNext)(source, ttPlus))) {
    method(source, expectPunctuation)(source, ttPlus);
    return TPlusExpression_constructor(TPlusExpression, parseUnaryExpression(source));
  }
  if (cast(method(source, isNext)(source, ttBang))) {
    method(source, expectPunctuation)(source, ttBang);
    return TBooleanNotExpression_constructor(TBooleanNotExpression, parseUnaryExpression(source));
  }
  if (cast(method(source, isNext)(source, ttTilde))) {
    method(source, expectPunctuation)(source, ttTilde);
    return TBitwiseNotExpression_constructor(TBitwiseNotExpression, parseUnaryExpression(source));
  }
  AnythingList result = parseExpressionLeaves(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttOpenParen))) {
      method(source, expectPunctuation)(source, ttOpenParen);
      AnythingListList arguments = [];
      while (!cast(method(source, isNext)(source, ttCloseParen))) {
        append(arguments, parseExpression(source));
        if (!cast(method(source, isNext)(source, ttCloseParen))) {
          method(source, expectPunctuation)(source, ttComma);
        }
      }
      method(source, expectPunctuation)(source, ttCloseParen);
      result = TFunctionCallExpression_constructor(TFunctionCallExpression, result, arguments);
      continue;
    }
    if (cast(method(source, isNext)(source, ttOpenBracket))) {
      method(source, expectPunctuation)(source, ttOpenBracket);
      AnythingList argument = parseExpression(source);
      method(source, expectPunctuation)(source, ttCloseBracket);
      result = TSubscriptExpression_constructor(TSubscriptExpression, result, argument);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionMultiplication(AnythingList source) {
  AnythingList result = parseUnaryExpression(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttAsterisk))) {
      method(source, expectPunctuation)(source, ttAsterisk);
      AnythingList rhs = parseUnaryExpression(source);
      result = TOperatorMultiplicationExpression_constructor(TOperatorMultiplicationExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttSlash))) {
      method(source, expectPunctuation)(source, ttSlash);
      AnythingList rhs = parseUnaryExpression(source);
      result = TOperatorDivisionExpression_constructor(TOperatorDivisionExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttModulus))) {
      method(source, expectPunctuation)(source, ttModulus);
      AnythingList rhs = parseUnaryExpression(source);
      result = TOperatorModulusExpression_constructor(TOperatorModulusExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionAddition(AnythingList source) {
  AnythingList result = parseExpressionMultiplication(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttPlus))) {
      method(source, expectPunctuation)(source, ttPlus);
      AnythingList rhs = parseExpressionMultiplication(source);
      result = TOperatorAdditionExpression_constructor(TOperatorAdditionExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttMinus))) {
      method(source, expectPunctuation)(source, ttMinus);
      AnythingList rhs = parseExpressionMultiplication(source);
      result = TOperatorSubtractionExpression_constructor(TOperatorSubtractionExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionShift(AnythingList source) {
  AnythingList result = parseExpressionAddition(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttLessThanLessThan))) {
      method(source, expectPunctuation)(source, ttLessThanLessThan);
      AnythingList rhs = parseExpressionAddition(source);
      result = TOperatorLeftShiftExpression_constructor(TOperatorLeftShiftExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttGreaterThanGreaterThan))) {
      method(source, expectPunctuation)(source, ttGreaterThanGreaterThan);
      AnythingList rhs = parseExpressionAddition(source);
      result = TOperatorRightShiftExpression_constructor(TOperatorRightShiftExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionRelational(AnythingList source) {
  AnythingList result = parseExpressionShift(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttLessThan))) {
      method(source, expectPunctuation)(source, ttLessThan);
      AnythingList rhs = parseExpressionShift(source);
      result = TOperatorLessThanExpression_constructor(TOperatorLessThanExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttLessThanEquals))) {
      method(source, expectPunctuation)(source, ttLessThanEquals);
      AnythingList rhs = parseExpressionShift(source);
      result = TOperatorLessThanOrEqualsExpression_constructor(TOperatorLessThanOrEqualsExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttGreaterThan))) {
      method(source, expectPunctuation)(source, ttGreaterThan);
      AnythingList rhs = parseExpressionAddition(source);
      result = TOperatorGreaterThanExpression_constructor(TOperatorGreaterThanExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttGreaterThanEquals))) {
      method(source, expectPunctuation)(source, ttGreaterThanEquals);
      AnythingList rhs = parseExpressionAddition(source);
      result = TOperatorGreaterThanOrEqualsExpression_constructor(TOperatorGreaterThanOrEqualsExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionLogicalEquality(AnythingList source) {
  AnythingList result = parseExpressionRelational(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttEqualsEquals))) {
      method(source, expectPunctuation)(source, ttEqualsEquals);
      AnythingList rhs = parseExpressionRelational(source);
      result = TOperatorEqualsEqualsExpression_constructor(TOperatorEqualsEqualsExpression, result, rhs);
      continue;
    }
    if (cast(method(source, isNext)(source, ttBangEquals))) {
      method(source, expectPunctuation)(source, ttBangEquals);
      AnythingList rhs = parseExpressionRelational(source);
      result = TOperatorBangEqualsExpression_constructor(TOperatorBangEqualsExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionBitwiseAnd(AnythingList source) {
  AnythingList result = parseExpressionLogicalEquality(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttAmpersand))) {
      method(source, expectPunctuation)(source, ttAmpersand);
      AnythingList rhs = parseExpressionLogicalEquality(source);
      result = TOperatorBitwiseAndExpression_constructor(TOperatorBitwiseAndExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionBitwiseXor(AnythingList source) {
  AnythingList result = parseExpressionBitwiseAnd(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttCaret))) {
      method(source, expectPunctuation)(source, ttCaret);
      AnythingList rhs = parseExpressionBitwiseAnd(source);
      result = TOperatorBitwiseXorExpression_constructor(TOperatorBitwiseXorExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionBitwiseOr(AnythingList source) {
  AnythingList result = parseExpressionBitwiseXor(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttVerticalBar))) {
      method(source, expectPunctuation)(source, ttVerticalBar);
      AnythingList rhs = parseExpressionBitwiseXor(source);
      result = TOperatorBitwiseOrExpression_constructor(TOperatorBitwiseOrExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList parseExpressionLogicalAnd(AnythingList source) {
  AnythingList result = parseExpressionBitwiseOr(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttAmpersandAmpersand))) {
      method(source, expectPunctuation)(source, ttAmpersandAmpersand);
      AnythingList rhs = parseExpressionBitwiseOr(source);
      result = TOperatorLogicalAndExpression_constructor(TOperatorLogicalAndExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}

AnythingList _parseExpression(AnythingList source) {
  AnythingList result = parseExpressionLogicalAnd(source);
  while (true) {
    if (cast(method(source, isNext)(source, ttVerticalBarVerticalBar))) {
      method(source, expectPunctuation)(source, ttVerticalBarVerticalBar);
      AnythingList rhs = parseExpressionLogicalAnd(source);
      result = TOperatorLogicalOrExpression_constructor(TOperatorLogicalOrExpression, result, rhs);
      continue;
    }
    break;
  }
  return result;
}
parseExpression = _parseExpression;

// forward declaration
AnythingListFunction parseStatement;

AnythingList parseBlock(AnythingList source) {
  method(source, expectPunctuation)(source, ttOpenBrace);
  AnythingListList statements = [];
  while (!cast(method(source, isNext)(source, ttCloseBrace))) {
    append(statements, parseStatement(source));
  }
  method(source, expectPunctuation)(source, ttCloseBrace);
  return TStatementBlock_constructor(TStatementBlock, statements);
}

AnythingList parseIfStatement(AnythingList source) {
  method(source, readIdentifier)(source); // if
  method(source, expectPunctuation)(source, ttOpenParen);
  AnythingList expression = parseExpression(source);
  method(source, expectPunctuation)(source, ttCloseParen);
  AnythingList block = parseBlock(source);
  AnythingList elseClause;
  if (cast(method(source, isNextIdentifier)(source, 'else'))) {
    method(source, readIdentifier)(source); // else
    if (cast(method(source, isNextIdentifier)(source, 'if'))) {
      elseClause = TElseIfClause_constructor(TElseIfClause, parseIfStatement(source));
    } else {
      elseClause = TDefaultElseClause_constructor(TDefaultElseClause, parseBlock(source));
    }
  }
  return TIfStatement_constructor(TIfStatement, expression, block, elseClause);
}

AnythingList _parseStatement(AnythingList source) {
  if (cast(method(source, isNextIdentifier)(source, 'enum'))) {
    method(source, readIdentifier)(source); // enum
    String name = cast(method(source, readIdentifier)(source));
    method(source, expectPunctuation)(source, ttOpenBrace);
    StringList values = [];
    while (cast(method(source, isNext)(source, ttIdentifier))) {
      append(values, cast(method(source, readIdentifier)(source)));
    }
    method(source, expectPunctuation)(source, ttCloseBrace);
    return TEnumDeclaration_constructor(TEnumDeclaration, name, values);
  }
  if (cast(method(source, isNextIdentifier)(source, 'if'))) {
    return parseIfStatement(source);
  }
  if (cast(method(source, isNextIdentifier)(source, 'return'))) {
    method(source, readIdentifier)(source); // return
    AnythingList returnValue;
    if (!cast(method(source, isNext)(source, ttSemicolon))) {
      returnValue = parseExpression(source);
    }
    method(source, expectPunctuation)(source, ttSemicolon);
    return TReturnStatement_constructor(TReturnStatement, returnValue);
  }
  if (cast(method(source, isNextIdentifier)(source, 'import'))) {
    method(source, readIdentifier)(source); // import
    String path = cast(method(source, readString)(source));
    method(source, expectPunctuation)(source, ttSemicolon);
    return TImportStatement_constructor(TImportStatement, path);
  }
  if (cast(method(source, isNextIdentifier)(source, 'while'))) {
    method(source, readIdentifier)(source); // while
    method(source, expectPunctuation)(source, ttOpenParen);
    AnythingList expression = parseExpression(source);
    method(source, expectPunctuation)(source, ttCloseParen);
    AnythingList block = parseBlock(source);
    return TWhileStatement_constructor(TWhileStatement, expression, block);
  }
  if (cast(method(source, isNextIdentifier)(source, 'for'))) {
    method(source, readIdentifier)(source); // for
    method(source, expectPunctuation)(source, ttOpenParen);
    String variable = cast(method(source, readIdentifier)(source));
    method(source, expectIdentifier)(source, 'in');
    AnythingList expression = parseExpression(source);
    method(source, expectPunctuation)(source, ttCloseParen);
    AnythingList block = parseBlock(source);
    return TForStatement_constructor(TForStatement, variable, expression, block);
  }
  // return ...
  // break
  // continue
  // type identifier( ...
  // type identifier;
  // type identifier = ...
  if (cast(method(source, isNext2)(source, ttIdentifier, ttIdentifier))) {
    String type = cast(method(source, readIdentifier)(source));
    String identifier = cast(method(source, readIdentifier)(source));
    if (cast(method(source, isNext)(source, ttEquals))) {
      method(source, expectPunctuation)(source, ttEquals);
      AnythingList initializer = parseExpression(source);
      method(source, expectPunctuation)(source, ttSemicolon);
      return TVariableDeclarationStatement_constructor(TVariableDeclarationStatement, type, identifier, initializer);
    }
    if (cast(method(source, isNext)(source, ttOpenParen))) {
      method(source, expectPunctuation)(source, ttOpenParen);
      StringListList parameters = [];
      while (!cast(method(source, isNext)(source, ttCloseParen))) {
        if (len(parameters) > 0) {
          method(source, expectPunctuation)(source, ttComma);
        }
        append(parameters, [
          cast(method(source, readIdentifier)(source)),
          cast(method(source, readIdentifier)(source)),
        ]);
      }
      method(source, expectPunctuation)(source, ttCloseParen);
      AnythingList block = parseBlock(source);
      return TFunctionDeclarationStatement_constructor(TFunctionDeclarationStatement, type, identifier, parameters, block);
    }
    if (cast(method(source, isNext)(source, ttSemicolon))) {
      method(source, expectPunctuation)(source, ttSemicolon);
      return TVariableDeclarationStatement_constructor(TVariableDeclarationStatement, type, identifier, null);
    }
    throw(cast(method(source, expected)(source, '"=", "(", or ";"')));
  }
  AnythingList expression = parseExpression(source);
  if (cast(method(source, isNext)(source, ttSemicolon))) {
    method(source, expectPunctuation)(source, ttSemicolon);
    return TExpressionStatement_constructor(TExpressionStatement, expression);
  }
  // Expression followed by some operator: must be assignment.
  if (!cast(method(expression, isLValue)(expression))) {
    throw(cast(method(source, butFound)(source, 'assignable lvalue expression', cast(method(expression, toString)(expression)))));
  }
  if (cast(method(source, isNext)(source, ttEquals))) {
    method(source, expectPunctuation)(source, ttEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TStraightAssignmentStatement_constructor(TStraightAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttPlusEquals))) {
    method(source, expectPunctuation)(source, ttPlusEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TPlusAssignmentStatement_constructor(TPlusAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttMinusEquals))) {
    method(source, expectPunctuation)(source, ttMinusEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TMinusAssignmentStatement_constructor(TMinusAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttAsteriskEquals))) {
    method(source, expectPunctuation)(source, ttAsteriskEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TAsteriskAssignmentStatement_constructor(TAsteriskAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttAsteriskEquals))) {
    method(source, expectPunctuation)(source, ttAsteriskEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TAsteriskAssignmentStatement_constructor(TAsteriskAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttSlashEquals))) {
    method(source, expectPunctuation)(source, ttSlashEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TSlashAssignmentStatement_constructor(TSlashAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttModulusEquals))) {
    method(source, expectPunctuation)(source, ttModulusEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TModulusAssignmentStatement_constructor(TModulusAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttAmpersandEquals))) {
    method(source, expectPunctuation)(source, ttAmpersandEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TBitwiseAndAssignmentStatement_constructor(TBitwiseAndAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttCaretEquals))) {
    method(source, expectPunctuation)(source, ttCaretEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TBitwiseXorAssignmentStatement_constructor(TBitwiseXorAssignmentStatement, expression, initializer);
  }
  if (cast(method(source, isNext)(source, ttVerticalBarEquals))) {
    method(source, expectPunctuation)(source, ttVerticalBarEquals);
    AnythingList initializer = parseExpression(source);
    method(source, expectPunctuation)(source, ttSemicolon);
    return TBitwiseOrAssignmentStatement_constructor(TBitwiseOrAssignmentStatement, expression, initializer);
  }
  throw(cast(method(source, expected)(source, 'assignment operator (e.g. "=")')));
}
parseStatement = _parseStatement;

AnythingList parseTokens(AnythingList tokens) {
  println('parsing...');
  AnythingList source = TTokenConsumer_constructor(TTokenConsumer, tokens);
  AnythingListList statements = [];
  while (!cast(method(source, isNext)(source, ttEof))) {
    append(statements, parseStatement(source));
  }
  return TProgram_constructor(TProgram, statements);
}

AnythingList parseString(String data, String filename) {
  return parseTokens(tokenize(data, filename));
}

AnythingList parseFile(String filename) {
  return parseTokens(tokenize(scalarValues(readFile(filename)), filename));
}

Null processFile(String filename, AnythingList files) {
  assert(method(files, get)(files, filename) == null);
  AnythingList ast = parseFile(filename);
  method(files, set)(files, filename, ast);
  AnythingListList children = cast(ast[TStatementBlock_children]);
  for (child in children) {
    if (is(child, TImportStatement)) {
      if (method(files, get)(files, child[TImportStatement_path]) == null) {
        processFile(cast(child[TImportStatement_path]), files);
      }
    } else {
      break;
    }
  }
}


AnythingList files = TMap_constructor(TMap);
processFile('syd.syd', files);

