import '../compiler/core.syd';

class Cell {
  Integer x;
  Integer y;

  Null constructor(Integer xArg, Integer yArg) {
    x = xArg;
    y = yArg;
  }
}
Integer debugIndent = 0;
class Box extends Cell {
  CellList children = []:Cell;
  Boolean player;
  Boolean possesable;
  Integer playerOrder;
  Boolean isBlock;
  Integer width;
  Integer height;
  Boolean flipped;

  Map infs = Map(); // Integer -> Cell
  Map epss = Map(); // Integer -> Cell
  Integer epsilon = 0; // 0 means this is not an epsilon block
  Integer infinity = 0; // 0 means this is not an infinity block

  Null setReal(Integer xArg, Integer yArg, Boolean playerArg, Boolean possesableArg, Integer playerOrderArg) {
    x = xArg;
    y = yArg;
    player = playerArg;
    possesable = possesableArg;
    playerOrder = playerOrderArg;
  }
  Null setInf(Cell inf, Integer infNum) {
    infs.set(infNum, inf);
    if (inf == this) {
      infinity = infNum;
    }
  }
  Null setSelfEps(Integer epsNum) {
    epsilon = epsNum;
  }
  Null setEps(Cell eps, Integer epsNum) {
    epss.set(epsNum, eps);
    if (eps is Box) {
      (eps as Box).setSelfEps(epsNum);
    }
  }
  WhateverList childrenOrNothing() {
    if (len(children) == 0) {
      return ['nothing!'];
    }
    return children;
  }

  String toString() {
    debugIndent += 2;
    String result = concat(width, 'x', height, ' Block (fillWithWalls: ', isBlock, ', infinityNumber (0 if not infinity): ', infinity, ', epsilonNumber (0 if not epsilon): ', epsilon, ', flipped: ', flipped, ', player: ', player, ', possesable: ', possesable, ', playerOrder: ', playerOrder, ') at ', x, ', ', y, '\n', ' ' * debugIndent, '- ', join(map(childrenOrNothing(), concat) as StringList, concat('\n', ' ' * debugIndent, '- ')));
    debugIndent -= 2;
    return result;
  }

  Null constructor(Integer xArg, Integer yArg, Boolean playerArg, Boolean possesableArg, Integer playerOrderArg, Boolean isBlockArg, Boolean flippedArg, Integer widthArg, Integer heightArg) {
    super.constructor(xArg, yArg);
    player = playerArg;
    possesable = possesableArg;
    playerOrder = playerOrderArg;
    isBlock = isBlockArg;
    width = widthArg;
    height = heightArg;
    flipped = flippedArg;
  }
}
class Clone extends Cell {
  Boolean player;
  Boolean possesable;
  Integer playerOrder;
  Integer epsilon; // 0 means this is not an epsilon block
  Integer infinity; // 0 means this is not an infinity block
  Box referencing;
  Boolean flipped;

  String toString() {
    return concat('Clone (flipped: ', flipped, ', infinityNumber (0 if not infinity): ', infinity, ', epsilonNumber (0 if not epsilon): ', epsilon, 'player: ', player, ', possesable: ', possesable, ', playerOrder: ', playerOrder, ') at ', x, ', ', y);
  }

  Null constructor(Integer xArg, Integer yArg, Boolean playerArg, Boolean possesableArg, Integer playerOrderArg, Box referencingArg, Boolean flippedArg, Integer epsilonArg, Integer infinityArg) {
    super.constructor(xArg, yArg);
    player = playerArg;
    possesable = possesableArg;
    playerOrder = playerOrderArg;
    epsilon = epsilonArg; 
    infinity = infinityArg; 
    referencing = referencingArg;
    flipped = flippedArg;
  }
}
class Wall extends Cell {
  Boolean player;
  Boolean possesable;
  Integer playerOrder;

  String toString() {
    return concat('Wall (player: ', player, ', possesable: ', possesable, ', playerOrder: ', playerOrder, ') at ', x, ', ', y);
  }

  Null constructor(Integer xArg, Integer yArg, Boolean playerArg, Boolean possesableArg, Integer playerOrderArg) {
    super.constructor(xArg, yArg);
    player = playerArg;
    possesable = possesableArg;
    playerOrder = playerOrderArg;
  }
}
class Floor extends Cell {
  String type;

  String toString() {
    return concat(type, ' at ', x, ', ', y);
  }

  Null constructor(Integer xArg, Integer yArg, String typeArg) {
    super.constructor(xArg, yArg);
    type = typeArg;
  }
}

StringList parts = split(readFile('in.txt'), '\n#\n');
assert(len(parts) == 2, 'more or less than one #');
StringList headers = split(parts[0], '\n');
assert(contains(headers, 'version 4'), 'No version header, or invalid version header');
assert(len(headers) == 1, 'only one header supported currently');
StringList blocks = split(parts[1], '\n');
Map addTo = Map(); // Integer -> Box
addTo.set(1, Box(-1, -1, false, false, -1, false, false, 1, 1));
Map boxes = Map(); // Integer -> Box
for (block in blocks) {
  StringList tabs = split(block, '\t');
  Integer indentation = len(tabs);
  StringList parts = split(last(tabs) as String, ' ');
  if (first(parts) == 'Block') {
    assert(len(parts) == 17, 'Too many/few arguments to Block cell');
    assert(parts[15] == '0', 'floating in space not allowed');
    Box box = Box(parseInt(parts[1]), parseInt(parts[2]), parts[11] == '1', parts[12] == '1', parseInt(parts[13]), parts[10] == '1', parts[14] == '1', parseInt(parts[4]), parseInt(parts[5]));
    append((addTo.get(indentation) as Box).children, box);
    boxes.set(parseInt(parts[3]), box);
    addTo.set(indentation + 1, box);
  } else if (first(parts) == 'Ref') {
    assert(len(parts) == 16, 'Too many/few arguments to Ref cell');
    assert(parts[14] == '0', 'floating in space not allowed');
    Box box = boxes.get(parseInt(parts[3])) as Box;
    Integer infinity;
    Integer epsilon;
    if (parts[5] == '1') {
      infinity = parseInt(parts[6]);
    } else {
      infinity = 0;
    }
    if (parts[7] == '1') {
      epsilon = parseInt(parts[8]);
    } else {
      epsilon = 0;
    }
    if (parts[4] == '1') {
      box.setReal(parseInt(parts[1]), parseInt(parts[2]), parts[10] == '1', parts[11] == '1', parseInt(parts[12]));
      if (infinity > 0) {
        box.setInf(box, infinity);
      }
      if (epsilon > 0) {
        (boxes.get(parseInt(parts[9])) as Box).setEps(box, epsilon);
      }
    } else {
      Clone clone = Clone(parseInt(parts[1]), parseInt(parts[2]), parts[10] == '1', parts[11] == '1', parseInt(parts[12]), box, parts[13] == '1', epsilon, infinity);
      if (infinity > 0) {
        box.setInf(clone, infinity);
      }
      if (epsilon > 0) {
        (boxes.get(parseInt(parts[9])) as Box).setEps(clone, epsilon);
      }
      append((addTo.get(indentation) as Box).children, clone);
    }
  } else if (first(parts) == 'Wall') {
    assert(len(parts) == 6 || len(parts) == 7, 'Too many/few arguments to Wall cell');
    assert(len(parts) == 6 || parts[6] == '_', '7th argument to Wall must be _');
    append((addTo.get(indentation) as Box).children, Wall(parseInt(parts[1]), parseInt(parts[2]), parts[3] == '1', parts[4] == '1', parseInt(parts[5])));
  } else {
    assert(first(parts) == 'Floor', concat('Unrecognized ', first(parts), ' cell type'));
    assert(len(parts) == 4, 'Too many/few arguments to Floor cell');
    append((addTo.get(indentation) as Box).children, Floor(parseInt(parts[1]), parseInt(parts[2]), parts[3]));
  }
}
println(addTo.get(1));